<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1732348">
    <body>
      <group id="1732348">
        <trans-unit id="ccd2e00de6a7833dd11d2079f5b5b099a6e04da7" translate="yes" xml:space="preserve">
          <source>&quot;unpretty&quot; attributes with a space before the &quot;=&quot; symbol, after it and both before and after it.</source>
          <target state="translated">&quot;unpretty &quot;属性は、&quot;=&quot;記号の前にスペースがあり、後にも前後にもスペースがあります。</target>
        </trans-unit>
        <trans-unit id="392ad88b0cb34d87fa7d4457a6637b91ceafc10b" translate="yes" xml:space="preserve">
          <source>&amp;lt;br&amp;gt;</source>
          <target state="translated">&amp;lt;br&amp;gt;</target>
        </trans-unit>
        <trans-unit id="50709f0c2fc769b8029465696613cd45319835fb" translate="yes" xml:space="preserve">
          <source>&amp;lt;br/&amp;gt;</source>
          <target state="translated">&amp;lt;br/&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ecfb18e3fd89ce3fed2c8046ff8dc43d3ee45bbf" translate="yes" xml:space="preserve">
          <source>&amp;lt;hr /&amp;gt;</source>
          <target state="translated">&amp;lt;hr /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3239efc545dfa4f75dc0905c388a28a61c34c974" translate="yes" xml:space="preserve">
          <source>(Take care, in that note I wrongly used the &quot;m&quot; modifier; it should be erased, notwithstanding it is discarded by the RegExp engine, since no ^ or $ anchorage was used).</source>
          <target state="translated">(注意してください、私は間違って &quot;m&quot; 修飾子を使用していました;^ または $ アンカレッジが使用されていなかったので、RegExp エンジンによって破棄されたにもかかわらず、それは消去されるべきです)。</target>
        </trans-unit>
        <trans-unit id="a8662e799cce40f7a10db5f20413cbc30727a2b7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://pastebin.com/hzYazFVb&quot;&gt;regex to tokenize an xml&lt;/a&gt; or &lt;a href=&quot;http://pastebin.com/HUmPzP5M&quot;&gt;the full plain regex&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://pastebin.com/hzYazFVb&quot;&gt;xml&lt;/a&gt;または&lt;a href=&quot;http://pastebin.com/HUmPzP5M&quot;&gt;完全な正規&lt;/a&gt; 表現をトークン化する 正規表現</target>
        </trans-unit>
        <trans-unit id="832bcd8f1b94df226af144e70783a66198bd3e61" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;simplehtmldom&lt;/a&gt; is good, but I found it a bit buggy, and it is is quite memory heavy [Will crash on large pages.]</source>
          <target state="translated">&lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;simplehtmldom&lt;/a&gt;は良いですが、少しバグがあり、かなりメモリが重いです[大きなページでクラッシュします]。</target>
        </trans-unit>
        <trans-unit id="0fb3c21dc29172e2446bc3eb1b052ae2cf60faea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;LL I​S L&lt;/b&gt;OST th</source>
          <target state="translated">&lt;b&gt;LL I SL&lt;/b&gt; OST th</target>
        </trans-unit>
        <trans-unit id="6e79435135c0746fa05560a3972c6d46478d0ea8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Locked&lt;/b&gt;. There are &lt;a href=&quot;/help/locked-posts&quot;&gt;disputes about this answer&amp;rsquo;s content&lt;/a&gt; being resolved at this time. It is not currently accepting new interactions.</source>
          <target state="translated">&lt;b&gt;ロックされてい&lt;/b&gt;ます。 現在&lt;a href=&quot;/help/locked-posts&quot;&gt;、この回答のコンテンツ&lt;/a&gt;が解決されているという論争があります。 現在、新しい相互作用を受け入れていません。</target>
        </trans-unit>
        <trans-unit id="716a4e892e498fc58500550d231fb8d0142d36b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;O​O N&lt;/b&gt;&amp;Theta; stop t</source>
          <target state="translated">&lt;b&gt;O&lt;/b&gt; ON&amp;Theta;停止t</target>
        </trans-unit>
        <trans-unit id="1c101f468dfe424c6604dac4e8ce77d6d85f2f3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;: closing &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; ：終了 &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b62a075d15f1adc779c6d1b0fe159e3b547852c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;: starting character</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; ：開始文字</target>
        </trans-unit>
        <trans-unit id="edd69111dcbfaec727aaaeb23b7029011a65191a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?&amp;lt;-group&amp;gt;)&lt;/code&gt; - pops the top most capture with the name group off the
  capture stack.</source>
          <target state="translated">&lt;code&gt;(?&amp;lt;-group&amp;gt;)&lt;/code&gt; -キャプチャスタックからグループという名前の一番上のキャプチャをポップします。</target>
        </trans-unit>
        <trans-unit id="d45de3e20cd061b6edb60d843a32a44f30527fa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?&amp;lt;group&amp;gt;)&lt;/code&gt; - pushes the captured result on the capture stack with
  the name group.</source>
          <target state="translated">&lt;code&gt;(?&amp;lt;group&amp;gt;)&lt;/code&gt; -キャプチャされた結果をグループという名前でキャプチャスタックにプッシュします。</target>
        </trans-unit>
        <trans-unit id="e8253025aa1e0fb8ada068fc00792760bbe3d0c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?(group)yes|no)&lt;/code&gt; - matches the yes part if there exists a group
  with the name group otherwise matches no part.</source>
          <target state="translated">&lt;code&gt;(?(group)yes|no)&lt;/code&gt; -groupという名前のグループが存在する場合はyesの部分に一致し、それ以外の場合はどの部分にも一致しません。</target>
        </trans-unit>
        <trans-unit id="56885e7cfe6e3708ab901dd138fd887bd58c790d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(\w+)&lt;/code&gt;: tags can contain letters and numbers (h1). Well, &lt;code&gt;\w&lt;/code&gt; also matches '_', but it does not hurt I guess. If curious use ([a-zA-Z0-9]+) instead.</source>
          <target state="translated">&lt;code&gt;(\w+)&lt;/code&gt; ：タグには文字と数字（h1）を含めることができます。 まあ、 &lt;code&gt;\w&lt;/code&gt; は '_'にも一致しますが、それは私が害を及ぼすことはないと思います。 好奇心が強い場合は、代わりに（[a-zA-Z0-9] +）を使用してください。</target>
        </trans-unit>
        <trans-unit id="27378fcce2128b2795fafae4f93ebe3ba7c8ec5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[^/&amp;gt;]*&lt;/code&gt;: anything except &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; until closing &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[^/&amp;gt;]*&lt;/code&gt; ： &lt;code&gt;&amp;gt;&lt;/code&gt; および &lt;code&gt;/&lt;/code&gt; を除くすべて&amp;gt;終了まで &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0cdd6edcac3875daf87e4d7a216db2702e63b2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s*&lt;/code&gt;: it may have whitespaces before tag name (ugly but possible).</source>
          <target state="translated">&lt;code&gt;\s*&lt;/code&gt; ：タグ名の前に空白が含まれている可能性があります（醜いが可能です）。</target>
        </trans-unit>
        <trans-unit id="beb0d3eebbac4ba7a6e556f1885908f5a8b44a54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;It is a .NET code library that allows
  you to parse &quot;out of the web&quot; HTML
  files. The parser is very tolerant
  with &quot;real world&quot; malformed HTML.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;これは、「Web外」のHTMLファイルを解析できる.NETコードライブラリです。&lt;/em&gt; &lt;em&gt;パーサーは、「実世界」の不正なHTMLに非常に耐性があります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c6e323e6d7b2404e267e45fec8933c5f11df6f5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;/EDIT&amp;gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;lt;/EDIT&amp;gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4eeca80a434106c9c5953d86b5711b944275e484" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;EDIT&amp;gt;&lt;/strong&gt;
I forgot that the question from the user was to avoid the parsing of self-closing tags.
In this case the pattern is simpler, turning into this:</source>
          <target state="translated">&lt;strong&gt;&amp;lt;編集&amp;gt;&lt;/strong&gt;ユーザーからの質問が自己終了タグの解析を回避することであることを忘れていました。 この場合、パターンはより単純になり、次のようになります。</target>
        </trans-unit>
        <trans-unit id="bfe34076d009a4ea9a539e48cf63cf2660a68659" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;.NET Regular Expression Engine&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;.NET正規表現エンジン&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="84c7b23e39a82950709baca989fe9cf94e0ac7c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caveat&lt;/strong&gt;: I should note that this regex still breaks down in the presence of CDATA blocks, comments, and script and style elements. Good news is, you can get rid of those using a regex...</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt; ：この正規表現は、CDATAブロック、コメント、スクリプトおよびスタイル要素が存在する場合でも機能しないことに注意してください。 良いニュースは、正規表現を使用してそれらを取り除くことができるということです...</target>
        </trans-unit>
        <trans-unit id="45fc82d5456ed3961e342820361d39292947a88e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer&lt;/strong&gt;: use a parser if you have the option. That said...</source>
          <target state="translated">&lt;strong&gt;免責事項&lt;/strong&gt; ：オプションがある場合は、パーサーを使用してください。 それは言いました...</target>
        </trans-unit>
        <trans-unit id="28fb9f9055a519baf77c8a0c677593f8a1967066" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Moderator's Note&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;モデレーターのメモ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2412b65f77f0efaca93518e50a127a0ceec7ed35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To downvoters:&lt;/strong&gt; This is working code from an actual product. I doubt anyone reading this page will get the impression that it is socially acceptable to use regexes on HTML.</source>
          <target state="translated">&lt;strong&gt;反対投票者へ：&lt;/strong&gt;これは実際の製品からの作業コードです。 このページを読んでいる人が、HTMLで正規表現を使用することは社会的に受け入れられるという印象を受けるとは思えません。</target>
        </trans-unit>
        <trans-unit id="b00d0a9c4b3ab55c1726cc4d54869fbac2f0d000" translate="yes" xml:space="preserve">
          <source>A RegExp-agnostic colleague notified me this discussion, which is not certainly the first on the web about this old and hot topic.</source>
          <target state="translated">RegExp-agnosticな同僚がこの議論を私に知らせてくれました。</target>
        </trans-unit>
        <trans-unit id="e3504a93684584a9ba5c4e8dff8fbf39739ee1de" translate="yes" xml:space="preserve">
          <source>A simple regex like &lt;code&gt;&amp;lt;([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; is usually good enough, in cases such as those I just mentioned. It's a naive solution, all things considered, but it does correctly allow unencoded &lt;code&gt;&amp;gt;&lt;/code&gt; symbols in attribute values. If you're looking for, e.g., a &lt;code&gt;table&lt;/code&gt; tag, you could adapt it as &lt;code&gt;&amp;lt;/?table\b([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; ような単純な正規表現は、今述べたような場合には通常十分です。 これはすべてを考慮した単純な解決策ですが、属性値にエンコードされていない &lt;code&gt;&amp;gt;&lt;/code&gt; 記号を正しく許可します。 たとえば、 &lt;code&gt;table&lt;/code&gt; タグを探している場合は、 &lt;code&gt;&amp;lt;/?table\b([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; として適合させることができます。 。</target>
        </trans-unit>
        <trans-unit id="a039c1c26fe0f237cd4c396efb45b67c58a5e34d" translate="yes" xml:space="preserve">
          <source>About the question of the RegExp methods to parse (x)HTML, the answer to all of the ones who spoke about some limits is: you have not been trained enough to rule the force of this powerful weapon, since &lt;strong&gt;NOBODY&lt;/strong&gt; here spoke about &lt;strong&gt;recursion&lt;/strong&gt;.</source>
          <target state="translated">（x）HTMLを解析するRegExpメソッドの質問について、いくつかの制限について話したすべての人への答えは次のとおりです&lt;strong&gt;。NOBODYが&lt;/strong&gt;ここで&lt;strong&gt;再帰&lt;/strong&gt;について話したので、この強力な武器の力を支配する十分な訓練を受けていません。</target>
        </trans-unit>
        <trans-unit id="489cc8d83fc1a950af1e4ec274f14d5d31165bbc" translate="yes" xml:space="preserve">
          <source>After reading some posts, the first thing I did was looking for the &quot;?R&quot; string in this thread. The second was to search about &quot;recursion&quot;.</source>
          <target state="translated">いくつかの書き込みを読んで、まず最初にこのスレッドで「?R」という文字列を探しました。2つ目は「再帰」について検索してみました。</target>
        </trans-unit>
        <trans-unit id="a3a75c0c6fe92ec2cda26b61e50e68af1ff0a32b" translate="yes" xml:space="preserve">
          <source>Against my expectation this got some upvotes, so I'll suggest some better regular expressions:</source>
          <target state="translated">私の予想に反して、これはいくつかの好意的な評価を得たので、より良い正規表現をいくつか提案します。</target>
        </trans-unit>
        <trans-unit id="d71dc9d3aa06d9d64e4ed0039016360a328e4c22" translate="yes" xml:space="preserve">
          <source>Almost there - just divide the whole thing by zero. Easy-peasy.</source>
          <target state="translated">もうすぐだぞ-全体をゼロで割るだけだ。簡単だ</target>
        </trans-unit>
        <trans-unit id="fee1e23317ba16ad1ccae9d12e0a015990432476" translate="yes" xml:space="preserve">
          <source>Although it's not suitable and effective to use regular expressions for that purpose sometimes regular expressions provide quick solutions for simple match problems and in my view it's not that horrbile to use regular expressions for trivial works.</source>
          <target state="translated">そのために正規表現を使用することは適切で効果的ではありませんが、単純なマッチの問題に対しては正規表現が迅速な解決策を提供してくれることもありますし、些細な作業に正規表現を使用することはそれほど難しいことではないと私は考えています。</target>
        </trans-unit>
        <trans-unit id="a430cebe8e1c6b5026f2667ef4e684539ee6d594" translate="yes" xml:space="preserve">
          <source>And to fellows who underestimate regular expressions saying they are only as powerful as regular languages:</source>
          <target state="translated">正規表現を過小評価している人たちは、正規表現は正規言語と同じくらいの力しかないと言っています。</target>
        </trans-unit>
        <trans-unit id="1b4c5b09ea0d4dcf09356da001dd69ed7c2e026c" translate="yes" xml:space="preserve">
          <source>Another one to try is my &lt;a href=&quot;http://github.com/siteroller/domparser&quot;&gt;DOMParser&lt;/a&gt; which is very light on resources and I've been using happily for a while. Simple to learn &amp;amp; powerful.</source>
          <target state="translated">もう1つ試すのは、リソースが非常に&lt;a href=&quot;http://github.com/siteroller/domparser&quot;&gt;少ないDOMParser&lt;/a&gt;です。しばらくの間、私は楽しく使用しています。 学ぶのが簡単で強力です。</target>
        </trans-unit>
        <trans-unit id="0e63871b8e67058c915c0916cf65a319929856cc" translate="yes" xml:space="preserve">
          <source>Anyhow it is only a RegExp pattern, but it discloses the possibility to develop of a lot of powerful implementations.</source>
          <target state="translated">いずれにしても、ただのRegExpパターンですが、多くの強力な実装の開発可能性を開示しています。</target>
        </trans-unit>
        <trans-unit id="7bc89deb2a5a51e26b543874949bc6016b7dee8c" translate="yes" xml:space="preserve">
          <source>As described above properly balanced constructs cannot be described by
  a regular expression. However, the .NET regular expression engine
  provides a few constructs that allow balanced constructs to be
  recognized.</source>
          <target state="translated">上で述べたように、適切にバランスのとれた構成は正規表現では記述できません。しかし、.NET 正規表現エンジンはバランスの取れた構成を認識できるようにするいくつかの構成を提供しています。</target>
        </trans-unit>
        <trans-unit id="23f8839aa08cf9ff361179fc788965803d7b92e4" translate="yes" xml:space="preserve">
          <source>As many people have already pointed out, HTML is not a regular language which can make it very difficult to parse. My solution to this is to turn it into a regular language using a tidy program and then to use an XML parser to consume the results. There are a lot of good options for this. My program is written using Java with the &lt;a href=&quot;http://jtidy.sourceforge.net/&quot;&gt;jtidy&lt;/a&gt; library to turn the HTML into XML and then Jaxen to xpath into the result.</source>
          <target state="translated">多くの人がすでに指摘したように、HTMLは通常の言語ではないため、解析が非常に困難になります。 これに対する私の解決策は、整頓されたプログラムを使用してそれを通常の言語に変換し、XMLパーサーを使用して結果を利用することです。 これには良いオプションがたくさんあります。 私のプログラムは、Javaと&lt;a href=&quot;http://jtidy.sourceforge.net/&quot;&gt;jtidy&lt;/a&gt;ライブラリを使用して記述されており、HTMLをXMLに変換し、次にJaxenが結果にxpathを変換します。</target>
        </trans-unit>
        <trans-unit id="6ec0c091ef78305814e216017d3186d039895a12" translate="yes" xml:space="preserve">
          <source>At the end of the day, use the most appropriate tool for the job, even in the cases when that tool happens to be a regex.</source>
          <target state="translated">一日の終わりには、たとえそのツールが正規表現であったとしても、その仕事に最も適したツールを使用してください。</target>
        </trans-unit>
        <trans-unit id="ee0292f6ec302ec831d0a3d73bf3ba082b945c21" translate="yes" xml:space="preserve">
          <source>Backreferencing &lt;a href=&quot;http://en.wiktionary.org/wiki/FTW&quot;&gt;FTW&lt;/a&gt;!</source>
          <target state="translated">&lt;a href=&quot;http://en.wiktionary.org/wiki/FTW&quot;&gt;FTWの&lt;/a&gt;逆参照！</target>
        </trans-unit>
        <trans-unit id="e76721be008ac232fc787ac592a249a6a0b4bb86" translate="yes" xml:space="preserve">
          <source>Based on that you can create a pretty good regexp to handle things like stripping tags.</source>
          <target state="translated">これを元に、タグの剥ぎ取りなどの処理を行うための非常に優れた正規表現を作成することができます。</target>
        </trans-unit>
        <trans-unit id="74dec6c7e6bd60b234219702f40493e82463304e" translate="yes" xml:space="preserve">
          <source>Basically just define the element node names that are self closing, load the whole html string into a DOM library, grab all elements, loop through and filter out ones which aren't self closing and operate on them.</source>
          <target state="translated">基本的には、自己閉鎖的な要素のノード名を定義し、HTML 文字列全体を DOM ライブラリに読み込み、すべての要素を取得し、ループして自己閉鎖的でない要素をフィルタリングし、それらを操作するだけです。</target>
        </trans-unit>
        <trans-unit id="2fd99963c03782b18787dfc6cb3594dcb6c80def" translate="yes" xml:space="preserve">
          <source>But many will try, some will even claim success - but until others find the fault and totally mess you up.</source>
          <target state="translated">しかし、多くの人が試してみて、いくつかは成功を主張するでしょう-しかし、他の人が障害を見つけて、完全にあなたを台無しにするまで。</target>
        </trans-unit>
        <trans-unit id="eb3c73a7771d13969490ceb2f225b558c87d11f3" translate="yes" xml:space="preserve">
          <source>But not these:</source>
          <target state="translated">でもこれは違う</target>
        </trans-unit>
        <trans-unit id="201b0e9006bea17e6be8fbec59ab5c0fb1baedd0" translate="yes" xml:space="preserve">
          <source>Can you provide a little more information on the problem you're trying to solve?  Are you iterating through tags programatically?</source>
          <target state="translated">解決しようとしている問題についてもう少し情報を提供してもらえますか?タグをプログラム的に反復処理していますか?</target>
        </trans-unit>
        <trans-unit id="b8fde2430ed872968deeaaced84cc8f3cc101507" translate="yes" xml:space="preserve">
          <source>Consider the following regular expression:</source>
          <target state="translated">次の正規表現を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="dfa51c240f8abc4eddb1aab8ac728fcb6c1daf9a" translate="yes" xml:space="preserve">
          <source>Do I have that right? And more importantly, what do you think?</source>
          <target state="translated">これでいいのかな?そして、もっと重要なのは、どう思うか?</target>
        </trans-unit>
        <trans-unit id="89791df6d0913a20e70b1f075f65baa21fec7900" translate="yes" xml:space="preserve">
          <source>Don't listen to these guys. You totally &lt;strong&gt;can&lt;/strong&gt; parse context-free grammars with regex if you break the task into smaller pieces. You can generate the correct pattern with a script that does each of these in order:</source>
          <target state="translated">これらの人に耳を傾けないでください。 タスクを細かく分割すれば、完全に正規表現を使用して文脈自由文法を解析&lt;strong&gt;でき&lt;/strong&gt;ます。 これらを順番に実行するスクリプトを使用して、正しいパターンを生成できます。</target>
        </trans-unit>
        <trans-unit id="c40843389e0f5b256a2400a9132a52c445461a2b" translate="yes" xml:space="preserve">
          <source>E MY FACE ᵒh god n&lt;b&gt;o NO NOO̼&lt;/b&gt;</source>
          <target state="translated">E MY FACEᵒhgod n &lt;b&gt;o NONOO̼&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4130705574014c580de59636d30628dd3b203bfe" translate="yes" xml:space="preserve">
          <source>Excerpt:</source>
          <target state="translated">Excerpt:</target>
        </trans-unit>
        <trans-unit id="2ad9d9e9824270d481f3774905d98736bcee5670" translate="yes" xml:space="preserve">
          <source>Find (and capture) a-z one or more times, then</source>
          <target state="translated">a-zを1回以上見つけて(捕捉して)</target>
        </trans-unit>
        <trans-unit id="1d62b3cf5e66d1004bdcb37b62e3847fa43f5ea5" translate="yes" xml:space="preserve">
          <source>Find a greater-than</source>
          <target state="translated">より大きいものを探す</target>
        </trans-unit>
        <trans-unit id="e9f182c7233327a73156c429c46ec0bca09513bc" translate="yes" xml:space="preserve">
          <source>Find a less-than, then</source>
          <target state="translated">未満のものを見つけて</target>
        </trans-unit>
        <trans-unit id="ef69898f6d3c5528cdbd0de1bd0fdf314dad1fc8" translate="yes" xml:space="preserve">
          <source>Find any character zero or more times, greedy, except &lt;code&gt;/&lt;/code&gt;, then</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 以外の文字を0回以上貪欲に検索し、</target>
        </trans-unit>
        <trans-unit id="4f924d21074cc3fb26507a968919ecf7195b88d8" translate="yes" xml:space="preserve">
          <source>Find zero or more spaces, then</source>
          <target state="translated">0個以上のスペースを見つけて</target>
        </trans-unit>
        <trans-unit id="0d7c5280ed7e07e90b90f8658292c92cbadfbd89" translate="yes" xml:space="preserve">
          <source>Follow the var links for &lt;code&gt;QName&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, and &lt;code&gt;Attribute&lt;/code&gt; to get a clearer picture.</source>
          <target state="translated">&lt;code&gt;QName&lt;/code&gt; 、 &lt;code&gt;S&lt;/code&gt; 、および &lt;code&gt;Attribute&lt;/code&gt; のvarリンクをたどると、より明確な画像が得られます。</target>
        </trans-unit>
        <trans-unit id="cf4a4868fa67f0f821777e8c58e576588a83ca85" translate="yes" xml:space="preserve">
          <source>For Python and Java, similar links were posted.</source>
          <target state="translated">PythonとJavaについては、似たようなリンクが貼られていました。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="3835e68a9fb13e4990fe61a2c3a6bb38c1da30a3" translate="yes" xml:space="preserve">
          <source>For the downvoters - I only wrote my class when the XML parsers proved unable to withstand real use. Religious downvoting just prevents useful answers from being posted - keep things within perspective of the question, please.</source>
          <target state="translated">ダウンボーダーのために-私はXMLパーサーが実際の使用に耐えられないことが証明されたときに私のクラスを書いただけです。宗教的なdownnvotingは有用な回答が投稿されるのを防ぐだけです-質問の観点から物事を維持してください。</target>
        </trans-unit>
        <trans-unit id="b71baca6025abb3df3fd982ef9ea831e48620ba4" translate="yes" xml:space="preserve">
          <source>For this reason, I believe you CAN parse XML using regular expressions. Note however, that it &lt;strong&gt;must be valid XML&lt;/strong&gt; (&lt;em&gt;browsers are very forgiving of HTML and allow bad XML syntax inside HTML&lt;/em&gt;). This is possible since the &quot;Balancing Group Definition&quot; will allow the regular expression engine to act as a PDA.</source>
          <target state="translated">このため、正規表現を使用してXMLを解析できると思います。 ただし、 &lt;strong&gt;有効なXML&lt;/strong&gt;である&lt;strong&gt;必要が&lt;/strong&gt;あることに注意してください（ &lt;em&gt;ブラウザーはHTMLを非常に許容し、HTML内の不正なXML構文を許可します&lt;/em&gt; ）。 これは、「バランスグループの定義」により、正規表現エンジンがPDAとして機能できるようになるためです。</target>
        </trans-unit>
        <trans-unit id="fda26d5e5c5ac0a8c6a86392f4d1739052bb39fc" translate="yes" xml:space="preserve">
          <source>Granted, these don't account for surrounding context and a few edge cases, but even such things could be dealt with if you really wanted to (e.g., by searching between the matches of another regex).</source>
          <target state="translated">しかし、このようなことでさえも、本当に必要であれば(例えば、別の正規表現のマッチの間を検索することで)対処することができます。</target>
        </trans-unit>
        <trans-unit id="ddfca12da1b8e2626e09bf2de8420516252a5e63" translate="yes" xml:space="preserve">
          <source>HTML Split</source>
          <target state="translated">HTML分割</target>
        </trans-unit>
        <trans-unit id="6c3bb55dbe0fb3cbcbc40ad1f139eaae779348bd" translate="yes" xml:space="preserve">
          <source>Hacking stackoverflow.com's HTML sanitizer</source>
          <target state="translated">stackoverflow.com の HTML サニタイザーをハックする</target>
        </trans-unit>
        <trans-unit id="9ec955a6d30b0da0f17f1892186c1fa8f07ed132" translate="yes" xml:space="preserve">
          <source>Have you tried using an XML parser instead?</source>
          <target state="translated">代わりにXMLパーサーを使ってみましたか?</target>
        </trans-unit>
        <trans-unit id="62d338caf42aa263445453c7fd40bf4f6302c521" translate="yes" xml:space="preserve">
          <source>Here is a &lt;a href=&quot;http://kingdesk.com/projects/php-parser/&quot;&gt;PHP based parser&lt;/a&gt; that parses HTML using  some ungodly regex. As the author of this project, I can tell you it is possible to parse HTML with regex, but not efficient. If you need a server-side solution (as I did for my &lt;a href=&quot;http://wordpress.org/extend/plugins/wp-typography/&quot;&gt;wp-Typography WordPress plugin&lt;/a&gt;), this works.</source>
          <target state="translated">&lt;a href=&quot;http://kingdesk.com/projects/php-parser/&quot;&gt;PHPに基づくパーサー&lt;/a&gt;は、不思議な正規表現を使用してHTMLを解析します。 このプロジェクトの作成者として、正規表現を使用してHTMLを解析することは可能ですが、効率的ではないと言えるでしょう。 サーバーサイドソリューションが必要な場合（私の&lt;a href=&quot;http://wordpress.org/extend/plugins/wp-typography/&quot;&gt;WP-Typography WordPressプラグインで行ったように&lt;/a&gt; ）、これは機能します。</target>
        </trans-unit>
        <trans-unit id="de8fd03b5c9fb5a8404878e31a8e0845726217a3" translate="yes" xml:space="preserve">
          <source>Here's a &lt;strong&gt;sample note on the PHP manual&lt;/strong&gt; I wrote on January: &lt;a href=&quot;http://php.net/manual/en/regexp.reference.recursive.php&quot;&gt;Reference&lt;/a&gt;</source>
          <target state="translated">1月に書い&lt;strong&gt;たPHPマニュアルのサンプルノートを以下に示します&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c95897a114ae327a0fcd3248ce2f00b0ecf00ea" translate="yes" xml:space="preserve">
          <source>Here's the magic pattern:</source>
          <target state="translated">ここに魔法のパターンがあります。</target>
        </trans-unit>
        <trans-unit id="c10b2e598b32c332a06818be23de20fdc89e2f2a" translate="yes" xml:space="preserve">
          <source>Here's the solution:</source>
          <target state="translated">その解決策がこちらです。</target>
        </trans-unit>
        <trans-unit id="2cb54d7b11fcfb379247546c25fc8c672912b48c" translate="yes" xml:space="preserve">
          <source>However, a na&amp;iuml;ve implementation of that will end up matching &lt;code&gt;&amp;lt;bar/&amp;gt;&amp;lt;/foo&amp;gt;&lt;/code&gt; in this example document</source>
          <target state="translated">ただし、その単純な実装は、このドキュメント例の &lt;code&gt;&amp;lt;bar/&amp;gt;&amp;lt;/foo&amp;gt;&lt;/code&gt; に一致します。</target>
        </trans-unit>
        <trans-unit id="5ee1e08a15d19fdb33d20bd07c63e0818a8b9803" translate="yes" xml:space="preserve">
          <source>I agree that the right tool to parse XML and &lt;em&gt;especially HTML&lt;/em&gt; is a parser and not a regular expression engine. However, like others have pointed out, sometimes using a regex is quicker, easier, and gets the job done if you know the data format.</source>
          <target state="translated">XML、 &lt;em&gt;特にHTML&lt;/em&gt;を解析する適切なツールはパーサーであり、正規表現エンジンではないことに同意し&lt;em&gt;ます&lt;/em&gt; 。 ただし、他の人が指摘したように、正規表現を使用する方が速くて簡単で、データ形式がわかっている場合は作業が完了することがあります。</target>
        </trans-unit>
        <trans-unit id="65c26198557f567b9e45c7ec5c4d24af104d4dba" translate="yes" xml:space="preserve">
          <source>I also entered tags with:</source>
          <target state="translated">タグも一緒に入力しました。</target>
        </trans-unit>
        <trans-unit id="f992540f103a26060e050d18a000903263722fe7" translate="yes" xml:space="preserve">
          <source>I believe it says:</source>
          <target state="translated">書いてあると思います。</target>
        </trans-unit>
        <trans-unit id="67002a6457c576d19392a6bb03d1003175f5f89d" translate="yes" xml:space="preserve">
          <source>I bet I will get downvoted for this.</source>
          <target state="translated">これでダウンボイルドになるんだろうな。</target>
        </trans-unit>
        <trans-unit id="a78333526ec3e39b92b14f68dec9aff52646cd97" translate="yes" xml:space="preserve">
          <source>I came up with this and wanted to make sure I've got it right. I am only capturing the &lt;code&gt;a-z&lt;/code&gt;.</source>
          <target state="translated">私はこれを思いつき、それが正しいことを確認したかったのです。 私は &lt;code&gt;a-z&lt;/code&gt; だけをキャプチャしています。</target>
        </trans-unit>
        <trans-unit id="c510ddbef2e355def2551ab12c01a3563da7ee62" translate="yes" xml:space="preserve">
          <source>I don't know your exact need for this, but if you are also using .NET, couldn't you use &lt;a href=&quot;http://www.codeplex.com/htmlagilitypack&quot;&gt;Html Agility Pack&lt;/a&gt;?</source>
          <target state="translated">これの正確な必要性はわかりませんが、.NETも使用している場合は、 &lt;a href=&quot;http://www.codeplex.com/htmlagilitypack&quot;&gt;Html Agility Pack&lt;/a&gt;を使用できませんでしたか？</target>
        </trans-unit>
        <trans-unit id="a18f149e6422b3edd9f248402bd13c1e293f7282" translate="yes" xml:space="preserve">
          <source>I guess to make it not match self contained tags, you'd either want to use &lt;a href=&quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732395#1732395&quot;&gt;Kobi&lt;/a&gt;'s negative look-behind:</source>
          <target state="translated">自己完結型のタグと一致しないようにするために、 &lt;a href=&quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732395#1732395&quot;&gt;Kobi&lt;/a&gt;の否定的な後読みを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="446fea43937f34270d7612150462764e964be907" translate="yes" xml:space="preserve">
          <source>I have also composed a haiku describing the nature of regex in Perl.</source>
          <target state="translated">また、Perlの正規表現の性質を表現した俳句を詠んでみました。</target>
        </trans-unit>
        <trans-unit id="682e33f67784d033cbcf7127d0e8db1135907695" translate="yes" xml:space="preserve">
          <source>I have composed a haiku describing the nature of HTML.</source>
          <target state="translated">HTMLの本質を描いた俳句を詠みました。</target>
        </trans-unit>
        <trans-unit id="b7d276bff4ead75187b5216ebca62ddd0544740b" translate="yes" xml:space="preserve">
          <source>I have never used &lt;a href=&quot;http://querypath.org/&quot;&gt;querypath&lt;/a&gt;, so can't comment on its usefulness.</source>
          <target state="translated">&lt;a href=&quot;http://querypath.org/&quot;&gt;querypath&lt;/a&gt;を使用したことがないので、その有用性についてコメントすることはできません。</target>
        </trans-unit>
        <trans-unit id="a3d81722ce02cdd1e1d406605ca28b6afc2989ae" translate="yes" xml:space="preserve">
          <source>I haven't quite finished the last part myself, but I know I'm getting close. It keeps throwing &lt;code&gt;CthulhuRlyehWgahnaglFhtagnException&lt;/code&gt;s for some reason, so I'm going to port it to VB 6 and use &lt;code&gt;On Error Resume Next&lt;/code&gt;. I'll update with the code once I investigate this strange door that just opened in the wall. Hmm.</source>
          <target state="translated">私は最後の部分を自分で完成させたわけではありませんが、近づいていることはわかっています。 なんらかの理由で &lt;code&gt;CthulhuRlyehWgahnaglFhtagnException&lt;/code&gt; がスローされ続けるので、VB 6に移植して &lt;code&gt;On Error Resume Next&lt;/code&gt; を使用します。 壁に開いたばかりのこの奇妙なドアを調査したら、コードを更新します。 うーん。</target>
        </trans-unit>
        <trans-unit id="57a8d4c706d6a34ee3af3112fdb317e71ff9acca" translate="yes" xml:space="preserve">
          <source>I like to parse HTML with regular expressions. I don't attempt to parse idiot HTML that is deliberately broken. This code is my main parser (Perl edition):</source>
          <target state="translated">私は正規表現でHTMLをパースするのが好きです。意図的に壊れているバカなHTMLを解析しようとはしません。このコードは私のメインパーサー(Perl版)です。</target>
        </trans-unit>
        <trans-unit id="8ea04fa9f527bf7438dfd9b91e87f0721f39b7be" translate="yes" xml:space="preserve">
          <source>I need to match all of these opening tags:</source>
          <target state="translated">これらのオープニングタグをすべて一致させる必要があります。</target>
        </trans-unit>
        <trans-unit id="f58bfd6885d7586198e4ea7d285dc17ac4158c70" translate="yes" xml:space="preserve">
          <source>I suggest using &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; for parsing XML and HTML in PHP.  It's basically much the same syntax as jQuery, only it's on the server side.</source>
          <target state="translated">PHPでXMLとHTMLを解析するには、 &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt;を使用することをお勧めします。 基本的にはjQueryとほとんど同じ構文ですが、サーバー側のみです。</target>
        </trans-unit>
        <trans-unit id="ece9292e931d9ba43626cda22fdf3280d35633a6" translate="yes" xml:space="preserve">
          <source>I think the XML case is quite simple. The RegEx (in the .NET syntax), deflated and coded in base64 to make it easier to comprehend by your feeble mind, should be something like this:</source>
          <target state="translated">XML の場合は非常に単純だと思います。RegEx (.NET の構文)をデフレーションして、弱った頭でも理解しやすいように base64 でコード化したものは、次のようなものになるはずです。</target>
        </trans-unit>
        <trans-unit id="18040856a3f0eb37bda82501b7d790ae361b0b2d" translate="yes" xml:space="preserve">
          <source>I think the flaw here is that HTML is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;Chomsky Type 2 grammar (context free grammar)&lt;/a&gt; and RegEx is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_grammar&quot;&gt;Chomsky Type 3 grammar (regular grammar)&lt;/a&gt;. Since a Type 2 grammar is fundamentally more complex than a Type 3 grammar (see the &lt;a href=&quot;http://en.wikipedia.org/wiki/Chomsky_hierarchy&quot;&gt;Chomsky hierarchy&lt;/a&gt;), it is &lt;em&gt;mathematically impossible&lt;/em&gt; to parse XML with RegEx.</source>
          <target state="translated">ここでの欠点は、HTMLが&lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;チョムスキータイプ2文法（文脈自由文法）で&lt;/a&gt;あり、RegExが&lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_grammar&quot;&gt;チョムスキータイプ3文法（標準文法）であること&lt;/a&gt;です。 タイプ2の文法は基本的にタイプ3の文法よりも複雑であるため（ &lt;a href=&quot;http://en.wikipedia.org/wiki/Chomsky_hierarchy&quot;&gt;チョムスキー階層を&lt;/a&gt;参照）、RegExでXMLを解析することは&lt;em&gt;数学的に不可能&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="46e4bbf54843bf1bf2bb54e48219620db67794ee" translate="yes" xml:space="preserve">
          <source>I used a open source tool called &lt;a href=&quot;http://htmlparser.sourceforge.net/&quot;&gt;HTMLParser&lt;/a&gt; before. It's designed to parse HTML in various ways and serves the purpose quite well. It can parse HTML as different treenode and you can easily use its API to get attributes out of the node. Check it out and see if this can help you.</source>
          <target state="translated">以前、 &lt;a href=&quot;http://htmlparser.sourceforge.net/&quot;&gt;HTMLParser&lt;/a&gt;というオープンソースツールを使用していました。 HTMLをさまざまな方法で解析するように設計されており、目的を十分に果たします。 HTMLを別のツリーノードとして解析でき、そのAPIを使用してノードから属性を簡単に取得できます。 それをチェックして、これがあなたを助けることができるかどうか見てください。</target>
        </trans-unit>
        <trans-unit id="50830c82c86965110baf1111e9368113230c821b" translate="yes" xml:space="preserve">
          <source>I used the sample source of:</source>
          <target state="translated">のサンプルソースを使ってみました。</target>
        </trans-unit>
        <trans-unit id="fb040c717878233cc23503d0d656d6a7c4f3856c" translate="yes" xml:space="preserve">
          <source>I wrote it in 30 seconds, and tested here:
&lt;a href=&quot;http://gskinner.com/RegExr/&quot;&gt;http://gskinner.com/RegExr/&lt;/a&gt;</source>
          <target state="translated">私はそれを30秒で書いて、ここでテストしました： &lt;a href=&quot;http://gskinner.com/RegExr/&quot;&gt;http&lt;/a&gt; : //gskinner.com/RegExr/</target>
        </trans-unit>
        <trans-unit id="eb8a7f1667c9d5eff8cc8d64ddbce9b58e23a699" translate="yes" xml:space="preserve">
          <source>I wrote this pattern to power the &lt;em&gt;recursive descent parser&lt;/em&gt; of a template engine I built in my framework, and performances are really great, both in execution times or in memory usage (nothing to do with other template engines which use the same syntax).</source>
          <target state="translated">このパターンは、フレームワークに組み込んだテンプレートエンジンの&lt;em&gt;再帰降下パーサー&lt;/em&gt;を強化するために作成しました。パフォーマンスは、実行時間とメモリ使用量の両方で非常に優れています（同じ構文を使用する他のテンプレートエンジンとは関係ありません）。</target>
        </trans-unit>
        <trans-unit id="f454869fe61fa45429bc7ee92bc5ad9345d8b481" translate="yes" xml:space="preserve">
          <source>I'm sure you already know by now that you shouldn't use regex for this purpose.</source>
          <target state="translated">この目的で正規表現を使ってはいけないことはもうお分かりだと思います。</target>
        </trans-unit>
        <trans-unit id="40dea22884315ebb5434973f5bb9c5c1ca6166f5" translate="yes" xml:space="preserve">
          <source>If You Like Regular Expressions So Much, Why Don't You Marry Them?</source>
          <target state="translated">正規表現がそんなに好きなら、なぜ結婚しないの?</target>
        </trans-unit>
        <trans-unit id="cbfa4fd68fca2bc7eab26c99ba711ac9cab9bb23" translate="yes" xml:space="preserve">
          <source>If an (x)HTML parser needs recursion, a RegExp parser without recursion is not enough for the purpose. It's a simple construct.</source>
          <target state="translated">(x)HTMLパーサーが再帰を必要とする場合、再帰のないRegExpパーサーでは十分ではありません。シンプルな構成になっています。</target>
        </trans-unit>
        <trans-unit id="919388ca02cd994c288549580960ad9ba47f962b" translate="yes" xml:space="preserve">
          <source>If someone is interested in learning more about the pattern, I provide some line:</source>
          <target state="translated">誰かがパターンについて詳しく知りたいと思っているなら、私はいくつかのラインを提供しています。</target>
        </trans-unit>
        <trans-unit id="557f9117f8433eb60bbd29cff5259745d632f952" translate="yes" xml:space="preserve">
          <source>If you add something to the regex, by backtracking it can be forced to match silly things like &lt;code&gt;&amp;lt;a &amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;[^/]&lt;/code&gt; is too permissive. Also note that &lt;code&gt;&amp;lt;space&amp;gt;*[^/]*&lt;/code&gt; is redundant, because the &lt;code&gt;[^/]*&lt;/code&gt; can also match spaces.</source>
          <target state="translated">正規表現に何かを追加すると、バックトラックにより、 &lt;code&gt;&amp;lt;a &amp;gt;&amp;gt;&lt;/code&gt; ようなばかげたものとの一致が強制される可能性があります。 &lt;code&gt;[^/]&lt;/code&gt; は許容範囲が広すぎます。 また、 &lt;code&gt;[^/]*&lt;/code&gt; はスペースにも一致するため、 &lt;code&gt;&amp;lt;space&amp;gt;*[^/]*&lt;/code&gt; は冗長です。</target>
        </trans-unit>
        <trans-unit id="a298912d3657e52c67b5f74e85c231c1485f0d0c" translate="yes" xml:space="preserve">
          <source>If you are unsure, no, I'm NOT kidding (but perhaps I'm lying). It WILL work. I've built tons of unit tests to test it, and I have even used (part of) the &lt;a href=&quot;http://www.w3.org/XML/Test/&quot;&gt;conformance tests&lt;/a&gt;. It's a tokenizer, not a full-blown parser, so it will only split the XML into its component tokens. It won't parse/integrate DTDs.</source>
          <target state="translated">わからない場合は、いいえ、冗談ではありません（しかし、私はうそをついています）。 それが動作します。 私はそれをテストするために大量の単体テストを作成し、 &lt;a href=&quot;http://www.w3.org/XML/Test/&quot;&gt;適合テスト&lt;/a&gt; （の一部）さえ使用しました。 これはトークナイザーであり、本格的なパーサーではないため、XMLをコンポーネントトークンに分割するだけです。 DTDを解析/統合しません。</target>
        </trans-unit>
        <trans-unit id="2b5bc330d9a583246ad4801874fc84163c931493" translate="yes" xml:space="preserve">
          <source>If you have a small set of HTML pages that you want to scrape data from and then stuff into a database, regexes might work fine.  For example, I recently wanted to get the names, parties, and districts of Australian federal Representatives, which I got off of the Parliament's web site.  This was a limited, one-time job.</source>
          <target state="translated">データをスクレイプしてデータベースに入れたいHTMLページの小さなセットがある場合は、正規表現を使うとうまくいくかもしれません。例えば、私は最近、オーストラリア連邦議会のウェブサイトからオーストラリア連邦下院議員の名前、政党、選挙区を取得したいと思っていました。これは一回限りの限定的な作業でした。</target>
        </trans-unit>
        <trans-unit id="d9db7068b93480af65771902d59739a0242c037f" translate="yes" xml:space="preserve">
          <source>If you have problems reconverting it to a human-readable regex, this should help:</source>
          <target state="translated">人間が読める正規表現に変換するのに問題がある場合は、これを使うと良いでしょう。</target>
        </trans-unit>
        <trans-unit id="14633b829212b8b056b036f6830ca7c6a918fe40" translate="yes" xml:space="preserve">
          <source>If you need this for PHP:</source>
          <target state="translated">PHPに必要な場合。</target>
        </trans-unit>
        <trans-unit id="f932b2b6098e1c3395b486c41745029eaaebe046" translate="yes" xml:space="preserve">
          <source>If you're simply trying to find those tags (without ambitions of parsing) try this regular expression:</source>
          <target state="translated">単純にタグを見つけようとしているのであれば(パースする気がないのであれば)、この正規表現を試してみてください。</target>
        </trans-unit>
        <trans-unit id="4b5c78fb6625eec434f0fbf5e5c22e99da727566" translate="yes" xml:space="preserve">
          <source>IgnoreCase (not necessary)</source>
          <target state="translated">IgnoreCase (必要ありません)</target>
        </trans-unit>
        <trans-unit id="195915971c682a24ad48d1e62483babae5188862" translate="yes" xml:space="preserve">
          <source>IgnorePatternWhitespace (not necessary if you collapse regex and remove all whitespace)</source>
          <target state="translated">IgnorePatternWhitespace (正規表現を折りたたんですべての空白を削除する場合は必要ありません)</target>
        </trans-unit>
        <trans-unit id="d8142f0416c264b4b799d2c8a0af8d098608064c" translate="yes" xml:space="preserve">
          <source>In shell, you can parse &lt;a href=&quot;https://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; using &lt;a href=&quot;https://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt;:</source>
          <target state="translated">シェルでは、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt;を使用して&lt;a href=&quot;https://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt;を解析できます 。</target>
        </trans-unit>
        <trans-unit id="3e72a4a4bfbcf98641ca469ef038c0e9caca1753" translate="yes" xml:space="preserve">
          <source>In this case your enemy is HTML and you are either yourself or regex.  You might even be Perl with irregular regex. Know HTML.  Know yourself.</source>
          <target state="translated">この場合の敵はHTMLであり、あなた自身か正規表現のどちらかになります。不規則な正規表現でPerlになってしまうかもしれません。HTMLを知る。自分自身を知る。</target>
        </trans-unit>
        <trans-unit id="4da0bc6ccd100c1869c39b7908884293a4fdecf6" translate="yes" xml:space="preserve">
          <source>It is said that if you know your enemies and know yourself, you can win a hundred battles without a single loss.
  If you only know yourself, but not your opponent, you may win or may lose.
  If you know neither yourself nor your enemy, you will always endanger yourself.</source>
          <target state="translated">敵を知り、自分を知れば百戦危うからずと言われています。敵を知らず自分だけを知れば、勝つこともあれば負けることもある。自分も敵も知らなければ、必ず自分を危険にさらすことになる。</target>
        </trans-unit>
        <trans-unit id="8cd9da1c9f2693e6ec017e2869a577b714739b63" translate="yes" xml:space="preserve">
          <source>It is similar to yours, but the last &lt;code&gt;&amp;gt;&lt;/code&gt; must not be after a slash, and also accepts &lt;code&gt;h1&lt;/code&gt;.</source>
          <target state="translated">これはあなたのものと似ていますが、最後の &lt;code&gt;&amp;gt;&lt;/code&gt; はスラッシュの後に置くことはできず、 &lt;code&gt;h1&lt;/code&gt; も受け入れます。</target>
        </trans-unit>
        <trans-unit id="6ad138f054cb998fb3ecb181104c2f9f5989e48b" translate="yes" xml:space="preserve">
          <source>It is simple enough to rejig my slurp-everything-first Perl script into a nice streaming thing, if you wish to process enormous web pages. But it's not really necessary.</source>
          <target state="translated">膨大なウェブページを処理したいのであれば、私のslurp-everything-firstのPerlスクリプトを素敵なストリーミング用のものに再構築するのは十分に簡単です。しかし、実際にはその必要はありません。</target>
        </trans-unit>
        <trans-unit id="f4114fb01ee1d4a7e528e4b5db702779bb015416" translate="yes" xml:space="preserve">
          <source>It matches the types of tags you mentioned, while ignoring the types you said you wanted to ignore.</source>
          <target state="translated">無視したいと言っていたタグの種類を無視しつつ、言及したタグの種類にマッチします。</target>
        </trans-unit>
        <trans-unit id="e92b765161d9c9393ab926712762103321511c85" translate="yes" xml:space="preserve">
          <source>It may not be perfect, but I ran this code through a &lt;em&gt;lot&lt;/em&gt; of HTML. Note that it even catches strange things like &lt;code&gt;&amp;lt;a name=&quot;badgenerator&quot;&quot;&amp;gt;&lt;/code&gt;, which show up on the web.</source>
          <target state="translated">完璧ではないかもしれませんが、私はこのコードを&lt;em&gt;多く&lt;/em&gt;のHTMLで実行しました。 Webに表示される &lt;code&gt;&amp;lt;a name=&quot;badgenerator&quot;&quot;&amp;gt;&lt;/code&gt; のような奇妙なものさえもキャッチすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3c401fdac65c6774bcadecd58093d69231332e3b" translate="yes" xml:space="preserve">
          <source>It seems to me you're trying to match tags without a &quot;/&quot; at the end. Try this:</source>
          <target state="translated">タグの最後に&quot;&quot;を付けずにマッチさせようとしているように見えます。これを試してみてください。</target>
        </trans-unit>
        <trans-unit id="f6ca3fc0ed09308a49c656e7527184db98c56489" translate="yes" xml:space="preserve">
          <source>It's called htmlsplit, splits the HTML into lines, with one tag or chunk of text on each line.  The lines can then be processed further with other text tools and scripts, such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt;, Perl, etc. I'm not even joking :) Enjoy.</source>
          <target state="translated">これはhtmlsplitと呼ばれ、HTMLを行に分割し、各行に1つのタグまたはテキストのチャンクを付けます。 この行は、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt; 、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt; 、Perlなどの他のテキストツールやスクリプトでさらに処理できます。冗談でもありません:)お楽しみください。</target>
        </trans-unit>
        <trans-unit id="9ec7139f7024ff295c9ba4a49287ac0b4b6fc319" translate="yes" xml:space="preserve">
          <source>It's true that when programming it's usually best to use dedicated parsers and APIs instead of regular expressions when dealing with HTML, especially if accuracy is paramount (e.g., if your processing might have security implications). However, I don&amp;rsquo;t ascribe to a dogmatic view that XML-style markup should never be processed with regular expressions. There are cases when regular expressions are a great tool for the job, such as when making one-time edits in a text editor, fixing broken XML files, or dealing with file formats that look like but aren&amp;rsquo;t quite XML. There are some issues to be aware of, but they're not insurmountable or even necessarily relevant.</source>
          <target state="translated">特に正確さが最優先の場合（たとえば、処理がセキュリティに影響を与える可能性がある場合）、HTMLを処理するときは、通常、プログラミング時に正規表現ではなく専用のパーサーとAPIを使用するのが最善です。 ただし、XMLスタイルのマークアップを正規表現で処理してはならないという独断的な見方には同意しません。 テキストエディターで1回限りの編集を行ったり、壊れたXMLファイルを修正したり、XMLに似ていても完全ではないファイル形式を処理したりする場合など、正規表現が仕事に最適なツールとなる場合があります。 知っておくべき問題がいくつかありますが、それらは乗り越えられないわけではなく、必ずしも関連性さえありません。</target>
        </trans-unit>
        <trans-unit id="39e7ab248960684eaa9b9f720409b41a17a28cff" translate="yes" xml:space="preserve">
          <source>It's written as a PHP string, so the &quot;s&quot; modifier makes classes include newlines.</source>
          <target state="translated">PHPの文字列として書かれているので、&quot;s &quot;修飾子でクラスに改行が含まれるようになっています。</target>
        </trans-unit>
        <trans-unit id="427486fffe171253525e01e3f06e796d5676dc63" translate="yes" xml:space="preserve">
          <source>Just to give a sense of what a more &quot;advanced&quot; HTML regex would look like, the following does a fairly respectable job of emulating real-world browser behavior and the HTML5 parsing algorithm:</source>
          <target state="translated">より「高度な」HTML 正規表現がどのように見えるかの感覚を与えるために、以下は実世界のブラウザの動作と HTML5 の解析アルゴリズムをエミュレートするためのかなり立派な仕事をしています。</target>
        </trans-unit>
        <trans-unit id="22605049c94f39fec40c01fc01b8d0235c7512b9" translate="yes" xml:space="preserve">
          <source>Just try it.</source>
          <target state="translated">試してみてください。</target>
        </trans-unit>
        <trans-unit id="601daad3ec0906e4e0d799c06fb0f95e6770d70e" translate="yes" xml:space="preserve">
          <source>Lastly, I really enjoyed Jeff Atwood's article:  &lt;a href=&quot;https://blog.codinghorror.com/parsing-html-the-cthulhu-way/&quot;&gt;Parsing Html The Cthulhu Way&lt;/a&gt;. Funny enough, it cites the answer to this question that currently has over 4k votes.</source>
          <target state="translated">最後に、Jeff Atwoodの記事「 &lt;a href=&quot;https://blog.codinghorror.com/parsing-html-the-cthulhu-way/&quot;&gt;Parsing Html The Cthulhu Way」&lt;/a&gt;を本当に楽しんだ。 面白いことに、この質問への回答は現在4千票を超えています。</target>
        </trans-unit>
        <trans-unit id="d67da4c32f78ca5c993f0ad4bcd5b49e6538c409" translate="yes" xml:space="preserve">
          <source>Like Lord Marshal (is he a relative of the Marshal .NET class?), I have seen the &lt;strike&gt;Underverse&lt;/strike&gt; Stack Based Regex-Verse and returned with &lt;strike&gt;powers&lt;/strike&gt; knowledge you can't imagine. Yes, I think there were an Old One or two protecting them, but they were watching football on the TV, so it wasn't difficult.</source>
          <target state="translated">Lord Marshalと同様に（彼はMarshal .NETクラスの親類ですか？）、 &lt;strike&gt;Underverse&lt;/strike&gt; Stack Based Regex-Verseを見て、想像もできないような&lt;strike&gt;力の&lt;/strike&gt;知識で戻ってきました。 はい、彼らを守るオールドワンか2人がいたと思いますが、彼らはテレビでフットボールを見ていましたので、難しくありませんでした。</target>
        </trans-unit>
        <trans-unit id="1c3e6997e482742cdf179a4397cb018cad2d8564" translate="yes" xml:space="preserve">
          <source>Microsoft actually has a section of &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices&quot;&gt;Best Practices for Regular Expressions in the .NET Framework&lt;/a&gt; and specifically talks about &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices#consider-the-input-source&quot;&gt;Consider[ing] the Input Source&lt;/a&gt;.</source>
          <target state="translated">マイクロソフトには、実際に&lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices&quot;&gt;.NET Frameworkの正規表現のベストプラクティスの&lt;/a&gt;セクションがあり、特に&lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices#consider-the-input-source&quot;&gt;入力ソースの検討&lt;/a&gt;について説明しています 。</target>
        </trans-unit>
        <trans-unit id="ba3b99fc49923cc3bbd90f5e080753b12725e9bc" translate="yes" xml:space="preserve">
          <source>My suggestion would be</source>
          <target state="translated">私の提案は</target>
        </trans-unit>
        <trans-unit id="72810c91afedb33b80069b7076436fecf94d1af6" translate="yes" xml:space="preserve">
          <source>No, holy cow, no match found.</source>
          <target state="translated">一致するものが見つかりませんでした</target>
        </trans-unit>
        <trans-unit id="a474b6597430f9ba4fac174b06490808a6e22af5" translate="yes" xml:space="preserve">
          <source>Note that this allows things like &lt;code&gt;&amp;lt;a/ &amp;gt;&lt;/code&gt; (just like the original regex), so if you want something more restrictive, you need to build a regex to match attribute pairs separated by spaces.</source>
          <target state="translated">これにより、 &lt;code&gt;&amp;lt;a/ &amp;gt;&lt;/code&gt; （元の正規表現と同様）が許可されるため、さらに制限が必要な場合は、スペースで区切られた属性ペアに一致する正規表現を作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="aa7cf65bf2ed58b9c07633b4dd41874bd458e314" translate="yes" xml:space="preserve">
          <source>Now, we could speak about the limits of this method from a more informed point of view:</source>
          <target state="translated">さて、この方法の限界について、より詳しい視点からお話することができました。</target>
        </trans-unit>
        <trans-unit id="1022301500a966b54ef35dd0b0c702c86a1e6cad" translate="yes" xml:space="preserve">
          <source>Oh... if you want the source code of the regex, with some auxiliary methods:</source>
          <target state="translated">ああ...補助的なメソッドを含む正規表現のソースコードが欲しいなら</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="efc9dd879d5fa6c41b5a8b4a174e9bbeea207c3f" translate="yes" xml:space="preserve">
          <source>P.S. Pierre de Fermat also figured out how to do it, but the margin he was writing in wasn't big enough for the code.</source>
          <target state="translated">P.S.ピエール・ド・フェルマーも方法を考えたのですが、書き込んでいた余白がコードの大きさに足りませんでした。</target>
        </trans-unit>
        <trans-unit id="fb344f772f606bf069b994b1800b75ad467d5eb0" translate="yes" xml:space="preserve">
          <source>Profit!</source>
          <target state="translated">Profit!</target>
        </trans-unit>
        <trans-unit id="ffe7bde078bc620df9c2922255941de3200d1c7e" translate="yes" xml:space="preserve">
          <source>Quote from article 1 cited above:</source>
          <target state="translated">上に引用した記事1から引用します。</target>
        </trans-unit>
        <trans-unit id="ebb8b5eff359c8e4629b4281a740853315bc1649" translate="yes" xml:space="preserve">
          <source>RegEx match open tags except XHTML self-contained tags</source>
          <target state="translated">RegExはXHTMLの自己完結型タグ以外のオープンタグにマッチします。</target>
        </trans-unit>
        <trans-unit id="8336d194052f52769b114f9bc2344752e9b3f02b" translate="yes" xml:space="preserve">
          <source>Regexes worked just fine for me, and were very fast to set up.</source>
          <target state="translated">Regex は私にはちょうどよく機能し、セットアップも非常に速かったです。</target>
        </trans-unit>
        <trans-unit id="9ca09288e6a253e0dfa4bc1e29bfae12ab028bb9" translate="yes" xml:space="preserve">
          <source>Regular Expression Explained (inline)</source>
          <target state="translated">正規表現の説明 (インライン)</target>
        </trans-unit>
        <trans-unit id="24b2174abc016feccbfb08853265c6a5a2ea6e89" translate="yes" xml:space="preserve">
          <source>Regular Expressions do have limitations, but have you considered the following?</source>
          <target state="translated">正規表現には制限がありますが、以下のようなことを考えたことはありますか?</target>
        </trans-unit>
        <trans-unit id="f20c01e8fa442e15f50708e2e685f84f38cf9f06" translate="yes" xml:space="preserve">
          <source>Regular Expressions: Now You Have Two Problems</source>
          <target state="translated">正規表現。今、あなたは二つの問題を抱えています</target>
        </trans-unit>
        <trans-unit id="b49c5b3c647bd9589b36c369c0bc3c5a638f66ed" translate="yes" xml:space="preserve">
          <source>Related (why you shouldn't use regex match):</source>
          <target state="translated">関連(正規表現一致を使ってはいけない理由)。</target>
        </trans-unit>
        <trans-unit id="16962bdac3ee084e07372a69f0ada8648f72cfce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.microsoft.com/archive/blogs/bclteam/net-regular-expressions-regex-and-balanced-matching-ryan-byington&quot;&gt;.NET Regular Expressions: Regex and Balanced Matching&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.microsoft.com/archive/blogs/bclteam/net-regular-expressions-regex-and-balanced-matching-ryan-byington&quot;&gt;.NET正規表現：正規表現とバランスマッチングを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="de60e0a6c744236d2ff2a2469aa87dabd965b8f9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://weblogs.asp.net/whaggard/377025&quot;&gt;Matching Balanced Constructs with .NET Regular Expressions&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://weblogs.asp.net/whaggard/377025&quot;&gt;.NET正規表現によるバランスのとれた構成のマッチングを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a3ea9fb6afc3bc06c915f2dc863ae7a60ef9464e" translate="yes" xml:space="preserve">
          <source>See Microsoft's docs on &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;Balancing Group Definitions&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;グループ定義の分散&lt;/a&gt;に関するMicrosoftのドキュメントを参照してください</target>
        </trans-unit>
        <trans-unit id="0ad4363c94846f440a3409baad524ee90a091468" translate="yes" xml:space="preserve">
          <source>Should you find something which does not work in the proof of concept above, I am available in analyzing the code to improve my skills.</source>
          <target state="translated">あなたが上記の概念の証明で動作しない何かを見つける必要があります、私は私のスキルを向上させるためにコードを分析するために利用可能です。</target>
        </trans-unit>
        <trans-unit id="92cfc65b8206d5667dc7ccac83a9a9a793d658df" translate="yes" xml:space="preserve">
          <source>Since nobody mentioned the main mechanism a parser is built onto, I was soon aware that nobody got the point.</source>
          <target state="translated">誰もパーサが組み込まれている主なメカニズムについて言及していないので、誰も意味を理解していないことにすぐに気がつきました。</target>
        </trans-unit>
        <trans-unit id="4e222f3f71ebc82ced1555d79e3896204e2da9f1" translate="yes" xml:space="preserve">
          <source>Singleline</source>
          <target state="translated">Singleline</target>
        </trans-unit>
        <trans-unit id="2e489e37aeb575873f40d9f8a80c3e74b1c26ae6" translate="yes" xml:space="preserve">
          <source>Small tip: to better analyze this code it is necessary looking at the source code generated since I did not provide any HTML special characters escaping.</source>
          <target state="translated">小さなヒント:私は任意のHTMLの特殊文字エスケープを提供していないので、より良いこのコードを分析するには、生成されたソースコードを見ている必要があります。</target>
        </trans-unit>
        <trans-unit id="2ccc837c5ed1e3feef77351cd1d620591415719e" translate="yes" xml:space="preserve">
          <source>Solve the Halting Problem.</source>
          <target state="translated">停車問題を解決する。</target>
        </trans-unit>
        <trans-unit id="b8fc19b88ebcae8fab9f0ca6d99cb4a564e9d1d4" translate="yes" xml:space="preserve">
          <source>Square a circle.</source>
          <target state="translated">円を四角くする。</target>
        </trans-unit>
        <trans-unit id="e1c5ebb5af83fa15c6406a756fafb86dfda684e1" translate="yes" xml:space="preserve">
          <source>Sun Tzu, an ancient Chinese strategist, general, and philosopher, said:</source>
          <target state="translated">古代中国の戦略家、将軍、哲学者である孫子が言っていました。</target>
        </trans-unit>
        <trans-unit id="1361c33aa4292835661dbf5c91a1e629b1a6decc" translate="yes" xml:space="preserve">
          <source>The .NET framework is unique when it comes to regular expressions in that it supports &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;Balancing Group Definitions&lt;/a&gt;.</source>
          <target state="translated">.NETフレームワークは、正規表現に関しては、 &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;Balancing Group Definitionsを&lt;/a&gt;サポートするという点で独特です。</target>
        </trans-unit>
        <trans-unit id="55da94ce9e0ca8998eabc3076f92485f67f4f2eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.php.net/manual/en/function.dom-import-simplexml.php&quot;&gt;PHP DOM&lt;/a&gt;&lt;a href=&quot;http://php.net/manual/en/class.domdocument.php&quot;&gt;functions&lt;/a&gt; won't work properly unless it is properly formatted XML. No matter how much better their use is for the rest of mankind.</source>
          <target state="translated">&lt;a href=&quot;http://www.php.net/manual/en/function.dom-import-simplexml.php&quot;&gt;PHP DOM&lt;/a&gt; &lt;a href=&quot;http://php.net/manual/en/class.domdocument.php&quot;&gt;関数&lt;/a&gt;は、適切にフォーマットされたXMLでない限り、正しく機能しません。 他の人類にとってそれらの使用がどれほど優れていても。</target>
        </trans-unit>
        <trans-unit id="4ac395740ae412d2f1cc1a46e41f7844bd6163b7" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;black art of RegExp is hard to master&lt;/strong&gt;, so maybe there are further possibilities we left out while trying and testing our personal solution to capture the whole web in one hand... Well, I am sure about it :)</source>
          <target state="translated">&lt;strong&gt;RegExp&lt;/strong&gt;の&lt;strong&gt;ブラックアートを習得するのは難しい&lt;/strong&gt;ので、Web全体を片手でキャプチャするための個人用ソリューションを試してテストしている間に除外された可能性がさらにあるかもしれません...まあ、私はそれについて確信しています:)</target>
        </trans-unit>
        <trans-unit id="997812962876e0edf9df4c8486980789ffe0886d" translate="yes" xml:space="preserve">
          <source>The W3C explains parsing in a pseudo regexp form:</source>
          <target state="translated">W3Cでは、擬似正規表現形式でのパースについて説明しています。</target>
        </trans-unit>
        <trans-unit id="fdcdc94a48b14eafa651bbe7dd5b0b9e404ab530" translate="yes" xml:space="preserve">
          <source>The best way to write regular expressions is in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Lex_%28software%29&quot;&gt;Lex&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; style, not as opaque one-liners or commented multi-line monstrosities. I didn't do that here, yet; these ones barely need it.</source>
          <target state="translated">正規表現を書くための最良の方法は、不透明な1行やコメント付きの複数行の怪物ではなく、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Lex_%28software%29&quot;&gt;Lex&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt;スタイルです。 ここではまだそれをしていません。 これらはほとんど必要ありません。</target>
        </trans-unit>
        <trans-unit id="712ab4b4a1f7ed2c6d0a80c8195f21170140f25f" translate="yes" xml:space="preserve">
          <source>The following matches a fairly strict definition of XML tags (although it doesn't account for the full set of Unicode characters allowed in XML names):</source>
          <target state="translated">以下は、かなり厳密なXMLタグの定義と一致しています(ただし、XML名で許可されているUnicode文字の完全なセットは考慮されていません)。</target>
        </trans-unit>
        <trans-unit id="b4cfd79b880dc8c38082dbd0830e9fdee4557b44" translate="yes" xml:space="preserve">
          <source>The options to set is &lt;code&gt;RegexOptions.ExplicitCapture&lt;/code&gt;. The capture group you are looking for is &lt;code&gt;ELEMENTNAME&lt;/code&gt;. If the capture group &lt;code&gt;ERROR&lt;/code&gt; is not empty then there was a parsing error and the Regex stopped.</source>
          <target state="translated">設定するオプションは &lt;code&gt;RegexOptions.ExplicitCapture&lt;/code&gt; です。 探しているキャプチャグループは &lt;code&gt;ELEMENTNAME&lt;/code&gt; です。 キャプチャグループ &lt;code&gt;ERROR&lt;/code&gt; が空でない場合、解析エラーが発生し、正規表現が停止しました。</target>
        </trans-unit>
        <trans-unit id="42afcd3eb11823b2c3d7a0e945433e5d9be383b6" translate="yes" xml:space="preserve">
          <source>The parts explained:</source>
          <target state="translated">部品の説明をしました。</target>
        </trans-unit>
        <trans-unit id="7b1c98adf4b68d1b5b5505c62c8cdcb98c54e922" translate="yes" xml:space="preserve">
          <source>The pattern will be pretty big, so make sure you have an algorithm that losslessly compresses random data.</source>
          <target state="translated">かなり大きなパターンになるので、ランダムなデータをロスレスに圧縮するアルゴリズムを用意しておきましょう。</target>
        </trans-unit>
        <trans-unit id="7216ec9c43638b3c7e394bf44fd4c73431e98cef" translate="yes" xml:space="preserve">
          <source>The suggested regex is wrong, though:</source>
          <target state="translated">提案された正規表現は間違っていますが。</target>
        </trans-unit>
        <trans-unit id="9a7f6c57efe365adfc81358edd4c2317e716adc0" translate="yes" xml:space="preserve">
          <source>The tag to match may end with a simple &quot;&amp;gt;&quot; symbol, or a possible XHTML closure, which makes use of the slash before it: (/&amp;gt;|&amp;gt;). The slash is, of course, escaped since it coincides with the regular expression delimiter.</source>
          <target state="translated">一致するタグは、単純な &quot;&amp;gt;&quot;記号、またはその前のスラッシュを使用する可能なXHTMLクロージャで終了する場合があります：（/&amp;gt; |&amp;gt;）。 スラッシュは、正規表現の区切り文字と一致するため、もちろんエスケープされます。</target>
        </trans-unit>
        <trans-unit id="d8320be450cb3daac23d24918c511589e5cc20d4" translate="yes" xml:space="preserve">
          <source>The user @ridgerunner noticed that the pattern does not allow &lt;strong&gt;unquoted attributes&lt;/strong&gt; or &lt;strong&gt;attributes with no value&lt;/strong&gt;. In this case a fine tuning brings us the following pattern:</source>
          <target state="translated">ユーザー@ridgerunnerは、パターンが&lt;strong&gt;引用符で囲まれて&lt;/strong&gt;いない&lt;strong&gt;属性&lt;/strong&gt;または&lt;strong&gt;値のない属性を&lt;/strong&gt;許可しないことに気づきました。 この場合、微調整により次のパターンが得られます。</target>
        </trans-unit>
        <trans-unit id="96ae70a6ef53719f5c2ee204876a53bf013a8cbd" translate="yes" xml:space="preserve">
          <source>Then, since a tag may end with a whitespace before the &quot;&amp;gt;&quot; symbol, zero or more whitespaces are matched with the \s* subpattern.</source>
          <target state="translated">次に、タグが &quot;&amp;gt;&quot;記号の前の空白文字で終了する可能性があるため、0個以上の空白文字が\ s *サブパターンと一致します。</target>
        </trans-unit>
        <trans-unit id="868220302ade7af78023c7b85a0b0afbdb075b65" translate="yes" xml:space="preserve">
          <source>There are people that will tell you that Regular Expressions shouldn't be recursive. They are limiting you. They need to subjugate you, and they do it by keeping you in ignorance.</source>
          <target state="translated">正規表現は再帰的であるべきではないと言う人がいます。彼らはあなたを制限しているのです。彼らはあなたを服従させる必要があり、あなたを無知のままにしておくことでそれをしているのです。</target>
        </trans-unit>
        <trans-unit id="62180d2f49459a045257d1d5b700900365c68916" translate="yes" xml:space="preserve">
          <source>There are people that will tell you that the Earth is round (or perhaps that the Earth is an oblate spheroid if they want to use strange words). They are lying.</source>
          <target state="translated">地球は丸いと言う人がいます(変な言葉を使いたければ、地球は楕円球体だと言うかもしれません)。彼らは嘘をついています。</target>
        </trans-unit>
        <trans-unit id="684dfff1de896a122d012445ef544b2496206f87" translate="yes" xml:space="preserve">
          <source>There are some nice regexes for replacing HTML with BBCode &lt;a href=&quot;http://www.garyshood.com/htmltobb/source.txt&quot;&gt;here&lt;/a&gt;. For all you nay-sayers, note that he's not trying to fully parse HTML, just to sanitize it. He can probably afford to kill off tags that his simple &quot;parser&quot; can't understand.</source>
          <target state="translated">HTMLをBBCodeに置き換えるための素晴らしい正規表現がいくつかあり&lt;a href=&quot;http://www.garyshood.com/htmltobb/source.txt&quot;&gt;ます&lt;/a&gt; 。 言い分を言わないすべての人にとって、彼はHTMLを完全に解析するのではなく、それをサニタイズしようとしていることに注意してください。 彼はおそらく、彼の単純な「パーサー」が理解できないタグを削除する余裕があります。</target>
        </trans-unit>
        <trans-unit id="76477d9fdddcc475f5d450550d80b052eec3964d" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;http://blog.stevenlevithan.com/archives/match-innermost-html-element&quot;&gt;definitive blog post&lt;/a&gt; about matching innermost HTML elements written by Steven Levithan.</source>
          <target state="translated">Steven Levithanによって書かれた最も内側のHTML要素のマッチングに関する&lt;a href=&quot;http://blog.stevenlevithan.com/archives/match-innermost-html-element&quot;&gt;決定的なブログ投稿&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="a4e1c0773bdde0557a23f8bb7011bb1819bc446f" translate="yes" xml:space="preserve">
          <source>These constructs allow for a .NET regular expression to emulate a
  restricted PDA by essentially allowing simple versions of the stack
  operations: push, pop and empty. The simple operations are pretty much
  equivalent to increment, decrement and compare to zero respectively.
  This allows for the .NET regular expression engine to recognize a
  subset of the context-free languages, in particular the ones that only
  require a simple counter. This in turn allows for the non-traditional
  .NET regular expressions to recognize individual properly balanced
  constructs.</source>
          <target state="translated">これらの構成により、.NET 正規表現は、基本的にスタック操作の単純なバージョンであるプッシュ、ポップ、エンプティを許可することで、制限された PDA をエミュレートすることができます。これらの単純な操作は、それぞれインクリメント、デクリメント、ゼロとの比較に相当します。これにより、.NET正規表現エンジンはコンテキストフリー言語のサブセット、特に単純なカウンタのみを必要とする言語を認識することができます。これにより、伝統的ではない.NET正規表現でも、個々の適切にバランスのとれた構造体を認識することができます。</target>
        </trans-unit>
        <trans-unit id="83ac605b777d6f693f2b21254eb270d567a76728" translate="yes" xml:space="preserve">
          <source>They are good for XML / XHTML.</source>
          <target state="translated">それらはXML XHTMLに適しています。</target>
        </trans-unit>
        <trans-unit id="ea04181710e1449f97e72ce6888abc9705be60aa" translate="yes" xml:space="preserve">
          <source>This found the match:</source>
          <target state="translated">これで一致しました。</target>
        </trans-unit>
        <trans-unit id="bbe32d2a62e217c596147afa1c643ecf26c036ca" translate="yes" xml:space="preserve">
          <source>This is the regex I use (!) to match HTML tags:</source>
          <target state="translated">これは私がHTMLタグにマッチさせるために使っている正規表現(!)です。</target>
        </trans-unit>
        <trans-unit id="d8d8d6a39df8c08ee1ff1787d57aba7ddbd1bee3" translate="yes" xml:space="preserve">
          <source>This post is locked to prevent inappropriate edits to its content. The post looks exactly as it is supposed to look - there are no problems with its content. Please do not flag it for our attention.</source>
          <target state="translated">この投稿は、内容の不適切な編集を防ぐためにロックされています。この投稿は見た目通りに見えます-内容には何の問題もありません。私たちの注意を引くためにフラグを立てないでください。</target>
        </trans-unit>
        <trans-unit id="20cb5dd39a077afa5b7e29efe1aa539dad4031b6" translate="yes" xml:space="preserve">
          <source>To test it deeply, I entered in the string auto-closing tags like:</source>
          <target state="translated">深くテストするために、文字列の自動閉鎖タグのようなものを入力してみました。</target>
        </trans-unit>
        <trans-unit id="102acb4ebe4f9295900af5f522c91830395377c0" translate="yes" xml:space="preserve">
          <source>Try:</source>
          <target state="translated">Try:</target>
        </trans-unit>
        <trans-unit id="a26ac4a7ee00f2bdbb69b3a7cd21e43c2ce7b858" translate="yes" xml:space="preserve">
          <source>Turing.sed</source>
          <target state="translated">Turing.sed</target>
        </trans-unit>
        <trans-unit id="a28f42522bb52c00621284c63c8ba53d7dfda10f" translate="yes" xml:space="preserve">
          <source>UNRELATED</source>
          <target state="translated">UNRELATED</target>
        </trans-unit>
        <trans-unit id="e8d3e730d87ce69a125b79edeeb87c6e997fdfb7" translate="yes" xml:space="preserve">
          <source>Understanding the pattern</source>
          <target state="translated">パターンを理解する</target>
        </trans-unit>
        <trans-unit id="ada5ca9b4d7507ffcf81b9659577ff9cbe1d1ccf" translate="yes" xml:space="preserve">
          <source>Use the flags:</source>
          <target state="translated">旗を使え</target>
        </trans-unit>
        <trans-unit id="24df9df6515abc09f921403db3f2eb9d44796515" translate="yes" xml:space="preserve">
          <source>W3C Link</source>
          <target state="translated">W3Cリンク</target>
        </trans-unit>
        <trans-unit id="01acb4cbe019ba6b6ce6e22bcd09638b1774d9c8" translate="yes" xml:space="preserve">
          <source>Whenever I need to quickly extract something from an HTML document, I use Tidy to convert it to XML and then use XPath or XSLT to get what I need.
In your case, something like this:</source>
          <target state="translated">HTML文書から何かを素早く抽出する必要があるときは、Tidyを使ってXMLに変換し、XPathやXSLTを使って必要なものを取得しています。あなたの場合は、こんな感じです。</target>
        </trans-unit>
        <trans-unit id="49b8872857a1e031d0578f467b1e399793cd9b96" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;(?&amp;lt;! ... )&lt;/code&gt; is (in Perl regexes) the negative look-behind. It reads &quot;a &amp;lt;, then a word, then anything that's not a &amp;gt;, the last of which may not be a /, followed by &amp;gt;&quot;.</source>
          <target state="translated">&lt;code&gt;(?&amp;lt;! ... )&lt;/code&gt; は（Perl正規表現では）否定的な後読みです。 これは、「&amp;lt;、次に単語、&amp;gt;でないもの、最後が/でない可能性があり、その後に&amp;gt;」と表示されます。</target>
        </trans-unit>
        <trans-unit id="d88b6a634389ee3ca966ecac67f70a5331dc8d96" translate="yes" xml:space="preserve">
          <source>While &lt;em&gt;arbitrary&lt;/em&gt; HTML with only a regex is impossible, it's sometimes appropriate to use them for parsing a &lt;em&gt;limited, known&lt;/em&gt; set of HTML.</source>
          <target state="translated">正規表現のみで&lt;em&gt;任意の&lt;/em&gt; HTMLを作成することは不可能ですが&lt;em&gt;、既知の制限された&lt;/em&gt; HTMLのセットを解析するためにそれらを使用することが適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="b1bfbd9fe61d2ecc1e2a19393a476e7388bf0166" translate="yes" xml:space="preserve">
          <source>While the answers that you can't parse HTML with regexes are correct, they don't apply here. The OP just wants to parse one HTML tag with regexes, and that is something that can be done with a regular expression.</source>
          <target state="translated">正規表現を使ってHTMLを解析できないという回答は正しいですが、ここでは当てはまりません。OPはただ一つのHTMLタグを正規表現で解析したいだけで、それは正規表現でできることです。</target>
        </trans-unit>
        <trans-unit id="93249a5d51a2ea1bf181a9d0b47641aa389e6924" translate="yes" xml:space="preserve">
          <source>With minor variations, it can cope with messy HTML... or convert the HTML -&amp;gt; XHTML first.</source>
          <target state="translated">マイナーなバリエーションで、乱雑なHTMLに対応できます...または、最初にHTML-&amp;gt; XHTMLに変換します。</target>
        </trans-unit>
        <trans-unit id="86912b1a63422276d3fb2e364ae480edfb2fc529" translate="yes" xml:space="preserve">
          <source>Work out the Traveling Salesman Problem in O(log n) or less. If it's any more than that, you'll run out of RAM and the engine will hang.</source>
          <target state="translated">旅するセールスマン問題を O(log n)以下で解く。それ以上になるとRAMが不足してエンジンがハングアップしてしまいます。</target>
        </trans-unit>
        <trans-unit id="865301223dfe7d72c3b014a14a4edf685de64f15" translate="yes" xml:space="preserve">
          <source>Write HTML parser (homework)</source>
          <target state="translated">HTMLパーサーを書く(宿題</target>
        </trans-unit>
        <trans-unit id="99b34e00427c7bc9e27cce20b1b8167ea540549e" translate="yes" xml:space="preserve">
          <source>You can live in their reality or take the red pill.</source>
          <target state="translated">彼らの現実の中で生きるか、赤い薬を飲むか。</target>
        </trans-unit>
        <trans-unit id="a6a9711b57d9a5eea84e16f2d7ce057f02584407" translate="yes" xml:space="preserve">
          <source>You can try this at &lt;a href=&quot;http://derekslager.com/blog/posts/2007/09/a-better-dotnet-regular-expression-tester.ashx&quot;&gt;A Better .NET Regular Expression Tester&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://derekslager.com/blog/posts/2007/09/a-better-dotnet-regular-expression-tester.ashx&quot;&gt;A Better .NET正規表現テスターで&lt;/a&gt;これを試すことができます 。</target>
        </trans-unit>
        <trans-unit id="6b81d0ffa357688587ac76745c399587c1efb48a" translate="yes" xml:space="preserve">
          <source>You can't parse [X]HTML with regex. Because HTML can't be parsed by regex. Regex is not a tool that can be used to correctly parse HTML. As I have answered in HTML-and-regex questions here so many times before, the use of regex will not allow you to consume HTML. Regular expressions are a tool that is insufficiently sophisticated to understand the constructs employed by HTML. HTML is not a regular language and hence cannot be parsed by regular expressions. Regex queries are not equipped to break down HTML into its meaningful parts. so many times but it is not getting to me. Even enhanced irregular regular expressions as used by Perl are not up to the task of parsing HTML. You will never make me crack. HTML is a language of sufficient complexity that it cannot be parsed by regular expressions. Even Jon Skeet cannot parse HTML using regular expressions. Every time you attempt to parse HTML with regular expressions, the unholy child weeps the blood of virgins, and Russian hackers pwn your webapp. Parsing HTML with regex summons tainted souls into the realm of the living. HTML and regex go together like love, marriage, and ritual infanticide. The &amp;lt;center&amp;gt; cannot hold it is too late. The force of regex and HTML together in the same conceptual space will destroy your mind like so much watery putty. If you parse HTML with regex you are giving in to Them and their blasphemous ways which doom us all to inhuman toil for the One whose Name cannot be expressed in the Basic Multilingual Plane, he comes. HTML-plus-regexp will liquify the n​erves of the sentient whilst you observe, your psyche withering in the onslaught of horror. Rege̿̔̉x-based HTML parsers are the cancer that is killing StackOverflow</source>
          <target state="translated">正規表現では[X] HTMLを解析できません。 正規表現ではHTMLを解析できないためです。 正規表現は、HTMLを正しく解析するために使用できるツールではありません。 ここで何度もHTMLと正規表現の質問に回答したので、正規表現を使用するとHTMLを使用できなくなります。 正規表現は、HTMLで採用されている構成を理解するには不十分で高度なツールです。 HTMLは通常の言語ではないため、正規表現で解析できません。 正規表現クエリは、HTMLを意味のある部分に分解する機能を備えていません。 何度もですが、私には届きません。 Perlで使用されているように拡張された不規則な正規表現でさえ、HTMLを解析する役割を果たしていません。 あなたは私をクラックさせません。 HTMLは、正規表現で解析できないほど複雑な言語です。 Jon Skeetでさえ、正規表現を使用してHTMLを解析することはできません。 正規表現を使用してHTMLを解析しようとするたびに、不浄な子が処女の血を流し、ロシアのハッカーがWebアプリケーションを作成します。 正規表現でHTMLを解析すると、汚染された魂が生活の領域に呼び出されます。 HTMLと正規表現は、愛、結婚、儀式的な幼児殺害のように一緒になります。 &amp;lt;center&amp;gt;はそれを保持できません。 正規表現とHTMLが同じ概念空間で一緒に働く力は、水っぽいパテのようにあなたの心を破壊します。 正規表現を使用してHTMLを解析すると、それらとそれらの冒涜的な方法に屈服し、基本的な多言語プレーンで名前を表現できない人のために非人道的な苦労をします。 HTML-plus-regexpは、あなたが観察している間、感覚の神経を液化させ、あなたの精神は恐怖の猛攻撃で衰退します。 Rege̿̔̉xベースのHTMLパーサーはStackOverflowを殺している癌です</target>
        </trans-unit>
        <trans-unit id="d4cc5878bfc8de446a816e62a10b477bf7628da8" translate="yes" xml:space="preserve">
          <source>You want the first &lt;code&gt;&amp;gt;&lt;/code&gt; not preceded by a &lt;code&gt;/&lt;/code&gt;.  Look &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;here&lt;/a&gt; for details on how to do that.  It's referred to as negative lookbehind.</source>
          <target state="translated">最初に &lt;code&gt;&amp;gt;&lt;/code&gt; ないでください。 その方法の詳細については、 &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;こちら&lt;/a&gt;をご覧ください。 ネガティブ後読みと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="0f094d4f9e70b554306ad025350bec42add64291" translate="yes" xml:space="preserve">
          <source>a&lt;sup&gt;n&lt;/sup&gt;ba&lt;sup&gt;n&lt;/sup&gt;ba&lt;sup&gt;n&lt;/sup&gt; which is not regular and not even context free, can be matched with &lt;code&gt;^(a+)b\1b\1$&lt;/code&gt;</source>
          <target state="translated">a &lt;sup&gt;n&lt;/sup&gt; ba &lt;sup&gt;n&lt;/sup&gt; ba &lt;sup&gt;n&lt;/sup&gt;は規則的ではなく、コンテキストフリーでもないため、 &lt;code&gt;^(a+)b\1b\1$&lt;/code&gt; と照合できます。</target>
        </trans-unit>
        <trans-unit id="7f7db1a41076f29a8bc513a82d4eeb79c22c4b29" translate="yes" xml:space="preserve">
          <source>according to the specific implementation of the RegExp engine, recursion may have a limit in the &lt;strong&gt;number of nested patterns parsed&lt;/strong&gt;, but it depends on the language used</source>
          <target state="translated">RegExpエンジンの特定の実装によると、再帰は、 &lt;strong&gt;解析されるネストされたパターン&lt;/strong&gt;の&lt;strong&gt;数に&lt;/strong&gt;制限がある場合がありますが、使用される言語によって異なります</target>
        </trans-unit>
        <trans-unit id="c4d4e32662c88b8424d1c0984fceefe61e4e23a5" translate="yes" xml:space="preserve">
          <source>again, zero or more whitespaces</source>
          <target state="translated">再度、ゼロ以上の空白文字</target>
        </trans-unit>
        <trans-unit id="416344de81011e88293f4de90995d2f4eb4cfe70" translate="yes" xml:space="preserve">
          <source>ain, the song of re̸gular exp​re&lt;strike&gt;ssion parsing &lt;/strike&gt;will exti</source>
          <target state="translated">ain、reregular exp re &lt;strike&gt;ssion parsing&lt;/strike&gt;の歌はextiになります</target>
        </trans-unit>
        <trans-unit id="dac38d2a71b13841b4f7fa59c2cbb41d8f4fe7c5" translate="yes" xml:space="preserve">
          <source>although corrupted (x)HTML does not drive into severe errors, it is not &lt;em&gt;sanitized&lt;/em&gt;.</source>
          <target state="translated">破損した（x）HTMLは重大なエラーを引き起こしませんが、 &lt;em&gt;サニタイズされ&lt;/em&gt;ません。</target>
        </trans-unit>
        <trans-unit id="b2c0c9e8369c247831710c647b81dda3b5b625b1" translate="yes" xml:space="preserve">
          <source>although it actually came out like this:</source>
          <target state="translated">実際にはこんな感じで出てきましたが。</target>
        </trans-unit>
        <trans-unit id="b91f3e1f4b4ae9ba5a969df90fc854016c1cfedf" translate="yes" xml:space="preserve">
          <source>and the dread realm of c͒ͪo͛ͫrrupt entities (like SGML entities, but</source>
          <target state="translated">と、c͒ Certificationso͛rruptエンティティの恐ろしい領域(SGMLエンティティのようなものですが</target>
        </trans-unit>
        <trans-unit id="789d3b546d80c656a137d6a2dae501ef948c9936" translate="yes" xml:space="preserve">
          <source>attributes containing single quotes when the delimiter is a double quote and vice versa</source>
          <target state="translated">区切り文字が二重引用符の場合はシングルクォートを含む属性、その逆の場合はシングルクォートを含む属性。</target>
        </trans-unit>
        <trans-unit id="83049ba02543c5468a7092d704e728351f015ce0" translate="yes" xml:space="preserve">
          <source>attributes which value is bound either into &lt;strong&gt;single quotes&lt;/strong&gt; or into &lt;strong&gt;double quotes&lt;/strong&gt;</source>
          <target state="translated">値が&lt;strong&gt;一&lt;/strong&gt; &lt;strong&gt;重引用&lt;/strong&gt; &lt;strong&gt;符&lt;/strong&gt;または&lt;strong&gt;二重引用&lt;/strong&gt; &lt;strong&gt;符に&lt;/strong&gt;バインドされている属性</target>
        </trans-unit>
        <trans-unit id="872af077bba705c60415b90068389b0d9ae136b2" translate="yes" xml:space="preserve">
          <source>ch between this world</source>
          <target state="translated">此の世の間</target>
        </trans-unit>
        <trans-unit id="b1ccf8aca583f64c44e6498a0abc71300cee934c" translate="yes" xml:space="preserve">
          <source>d of ceaseless screaming, he comes&lt;strike&gt;, the pestilent sl&lt;/strike&gt;ithy regex-infection wil​&lt;b&gt;l devour your HT&lt;/b&gt;​ML parser, application and existence for all time like Visual Basic only worse</source>
          <target state="translated">絶え間ない叫びのd、彼は来る&lt;strike&gt;、&lt;/strike&gt;辛い&lt;strike&gt;sl&lt;/strike&gt; ithy正規表現感染&lt;b&gt;、あなたのHT&lt;/b&gt; MLパーサー、アプリケーション、そしてVisual Basicのようにずっと存在する</target>
        </trans-unit>
        <trans-unit id="fad2a06a8e728d64f3eff45851e3b600bd2bf437" translate="yes" xml:space="preserve">
          <source>dear lord help us how can anyone survive this scourge</source>
          <target state="translated">主よ...助けてください...どうしたらこの惨劇を生き残れるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="5b52a1cb49381cdd269797b153d0660ee9133944" translate="yes" xml:space="preserve">
          <source>do not fi</source>
          <target state="translated">遣ってはいけない</target>
        </trans-unit>
        <trans-unit id="b9dea77ba556480de7588671f4a3d44f039e5d2e" translate="yes" xml:space="preserve">
          <source>e pon̷y he come</source>
          <target state="translated">えぽんみょうな彼が来る</target>
        </trans-unit>
        <trans-unit id="09cd68a2a77b22a312dded612dd0d9988685189f" translate="yes" xml:space="preserve">
          <source>es</source>
          <target state="translated">es</target>
        </trans-unit>
        <trans-unit id="707cd90a4f77675613cc63dfa16b29bedcf7d2e6" translate="yes" xml:space="preserve">
          <source>es al</source>
          <target state="translated">エスアル</target>
        </trans-unit>
        <trans-unit id="16829609b87ebecff7cb40016842539439ef333f" translate="yes" xml:space="preserve">
          <source>e̠̅s&lt;code&gt; ͎a̧͈͖r̽̾̈́͒͑e&lt;/code&gt; n&lt;b&gt;​ot rè̑ͧ̌aͨl̘̝̙̃ͤ͂̾̆ ZA̡͊͠͝LGΌ ISͮ̂҉̯͈͕̹̘̱ T&lt;/b&gt;O͇̹̺ͅƝ̴ȳ̳ TH̘&lt;b&gt;Ë͖́̉ ͠P̯͍̭O̚​N̐Y̡ H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝&lt;/b&gt;S̨̥̫͎̭ͯ̿̔̀ͅ</source>
          <target state="translated">e̠̅s͎a̧͈͖r̽̾̈́͒͑e n &lt;b&gt;ot r&amp;egrave;̑ͧ̌aͨl̘̝̙̃ͤ͂̾̆ZA̡͊͠͝LGΌISͮ̂҉̯͈͕̹̘̱ T&lt;/b&gt; &lt;b&gt;O͇̹̺ͅƝ̴ȳ̳TH̘&amp;Euml;͖́̉͠P̯͍̭O̚N̐Y̡H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝&lt;/b&gt; S̨̥̫͎̭ͯ̿̔̀ͅ</target>
        </trans-unit>
        <trans-unit id="0a971adf10fafe8fe3d724d80e0beaa10f271291" translate="yes" xml:space="preserve">
          <source>f the lie​&lt;b&gt;s of Man ALL IS LOŚ͖̩͇̗̪̏̈́T A&lt;/b&gt;</source>
          <target state="translated">人の嘘&lt;b&gt;はすべて失われている&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6c0c535eae65a352e21a597046b9c71062ef7e32" translate="yes" xml:space="preserve">
          <source>he an​*̶͑̾̾​̅ͫ͏̙̤g͇̫͛͆̾ͫ̑͆l͖͉̗̩̳̟̍ͫͥͨ</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21f7c212343db1452bf1005fe7bec61697f3efef" translate="yes" xml:space="preserve">
          <source>he comes he com</source>
          <target state="translated">来たるは来たるは来たる</target>
        </trans-unit>
        <trans-unit id="c1b6858eae6b82f5a342bbfcd9d5505ae8d8b304" translate="yes" xml:space="preserve">
          <source>he f&lt;code&gt;inal snuf&lt;/code&gt;fing o</source>
          <target state="translated">彼は &lt;code&gt;inal snuf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cba0af89feed0e8e942fec8ed4c10695745c757d" translate="yes" xml:space="preserve">
          <source>here comes the fun: the \4 part is a &lt;strong&gt;backreference operator&lt;/strong&gt;, which refers to a sub-expression defined before in the pattern, in this case, I am referring to the fourth sub-expression, which is the first attribute delimiter found</source>
          <target state="translated">ここでおもしろい：\ 4の部分は、パターン内で前に定義された部分式を参照する&lt;strong&gt;後方参照演算子&lt;/strong&gt;です。この場合、最初の属性区切り文字である4番目の部分式を参照しています。</target>
        </trans-unit>
        <trans-unit id="a8ec278d2e709b878840d59f0dc4611cd1bb49d5" translate="yes" xml:space="preserve">
          <source>it is too late it is too late we cannot be saved</source>
          <target state="translated">遅きに失して遅きに失して我らは救われぬ</target>
        </trans-unit>
        <trans-unit id="a38cb8457436d320aa6e6a447ea6ac270b0eb2aa" translate="yes" xml:space="preserve">
          <source>l MY FAC</source>
          <target state="translated">私の顔</target>
        </trans-unit>
        <trans-unit id="eb912827300bfa09ffaae9a61a04131d928f17d2" translate="yes" xml:space="preserve">
          <source>more corrupt) a mere glimp</source>
          <target state="translated">一片の腐れもない</target>
        </trans-unit>
        <trans-unit id="5a4bedc53d646eb4f152665ce04f194f119d1230" translate="yes" xml:space="preserve">
          <source>more than one attribute</source>
          <target state="translated">たぞくせい</target>
        </trans-unit>
        <trans-unit id="0f0f39e938eb9a6927af1fd3169cbf5dc39c8c05" translate="yes" xml:space="preserve">
          <source>nto a w</source>
          <target state="translated">wにする</target>
        </trans-unit>
        <trans-unit id="f676ebbcb5a6de68fd4cd64947f2f073b0bc183b" translate="yes" xml:space="preserve">
          <source>one attribute</source>
          <target state="translated">いちぞくせい</target>
        </trans-unit>
        <trans-unit id="b63094eb585e278a2a9faac15421a9c3b8a73f5d" translate="yes" xml:space="preserve">
          <source>one or more whitespaces \s+</source>
          <target state="translated">one or more whitespaces s+</target>
        </trans-unit>
        <trans-unit id="a4f0099e46341d0fc7c083fc51657b45fb1eb61a" translate="yes" xml:space="preserve">
          <source>or just combine if and if not.</source>
          <target state="translated">とか、そうでない場合とそうでない場合を組み合わせてみてください。</target>
        </trans-unit>
        <trans-unit id="90255a902e3a09b87ea94d0074d32fa53f1e3df0" translate="yes" xml:space="preserve">
          <source>orl</source>
          <target state="translated">orl</target>
        </trans-unit>
        <trans-unit id="5beefb69787012b543ff81b246c6096ef31b16cb" translate="yes" xml:space="preserve">
          <source>rogrammer's consciousness i</source>
          <target state="translated">プログラマの意識</target>
        </trans-unit>
        <trans-unit id="a529326c3bc272f1c87faf0fc168c3f2b888e5e1" translate="yes" xml:space="preserve">
          <source>s he c̶̮om&lt;strike&gt;es he co&lt;/strike&gt;&lt;b&gt;&lt;strike&gt;me&lt;/strike&gt;s t&lt;i&gt;he&lt;/i&gt; ich​&lt;/b&gt;or permeat</source>
          <target state="translated">&lt;strike&gt;彼は&lt;/strike&gt; &lt;b&gt;&lt;strike&gt;私&lt;/strike&gt; &lt;i&gt;に彼&lt;/i&gt;またはそれを&lt;/b&gt;浸透させます</target>
        </trans-unit>
        <trans-unit id="cdc9e9914e559a22d8c2863df88dcc0affd254bb" translate="yes" xml:space="preserve">
          <source>se of the world of reg​&lt;b&gt;ex parsers for HTML will ins&lt;/b&gt;​tantly transport a p</source>
          <target state="translated">&lt;b&gt;HTMLの&lt;/b&gt;正規表現&lt;b&gt;パーサーの&lt;/b&gt;世界は、apを瞬時に転送し&lt;b&gt;ます&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fcd31f61fdd2492a68c910cd84210be08c96a97c" translate="yes" xml:space="preserve">
          <source>stro҉ying all enli̍̈́̂̈́ghtenment, HTML tags &lt;b&gt;lea͠ki̧n͘g fr̶ǫm ̡yo​͟ur eye͢s̸ ̛l̕ik͏e liq&lt;/b&gt;​uid p</source>
          <target state="translated">すべての拡張機能を紹介し、HTMLタグは&lt;b&gt;lea͠ki̧n͘gfr̶ǫm̡yo͟ureye͢s̸̛l̕ik͏eliq&lt;/b&gt; uid p</target>
        </trans-unit>
        <trans-unit id="13cecb0242cc098120804e419e2c0898d7c5f3d9" translate="yes" xml:space="preserve">
          <source>the &quot;=&quot; symbol</source>
          <target state="translated">記号</target>
        </trans-unit>
        <trans-unit id="ef1ddac3121c15757add5489d19c276fcda4e43f" translate="yes" xml:space="preserve">
          <source>the attribute sub-expression ends here, with the specification of zero or more possible occurrences, given by the asterisk.</source>
          <target state="translated">属性部分式は、アスタリスクで与えられたゼロ以上の可能性のある出現を指定して、ここで終了します。</target>
        </trans-unit>
        <trans-unit id="9fb82ad748ee217a3d8676ebffa5f977ad107e1b" translate="yes" xml:space="preserve">
          <source>the delimiter of the attribute value, a single or double quote ('|&quot;). In the pattern, the single quote is escaped because it coincides with the PHP string delimiter. This sub-expression is captured with the parentheses so it can be referenced again to parse the closure of the attribute, that's why it is very important.</source>
          <target state="translated">&quot;).In the pattern,the single quote is escaped because it coincides with the PHP string delimiter.This sub-expression is captured with the parentheses so it can be referenced again to parse the closure of the attribute,that's why it is very important.</target>
        </trans-unit>
        <trans-unit id="bf47c953b6d49b59cea7ef6e949bcd244312ad84" translate="yes" xml:space="preserve">
          <source>the first sub-expression (\w+) matches the tag name</source>
          <target state="translated">最初のサブ式(\w+)は、タグ名と一致します。</target>
        </trans-unit>
        <trans-unit id="8ff32fe1a0c4d2f2143244e76a1ea25a84d0a50e" translate="yes" xml:space="preserve">
          <source>the name of the attribute (\w+)</source>
          <target state="translated">属性の名前</target>
        </trans-unit>
        <trans-unit id="a63f6d3ba68d8159445680753d6b7dcfea330647" translate="yes" xml:space="preserve">
          <source>the second sub-expression contains the pattern of an attribute. It is composed by:</source>
          <target state="translated">2番目の副式は、属性のパターンを含んでいます。によって構成されています。</target>
        </trans-unit>
        <trans-unit id="98c53a01bc3d612ea14d5657a8251e38b47274e3" translate="yes" xml:space="preserve">
          <source>the trangession of a chi͡ld ensures regex will consume all living tissue (except for HTML which it cannot, as previously prophesied)</source>
          <target state="translated">chi͡ldのtrangessionは、regexがすべての生きている組織を消費することを保証します(以前に予言されたように、それができないHTMLを除いて</target>
        </trans-unit>
        <trans-unit id="fcae9afa44c8d009bc39cd1558b5bcceb178f9f3" translate="yes" xml:space="preserve">
          <source>the value of the attribute, matched by &lt;em&gt;almost&lt;/em&gt; anything: (.*?); in this specific syntax, using the &lt;strong&gt;greedy match&lt;/strong&gt; (the question mark after the asterisk) the RegExp engine enables a &quot;look-ahead&quot;-like operator, which matches anything but what follows this sub-expression</source>
          <target state="translated">&lt;em&gt;ほとんど&lt;/em&gt;すべてに一致する属性の値：（。*？）; この特定の構文では、 &lt;strong&gt;貪欲な一致&lt;/strong&gt; （アスタリスクの後の疑問符）を使用して、RegExpエンジンは「先読み」に似た演算子を有効にします。</target>
        </trans-unit>
        <trans-unit id="e8cdc833b2aa479524c91f0c0770ca55cab15dbc" translate="yes" xml:space="preserve">
          <source>using rege</source>
          <target state="translated">正規表現</target>
        </trans-unit>
        <trans-unit id="05316c08fdd253a1c9a83c01ccb3802a454fbc33" translate="yes" xml:space="preserve">
          <source>using regex to parse HTML has doomed humanity to an eternity of dread torture and security holes</source>
          <target state="translated">正規表現を使ってHTMLを解析することは、人類を永遠の拷問とセキュリティホールに陥れる運命にあります。</target>
        </trans-unit>
        <trans-unit id="ab44de7440b2ebdde8558b36f16d5f922c19d2d5" translate="yes" xml:space="preserve">
          <source>x as a tool to process HTML establishes a brea</source>
          <target state="translated">HTMLを処理するためのツールとしてのxは、ブレアを確立します。</target>
        </trans-unit>
        <trans-unit id="7f524dcbd593bece540d29aea0353dc495423551" translate="yes" xml:space="preserve">
          <source>zero or more whitespaces \s*</source>
          <target state="translated">zero or more whitespaces ≪(ゼロ以上の白人)s*≫</target>
        </trans-unit>
        <trans-unit id="9bdd5426b4b4fdd866ac9851215bf267b6e6df44" translate="yes" xml:space="preserve">
          <source>zero or more whitespaces \s* (it is possible or not, leaving blanks here)</source>
          <target state="translated">ゼロかそれ以上のwhitespaces s*(可能かどうか、ここに空白を残して</target>
        </trans-unit>
        <trans-unit id="1b249f9d22bd1bda62f373b04cdb08126b054557" translate="yes" xml:space="preserve">
          <source>​ght h&lt;b&gt;e com̡e̶s, ̕h̵i&lt;/b&gt;​s un̨ho͞ly radiańcé de</source>
          <target state="translated">ght h &lt;b&gt;ecom̡e̶s、̕h̵isun̨ho͞lyradiańc&amp;eacute;de&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="87484f6cbcd5c18c6c4b093d13bc9f9ee13c577f" translate="yes" xml:space="preserve">
          <source>​nguish the voices of mor​&lt;b&gt;tal man from the sp&lt;/b&gt;​here I can see it can you see ̲͚̖͔̙î̩́t̲͎̩̱͔́̋̀ it is beautiful t​</source>
          <target state="translated">ここ&lt;b&gt;から&lt;/b&gt;私はそれを見ることができますspi &lt;b&gt;から&lt;/b&gt;モータルマンの声を苦しめますyou&amp;icirc;̩́t̲͎̩̱͔́̋̀それは美しいです</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
