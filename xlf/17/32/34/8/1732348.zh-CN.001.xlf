<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1732348">
    <body>
      <group id="1732348">
        <trans-unit id="ccd2e00de6a7833dd11d2079f5b5b099a6e04da7" translate="yes" xml:space="preserve">
          <source>&quot;unpretty&quot; attributes with a space before the &quot;=&quot; symbol, after it and both before and after it.</source>
          <target state="translated">&quot;unpretty &quot;属性,&quot;=&quot;符号前有空格,后有空格,前后都有空格。</target>
        </trans-unit>
        <trans-unit id="392ad88b0cb34d87fa7d4457a6637b91ceafc10b" translate="yes" xml:space="preserve">
          <source>&amp;lt;br&amp;gt;</source>
          <target state="translated">&amp;lt;br&amp;gt;</target>
        </trans-unit>
        <trans-unit id="50709f0c2fc769b8029465696613cd45319835fb" translate="yes" xml:space="preserve">
          <source>&amp;lt;br/&amp;gt;</source>
          <target state="translated">&amp;lt;br/&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ecfb18e3fd89ce3fed2c8046ff8dc43d3ee45bbf" translate="yes" xml:space="preserve">
          <source>&amp;lt;hr /&amp;gt;</source>
          <target state="translated">&amp;lt;hr /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3239efc545dfa4f75dc0905c388a28a61c34c974" translate="yes" xml:space="preserve">
          <source>(Take care, in that note I wrongly used the &quot;m&quot; modifier; it should be erased, notwithstanding it is discarded by the RegExp engine, since no ^ or $ anchorage was used).</source>
          <target state="translated">(注意,我在那篇注释中错误地使用了 &quot;m &quot;修改器;尽管它被正则引擎丢弃了,但应该删除,因为没有使用^或$锚点)。</target>
        </trans-unit>
        <trans-unit id="a8662e799cce40f7a10db5f20413cbc30727a2b7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://pastebin.com/hzYazFVb&quot;&gt;regex to tokenize an xml&lt;/a&gt; or &lt;a href=&quot;http://pastebin.com/HUmPzP5M&quot;&gt;the full plain regex&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://pastebin.com/hzYazFVb&quot;&gt;正则表达式以标记xml&lt;/a&gt;或&lt;a href=&quot;http://pastebin.com/HUmPzP5M&quot;&gt;完全正则表达式&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="832bcd8f1b94df226af144e70783a66198bd3e61" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;simplehtmldom&lt;/a&gt; is good, but I found it a bit buggy, and it is is quite memory heavy [Will crash on large pages.]</source>
          <target state="translated">&lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;simplehtmldom&lt;/a&gt;很好，但是我发现它有点bug，而且它的内存占用很大[将在大页面上崩溃。]</target>
        </trans-unit>
        <trans-unit id="0fb3c21dc29172e2446bc3eb1b052ae2cf60faea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;LL I​S L&lt;/b&gt;OST th</source>
          <target state="translated">&lt;b&gt;我是我&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6e79435135c0746fa05560a3972c6d46478d0ea8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Locked&lt;/b&gt;. There are &lt;a href=&quot;/help/locked-posts&quot;&gt;disputes about this answer&amp;rsquo;s content&lt;/a&gt; being resolved at this time. It is not currently accepting new interactions.</source>
          <target state="translated">&lt;b&gt;已锁定&lt;/b&gt; 。 目前， &lt;a href=&quot;/help/locked-posts&quot;&gt;此答案的内容&lt;/a&gt;已解决存在争议 。 它当前不接受新的交互。</target>
        </trans-unit>
        <trans-unit id="716a4e892e498fc58500550d231fb8d0142d36b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;O​O N&lt;/b&gt;&amp;Theta; stop t</source>
          <target state="translated">&lt;b&gt;O ON&lt;/b&gt;停止t</target>
        </trans-unit>
        <trans-unit id="1c101f468dfe424c6604dac4e8ce77d6d85f2f3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;: closing &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; ：关闭 &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b62a075d15f1adc779c6d1b0fe159e3b547852c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;: starting character</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; ：起始字符</target>
        </trans-unit>
        <trans-unit id="edd69111dcbfaec727aaaeb23b7029011a65191a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?&amp;lt;-group&amp;gt;)&lt;/code&gt; - pops the top most capture with the name group off the
  capture stack.</source>
          <target state="translated">&lt;code&gt;(?&amp;lt;-group&amp;gt;)&lt;/code&gt; -从捕获堆栈中弹出名称组最高的捕获。</target>
        </trans-unit>
        <trans-unit id="d45de3e20cd061b6edb60d843a32a44f30527fa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?&amp;lt;group&amp;gt;)&lt;/code&gt; - pushes the captured result on the capture stack with
  the name group.</source>
          <target state="translated">&lt;code&gt;(?&amp;lt;group&amp;gt;)&lt;/code&gt; -使用名称组将捕获的结果压入捕获堆栈。</target>
        </trans-unit>
        <trans-unit id="e8253025aa1e0fb8ada068fc00792760bbe3d0c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?(group)yes|no)&lt;/code&gt; - matches the yes part if there exists a group
  with the name group otherwise matches no part.</source>
          <target state="translated">&lt;code&gt;(?(group)yes|no)&lt;/code&gt; -如果存在名称为group的组，则匹配yes部分，否则不匹配。</target>
        </trans-unit>
        <trans-unit id="56885e7cfe6e3708ab901dd138fd887bd58c790d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(\w+)&lt;/code&gt;: tags can contain letters and numbers (h1). Well, &lt;code&gt;\w&lt;/code&gt; also matches '_', but it does not hurt I guess. If curious use ([a-zA-Z0-9]+) instead.</source>
          <target state="translated">&lt;code&gt;(\w+)&lt;/code&gt; ：标签可以包含字母和数字（h1）。 好吧， &lt;code&gt;\w&lt;/code&gt; 也匹配'_'，但是我猜并没有伤害。 如果好奇，请改用（[a-zA-Z0-9] +）。</target>
        </trans-unit>
        <trans-unit id="27378fcce2128b2795fafae4f93ebe3ba7c8ec5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[^/&amp;gt;]*&lt;/code&gt;: anything except &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; until closing &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[^/&amp;gt;]*&lt;/code&gt; ： &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; 之前的任何内容，直到关闭 &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0cdd6edcac3875daf87e4d7a216db2702e63b2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s*&lt;/code&gt;: it may have whitespaces before tag name (ugly but possible).</source>
          <target state="translated">&lt;code&gt;\s*&lt;/code&gt; ：标签名称前可能有空格（丑陋，但可能）。</target>
        </trans-unit>
        <trans-unit id="beb0d3eebbac4ba7a6e556f1885908f5a8b44a54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;It is a .NET code library that allows
  you to parse &quot;out of the web&quot; HTML
  files. The parser is very tolerant
  with &quot;real world&quot; malformed HTML.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;它是一个.NET代码库，可让您解析&amp;ldquo;网络外&amp;rdquo; HTML文件。&lt;/em&gt; &lt;em&gt;解析器对&amp;ldquo;真实世界&amp;rdquo;格式的HTML非常宽容。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c6e323e6d7b2404e267e45fec8933c5f11df6f5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;/EDIT&amp;gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;lt;/EDIT&amp;gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4eeca80a434106c9c5953d86b5711b944275e484" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;EDIT&amp;gt;&lt;/strong&gt;
I forgot that the question from the user was to avoid the parsing of self-closing tags.
In this case the pattern is simpler, turning into this:</source>
          <target state="translated">&lt;strong&gt;&amp;lt;EDIT&amp;gt;&lt;/strong&gt;我忘记了用户的问题是避免解析自动关闭标签。 在这种情况下，模式变得更简单了，变成了这样：</target>
        </trans-unit>
        <trans-unit id="bfe34076d009a4ea9a539e48cf63cf2660a68659" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;.NET Regular Expression Engine&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;.NET正则表达式引擎&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="84c7b23e39a82950709baca989fe9cf94e0ac7c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caveat&lt;/strong&gt;: I should note that this regex still breaks down in the presence of CDATA blocks, comments, and script and style elements. Good news is, you can get rid of those using a regex...</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt; ：我应该注意到，在存在CDATA块，注释以及脚本和样式元素的情况下，此正则表达式仍会分解。 好消息是，您可以摆脱使用正则表达式的那些东西。</target>
        </trans-unit>
        <trans-unit id="45fc82d5456ed3961e342820361d39292947a88e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer&lt;/strong&gt;: use a parser if you have the option. That said...</source>
          <target state="translated">&lt;strong&gt;免责声明&lt;/strong&gt; ：如果有选择，请使用解析器。 那就是...</target>
        </trans-unit>
        <trans-unit id="28fb9f9055a519baf77c8a0c677593f8a1967066" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Moderator's Note&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;主持人的话&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2412b65f77f0efaca93518e50a127a0ceec7ed35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To downvoters:&lt;/strong&gt; This is working code from an actual product. I doubt anyone reading this page will get the impression that it is socially acceptable to use regexes on HTML.</source>
          <target state="translated">&lt;strong&gt;致下降投票者：&lt;/strong&gt;这是来自实际产品的有效代码。 我怀疑任何阅读此页面的人都会得到这样的印象：在HTML上使用正则表达式在社会上是可以接受的。</target>
        </trans-unit>
        <trans-unit id="b00d0a9c4b3ab55c1726cc4d54869fbac2f0d000" translate="yes" xml:space="preserve">
          <source>A RegExp-agnostic colleague notified me this discussion, which is not certainly the first on the web about this old and hot topic.</source>
          <target state="translated">有位精通正则的同事通知我这个讨论,网络上关于这个老辣的话题肯定不是第一个。</target>
        </trans-unit>
        <trans-unit id="e3504a93684584a9ba5c4e8dff8fbf39739ee1de" translate="yes" xml:space="preserve">
          <source>A simple regex like &lt;code&gt;&amp;lt;([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; is usually good enough, in cases such as those I just mentioned. It's a naive solution, all things considered, but it does correctly allow unencoded &lt;code&gt;&amp;gt;&lt;/code&gt; symbols in attribute values. If you're looking for, e.g., a &lt;code&gt;table&lt;/code&gt; tag, you could adapt it as &lt;code&gt;&amp;lt;/?table\b([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在我刚才提到的情况下，像 &lt;code&gt;&amp;lt;([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; 这样的简单正则表达式通常就足够了。 考虑到所有因素，这是一个幼稚的解决方案，但是它确实允许属性值中使用未编码的 &lt;code&gt;&amp;gt;&lt;/code&gt; 符号。 如果要查找 &lt;code&gt;table&lt;/code&gt; 标记，则可以将其修改为 &lt;code&gt;&amp;lt;/?table\b([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a039c1c26fe0f237cd4c396efb45b67c58a5e34d" translate="yes" xml:space="preserve">
          <source>About the question of the RegExp methods to parse (x)HTML, the answer to all of the ones who spoke about some limits is: you have not been trained enough to rule the force of this powerful weapon, since &lt;strong&gt;NOBODY&lt;/strong&gt; here spoke about &lt;strong&gt;recursion&lt;/strong&gt;.</source>
          <target state="translated">关于用于解析（x）HTML的RegExp方法的问题，对于所有谈到某些限制的人的答案是：您没有受过足够的训练来统治这种强大武器的力量，因为&lt;strong&gt;NOBODY&lt;/strong&gt;在这里谈到了&lt;strong&gt;递归&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="489cc8d83fc1a950af1e4ec274f14d5d31165bbc" translate="yes" xml:space="preserve">
          <source>After reading some posts, the first thing I did was looking for the &quot;?R&quot; string in this thread. The second was to search about &quot;recursion&quot;.</source>
          <target state="translated">看了一些帖子后,第一件事就是在这个线程中寻找&quot;? &quot;R &quot;字符串。第二件事就是搜索了一下关于 &quot;递归 &quot;的内容。</target>
        </trans-unit>
        <trans-unit id="a3a75c0c6fe92ec2cda26b61e50e68af1ff0a32b" translate="yes" xml:space="preserve">
          <source>Against my expectation this got some upvotes, so I'll suggest some better regular expressions:</source>
          <target state="translated">与我的预期相反,这得到了一些涨价的票数,所以我建议用一些比较好的常规表达方式。</target>
        </trans-unit>
        <trans-unit id="d71dc9d3aa06d9d64e4ed0039016360a328e4c22" translate="yes" xml:space="preserve">
          <source>Almost there - just divide the whole thing by zero. Easy-peasy.</source>
          <target state="translated">就快到了,只要把整数除以0就可以了。很容易就能搞定。</target>
        </trans-unit>
        <trans-unit id="fee1e23317ba16ad1ccae9d12e0a015990432476" translate="yes" xml:space="preserve">
          <source>Although it's not suitable and effective to use regular expressions for that purpose sometimes regular expressions provide quick solutions for simple match problems and in my view it's not that horrbile to use regular expressions for trivial works.</source>
          <target state="translated">尽管为此目的使用正则表达式并不适合也不有效,有时正则表达式可以快速解决简单的匹配问题,而在我看来,用正则表达式来解决琐碎的工作并不是那么可怕。</target>
        </trans-unit>
        <trans-unit id="a430cebe8e1c6b5026f2667ef4e684539ee6d594" translate="yes" xml:space="preserve">
          <source>And to fellows who underestimate regular expressions saying they are only as powerful as regular languages:</source>
          <target state="translated">而对那些小看了正则表达式的家伙们说,它们只和正则语言一样强大。</target>
        </trans-unit>
        <trans-unit id="1b4c5b09ea0d4dcf09356da001dd69ed7c2e026c" translate="yes" xml:space="preserve">
          <source>Another one to try is my &lt;a href=&quot;http://github.com/siteroller/domparser&quot;&gt;DOMParser&lt;/a&gt; which is very light on resources and I've been using happily for a while. Simple to learn &amp;amp; powerful.</source>
          <target state="translated">另一个可以尝试的是我的&lt;a href=&quot;http://github.com/siteroller/domparser&quot;&gt;DOMParser&lt;/a&gt; ，它对资源非常少，并且我已经很开心地使用了一段时间。 简单易学，功能强大。</target>
        </trans-unit>
        <trans-unit id="0e63871b8e67058c915c0916cf65a319929856cc" translate="yes" xml:space="preserve">
          <source>Anyhow it is only a RegExp pattern, but it discloses the possibility to develop of a lot of powerful implementations.</source>
          <target state="translated">无论如何,这只是一个正则模式,但它揭示了很多强大的实现的可能性。</target>
        </trans-unit>
        <trans-unit id="7bc89deb2a5a51e26b543874949bc6016b7dee8c" translate="yes" xml:space="preserve">
          <source>As described above properly balanced constructs cannot be described by
  a regular expression. However, the .NET regular expression engine
  provides a few constructs that allow balanced constructs to be
  recognized.</source>
          <target state="translated">如上所述,正确的平衡构造不能用正则表达式来描述。然而,.NET正则表达式引擎提供了一些可以识别平衡构造的构造。</target>
        </trans-unit>
        <trans-unit id="23f8839aa08cf9ff361179fc788965803d7b92e4" translate="yes" xml:space="preserve">
          <source>As many people have already pointed out, HTML is not a regular language which can make it very difficult to parse. My solution to this is to turn it into a regular language using a tidy program and then to use an XML parser to consume the results. There are a lot of good options for this. My program is written using Java with the &lt;a href=&quot;http://jtidy.sourceforge.net/&quot;&gt;jtidy&lt;/a&gt; library to turn the HTML into XML and then Jaxen to xpath into the result.</source>
          <target state="translated">正如许多人已经指出的那样，HTML不是一种常规语言，因此很难解析。 我的解决方案是使用整洁的程序将其转换为常规语言，然后使用XML解析器使用结果。 为此有很多不错的选择。 我的程序是使用Java和&lt;a href=&quot;http://jtidy.sourceforge.net/&quot;&gt;jtidy&lt;/a&gt;库编写的，将HTML转换为XML，然后通过Jaxen将xpath转换为结果。</target>
        </trans-unit>
        <trans-unit id="6ec0c091ef78305814e216017d3186d039895a12" translate="yes" xml:space="preserve">
          <source>At the end of the day, use the most appropriate tool for the job, even in the cases when that tool happens to be a regex.</source>
          <target state="translated">最后,使用最合适的工具来完成工作,即使是在工具恰好是regex的情况下。</target>
        </trans-unit>
        <trans-unit id="ee0292f6ec302ec831d0a3d73bf3ba082b945c21" translate="yes" xml:space="preserve">
          <source>Backreferencing &lt;a href=&quot;http://en.wiktionary.org/wiki/FTW&quot;&gt;FTW&lt;/a&gt;!</source>
          <target state="translated">反引用&lt;a href=&quot;http://en.wiktionary.org/wiki/FTW&quot;&gt;FTW&lt;/a&gt; ！</target>
        </trans-unit>
        <trans-unit id="e76721be008ac232fc787ac592a249a6a0b4bb86" translate="yes" xml:space="preserve">
          <source>Based on that you can create a pretty good regexp to handle things like stripping tags.</source>
          <target state="translated">在此基础上,你可以创建一个很好的regexp来处理诸如剥离标签的事情。</target>
        </trans-unit>
        <trans-unit id="74dec6c7e6bd60b234219702f40493e82463304e" translate="yes" xml:space="preserve">
          <source>Basically just define the element node names that are self closing, load the whole html string into a DOM library, grab all elements, loop through and filter out ones which aren't self closing and operate on them.</source>
          <target state="translated">基本上只要定义好自闭的元素节点名称,将整个html字符串加载到DOM库中,抓取所有的元素,循环通过,过滤出不是自闭的元素,并对其进行操作。</target>
        </trans-unit>
        <trans-unit id="2fd99963c03782b18787dfc6cb3594dcb6c80def" translate="yes" xml:space="preserve">
          <source>But many will try, some will even claim success - but until others find the fault and totally mess you up.</source>
          <target state="translated">但很多人都会去尝试,有的人甚至会声称成功--但直到别人发现了错误,完全把你搞得一团糟。</target>
        </trans-unit>
        <trans-unit id="eb3c73a7771d13969490ceb2f225b558c87d11f3" translate="yes" xml:space="preserve">
          <source>But not these:</source>
          <target state="translated">但不是这些。</target>
        </trans-unit>
        <trans-unit id="201b0e9006bea17e6be8fbec59ab5c0fb1baedd0" translate="yes" xml:space="preserve">
          <source>Can you provide a little more information on the problem you're trying to solve?  Are you iterating through tags programatically?</source>
          <target state="translated">你能提供一点关于你要解决的问题的信息吗?你是在程序化地通过标签进行迭代吗?</target>
        </trans-unit>
        <trans-unit id="b8fde2430ed872968deeaaced84cc8f3cc101507" translate="yes" xml:space="preserve">
          <source>Consider the following regular expression:</source>
          <target state="translated">考虑以下正则表达式:</target>
        </trans-unit>
        <trans-unit id="dfa51c240f8abc4eddb1aab8ac728fcb6c1daf9a" translate="yes" xml:space="preserve">
          <source>Do I have that right? And more importantly, what do you think?</source>
          <target state="translated">我说的对吗?更重要的是,你觉得呢?</target>
        </trans-unit>
        <trans-unit id="89791df6d0913a20e70b1f075f65baa21fec7900" translate="yes" xml:space="preserve">
          <source>Don't listen to these guys. You totally &lt;strong&gt;can&lt;/strong&gt; parse context-free grammars with regex if you break the task into smaller pieces. You can generate the correct pattern with a script that does each of these in order:</source>
          <target state="translated">不要听这些家伙。 如果将任务分解成小块，则&lt;strong&gt;可以&lt;/strong&gt;使用regex完全解析上下文无关的语法。 您可以使用按顺序执行每个脚本的脚本来生成正确的模式：</target>
        </trans-unit>
        <trans-unit id="c40843389e0f5b256a2400a9132a52c445461a2b" translate="yes" xml:space="preserve">
          <source>E MY FACE ᵒh god n&lt;b&gt;o NO NOO̼&lt;/b&gt;</source>
          <target state="translated">E MY FACEᵒhgod &lt;b&gt;no nonoo̼&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4130705574014c580de59636d30628dd3b203bfe" translate="yes" xml:space="preserve">
          <source>Excerpt:</source>
          <target state="translated">Excerpt:</target>
        </trans-unit>
        <trans-unit id="2ad9d9e9824270d481f3774905d98736bcee5670" translate="yes" xml:space="preserve">
          <source>Find (and capture) a-z one or more times, then</source>
          <target state="translated">找到(并捕获)a-z一次或多次,然后</target>
        </trans-unit>
        <trans-unit id="1d62b3cf5e66d1004bdcb37b62e3847fa43f5ea5" translate="yes" xml:space="preserve">
          <source>Find a greater-than</source>
          <target state="translated">找一个大于</target>
        </trans-unit>
        <trans-unit id="e9f182c7233327a73156c429c46ec0bca09513bc" translate="yes" xml:space="preserve">
          <source>Find a less-than, then</source>
          <target state="translated">找到一个小于,然后</target>
        </trans-unit>
        <trans-unit id="ef69898f6d3c5528cdbd0de1bd0fdf314dad1fc8" translate="yes" xml:space="preserve">
          <source>Find any character zero or more times, greedy, except &lt;code&gt;/&lt;/code&gt;, then</source>
          <target state="translated">找到零个或更多次的字符，贪婪的，除了 &lt;code&gt;/&lt;/code&gt; ，然后</target>
        </trans-unit>
        <trans-unit id="4f924d21074cc3fb26507a968919ecf7195b88d8" translate="yes" xml:space="preserve">
          <source>Find zero or more spaces, then</source>
          <target state="translated">找到0或更多的空格,然后</target>
        </trans-unit>
        <trans-unit id="0d7c5280ed7e07e90b90f8658292c92cbadfbd89" translate="yes" xml:space="preserve">
          <source>Follow the var links for &lt;code&gt;QName&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, and &lt;code&gt;Attribute&lt;/code&gt; to get a clearer picture.</source>
          <target state="translated">按照var链接获取 &lt;code&gt;QName&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;Attribute&lt;/code&gt; 以获得更清晰的图片。</target>
        </trans-unit>
        <trans-unit id="cf4a4868fa67f0f821777e8c58e576588a83ca85" translate="yes" xml:space="preserve">
          <source>For Python and Java, similar links were posted.</source>
          <target state="translated">对于Python和Java,也贴出了类似的链接。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="3835e68a9fb13e4990fe61a2c3a6bb38c1da30a3" translate="yes" xml:space="preserve">
          <source>For the downvoters - I only wrote my class when the XML parsers proved unable to withstand real use. Religious downvoting just prevents useful answers from being posted - keep things within perspective of the question, please.</source>
          <target state="translated">对于downvototers们来说--我只是在XML解析器证明无法承受实际使用时才写了我的类。宗教性的下投只会让有用的答案无法被贴出来----请把事情放在问题的角度上,请保持在问题的范围内。</target>
        </trans-unit>
        <trans-unit id="b71baca6025abb3df3fd982ef9ea831e48620ba4" translate="yes" xml:space="preserve">
          <source>For this reason, I believe you CAN parse XML using regular expressions. Note however, that it &lt;strong&gt;must be valid XML&lt;/strong&gt; (&lt;em&gt;browsers are very forgiving of HTML and allow bad XML syntax inside HTML&lt;/em&gt;). This is possible since the &quot;Balancing Group Definition&quot; will allow the regular expression engine to act as a PDA.</source>
          <target state="translated">因此，我相信您可以使用正则表达式解析XML。 但是请注意，它&lt;strong&gt;必须是有效的XML&lt;/strong&gt; （ &lt;em&gt;浏览器对HTML的&lt;/em&gt; &lt;strong&gt;理解&lt;/strong&gt; &lt;em&gt;非常宽容，并且HTML中允许使用错误的XML语法&lt;/em&gt; ）。 这是可能的，因为&amp;ldquo;平衡组定义&amp;rdquo;将允许正则表达式引擎充当PDA。</target>
        </trans-unit>
        <trans-unit id="fda26d5e5c5ac0a8c6a86392f4d1739052bb39fc" translate="yes" xml:space="preserve">
          <source>Granted, these don't account for surrounding context and a few edge cases, but even such things could be dealt with if you really wanted to (e.g., by searching between the matches of another regex).</source>
          <target state="translated">诚然,这些都没有考虑到周围的上下文和一些边缘情况,但如果你真的想的话,即使这样的事情也可以处理(例如,通过在另一个gex的匹配之间搜索)。</target>
        </trans-unit>
        <trans-unit id="ddfca12da1b8e2626e09bf2de8420516252a5e63" translate="yes" xml:space="preserve">
          <source>HTML Split</source>
          <target state="translated">HTML Split</target>
        </trans-unit>
        <trans-unit id="6c3bb55dbe0fb3cbcbc40ad1f139eaae779348bd" translate="yes" xml:space="preserve">
          <source>Hacking stackoverflow.com's HTML sanitizer</source>
          <target state="translated">Hacking stackoverflow.com的HTML消毒器被黑掉了</target>
        </trans-unit>
        <trans-unit id="9ec955a6d30b0da0f17f1892186c1fa8f07ed132" translate="yes" xml:space="preserve">
          <source>Have you tried using an XML parser instead?</source>
          <target state="translated">你有没有试过用XML解析器来代替?</target>
        </trans-unit>
        <trans-unit id="62d338caf42aa263445453c7fd40bf4f6302c521" translate="yes" xml:space="preserve">
          <source>Here is a &lt;a href=&quot;http://kingdesk.com/projects/php-parser/&quot;&gt;PHP based parser&lt;/a&gt; that parses HTML using  some ungodly regex. As the author of this project, I can tell you it is possible to parse HTML with regex, but not efficient. If you need a server-side solution (as I did for my &lt;a href=&quot;http://wordpress.org/extend/plugins/wp-typography/&quot;&gt;wp-Typography WordPress plugin&lt;/a&gt;), this works.</source>
          <target state="translated">这是一个&lt;a href=&quot;http://kingdesk.com/projects/php-parser/&quot;&gt;基于PHP的解析器&lt;/a&gt; ，它使用一些不合常规的正则表达式来解析HTML。 作为该项目的作者，我可以告诉您可以使用正则表达式解析HTML，但是效率不高。 如果您需要服务器端解决方案（就像我为&lt;a href=&quot;http://wordpress.org/extend/plugins/wp-typography/&quot;&gt;wp-Typography WordPress插件&lt;/a&gt;所做的那样），则可以使用。</target>
        </trans-unit>
        <trans-unit id="de8fd03b5c9fb5a8404878e31a8e0845726217a3" translate="yes" xml:space="preserve">
          <source>Here's a &lt;strong&gt;sample note on the PHP manual&lt;/strong&gt; I wrote on January: &lt;a href=&quot;http://php.net/manual/en/regexp.reference.recursive.php&quot;&gt;Reference&lt;/a&gt;</source>
          <target state="translated">这是我在一月份写&lt;strong&gt;的PHP手册&lt;/strong&gt;的&lt;strong&gt;示例注释&lt;/strong&gt; ： &lt;a href=&quot;http://php.net/manual/en/regexp.reference.recursive.php&quot;&gt;参考&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c95897a114ae327a0fcd3248ce2f00b0ecf00ea" translate="yes" xml:space="preserve">
          <source>Here's the magic pattern:</source>
          <target state="translated">这里有一个神奇的模式。</target>
        </trans-unit>
        <trans-unit id="c10b2e598b32c332a06818be23de20fdc89e2f2a" translate="yes" xml:space="preserve">
          <source>Here's the solution:</source>
          <target state="translated">解决办法是这样的。</target>
        </trans-unit>
        <trans-unit id="2cb54d7b11fcfb379247546c25fc8c672912b48c" translate="yes" xml:space="preserve">
          <source>However, a na&amp;iuml;ve implementation of that will end up matching &lt;code&gt;&amp;lt;bar/&amp;gt;&amp;lt;/foo&amp;gt;&lt;/code&gt; in this example document</source>
          <target state="translated">但是，该示例的简单实现最终会在此示例文档中匹配 &lt;code&gt;&amp;lt;bar/&amp;gt;&amp;lt;/foo&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ee1e08a15d19fdb33d20bd07c63e0818a8b9803" translate="yes" xml:space="preserve">
          <source>I agree that the right tool to parse XML and &lt;em&gt;especially HTML&lt;/em&gt; is a parser and not a regular expression engine. However, like others have pointed out, sometimes using a regex is quicker, easier, and gets the job done if you know the data format.</source>
          <target state="translated">我同意解析XML（ &lt;em&gt;尤其是HTML&lt;/em&gt; ）的正确工具是解析器，而不是正则表达式引擎。 但是，就像其他人指出的那样，有时使用正则表达式会更快，更轻松，并且如果您知道数据格式，则可以完成工作。</target>
        </trans-unit>
        <trans-unit id="65c26198557f567b9e45c7ec5c4d24af104d4dba" translate="yes" xml:space="preserve">
          <source>I also entered tags with:</source>
          <target state="translated">我还输入了标签与。</target>
        </trans-unit>
        <trans-unit id="f992540f103a26060e050d18a000903263722fe7" translate="yes" xml:space="preserve">
          <source>I believe it says:</source>
          <target state="translated">我相信它是这样说的。</target>
        </trans-unit>
        <trans-unit id="67002a6457c576d19392a6bb03d1003175f5f89d" translate="yes" xml:space="preserve">
          <source>I bet I will get downvoted for this.</source>
          <target state="translated">我打赌我一定会因为这个而被降票。</target>
        </trans-unit>
        <trans-unit id="a78333526ec3e39b92b14f68dec9aff52646cd97" translate="yes" xml:space="preserve">
          <source>I came up with this and wanted to make sure I've got it right. I am only capturing the &lt;code&gt;a-z&lt;/code&gt;.</source>
          <target state="translated">我想出了这个，想确保我做对了。 我只是捕获 &lt;code&gt;a-z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c510ddbef2e355def2551ab12c01a3563da7ee62" translate="yes" xml:space="preserve">
          <source>I don't know your exact need for this, but if you are also using .NET, couldn't you use &lt;a href=&quot;http://www.codeplex.com/htmlagilitypack&quot;&gt;Html Agility Pack&lt;/a&gt;?</source>
          <target state="translated">我不知道您对此有确切的需求，但是如果您还使用.NET，则不能使用&lt;a href=&quot;http://www.codeplex.com/htmlagilitypack&quot;&gt;HTML Agility Pack&lt;/a&gt;吗？</target>
        </trans-unit>
        <trans-unit id="a18f149e6422b3edd9f248402bd13c1e293f7282" translate="yes" xml:space="preserve">
          <source>I guess to make it not match self contained tags, you'd either want to use &lt;a href=&quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732395#1732395&quot;&gt;Kobi&lt;/a&gt;'s negative look-behind:</source>
          <target state="translated">我想使它与自包含标签不匹配，您要么想使用&lt;a href=&quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732395#1732395&quot;&gt;Kobi&lt;/a&gt;的否定式外观：</target>
        </trans-unit>
        <trans-unit id="446fea43937f34270d7612150462764e964be907" translate="yes" xml:space="preserve">
          <source>I have also composed a haiku describing the nature of regex in Perl.</source>
          <target state="translated">我还写了一个俳句,描述了Perl中regex的本质。</target>
        </trans-unit>
        <trans-unit id="682e33f67784d033cbcf7127d0e8db1135907695" translate="yes" xml:space="preserve">
          <source>I have composed a haiku describing the nature of HTML.</source>
          <target state="translated">我写了一篇描述HTML性质的俳句。</target>
        </trans-unit>
        <trans-unit id="b7d276bff4ead75187b5216ebca62ddd0544740b" translate="yes" xml:space="preserve">
          <source>I have never used &lt;a href=&quot;http://querypath.org/&quot;&gt;querypath&lt;/a&gt;, so can't comment on its usefulness.</source>
          <target state="translated">我从未使用过&lt;a href=&quot;http://querypath.org/&quot;&gt;querypath&lt;/a&gt; ，因此无法评论其有用性。</target>
        </trans-unit>
        <trans-unit id="a3d81722ce02cdd1e1d406605ca28b6afc2989ae" translate="yes" xml:space="preserve">
          <source>I haven't quite finished the last part myself, but I know I'm getting close. It keeps throwing &lt;code&gt;CthulhuRlyehWgahnaglFhtagnException&lt;/code&gt;s for some reason, so I'm going to port it to VB 6 and use &lt;code&gt;On Error Resume Next&lt;/code&gt;. I'll update with the code once I investigate this strange door that just opened in the wall. Hmm.</source>
          <target state="translated">我本人还没有完成最后一部分，但是我知道我已经接近了。 由于某种原因，它总是抛出 &lt;code&gt;CthulhuRlyehWgahnaglFhtagnException&lt;/code&gt; ，所以我将其移植到VB 6并使用 &lt;code&gt;On Error Resume Next&lt;/code&gt; 。 一旦调查了刚刚在墙上打开的这扇奇怪的门，我将更新代码。 嗯</target>
        </trans-unit>
        <trans-unit id="57a8d4c706d6a34ee3af3112fdb317e71ff9acca" translate="yes" xml:space="preserve">
          <source>I like to parse HTML with regular expressions. I don't attempt to parse idiot HTML that is deliberately broken. This code is my main parser (Perl edition):</source>
          <target state="translated">我喜欢用正则表达式解析HTML。我不尝试解析那些故意破坏的白痴HTML。这段代码是我的主要解析器(Perl版)。</target>
        </trans-unit>
        <trans-unit id="8ea04fa9f527bf7438dfd9b91e87f0721f39b7be" translate="yes" xml:space="preserve">
          <source>I need to match all of these opening tags:</source>
          <target state="translated">我需要匹配所有这些开场标签。</target>
        </trans-unit>
        <trans-unit id="f58bfd6885d7586198e4ea7d285dc17ac4158c70" translate="yes" xml:space="preserve">
          <source>I suggest using &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; for parsing XML and HTML in PHP.  It's basically much the same syntax as jQuery, only it's on the server side.</source>
          <target state="translated">我建议使用&lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt;在PHP中解析XML和HTML。 它的语法基本上与jQuery相同，只是在服务器端。</target>
        </trans-unit>
        <trans-unit id="ece9292e931d9ba43626cda22fdf3280d35633a6" translate="yes" xml:space="preserve">
          <source>I think the XML case is quite simple. The RegEx (in the .NET syntax), deflated and coded in base64 to make it easier to comprehend by your feeble mind, should be something like this:</source>
          <target state="translated">我认为XML的情况很简单。RegEx (在.NET语法中),为了让你的弱智的大脑更容易理解,用base64编码的RegEx应该是这样的。</target>
        </trans-unit>
        <trans-unit id="18040856a3f0eb37bda82501b7d790ae361b0b2d" translate="yes" xml:space="preserve">
          <source>I think the flaw here is that HTML is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;Chomsky Type 2 grammar (context free grammar)&lt;/a&gt; and RegEx is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_grammar&quot;&gt;Chomsky Type 3 grammar (regular grammar)&lt;/a&gt;. Since a Type 2 grammar is fundamentally more complex than a Type 3 grammar (see the &lt;a href=&quot;http://en.wikipedia.org/wiki/Chomsky_hierarchy&quot;&gt;Chomsky hierarchy&lt;/a&gt;), it is &lt;em&gt;mathematically impossible&lt;/em&gt; to parse XML with RegEx.</source>
          <target state="translated">我认为这里的缺点是HTML是&lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;Chomsky Type 2语法（无上下文语法），&lt;/a&gt;而RegEx是&lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_grammar&quot;&gt;Chomsky Type 3语法（常规语法）&lt;/a&gt; 。 由于类型2语法从根本上比类型3语法复杂（请参阅&lt;a href=&quot;http://en.wikipedia.org/wiki/Chomsky_hierarchy&quot;&gt;Chomsky层次结构&lt;/a&gt; ），因此从&lt;em&gt;数学&lt;/em&gt;上讲， &lt;em&gt;无法&lt;/em&gt;使用RegEx解析XML。</target>
        </trans-unit>
        <trans-unit id="46e4bbf54843bf1bf2bb54e48219620db67794ee" translate="yes" xml:space="preserve">
          <source>I used a open source tool called &lt;a href=&quot;http://htmlparser.sourceforge.net/&quot;&gt;HTMLParser&lt;/a&gt; before. It's designed to parse HTML in various ways and serves the purpose quite well. It can parse HTML as different treenode and you can easily use its API to get attributes out of the node. Check it out and see if this can help you.</source>
          <target state="translated">我以前使用过一个名为&lt;a href=&quot;http://htmlparser.sourceforge.net/&quot;&gt;HTMLParser的&lt;/a&gt;开源工具。 它旨在以各种方式解析HTML，并且很好地达到了目的。 它可以将HTML解析为不同的treenode，并且您可以轻松地使用其API从节点中获取属性。 检查一下，看看是否可以帮到您。</target>
        </trans-unit>
        <trans-unit id="50830c82c86965110baf1111e9368113230c821b" translate="yes" xml:space="preserve">
          <source>I used the sample source of:</source>
          <target state="translated">我使用的样本来源是:</target>
        </trans-unit>
        <trans-unit id="fb040c717878233cc23503d0d656d6a7c4f3856c" translate="yes" xml:space="preserve">
          <source>I wrote it in 30 seconds, and tested here:
&lt;a href=&quot;http://gskinner.com/RegExr/&quot;&gt;http://gskinner.com/RegExr/&lt;/a&gt;</source>
          <target state="translated">我在30秒内编写了它，并在此处进行了测试： &lt;a href=&quot;http://gskinner.com/RegExr/&quot;&gt;http&lt;/a&gt; ： //gskinner.com/RegExr/</target>
        </trans-unit>
        <trans-unit id="eb8a7f1667c9d5eff8cc8d64ddbce9b58e23a699" translate="yes" xml:space="preserve">
          <source>I wrote this pattern to power the &lt;em&gt;recursive descent parser&lt;/em&gt; of a template engine I built in my framework, and performances are really great, both in execution times or in memory usage (nothing to do with other template engines which use the same syntax).</source>
          <target state="translated">我编写了这种模式来增强我在框架中构建的模板引擎的&lt;em&gt;递归下降解析器&lt;/em&gt;的性能，无论是在执行时间还是在内存使用方面，其性能都非常好（与使用相同语法的其他模板引擎无关）。</target>
        </trans-unit>
        <trans-unit id="f454869fe61fa45429bc7ee92bc5ad9345d8b481" translate="yes" xml:space="preserve">
          <source>I'm sure you already know by now that you shouldn't use regex for this purpose.</source>
          <target state="translated">我相信你现在已经知道,你不应该为此目的使用regex。</target>
        </trans-unit>
        <trans-unit id="40dea22884315ebb5434973f5bb9c5c1ca6166f5" translate="yes" xml:space="preserve">
          <source>If You Like Regular Expressions So Much, Why Don't You Marry Them?</source>
          <target state="translated">如果你这么喜欢常态化的表达方式,为什么不结婚?</target>
        </trans-unit>
        <trans-unit id="cbfa4fd68fca2bc7eab26c99ba711ac9cab9bb23" translate="yes" xml:space="preserve">
          <source>If an (x)HTML parser needs recursion, a RegExp parser without recursion is not enough for the purpose. It's a simple construct.</source>
          <target state="translated">如果一个(x)HTML解析器需要递归,那么一个没有递归的 RegExp解析器是无法达到目的的。这是一个简单的构造。</target>
        </trans-unit>
        <trans-unit id="919388ca02cd994c288549580960ad9ba47f962b" translate="yes" xml:space="preserve">
          <source>If someone is interested in learning more about the pattern, I provide some line:</source>
          <target state="translated">如果有人有兴趣了解更多的模式,我提供一些线路。</target>
        </trans-unit>
        <trans-unit id="557f9117f8433eb60bbd29cff5259745d632f952" translate="yes" xml:space="preserve">
          <source>If you add something to the regex, by backtracking it can be forced to match silly things like &lt;code&gt;&amp;lt;a &amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;[^/]&lt;/code&gt; is too permissive. Also note that &lt;code&gt;&amp;lt;space&amp;gt;*[^/]*&lt;/code&gt; is redundant, because the &lt;code&gt;[^/]*&lt;/code&gt; can also match spaces.</source>
          <target state="translated">如果在正则表达式中添加某些内容，则可以通过回溯将其强制匹配诸如 &lt;code&gt;&amp;lt;a &amp;gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;[^/]&lt;/code&gt; 类的愚蠢内容。 另请注意， &lt;code&gt;&amp;lt;space&amp;gt;*[^/]*&lt;/code&gt; 是多余的，因为 &lt;code&gt;[^/]*&lt;/code&gt; 也可以匹配空格。</target>
        </trans-unit>
        <trans-unit id="a298912d3657e52c67b5f74e85c231c1485f0d0c" translate="yes" xml:space="preserve">
          <source>If you are unsure, no, I'm NOT kidding (but perhaps I'm lying). It WILL work. I've built tons of unit tests to test it, and I have even used (part of) the &lt;a href=&quot;http://www.w3.org/XML/Test/&quot;&gt;conformance tests&lt;/a&gt;. It's a tokenizer, not a full-blown parser, so it will only split the XML into its component tokens. It won't parse/integrate DTDs.</source>
          <target state="translated">如果您不确定，不，我不是在开玩笑（但也许我在撒谎）。 它将起作用。 我已经建立了大量的单元测试来对其进行测试，甚至还使用了（部分） &lt;a href=&quot;http://www.w3.org/XML/Test/&quot;&gt;一致性测试&lt;/a&gt; 。 这是一个标记器，而不是成熟的解析器，因此它将仅将XML拆分为其组件标记。 它不会解析/集成DTD。</target>
        </trans-unit>
        <trans-unit id="2b5bc330d9a583246ad4801874fc84163c931493" translate="yes" xml:space="preserve">
          <source>If you have a small set of HTML pages that you want to scrape data from and then stuff into a database, regexes might work fine.  For example, I recently wanted to get the names, parties, and districts of Australian federal Representatives, which I got off of the Parliament's web site.  This was a limited, one-time job.</source>
          <target state="translated">如果你有一个小的HTML页面,你想从这些页面中提取数据,然后将其塞进数据库中,regexes可能会很好用。例如,我最近想获得澳大利亚联邦众议员的姓名、党派和地区,我从议会的网站上获得了这些数据。这是一个有限的、一次性的工作。</target>
        </trans-unit>
        <trans-unit id="d9db7068b93480af65771902d59739a0242c037f" translate="yes" xml:space="preserve">
          <source>If you have problems reconverting it to a human-readable regex, this should help:</source>
          <target state="translated">如果你在将其转换为人类可读的regex时遇到问题,这个应该会有帮助。</target>
        </trans-unit>
        <trans-unit id="14633b829212b8b056b036f6830ca7c6a918fe40" translate="yes" xml:space="preserve">
          <source>If you need this for PHP:</source>
          <target state="translated">如果你对PHP有这方面的需求。</target>
        </trans-unit>
        <trans-unit id="f932b2b6098e1c3395b486c41745029eaaebe046" translate="yes" xml:space="preserve">
          <source>If you're simply trying to find those tags (without ambitions of parsing) try this regular expression:</source>
          <target state="translated">如果你只是想找到这些标签(不需要解析),可以试试这个正则表达式。</target>
        </trans-unit>
        <trans-unit id="4b5c78fb6625eec434f0fbf5e5c22e99da727566" translate="yes" xml:space="preserve">
          <source>IgnoreCase (not necessary)</source>
          <target state="translated">忽略案例(不需要)</target>
        </trans-unit>
        <trans-unit id="195915971c682a24ad48d1e62483babae5188862" translate="yes" xml:space="preserve">
          <source>IgnorePatternWhitespace (not necessary if you collapse regex and remove all whitespace)</source>
          <target state="translated">IgnorePatternWhitespace(如果你折叠regex并删除所有的whitespace,则不需要。</target>
        </trans-unit>
        <trans-unit id="d8142f0416c264b4b799d2c8a0af8d098608064c" translate="yes" xml:space="preserve">
          <source>In shell, you can parse &lt;a href=&quot;https://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; using &lt;a href=&quot;https://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt;:</source>
          <target state="translated">在shell中，您可以使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt;解析&lt;a href=&quot;https://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="3e72a4a4bfbcf98641ca469ef038c0e9caca1753" translate="yes" xml:space="preserve">
          <source>In this case your enemy is HTML and you are either yourself or regex.  You might even be Perl with irregular regex. Know HTML.  Know yourself.</source>
          <target state="translated">在这种情况下,你的敌人是HTML,你的敌人不是自己就是regex。你甚至有可能是Perl用不规则的regex。了解HTML。了解你自己。</target>
        </trans-unit>
        <trans-unit id="4da0bc6ccd100c1869c39b7908884293a4fdecf6" translate="yes" xml:space="preserve">
          <source>It is said that if you know your enemies and know yourself, you can win a hundred battles without a single loss.
  If you only know yourself, but not your opponent, you may win or may lose.
  If you know neither yourself nor your enemy, you will always endanger yourself.</source>
          <target state="translated">俗话说,知己知彼,百战不殆,百战不败。如果只知道自己,不知道对手,可能会赢,也可能会输。如果你既不了解自己,也不了解敌人,就会时时危及自己。</target>
        </trans-unit>
        <trans-unit id="8cd9da1c9f2693e6ec017e2869a577b714739b63" translate="yes" xml:space="preserve">
          <source>It is similar to yours, but the last &lt;code&gt;&amp;gt;&lt;/code&gt; must not be after a slash, and also accepts &lt;code&gt;h1&lt;/code&gt;.</source>
          <target state="translated">它与您的相似，但是last &lt;code&gt;&amp;gt;&lt;/code&gt; 不能在斜杠后，并且也接受 &lt;code&gt;h1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ad138f054cb998fb3ecb181104c2f9f5989e48b" translate="yes" xml:space="preserve">
          <source>It is simple enough to rejig my slurp-everything-first Perl script into a nice streaming thing, if you wish to process enormous web pages. But it's not really necessary.</source>
          <target state="translated">如果你想处理巨大的网页,把我的slurp-everything-first Perl脚本重新编排成一个漂亮的流媒体,这已经很简单了。但其实没有这个必要。</target>
        </trans-unit>
        <trans-unit id="f4114fb01ee1d4a7e528e4b5db702779bb015416" translate="yes" xml:space="preserve">
          <source>It matches the types of tags you mentioned, while ignoring the types you said you wanted to ignore.</source>
          <target state="translated">它符合你提到的标签类型,而忽略了你说要忽略的类型。</target>
        </trans-unit>
        <trans-unit id="e92b765161d9c9393ab926712762103321511c85" translate="yes" xml:space="preserve">
          <source>It may not be perfect, but I ran this code through a &lt;em&gt;lot&lt;/em&gt; of HTML. Note that it even catches strange things like &lt;code&gt;&amp;lt;a name=&quot;badgenerator&quot;&quot;&amp;gt;&lt;/code&gt;, which show up on the web.</source>
          <target state="translated">可能并不完美，但是我通过&lt;em&gt;许多&lt;/em&gt; HTML来运行此代码。 请注意，它甚至会捕获显示在网络上的奇怪内容，例如 &lt;code&gt;&amp;lt;a name=&quot;badgenerator&quot;&quot;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c401fdac65c6774bcadecd58093d69231332e3b" translate="yes" xml:space="preserve">
          <source>It seems to me you're trying to match tags without a &quot;/&quot; at the end. Try this:</source>
          <target state="translated">在我看来,你似乎在尝试匹配标签,而没有在结尾处加上&quot;&quot;。试试这个。</target>
        </trans-unit>
        <trans-unit id="f6ca3fc0ed09308a49c656e7527184db98c56489" translate="yes" xml:space="preserve">
          <source>It's called htmlsplit, splits the HTML into lines, with one tag or chunk of text on each line.  The lines can then be processed further with other text tools and scripts, such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt;, Perl, etc. I'm not even joking :) Enjoy.</source>
          <target state="translated">它称为htmlsplit，将HTML分成几行，每行上有一个标签或文本块。 然后可以使用其他文本工具和脚本（例如&lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt; ， &lt;a href=&quot;http://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt; ，Perl等）进一步处理这些行。我什至不开玩笑：）享受。</target>
        </trans-unit>
        <trans-unit id="9ec7139f7024ff295c9ba4a49287ac0b4b6fc319" translate="yes" xml:space="preserve">
          <source>It's true that when programming it's usually best to use dedicated parsers and APIs instead of regular expressions when dealing with HTML, especially if accuracy is paramount (e.g., if your processing might have security implications). However, I don&amp;rsquo;t ascribe to a dogmatic view that XML-style markup should never be processed with regular expressions. There are cases when regular expressions are a great tool for the job, such as when making one-time edits in a text editor, fixing broken XML files, or dealing with file formats that look like but aren&amp;rsquo;t quite XML. There are some issues to be aware of, but they're not insurmountable or even necessarily relevant.</source>
          <target state="translated">的确，在编程时，处理HTML时通常最好使用专用的解析器和API而不是正则表达式，尤其是在精度至关重要的情况下（例如，如果处理可能会带来安全隐患）。 但是，我不认为教条主义的观点是XML样式的标记永远不应使用正则表达式处理。 在某些情况下，正则表达式是完成这项工作的理想工具，例如，在文本编辑器中进行一次性编辑，修复损坏的XML文件或处理看起来像但不完全是XML的文件格式时。 有一些问题需要注意，但并非不可克服，甚至不一定是相关的。</target>
        </trans-unit>
        <trans-unit id="39e7ab248960684eaa9b9f720409b41a17a28cff" translate="yes" xml:space="preserve">
          <source>It's written as a PHP string, so the &quot;s&quot; modifier makes classes include newlines.</source>
          <target state="translated">它被写成了PHP字符串,所以 &quot;s &quot;修改器使得类包含了换行。</target>
        </trans-unit>
        <trans-unit id="427486fffe171253525e01e3f06e796d5676dc63" translate="yes" xml:space="preserve">
          <source>Just to give a sense of what a more &quot;advanced&quot; HTML regex would look like, the following does a fairly respectable job of emulating real-world browser behavior and the HTML5 parsing algorithm:</source>
          <target state="translated">为了给人一种更 &quot;高级 &quot;的 HTML regex 会是什么样子的感觉,以下是对现实世界中的浏览器行为和 HTML5 解析算法的模拟,做了相当不错的工作。</target>
        </trans-unit>
        <trans-unit id="22605049c94f39fec40c01fc01b8d0235c7512b9" translate="yes" xml:space="preserve">
          <source>Just try it.</source>
          <target state="translated">试试就好了。</target>
        </trans-unit>
        <trans-unit id="601daad3ec0906e4e0d799c06fb0f95e6770d70e" translate="yes" xml:space="preserve">
          <source>Lastly, I really enjoyed Jeff Atwood's article:  &lt;a href=&quot;https://blog.codinghorror.com/parsing-html-the-cthulhu-way/&quot;&gt;Parsing Html The Cthulhu Way&lt;/a&gt;. Funny enough, it cites the answer to this question that currently has over 4k votes.</source>
          <target state="translated">最后，我真的很喜欢Jeff Atwood的文章： &lt;a href=&quot;https://blog.codinghorror.com/parsing-html-the-cthulhu-way/&quot;&gt;解析Html The Cthulhu Way&lt;/a&gt; 。 有趣的是，它引用了这个问题的答案，目前该问题的投票已超过4k。</target>
        </trans-unit>
        <trans-unit id="d67da4c32f78ca5c993f0ad4bcd5b49e6538c409" translate="yes" xml:space="preserve">
          <source>Like Lord Marshal (is he a relative of the Marshal .NET class?), I have seen the &lt;strike&gt;Underverse&lt;/strike&gt; Stack Based Regex-Verse and returned with &lt;strike&gt;powers&lt;/strike&gt; knowledge you can't imagine. Yes, I think there were an Old One or two protecting them, but they were watching football on the TV, so it wasn't difficult.</source>
          <target state="translated">像元帅勋爵（他是元帅.NET类的亲戚吗？）一样，我已经看到了基于&lt;strike&gt;Underverse&lt;/strike&gt; Stack的Regex-Verse，并且返回了无法想象的&lt;strike&gt;能力&lt;/strike&gt;知识。 是的，我认为有一个或两个老人在保护他们，但是他们正在电视上看足球，所以这并不困难。</target>
        </trans-unit>
        <trans-unit id="1c3e6997e482742cdf179a4397cb018cad2d8564" translate="yes" xml:space="preserve">
          <source>Microsoft actually has a section of &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices&quot;&gt;Best Practices for Regular Expressions in the .NET Framework&lt;/a&gt; and specifically talks about &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices#consider-the-input-source&quot;&gt;Consider[ing] the Input Source&lt;/a&gt;.</source>
          <target state="translated">Microsoft实际上&lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices&quot;&gt;在.NET Framework中&lt;/a&gt;有一节有关正则表达式的最佳实践，并专门讨论了&lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices#consider-the-input-source&quot;&gt;考虑输入源&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba3b99fc49923cc3bbd90f5e080753b12725e9bc" translate="yes" xml:space="preserve">
          <source>My suggestion would be</source>
          <target state="translated">我的建议是</target>
        </trans-unit>
        <trans-unit id="72810c91afedb33b80069b7076436fecf94d1af6" translate="yes" xml:space="preserve">
          <source>No, holy cow, no match found.</source>
          <target state="translated">不,圣牛,没有找到匹配的。</target>
        </trans-unit>
        <trans-unit id="a474b6597430f9ba4fac174b06490808a6e22af5" translate="yes" xml:space="preserve">
          <source>Note that this allows things like &lt;code&gt;&amp;lt;a/ &amp;gt;&lt;/code&gt; (just like the original regex), so if you want something more restrictive, you need to build a regex to match attribute pairs separated by spaces.</source>
          <target state="translated">请注意，这允许使用 &lt;code&gt;&amp;lt;a/ &amp;gt;&lt;/code&gt; 类的东西（就像原始的正则表达式一样），因此，如果您想要更严格的限制，则需要构建一个正则表达式以匹配用空格分隔的属性对。</target>
        </trans-unit>
        <trans-unit id="aa7cf65bf2ed58b9c07633b4dd41874bd458e314" translate="yes" xml:space="preserve">
          <source>Now, we could speak about the limits of this method from a more informed point of view:</source>
          <target state="translated">现在,我们可以从更多的角度来谈一谈这种方法的局限性。</target>
        </trans-unit>
        <trans-unit id="1022301500a966b54ef35dd0b0c702c86a1e6cad" translate="yes" xml:space="preserve">
          <source>Oh... if you want the source code of the regex, with some auxiliary methods:</source>
          <target state="translated">哦......如果你想得到regex的源代码,还有一些辅助方法。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="efc9dd879d5fa6c41b5a8b4a174e9bbeea207c3f" translate="yes" xml:space="preserve">
          <source>P.S. Pierre de Fermat also figured out how to do it, but the margin he was writing in wasn't big enough for the code.</source>
          <target state="translated">P.S.Pierre de Fermat也想出了办法,但他写进去的余量不够大,无法满足代码的要求。</target>
        </trans-unit>
        <trans-unit id="fb344f772f606bf069b994b1800b75ad467d5eb0" translate="yes" xml:space="preserve">
          <source>Profit!</source>
          <target state="translated">Profit!</target>
        </trans-unit>
        <trans-unit id="ffe7bde078bc620df9c2922255941de3200d1c7e" translate="yes" xml:space="preserve">
          <source>Quote from article 1 cited above:</source>
          <target state="translated">引用上文第1条所引。</target>
        </trans-unit>
        <trans-unit id="ebb8b5eff359c8e4629b4281a740853315bc1649" translate="yes" xml:space="preserve">
          <source>RegEx match open tags except XHTML self-contained tags</source>
          <target state="translated">RegEx 匹配开放标签,但XHTML自带标签除外。</target>
        </trans-unit>
        <trans-unit id="8336d194052f52769b114f9bc2344752e9b3f02b" translate="yes" xml:space="preserve">
          <source>Regexes worked just fine for me, and were very fast to set up.</source>
          <target state="translated">Regexes对我来说效果很好,而且设置起来非常快。</target>
        </trans-unit>
        <trans-unit id="9ca09288e6a253e0dfa4bc1e29bfae12ab028bb9" translate="yes" xml:space="preserve">
          <source>Regular Expression Explained (inline)</source>
          <target state="translated">正则表达式解释(内联)</target>
        </trans-unit>
        <trans-unit id="24b2174abc016feccbfb08853265c6a5a2ea6e89" translate="yes" xml:space="preserve">
          <source>Regular Expressions do have limitations, but have you considered the following?</source>
          <target state="translated">正则表达式确实有局限性,但你考虑过以下几点吗?</target>
        </trans-unit>
        <trans-unit id="f20c01e8fa442e15f50708e2e685f84f38cf9f06" translate="yes" xml:space="preserve">
          <source>Regular Expressions: Now You Have Two Problems</source>
          <target state="translated">正则表达式。现在你有两个问题</target>
        </trans-unit>
        <trans-unit id="b49c5b3c647bd9589b36c369c0bc3c5a638f66ed" translate="yes" xml:space="preserve">
          <source>Related (why you shouldn't use regex match):</source>
          <target state="translated">相关(为什么不应该使用regex匹配)。</target>
        </trans-unit>
        <trans-unit id="16962bdac3ee084e07372a69f0ada8648f72cfce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.microsoft.com/archive/blogs/bclteam/net-regular-expressions-regex-and-balanced-matching-ryan-byington&quot;&gt;.NET Regular Expressions: Regex and Balanced Matching&lt;/a&gt;</source>
          <target state="translated">请参见&lt;a href=&quot;https://docs.microsoft.com/archive/blogs/bclteam/net-regular-expressions-regex-and-balanced-matching-ryan-byington&quot;&gt;.NET正则表达式：正则表达式和平衡匹配&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de60e0a6c744236d2ff2a2469aa87dabd965b8f9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://weblogs.asp.net/whaggard/377025&quot;&gt;Matching Balanced Constructs with .NET Regular Expressions&lt;/a&gt;</source>
          <target state="translated">请参见将&lt;a href=&quot;https://weblogs.asp.net/whaggard/377025&quot;&gt;平衡构造与.NET正则表达式匹配&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a3ea9fb6afc3bc06c915f2dc863ae7a60ef9464e" translate="yes" xml:space="preserve">
          <source>See Microsoft's docs on &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;Balancing Group Definitions&lt;/a&gt;</source>
          <target state="translated">请参阅有关&lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;平衡组定义的&lt;/a&gt; Microsoft文档</target>
        </trans-unit>
        <trans-unit id="0ad4363c94846f440a3409baad524ee90a091468" translate="yes" xml:space="preserve">
          <source>Should you find something which does not work in the proof of concept above, I am available in analyzing the code to improve my skills.</source>
          <target state="translated">如果您在上面的概念证明中发现有什么地方不适用,我可以通过分析代码来提高我的技能。</target>
        </trans-unit>
        <trans-unit id="92cfc65b8206d5667dc7ccac83a9a9a793d658df" translate="yes" xml:space="preserve">
          <source>Since nobody mentioned the main mechanism a parser is built onto, I was soon aware that nobody got the point.</source>
          <target state="translated">由于没有人提到解析器的主要机制,我很快就意识到没有人明白这个道理。</target>
        </trans-unit>
        <trans-unit id="4e222f3f71ebc82ced1555d79e3896204e2da9f1" translate="yes" xml:space="preserve">
          <source>Singleline</source>
          <target state="translated">Singleline</target>
        </trans-unit>
        <trans-unit id="2e489e37aeb575873f40d9f8a80c3e74b1c26ae6" translate="yes" xml:space="preserve">
          <source>Small tip: to better analyze this code it is necessary looking at the source code generated since I did not provide any HTML special characters escaping.</source>
          <target state="translated">小提示:为了更好地分析这段代码,有必要看一下生成的源代码,因为我没有提供任何HTML特殊字符的转义。</target>
        </trans-unit>
        <trans-unit id="2ccc837c5ed1e3feef77351cd1d620591415719e" translate="yes" xml:space="preserve">
          <source>Solve the Halting Problem.</source>
          <target state="translated">解决停滞问题。</target>
        </trans-unit>
        <trans-unit id="b8fc19b88ebcae8fab9f0ca6d99cb4a564e9d1d4" translate="yes" xml:space="preserve">
          <source>Square a circle.</source>
          <target state="translated">方圆一圈。</target>
        </trans-unit>
        <trans-unit id="e1c5ebb5af83fa15c6406a756fafb86dfda684e1" translate="yes" xml:space="preserve">
          <source>Sun Tzu, an ancient Chinese strategist, general, and philosopher, said:</source>
          <target state="translated">孙子,中国古代的谋士、将军、哲学家,说。</target>
        </trans-unit>
        <trans-unit id="1361c33aa4292835661dbf5c91a1e629b1a6decc" translate="yes" xml:space="preserve">
          <source>The .NET framework is unique when it comes to regular expressions in that it supports &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;Balancing Group Definitions&lt;/a&gt;.</source>
          <target state="translated">.NET框架在正则表达式方面是唯一的，因为它支持&lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;平衡组定义&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="55da94ce9e0ca8998eabc3076f92485f67f4f2eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.php.net/manual/en/function.dom-import-simplexml.php&quot;&gt;PHP DOM&lt;/a&gt;&lt;a href=&quot;http://php.net/manual/en/class.domdocument.php&quot;&gt;functions&lt;/a&gt; won't work properly unless it is properly formatted XML. No matter how much better their use is for the rest of mankind.</source>
          <target state="translated">除非使用正确格式的XML，否则&lt;a href=&quot;http://www.php.net/manual/en/function.dom-import-simplexml.php&quot;&gt;PHP DOM&lt;/a&gt; &lt;a href=&quot;http://php.net/manual/en/class.domdocument.php&quot;&gt;函数&lt;/a&gt;将无法正常工作。 无论它们对全人类的使用有多好。</target>
        </trans-unit>
        <trans-unit id="4ac395740ae412d2f1cc1a46e41f7844bd6163b7" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;black art of RegExp is hard to master&lt;/strong&gt;, so maybe there are further possibilities we left out while trying and testing our personal solution to capture the whole web in one hand... Well, I am sure about it :)</source>
          <target state="translated">&lt;strong&gt;RegExp&lt;/strong&gt;的&lt;strong&gt;黑色技巧很难掌握&lt;/strong&gt; ，因此也许在尝试和测试我们的个人解决方案时，有更多的可能性被我们遗漏了，以便用一只手捕获整个网络&amp;hellip;&amp;hellip;嗯，我敢肯定：)</target>
        </trans-unit>
        <trans-unit id="997812962876e0edf9df4c8486980789ffe0886d" translate="yes" xml:space="preserve">
          <source>The W3C explains parsing in a pseudo regexp form:</source>
          <target state="translated">W3C以伪regexp形式解释解析。</target>
        </trans-unit>
        <trans-unit id="fdcdc94a48b14eafa651bbe7dd5b0b9e404ab530" translate="yes" xml:space="preserve">
          <source>The best way to write regular expressions is in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Lex_%28software%29&quot;&gt;Lex&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; style, not as opaque one-liners or commented multi-line monstrosities. I didn't do that here, yet; these ones barely need it.</source>
          <target state="translated">编写正则表达式的最佳方法是使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Lex_%28software%29&quot;&gt;Lex&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt;样式，而不是不透明的单行代码或带有注释的多行怪物。 我还没有在这里做； 这些人几乎不需要它。</target>
        </trans-unit>
        <trans-unit id="712ab4b4a1f7ed2c6d0a80c8195f21170140f25f" translate="yes" xml:space="preserve">
          <source>The following matches a fairly strict definition of XML tags (although it doesn't account for the full set of Unicode characters allowed in XML names):</source>
          <target state="translated">以下是一个相当严格的XML标记的定义(尽管它没有考虑到XML名称中允许的全部Unicode字符)。</target>
        </trans-unit>
        <trans-unit id="b4cfd79b880dc8c38082dbd0830e9fdee4557b44" translate="yes" xml:space="preserve">
          <source>The options to set is &lt;code&gt;RegexOptions.ExplicitCapture&lt;/code&gt;. The capture group you are looking for is &lt;code&gt;ELEMENTNAME&lt;/code&gt;. If the capture group &lt;code&gt;ERROR&lt;/code&gt; is not empty then there was a parsing error and the Regex stopped.</source>
          <target state="translated">设置的选项是 &lt;code&gt;RegexOptions.ExplicitCapture&lt;/code&gt; 。 您正在寻找的捕获组是 &lt;code&gt;ELEMENTNAME&lt;/code&gt; 。 如果捕获组 &lt;code&gt;ERROR&lt;/code&gt; 不为空，则说明存在解析错误，并且正则表达式已停止。</target>
        </trans-unit>
        <trans-unit id="42afcd3eb11823b2c3d7a0e945433e5d9be383b6" translate="yes" xml:space="preserve">
          <source>The parts explained:</source>
          <target state="translated">的部分解释。</target>
        </trans-unit>
        <trans-unit id="7b1c98adf4b68d1b5b5505c62c8cdcb98c54e922" translate="yes" xml:space="preserve">
          <source>The pattern will be pretty big, so make sure you have an algorithm that losslessly compresses random data.</source>
          <target state="translated">这个模式会相当大,所以要确保你有一个无损压缩随机数据的算法。</target>
        </trans-unit>
        <trans-unit id="7216ec9c43638b3c7e394bf44fd4c73431e98cef" translate="yes" xml:space="preserve">
          <source>The suggested regex is wrong, though:</source>
          <target state="translated">不过,建议的regex是错误的。</target>
        </trans-unit>
        <trans-unit id="9a7f6c57efe365adfc81358edd4c2317e716adc0" translate="yes" xml:space="preserve">
          <source>The tag to match may end with a simple &quot;&amp;gt;&quot; symbol, or a possible XHTML closure, which makes use of the slash before it: (/&amp;gt;|&amp;gt;). The slash is, of course, escaped since it coincides with the regular expression delimiter.</source>
          <target state="translated">要匹配的标签可以以简单的&amp;ldquo;&amp;gt;&amp;rdquo;符号或可能的XHTML闭包结尾，该闭包使用其前的斜杠（/&amp;gt; |&amp;gt;）。 由于斜杠与正则表达式定界符一致，因此当然可以将其转义。</target>
        </trans-unit>
        <trans-unit id="d8320be450cb3daac23d24918c511589e5cc20d4" translate="yes" xml:space="preserve">
          <source>The user @ridgerunner noticed that the pattern does not allow &lt;strong&gt;unquoted attributes&lt;/strong&gt; or &lt;strong&gt;attributes with no value&lt;/strong&gt;. In this case a fine tuning brings us the following pattern:</source>
          <target state="translated">用户@ridgerunner注意到该模式不允许使用&lt;strong&gt;未引用的属性&lt;/strong&gt;或&lt;strong&gt;没有值的属性&lt;/strong&gt; 。 在这种情况下，微调为我们带来了以下模式：</target>
        </trans-unit>
        <trans-unit id="96ae70a6ef53719f5c2ee204876a53bf013a8cbd" translate="yes" xml:space="preserve">
          <source>Then, since a tag may end with a whitespace before the &quot;&amp;gt;&quot; symbol, zero or more whitespaces are matched with the \s* subpattern.</source>
          <target state="translated">然后，由于标签可能以&amp;ldquo;&amp;gt;&amp;rdquo;符号之前的空格结尾，因此零个或多个空格与\ s *子模式匹配。</target>
        </trans-unit>
        <trans-unit id="868220302ade7af78023c7b85a0b0afbdb075b65" translate="yes" xml:space="preserve">
          <source>There are people that will tell you that Regular Expressions shouldn't be recursive. They are limiting you. They need to subjugate you, and they do it by keeping you in ignorance.</source>
          <target state="translated">有人会告诉你,正则表达式不应该是递归的。他们是在限制你。他们需要征服你,他们通过让你处于无知的状态来做到这一点。</target>
        </trans-unit>
        <trans-unit id="62180d2f49459a045257d1d5b700900365c68916" translate="yes" xml:space="preserve">
          <source>There are people that will tell you that the Earth is round (or perhaps that the Earth is an oblate spheroid if they want to use strange words). They are lying.</source>
          <target state="translated">有些人会告诉你,地球是圆的(如果他们想用奇怪的词,或许地球是一个长方形的球体)。他们是在撒谎。</target>
        </trans-unit>
        <trans-unit id="684dfff1de896a122d012445ef544b2496206f87" translate="yes" xml:space="preserve">
          <source>There are some nice regexes for replacing HTML with BBCode &lt;a href=&quot;http://www.garyshood.com/htmltobb/source.txt&quot;&gt;here&lt;/a&gt;. For all you nay-sayers, note that he's not trying to fully parse HTML, just to sanitize it. He can probably afford to kill off tags that his simple &quot;parser&quot; can't understand.</source>
          <target state="translated">这里有一些很好的用BBCode替换HTML的正则表达式。 对于所有反对者，请注意，他并没有完全解析HTML，只是为了清理HTML。 他可能有能力杀死简单的&amp;ldquo;解析器&amp;rdquo;无法理解的标签。</target>
        </trans-unit>
        <trans-unit id="76477d9fdddcc475f5d450550d80b052eec3964d" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;http://blog.stevenlevithan.com/archives/match-innermost-html-element&quot;&gt;definitive blog post&lt;/a&gt; about matching innermost HTML elements written by Steven Levithan.</source>
          <target state="translated">有&lt;a href=&quot;http://blog.stevenlevithan.com/archives/match-innermost-html-element&quot;&gt;一篇&lt;/a&gt;关于匹配最里面的HTML元素的权威博客文章，这些元素由Steven Levithan撰写。</target>
        </trans-unit>
        <trans-unit id="a4e1c0773bdde0557a23f8bb7011bb1819bc446f" translate="yes" xml:space="preserve">
          <source>These constructs allow for a .NET regular expression to emulate a
  restricted PDA by essentially allowing simple versions of the stack
  operations: push, pop and empty. The simple operations are pretty much
  equivalent to increment, decrement and compare to zero respectively.
  This allows for the .NET regular expression engine to recognize a
  subset of the context-free languages, in particular the ones that only
  require a simple counter. This in turn allows for the non-traditional
  .NET regular expressions to recognize individual properly balanced
  constructs.</source>
          <target state="translated">这些构造允许.NET正则表达式通过允许堆栈操作的简单版本:push、pop和empo和empo空,来模拟受限的PDA。这些简单的操作分别相当于增量、减量和比对零。这使得.NET正则表达式引擎能够识别无上下文语言的子集,特别是那些只需要一个简单的计数器的语言。这又使非传统的.NET正则表达式引擎能够识别单独的适当平衡构造。</target>
        </trans-unit>
        <trans-unit id="83ac605b777d6f693f2b21254eb270d567a76728" translate="yes" xml:space="preserve">
          <source>They are good for XML / XHTML.</source>
          <target state="translated">它们对XML XHTML有好处。</target>
        </trans-unit>
        <trans-unit id="ea04181710e1449f97e72ce6888abc9705be60aa" translate="yes" xml:space="preserve">
          <source>This found the match:</source>
          <target state="translated">这下找到了匹配。</target>
        </trans-unit>
        <trans-unit id="bbe32d2a62e217c596147afa1c643ecf26c036ca" translate="yes" xml:space="preserve">
          <source>This is the regex I use (!) to match HTML tags:</source>
          <target state="translated">这是我用(!)来匹配HTML标签的regex。</target>
        </trans-unit>
        <trans-unit id="d8d8d6a39df8c08ee1ff1787d57aba7ddbd1bee3" translate="yes" xml:space="preserve">
          <source>This post is locked to prevent inappropriate edits to its content. The post looks exactly as it is supposed to look - there are no problems with its content. Please do not flag it for our attention.</source>
          <target state="translated">这个帖子被锁定,以防止对其内容进行不恰当的编辑。该帖子看起来和它应该的样子完全一样--内容没有问题。请不要将其标记为我们的关注点。</target>
        </trans-unit>
        <trans-unit id="20cb5dd39a077afa5b7e29efe1aa539dad4031b6" translate="yes" xml:space="preserve">
          <source>To test it deeply, I entered in the string auto-closing tags like:</source>
          <target state="translated">为了深入测试,我在字符串自动关闭标签中输入了这样的字符串自动关闭标签。</target>
        </trans-unit>
        <trans-unit id="102acb4ebe4f9295900af5f522c91830395377c0" translate="yes" xml:space="preserve">
          <source>Try:</source>
          <target state="translated">Try:</target>
        </trans-unit>
        <trans-unit id="a26ac4a7ee00f2bdbb69b3a7cd21e43c2ce7b858" translate="yes" xml:space="preserve">
          <source>Turing.sed</source>
          <target state="translated">Turing.sed</target>
        </trans-unit>
        <trans-unit id="a28f42522bb52c00621284c63c8ba53d7dfda10f" translate="yes" xml:space="preserve">
          <source>UNRELATED</source>
          <target state="translated">UNRELATED</target>
        </trans-unit>
        <trans-unit id="e8d3e730d87ce69a125b79edeeb87c6e997fdfb7" translate="yes" xml:space="preserve">
          <source>Understanding the pattern</source>
          <target state="translated">了解模式</target>
        </trans-unit>
        <trans-unit id="ada5ca9b4d7507ffcf81b9659577ff9cbe1d1ccf" translate="yes" xml:space="preserve">
          <source>Use the flags:</source>
          <target state="translated">用旗帜。</target>
        </trans-unit>
        <trans-unit id="24df9df6515abc09f921403db3f2eb9d44796515" translate="yes" xml:space="preserve">
          <source>W3C Link</source>
          <target state="translated">W3C链接</target>
        </trans-unit>
        <trans-unit id="01acb4cbe019ba6b6ce6e22bcd09638b1774d9c8" translate="yes" xml:space="preserve">
          <source>Whenever I need to quickly extract something from an HTML document, I use Tidy to convert it to XML and then use XPath or XSLT to get what I need.
In your case, something like this:</source>
          <target state="translated">每当我需要从一个HTML文档中快速提取一些东西时,我都会使用Tidy将其转换为XML,然后使用XPath或XSLT得到我所需要的东西。在你的情况下,就像这样。</target>
        </trans-unit>
        <trans-unit id="49b8872857a1e031d0578f467b1e399793cd9b96" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;(?&amp;lt;! ... )&lt;/code&gt; is (in Perl regexes) the negative look-behind. It reads &quot;a &amp;lt;, then a word, then anything that's not a &amp;gt;, the last of which may not be a /, followed by &amp;gt;&quot;.</source>
          <target state="translated">在Perl正则表达式中， &lt;code&gt;(?&amp;lt;! ... )&lt;/code&gt; 是负向后看。 它显示为&amp;ldquo;一个&amp;lt;，然后是一个单词，然后是不是&amp;gt;的任何内容，最后一个可能不是/，后跟&amp;gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d88b6a634389ee3ca966ecac67f70a5331dc8d96" translate="yes" xml:space="preserve">
          <source>While &lt;em&gt;arbitrary&lt;/em&gt; HTML with only a regex is impossible, it's sometimes appropriate to use them for parsing a &lt;em&gt;limited, known&lt;/em&gt; set of HTML.</source>
          <target state="translated">虽然只有正则表达式的&lt;em&gt;任意&lt;/em&gt; HTML是不可能的，但有时使用它们来解析&lt;em&gt;有限的已知&lt;/em&gt; HTML集合是适当的。</target>
        </trans-unit>
        <trans-unit id="b1bfbd9fe61d2ecc1e2a19393a476e7388bf0166" translate="yes" xml:space="preserve">
          <source>While the answers that you can't parse HTML with regexes are correct, they don't apply here. The OP just wants to parse one HTML tag with regexes, and that is something that can be done with a regular expression.</source>
          <target state="translated">虽然你不能用regexes解析HTML的答案是正确的,但在这里并不适用。OP只是想用regexes来解析一个HTML标签,而这是可以用正则表达式来完成的。</target>
        </trans-unit>
        <trans-unit id="93249a5d51a2ea1bf181a9d0b47641aa389e6924" translate="yes" xml:space="preserve">
          <source>With minor variations, it can cope with messy HTML... or convert the HTML -&amp;gt; XHTML first.</source>
          <target state="translated">只需稍作改动，它就可以处理杂乱的HTML ...或先转换HTML-&amp;gt; XHTML。</target>
        </trans-unit>
        <trans-unit id="86912b1a63422276d3fb2e364ae480edfb2fc529" translate="yes" xml:space="preserve">
          <source>Work out the Traveling Salesman Problem in O(log n) or less. If it's any more than that, you'll run out of RAM and the engine will hang.</source>
          <target state="translated">在O(log n)或更少的时间内解决旅行推销员问题。如果超过了这个时间,你的RAM就会耗尽,发动机就会挂掉。</target>
        </trans-unit>
        <trans-unit id="865301223dfe7d72c3b014a14a4edf685de64f15" translate="yes" xml:space="preserve">
          <source>Write HTML parser (homework)</source>
          <target state="translated">编写HTML解析器(家庭作业</target>
        </trans-unit>
        <trans-unit id="99b34e00427c7bc9e27cce20b1b8167ea540549e" translate="yes" xml:space="preserve">
          <source>You can live in their reality or take the red pill.</source>
          <target state="translated">你可以活在他们的现实中,也可以吃红丸。</target>
        </trans-unit>
        <trans-unit id="a6a9711b57d9a5eea84e16f2d7ce057f02584407" translate="yes" xml:space="preserve">
          <source>You can try this at &lt;a href=&quot;http://derekslager.com/blog/posts/2007/09/a-better-dotnet-regular-expression-tester.ashx&quot;&gt;A Better .NET Regular Expression Tester&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;http://derekslager.com/blog/posts/2007/09/a-better-dotnet-regular-expression-tester.ashx&quot;&gt;A Better .NET正则表达式测试&lt;/a&gt;器中尝试此操作。</target>
        </trans-unit>
        <trans-unit id="6b81d0ffa357688587ac76745c399587c1efb48a" translate="yes" xml:space="preserve">
          <source>You can't parse [X]HTML with regex. Because HTML can't be parsed by regex. Regex is not a tool that can be used to correctly parse HTML. As I have answered in HTML-and-regex questions here so many times before, the use of regex will not allow you to consume HTML. Regular expressions are a tool that is insufficiently sophisticated to understand the constructs employed by HTML. HTML is not a regular language and hence cannot be parsed by regular expressions. Regex queries are not equipped to break down HTML into its meaningful parts. so many times but it is not getting to me. Even enhanced irregular regular expressions as used by Perl are not up to the task of parsing HTML. You will never make me crack. HTML is a language of sufficient complexity that it cannot be parsed by regular expressions. Even Jon Skeet cannot parse HTML using regular expressions. Every time you attempt to parse HTML with regular expressions, the unholy child weeps the blood of virgins, and Russian hackers pwn your webapp. Parsing HTML with regex summons tainted souls into the realm of the living. HTML and regex go together like love, marriage, and ritual infanticide. The &amp;lt;center&amp;gt; cannot hold it is too late. The force of regex and HTML together in the same conceptual space will destroy your mind like so much watery putty. If you parse HTML with regex you are giving in to Them and their blasphemous ways which doom us all to inhuman toil for the One whose Name cannot be expressed in the Basic Multilingual Plane, he comes. HTML-plus-regexp will liquify the n​erves of the sentient whilst you observe, your psyche withering in the onslaught of horror. Rege̿̔̉x-based HTML parsers are the cancer that is killing StackOverflow</source>
          <target state="translated">您无法使用正则表达式解析[X] HTML。 因为正则表达式无法解析HTML。 正则表达式不是可用于正确解析HTML的工具。 正如我之前在这里多次回答HTML和Regex问题一样，使用正则表达式将不允许您使用HTML。 正则表达式是一种工具，不够复杂，无法理解HTML所采用的结构。 HTML不是常规语言，因此无法通过常规表达式进行解析。 正则表达式查询无法将HTML分解为有意义的部分。 有很多次了，但是没有得到我。 甚至Perl使用的增强的不规则正则表达式也无法完成HTML解析任务。 你永远不会让我崩溃。 HTML是一种足够复杂的语言，无法通过正则表达式进行解析。 甚至Jon Skeet也无法使用正则表达式解析HTML。 每次您尝试使用正则表达式解析HTML时，这个邪恶的孩子都会哭泣处女之血，俄罗斯黑客会伪装您的Web应用。 用正则表达式解析HTML会使灵魂陷入生活领域。 HTML和正则表达式可以像爱情，婚姻和仪式杀婴一样一起使用。 &amp;lt;center&amp;gt;无法容纳它为时已晚。 正则表达式和HTML共同作用于同一个概念空间中，将破坏您的思维，就像水腻腻一样。 如果您使用正则表达式来解析HTML，那么您就是在屈服于他们及其亵渎神明的方式，这使我们所有人都为不愿在基本多语言平面中表达其名字的人付出辛劳。 HTML + regexp将在您观察的同时液化知觉的神经，使您的心灵在恐怖的冲击中枯萎。 基于Rege̿̔̉x的HTML解析器是杀死StackOverflow的癌症</target>
        </trans-unit>
        <trans-unit id="d4cc5878bfc8de446a816e62a10b477bf7628da8" translate="yes" xml:space="preserve">
          <source>You want the first &lt;code&gt;&amp;gt;&lt;/code&gt; not preceded by a &lt;code&gt;/&lt;/code&gt;.  Look &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;here&lt;/a&gt; for details on how to do that.  It's referred to as negative lookbehind.</source>
          <target state="translated">您想要第一个 &lt;code&gt;&amp;gt;&lt;/code&gt; 而不以 &lt;code&gt;/&lt;/code&gt; 开头。 &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;在这里&lt;/a&gt;查看有关如何执行此操作的详细信息。 这被称为否定性回溯。</target>
        </trans-unit>
        <trans-unit id="0f094d4f9e70b554306ad025350bec42add64291" translate="yes" xml:space="preserve">
          <source>a&lt;sup&gt;n&lt;/sup&gt;ba&lt;sup&gt;n&lt;/sup&gt;ba&lt;sup&gt;n&lt;/sup&gt; which is not regular and not even context free, can be matched with &lt;code&gt;^(a+)b\1b\1$&lt;/code&gt;</source>
          <target state="translated">不是正规的，甚至不是上下文无关的，可以与 &lt;code&gt;^(a+)b\1b\1$&lt;/code&gt; 匹配</target>
        </trans-unit>
        <trans-unit id="7f7db1a41076f29a8bc513a82d4eeb79c22c4b29" translate="yes" xml:space="preserve">
          <source>according to the specific implementation of the RegExp engine, recursion may have a limit in the &lt;strong&gt;number of nested patterns parsed&lt;/strong&gt;, but it depends on the language used</source>
          <target state="translated">根据RegExp引擎的具体实现，递归&lt;strong&gt;解析的嵌套模式数量&lt;/strong&gt;可能有所限制，但这取决于所使用的语言</target>
        </trans-unit>
        <trans-unit id="c4d4e32662c88b8424d1c0984fceefe61e4e23a5" translate="yes" xml:space="preserve">
          <source>again, zero or more whitespaces</source>
          <target state="translated">再次,零位或更多的空格</target>
        </trans-unit>
        <trans-unit id="416344de81011e88293f4de90995d2f4eb4cfe70" translate="yes" xml:space="preserve">
          <source>ain, the song of re̸gular exp​re&lt;strike&gt;ssion parsing &lt;/strike&gt;will exti</source>
          <target state="translated">因此，常规表达式&lt;strike&gt;解析&lt;/strike&gt;的歌曲将会消失</target>
        </trans-unit>
        <trans-unit id="dac38d2a71b13841b4f7fa59c2cbb41d8f4fe7c5" translate="yes" xml:space="preserve">
          <source>although corrupted (x)HTML does not drive into severe errors, it is not &lt;em&gt;sanitized&lt;/em&gt;.</source>
          <target state="translated">尽管损坏的（x）HTML不会导致严重错误，但尚未&lt;em&gt;清理&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2c0c9e8369c247831710c647b81dda3b5b625b1" translate="yes" xml:space="preserve">
          <source>although it actually came out like this:</source>
          <target state="translated">虽然它实际上是这样出来的。</target>
        </trans-unit>
        <trans-unit id="b91f3e1f4b4ae9ba5a969df90fc854016c1cfedf" translate="yes" xml:space="preserve">
          <source>and the dread realm of c͒ͪo͛ͫrrupt entities (like SGML entities, but</source>
          <target state="translated">和可怕的领域c͒ͪoͪoͫ实体(就像SGML实体一样,但是</target>
        </trans-unit>
        <trans-unit id="789d3b546d80c656a137d6a2dae501ef948c9936" translate="yes" xml:space="preserve">
          <source>attributes containing single quotes when the delimiter is a double quote and vice versa</source>
          <target state="translated">当分界符为双引号时,包含单引号的属性,反之亦然。</target>
        </trans-unit>
        <trans-unit id="83049ba02543c5468a7092d704e728351f015ce0" translate="yes" xml:space="preserve">
          <source>attributes which value is bound either into &lt;strong&gt;single quotes&lt;/strong&gt; or into &lt;strong&gt;double quotes&lt;/strong&gt;</source>
          <target state="translated">值绑定到&lt;strong&gt;单引号&lt;/strong&gt;或&lt;strong&gt;双引号的&lt;/strong&gt;属性</target>
        </trans-unit>
        <trans-unit id="872af077bba705c60415b90068389b0d9ae136b2" translate="yes" xml:space="preserve">
          <source>ch between this world</source>
          <target state="translated">世间</target>
        </trans-unit>
        <trans-unit id="b1ccf8aca583f64c44e6498a0abc71300cee934c" translate="yes" xml:space="preserve">
          <source>d of ceaseless screaming, he comes&lt;strike&gt;, the pestilent sl&lt;/strike&gt;ithy regex-infection wil​&lt;b&gt;l devour your HT&lt;/b&gt;​ML parser, application and existence for all time like Visual Basic only worse</source>
          <target state="translated">由于不断尖叫，他来了&lt;strike&gt;，瘟疫&lt;/strike&gt;般的正则表达式感染只会像Visual Basic那样&lt;b&gt;吞噬您的HT&lt;/b&gt; ML解析器，应用程序和存在，只会变得更糟</target>
        </trans-unit>
        <trans-unit id="fad2a06a8e728d64f3eff45851e3b600bd2bf437" translate="yes" xml:space="preserve">
          <source>dear lord help us how can anyone survive this scourge</source>
          <target state="translated">主啊,救救救命啊,怎么会有人在这场灾难中活下来呢</target>
        </trans-unit>
        <trans-unit id="5b52a1cb49381cdd269797b153d0660ee9133944" translate="yes" xml:space="preserve">
          <source>do not fi</source>
          <target state="translated">不要</target>
        </trans-unit>
        <trans-unit id="b9dea77ba556480de7588671f4a3d44f039e5d2e" translate="yes" xml:space="preserve">
          <source>e pon̷y he come</source>
          <target state="translated">他来了</target>
        </trans-unit>
        <trans-unit id="09cd68a2a77b22a312dded612dd0d9988685189f" translate="yes" xml:space="preserve">
          <source>es</source>
          <target state="translated">es</target>
        </trans-unit>
        <trans-unit id="707cd90a4f77675613cc63dfa16b29bedcf7d2e6" translate="yes" xml:space="preserve">
          <source>es al</source>
          <target state="translated">es al</target>
        </trans-unit>
        <trans-unit id="16829609b87ebecff7cb40016842539439ef333f" translate="yes" xml:space="preserve">
          <source>e̠̅s&lt;code&gt; ͎a̧͈͖r̽̾̈́͒͑e&lt;/code&gt; n&lt;b&gt;​ot rè̑ͧ̌aͨl̘̝̙̃ͤ͂̾̆ ZA̡͊͠͝LGΌ ISͮ̂҉̯͈͕̹̘̱ T&lt;/b&gt;O͇̹̺ͅƝ̴ȳ̳ TH̘&lt;b&gt;Ë͖́̉ ͠P̯͍̭O̚​N̐Y̡ H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝&lt;/b&gt;S̨̥̫͎̭ͯ̿̔̀ͅ</source>
          <target state="translated">e̠̅ş͈͖a̧͈͖r̽̾̈́͒͑en &lt;b&gt;ot r&amp;egrave;̑ͧ̌aͨl̘̝̙̃ͤ͂̾̆ZA̡͊͠͝LGΌISͮ̂҉̯͈͕̹̘̱ T&lt;/b&gt; &lt;b&gt;O͇̹̺ͅƝ̴ȳ̳TH̘&amp;Euml;͖́̉ P͖̈́̉O̚N̚Y̐ H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝&lt;/b&gt; S̨̥̫͎̭ͯ̿̔̀ͅ</target>
        </trans-unit>
        <trans-unit id="0a971adf10fafe8fe3d724d80e0beaa10f271291" translate="yes" xml:space="preserve">
          <source>f the lie​&lt;b&gt;s of Man ALL IS LOŚ͖̩͇̗̪̏̈́T A&lt;/b&gt;</source>
          <target state="translated">如果&lt;b&gt;是人类&lt;/b&gt;的谎言</target>
        </trans-unit>
        <trans-unit id="6c0c535eae65a352e21a597046b9c71062ef7e32" translate="yes" xml:space="preserve">
          <source>he an​*̶͑̾̾​̅ͫ͏̙̤g͇̫͛͆̾ͫ̑͆l͖͉̗̩̳̟̍ͫͥͨ</source>
          <target state="translated">he an*̶͑̾̾̅ͫ͏̙̤g͇̫͛͆̾ͫ̑͆l͖͖͉̗̩̳̟̍ͫͥͨ</target>
        </trans-unit>
        <trans-unit id="21f7c212343db1452bf1005fe7bec61697f3efef" translate="yes" xml:space="preserve">
          <source>he comes he com</source>
          <target state="translated">他来了,他来了,他来了</target>
        </trans-unit>
        <trans-unit id="c1b6858eae6b82f5a342bbfcd9d5505ae8d8b304" translate="yes" xml:space="preserve">
          <source>he f&lt;code&gt;inal snuf&lt;/code&gt;fing o</source>
          <target state="translated">他 &lt;code&gt;inal snuf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cba0af89feed0e8e942fec8ed4c10695745c757d" translate="yes" xml:space="preserve">
          <source>here comes the fun: the \4 part is a &lt;strong&gt;backreference operator&lt;/strong&gt;, which refers to a sub-expression defined before in the pattern, in this case, I am referring to the fourth sub-expression, which is the first attribute delimiter found</source>
          <target state="translated">有趣的是：\ 4部分是&lt;strong&gt;向后引用运算符&lt;/strong&gt; ，它引用模式中之前定义的子表达式，在这种情况下，我指的是第四个子表达式，这是找到的第一个属性定界符</target>
        </trans-unit>
        <trans-unit id="a8ec278d2e709b878840d59f0dc4611cd1bb49d5" translate="yes" xml:space="preserve">
          <source>it is too late it is too late we cannot be saved</source>
          <target state="translated">来不及了,来不及了,来不及了,救不了了</target>
        </trans-unit>
        <trans-unit id="a38cb8457436d320aa6e6a447ea6ac270b0eb2aa" translate="yes" xml:space="preserve">
          <source>l MY FAC</source>
          <target state="translated">我的面孔</target>
        </trans-unit>
        <trans-unit id="eb912827300bfa09ffaae9a61a04131d928f17d2" translate="yes" xml:space="preserve">
          <source>more corrupt) a mere glimp</source>
          <target state="translated">浮光掠影</target>
        </trans-unit>
        <trans-unit id="5a4bedc53d646eb4f152665ce04f194f119d1230" translate="yes" xml:space="preserve">
          <source>more than one attribute</source>
          <target state="translated">多于一个属性</target>
        </trans-unit>
        <trans-unit id="0f0f39e938eb9a6927af1fd3169cbf5dc39c8c05" translate="yes" xml:space="preserve">
          <source>nto a w</source>
          <target state="translated">变成了</target>
        </trans-unit>
        <trans-unit id="f676ebbcb5a6de68fd4cd64947f2f073b0bc183b" translate="yes" xml:space="preserve">
          <source>one attribute</source>
          <target state="translated">一性</target>
        </trans-unit>
        <trans-unit id="b63094eb585e278a2a9faac15421a9c3b8a73f5d" translate="yes" xml:space="preserve">
          <source>one or more whitespaces \s+</source>
          <target state="translated">一个或多个空格+</target>
        </trans-unit>
        <trans-unit id="a4f0099e46341d0fc7c083fc51657b45fb1eb61a" translate="yes" xml:space="preserve">
          <source>or just combine if and if not.</source>
          <target state="translated">或只是结合,如果和如果不结合。</target>
        </trans-unit>
        <trans-unit id="90255a902e3a09b87ea94d0074d32fa53f1e3df0" translate="yes" xml:space="preserve">
          <source>orl</source>
          <target state="translated">orl</target>
        </trans-unit>
        <trans-unit id="5beefb69787012b543ff81b246c6096ef31b16cb" translate="yes" xml:space="preserve">
          <source>rogrammer's consciousness i</source>
          <target state="translated">程式设计者的意识</target>
        </trans-unit>
        <trans-unit id="a529326c3bc272f1c87faf0fc168c3f2b888e5e1" translate="yes" xml:space="preserve">
          <source>s he c̶̮om&lt;strike&gt;es he co&lt;/strike&gt;&lt;b&gt;&lt;strike&gt;me&lt;/strike&gt;s t&lt;i&gt;he&lt;/i&gt; ich​&lt;/b&gt;or permeat</source>
          <target state="translated">他认为自己富有&lt;b&gt;或&lt;/b&gt;渗透</target>
        </trans-unit>
        <trans-unit id="cdc9e9914e559a22d8c2863df88dcc0affd254bb" translate="yes" xml:space="preserve">
          <source>se of the world of reg​&lt;b&gt;ex parsers for HTML will ins&lt;/b&gt;​tantly transport a p</source>
          <target state="translated">&lt;b&gt;HTML的解析器&lt;/b&gt;世界本身&lt;b&gt;将立即&lt;/b&gt;传输ap</target>
        </trans-unit>
        <trans-unit id="fcd31f61fdd2492a68c910cd84210be08c96a97c" translate="yes" xml:space="preserve">
          <source>stro҉ying all enli̍̈́̂̈́ghtenment, HTML tags &lt;b&gt;lea͠ki̧n͘g fr̶ǫm ̡yo​͟ur eye͢s̸ ̛l̕ik͏e liq&lt;/b&gt;​uid p</source>
          <target state="translated">破坏所有的环境，HTML标记&lt;b&gt;使您的眼睛失去生命。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="13cecb0242cc098120804e419e2c0898d7c5f3d9" translate="yes" xml:space="preserve">
          <source>the &quot;=&quot; symbol</source>
          <target state="translated">&quot;=&quot;符号</target>
        </trans-unit>
        <trans-unit id="ef1ddac3121c15757add5489d19c276fcda4e43f" translate="yes" xml:space="preserve">
          <source>the attribute sub-expression ends here, with the specification of zero or more possible occurrences, given by the asterisk.</source>
          <target state="translated">属性子表达式到此结束,用星号给出的零或更多的可能出现的规范。</target>
        </trans-unit>
        <trans-unit id="9fb82ad748ee217a3d8676ebffa5f977ad107e1b" translate="yes" xml:space="preserve">
          <source>the delimiter of the attribute value, a single or double quote ('|&quot;). In the pattern, the single quote is escaped because it coincides with the PHP string delimiter. This sub-expression is captured with the parentheses so it can be referenced again to parse the closure of the attribute, that's why it is very important.</source>
          <target state="translated">&quot;).In the pattern,the single quote is escaped because it coincides with the PHP string delimiter.This sub-expression is captured with the parentheses so it can be referenced again to parse the closure of the attribute,that's why it is very important.</target>
        </trans-unit>
        <trans-unit id="bf47c953b6d49b59cea7ef6e949bcd244312ad84" translate="yes" xml:space="preserve">
          <source>the first sub-expression (\w+) matches the tag name</source>
          <target state="translated">第一个子表达式(\w+)与标签名称相匹配的</target>
        </trans-unit>
        <trans-unit id="8ff32fe1a0c4d2f2143244e76a1ea25a84d0a50e" translate="yes" xml:space="preserve">
          <source>the name of the attribute (\w+)</source>
          <target state="translated">属性名称(w+)</target>
        </trans-unit>
        <trans-unit id="a63f6d3ba68d8159445680753d6b7dcfea330647" translate="yes" xml:space="preserve">
          <source>the second sub-expression contains the pattern of an attribute. It is composed by:</source>
          <target state="translated">第二个子表达式包含一个属性的模式。它是由以下内容组成的:</target>
        </trans-unit>
        <trans-unit id="98c53a01bc3d612ea14d5657a8251e38b47274e3" translate="yes" xml:space="preserve">
          <source>the trangession of a chi͡ld ensures regex will consume all living tissue (except for HTML which it cannot, as previously prophesied)</source>
          <target state="translated">chi͡ld的trangession确保regex将消耗所有的活体组织(除了HTML,它不能像以前预言的那样,除了HTML之外)。</target>
        </trans-unit>
        <trans-unit id="fcae9afa44c8d009bc39cd1558b5bcceb178f9f3" translate="yes" xml:space="preserve">
          <source>the value of the attribute, matched by &lt;em&gt;almost&lt;/em&gt; anything: (.*?); in this specific syntax, using the &lt;strong&gt;greedy match&lt;/strong&gt; (the question mark after the asterisk) the RegExp engine enables a &quot;look-ahead&quot;-like operator, which matches anything but what follows this sub-expression</source>
          <target state="translated">属性的值， &lt;em&gt;几乎与&lt;/em&gt;所有内容匹配：（。*？）; 在这种特定语法中，使用&lt;strong&gt;贪婪匹配&lt;/strong&gt; （星号后的问号），RegExp引擎启用了类似于&amp;ldquo;先行查找&amp;rdquo;的运算符，该运算符除了此子表达式之后的内容之外，都匹配</target>
        </trans-unit>
        <trans-unit id="e8cdc833b2aa479524c91f0c0770ca55cab15dbc" translate="yes" xml:space="preserve">
          <source>using rege</source>
          <target state="translated">叠加</target>
        </trans-unit>
        <trans-unit id="05316c08fdd253a1c9a83c01ccb3802a454fbc33" translate="yes" xml:space="preserve">
          <source>using regex to parse HTML has doomed humanity to an eternity of dread torture and security holes</source>
          <target state="translated">使用regex来解析HTML,注定了人类将永远受到可怕的折磨和安全漏洞的折磨</target>
        </trans-unit>
        <trans-unit id="ab44de7440b2ebdde8558b36f16d5f922c19d2d5" translate="yes" xml:space="preserve">
          <source>x as a tool to process HTML establishes a brea</source>
          <target state="translated">x作为处理HTML的工具,建立了一个新的HTML处理工具。</target>
        </trans-unit>
        <trans-unit id="7f524dcbd593bece540d29aea0353dc495423551" translate="yes" xml:space="preserve">
          <source>zero or more whitespaces \s*</source>
          <target state="translated">零或更多空格*</target>
        </trans-unit>
        <trans-unit id="9bdd5426b4b4fdd866ac9851215bf267b6e6df44" translate="yes" xml:space="preserve">
          <source>zero or more whitespaces \s* (it is possible or not, leaving blanks here)</source>
          <target state="translated">0或更多的空白处</target>
        </trans-unit>
        <trans-unit id="1b249f9d22bd1bda62f373b04cdb08126b054557" translate="yes" xml:space="preserve">
          <source>​ght h&lt;b&gt;e com̡e̶s, ̕h̵i&lt;/b&gt;​s un̨ho͞ly radiańcé de</source>
          <target state="translated">&lt;b&gt;ghh ecom̶e̶，̕h̵i&lt;/b&gt;不幸的弧度</target>
        </trans-unit>
        <trans-unit id="87484f6cbcd5c18c6c4b093d13bc9f9ee13c577f" translate="yes" xml:space="preserve">
          <source>​nguish the voices of mor​&lt;b&gt;tal man from the sp&lt;/b&gt;​here I can see it can you see ̲͚̖͔̙î̩́t̲͎̩̱͔́̋̀ it is beautiful t​</source>
          <target state="translated">从那儿刺探凡人的声音， &lt;b&gt;在&lt;/b&gt;这里我可以看到它，你可以看到它很美丽吗？</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
