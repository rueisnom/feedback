<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/1732348">
    <body>
      <group id="1732348">
        <trans-unit id="ccd2e00de6a7833dd11d2079f5b5b099a6e04da7" translate="yes" xml:space="preserve">
          <source>&quot;unpretty&quot; attributes with a space before the &quot;=&quot; symbol, after it and both before and after it.</source>
          <target state="translated">&quot;некрасивые&quot; атрибуты с пробелом перед символом &quot;=&quot;,после него и как до,так и после него.</target>
        </trans-unit>
        <trans-unit id="392ad88b0cb34d87fa7d4457a6637b91ceafc10b" translate="yes" xml:space="preserve">
          <source>&amp;lt;br&amp;gt;</source>
          <target state="translated">&amp;lt;br&amp;gt;</target>
        </trans-unit>
        <trans-unit id="50709f0c2fc769b8029465696613cd45319835fb" translate="yes" xml:space="preserve">
          <source>&amp;lt;br/&amp;gt;</source>
          <target state="translated">&amp;lt;br/&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ecfb18e3fd89ce3fed2c8046ff8dc43d3ee45bbf" translate="yes" xml:space="preserve">
          <source>&amp;lt;hr /&amp;gt;</source>
          <target state="translated">&amp;lt;ч /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3239efc545dfa4f75dc0905c388a28a61c34c974" translate="yes" xml:space="preserve">
          <source>(Take care, in that note I wrongly used the &quot;m&quot; modifier; it should be erased, notwithstanding it is discarded by the RegExp engine, since no ^ or $ anchorage was used).</source>
          <target state="translated">(Будьте осторожны,в этой заметке я неправильно использовал модификатор &quot;m&quot;;его следует удалить,несмотря на то,что он отбрасывается движком RegExp,так как не использовался ^ или $ якорь).</target>
        </trans-unit>
        <trans-unit id="a8662e799cce40f7a10db5f20413cbc30727a2b7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://pastebin.com/hzYazFVb&quot;&gt;regex to tokenize an xml&lt;/a&gt; or &lt;a href=&quot;http://pastebin.com/HUmPzP5M&quot;&gt;the full plain regex&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://pastebin.com/hzYazFVb&quot;&gt;регулярное выражение для токенизации XML&lt;/a&gt; или &lt;a href=&quot;http://pastebin.com/HUmPzP5M&quot;&gt;полное простое регулярное выражение&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="832bcd8f1b94df226af144e70783a66198bd3e61" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;simplehtmldom&lt;/a&gt; is good, but I found it a bit buggy, and it is is quite memory heavy [Will crash on large pages.]</source>
          <target state="translated">&lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;simplehtmldom&lt;/a&gt; - это хорошо, но я обнаружил, что он немного глючит, и это довольно много памяти [вылетает на больших страницах.]</target>
        </trans-unit>
        <trans-unit id="0fb3c21dc29172e2446bc3eb1b052ae2cf60faea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;LL I​S L&lt;/b&gt;OST th</source>
          <target state="translated">&lt;b&gt;LL I SL&lt;/b&gt; OST th</target>
        </trans-unit>
        <trans-unit id="6e79435135c0746fa05560a3972c6d46478d0ea8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Locked&lt;/b&gt;. There are &lt;a href=&quot;/help/locked-posts&quot;&gt;disputes about this answer&amp;rsquo;s content&lt;/a&gt; being resolved at this time. It is not currently accepting new interactions.</source>
          <target state="translated">&lt;b&gt;Заблокирован&lt;/b&gt; В настоящее время возникают &lt;a href=&quot;/help/locked-posts&quot;&gt;разногласия по поводу содержания этого ответа&lt;/a&gt; . В настоящее время он не принимает новых взаимодействий.</target>
        </trans-unit>
        <trans-unit id="716a4e892e498fc58500550d231fb8d0142d36b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;O​O N&lt;/b&gt;&amp;Theta; stop t</source>
          <target state="translated">&lt;b&gt;O ON&lt;/b&gt; &amp;Theta; остановить</target>
        </trans-unit>
        <trans-unit id="1c101f468dfe424c6604dac4e8ce77d6d85f2f3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;: closing &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; : закрытие &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b62a075d15f1adc779c6d1b0fe159e3b547852c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;: starting character</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; : начальный символ</target>
        </trans-unit>
        <trans-unit id="edd69111dcbfaec727aaaeb23b7029011a65191a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?&amp;lt;-group&amp;gt;)&lt;/code&gt; - pops the top most capture with the name group off the
  capture stack.</source>
          <target state="translated">&lt;code&gt;(?&amp;lt;-group&amp;gt;)&lt;/code&gt; - выводит самый верхний захват с группой имен из стека захвата.</target>
        </trans-unit>
        <trans-unit id="d45de3e20cd061b6edb60d843a32a44f30527fa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?&amp;lt;group&amp;gt;)&lt;/code&gt; - pushes the captured result on the capture stack with
  the name group.</source>
          <target state="translated">&lt;code&gt;(?&amp;lt;group&amp;gt;)&lt;/code&gt; - помещает захваченный результат в стек захвата вместе с группой имен.</target>
        </trans-unit>
        <trans-unit id="e8253025aa1e0fb8ada068fc00792760bbe3d0c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?(group)yes|no)&lt;/code&gt; - matches the yes part if there exists a group
  with the name group otherwise matches no part.</source>
          <target state="translated">&lt;code&gt;(?(group)yes|no)&lt;/code&gt; - соответствует части yes, если существует группа с именем группы, в противном случае не соответствует ни одной части.</target>
        </trans-unit>
        <trans-unit id="56885e7cfe6e3708ab901dd138fd887bd58c790d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(\w+)&lt;/code&gt;: tags can contain letters and numbers (h1). Well, &lt;code&gt;\w&lt;/code&gt; also matches '_', but it does not hurt I guess. If curious use ([a-zA-Z0-9]+) instead.</source>
          <target state="translated">&lt;code&gt;(\w+)&lt;/code&gt; : теги могут содержать буквы и цифры (h1). Ну, &lt;code&gt;\w&lt;/code&gt; также соответствует '_', но это не больно, я думаю. Если любопытно, используйте ([a-zA-Z0-9] +) вместо этого.</target>
        </trans-unit>
        <trans-unit id="27378fcce2128b2795fafae4f93ebe3ba7c8ec5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[^/&amp;gt;]*&lt;/code&gt;: anything except &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; until closing &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[^/&amp;gt;]*&lt;/code&gt; : все, кроме &lt;code&gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;/&lt;/code&gt; до закрытия &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0cdd6edcac3875daf87e4d7a216db2702e63b2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s*&lt;/code&gt;: it may have whitespaces before tag name (ugly but possible).</source>
          <target state="translated">&lt;code&gt;\s*&lt;/code&gt; : перед именем тега могут быть пробелы (безобразно, но возможно).</target>
        </trans-unit>
        <trans-unit id="beb0d3eebbac4ba7a6e556f1885908f5a8b44a54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;It is a .NET code library that allows
  you to parse &quot;out of the web&quot; HTML
  files. The parser is very tolerant
  with &quot;real world&quot; malformed HTML.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Это библиотека кода .NET, которая позволяет анализировать HTML-файлы &amp;laquo;из Интернета&amp;raquo;.&lt;/em&gt; &lt;em&gt;Синтаксический анализатор очень терпим с искаженным &amp;laquo;реальным миром&amp;raquo; HTML.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c6e323e6d7b2404e267e45fec8933c5f11df6f5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;/EDIT&amp;gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;lt;/EDIT&amp;gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4eeca80a434106c9c5953d86b5711b944275e484" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;EDIT&amp;gt;&lt;/strong&gt;
I forgot that the question from the user was to avoid the parsing of self-closing tags.
In this case the pattern is simpler, turning into this:</source>
          <target state="translated">&lt;strong&gt;&amp;lt;EDIT&amp;gt;&lt;/strong&gt; Я забыл, что вопрос от пользователя состоял в том, чтобы избежать анализа самозакрывающихся тегов. В этом случае шаблон проще, превращаясь в это:</target>
        </trans-unit>
        <trans-unit id="bfe34076d009a4ea9a539e48cf63cf2660a68659" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;.NET Regular Expression Engine&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Механизм регулярных выражений .NET&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="84c7b23e39a82950709baca989fe9cf94e0ac7c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caveat&lt;/strong&gt;: I should note that this regex still breaks down in the presence of CDATA blocks, comments, and script and style elements. Good news is, you can get rid of those using a regex...</source>
          <target state="translated">&lt;strong&gt;Предостережение&lt;/strong&gt; : я должен отметить, что это регулярное выражение все еще не работает при наличии блоков CDATA, комментариев, элементов сценария и стиля. Хорошая новость в том, что вы можете избавиться от тех, кто использует регулярные выражения ...</target>
        </trans-unit>
        <trans-unit id="45fc82d5456ed3961e342820361d39292947a88e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer&lt;/strong&gt;: use a parser if you have the option. That said...</source>
          <target state="translated">&lt;strong&gt;Отказ от ответственности&lt;/strong&gt; : используйте парсер, если у вас есть возможность. Это сказал ...</target>
        </trans-unit>
        <trans-unit id="28fb9f9055a519baf77c8a0c677593f8a1967066" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Moderator's Note&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Заметка модератора&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2412b65f77f0efaca93518e50a127a0ceec7ed35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To downvoters:&lt;/strong&gt; This is working code from an actual product. I doubt anyone reading this page will get the impression that it is socially acceptable to use regexes on HTML.</source>
          <target state="translated">&lt;strong&gt;Для downvoters:&lt;/strong&gt; это рабочий код из реального продукта. Я сомневаюсь, что у любого, кто читает эту страницу, сложится впечатление, что в HTML приемлемо использовать регулярные выражения.</target>
        </trans-unit>
        <trans-unit id="b00d0a9c4b3ab55c1726cc4d54869fbac2f0d000" translate="yes" xml:space="preserve">
          <source>A RegExp-agnostic colleague notified me this discussion, which is not certainly the first on the web about this old and hot topic.</source>
          <target state="translated">Коллега по диагностике RegExp уведомил меня об этой дискуссии,которая,безусловно,не первая в Интернете на эту старую и горячую тему.</target>
        </trans-unit>
        <trans-unit id="e3504a93684584a9ba5c4e8dff8fbf39739ee1de" translate="yes" xml:space="preserve">
          <source>A simple regex like &lt;code&gt;&amp;lt;([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; is usually good enough, in cases such as those I just mentioned. It's a naive solution, all things considered, but it does correctly allow unencoded &lt;code&gt;&amp;gt;&lt;/code&gt; symbols in attribute values. If you're looking for, e.g., a &lt;code&gt;table&lt;/code&gt; tag, you could adapt it as &lt;code&gt;&amp;lt;/?table\b([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Простое регулярное выражение типа &lt;code&gt;&amp;lt;([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; обычно достаточно хорошо в случаях, подобных тем, которые я только что упомянул. Это наивное решение, учитывая все обстоятельства, но оно правильно разрешает некодированные символы &lt;code&gt;&amp;gt;&lt;/code&gt; в значениях атрибутов. Если вы ищете, например, &lt;code&gt;table&lt;/code&gt; тег, вы можете изменить его как &lt;code&gt;&amp;lt;/?table\b([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="a039c1c26fe0f237cd4c396efb45b67c58a5e34d" translate="yes" xml:space="preserve">
          <source>About the question of the RegExp methods to parse (x)HTML, the answer to all of the ones who spoke about some limits is: you have not been trained enough to rule the force of this powerful weapon, since &lt;strong&gt;NOBODY&lt;/strong&gt; here spoke about &lt;strong&gt;recursion&lt;/strong&gt;.</source>
          <target state="translated">На вопрос о методах RegExp для синтаксического анализа (x) HTML ответ на все те, кто говорил о некоторых ограничениях: вы недостаточно обучены, чтобы управлять силой этого мощного оружия, так как здесь &lt;strong&gt;никто не&lt;/strong&gt; говорил о &lt;strong&gt;рекурсии&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="489cc8d83fc1a950af1e4ec274f14d5d31165bbc" translate="yes" xml:space="preserve">
          <source>After reading some posts, the first thing I did was looking for the &quot;?R&quot; string in this thread. The second was to search about &quot;recursion&quot;.</source>
          <target state="translated">После прочтения нескольких сообщений,первое,что я сделал,это искал строку &quot;?R&quot; в этой теме.Второе-искать о &quot;рекурсии&quot;.</target>
        </trans-unit>
        <trans-unit id="a3a75c0c6fe92ec2cda26b61e50e68af1ff0a32b" translate="yes" xml:space="preserve">
          <source>Against my expectation this got some upvotes, so I'll suggest some better regular expressions:</source>
          <target state="translated">Вопреки моим ожиданиям,это вызвало некоторый рост голосов,так что я предложу несколько лучших регулярных выражений:</target>
        </trans-unit>
        <trans-unit id="d71dc9d3aa06d9d64e4ed0039016360a328e4c22" translate="yes" xml:space="preserve">
          <source>Almost there - just divide the whole thing by zero. Easy-peasy.</source>
          <target state="translated">Почти пришли-просто разделите все на ноль.Легко.</target>
        </trans-unit>
        <trans-unit id="fee1e23317ba16ad1ccae9d12e0a015990432476" translate="yes" xml:space="preserve">
          <source>Although it's not suitable and effective to use regular expressions for that purpose sometimes regular expressions provide quick solutions for simple match problems and in my view it's not that horrbile to use regular expressions for trivial works.</source>
          <target state="translated">Хотя использование регулярных выражений для этой цели не подходит и неэффективно,иногда регулярные выражения дают быстрые решения для простых проблем с совпадением,и,на мой взгляд,использование регулярных выражений для тривиальных работ не так уж и ужасно.</target>
        </trans-unit>
        <trans-unit id="a430cebe8e1c6b5026f2667ef4e684539ee6d594" translate="yes" xml:space="preserve">
          <source>And to fellows who underestimate regular expressions saying they are only as powerful as regular languages:</source>
          <target state="translated">И для тех,кто недооценивает регулярные выражения,говоря,что они только такие же сильные,как регулярные языки:</target>
        </trans-unit>
        <trans-unit id="1b4c5b09ea0d4dcf09356da001dd69ed7c2e026c" translate="yes" xml:space="preserve">
          <source>Another one to try is my &lt;a href=&quot;http://github.com/siteroller/domparser&quot;&gt;DOMParser&lt;/a&gt; which is very light on resources and I've been using happily for a while. Simple to learn &amp;amp; powerful.</source>
          <target state="translated">Еще один &lt;a href=&quot;http://github.com/siteroller/domparser&quot;&gt;пример&lt;/a&gt; - мой DOMParser, который очень лёгок на ресурсах, и какое-то время я с удовольствием его использовал. Простой в освоении и мощный.</target>
        </trans-unit>
        <trans-unit id="0e63871b8e67058c915c0916cf65a319929856cc" translate="yes" xml:space="preserve">
          <source>Anyhow it is only a RegExp pattern, but it discloses the possibility to develop of a lot of powerful implementations.</source>
          <target state="translated">Так или иначе,это всего лишь шаблон RegExp,но он раскрывает возможность разработки множества мощных реализаций.</target>
        </trans-unit>
        <trans-unit id="7bc89deb2a5a51e26b543874949bc6016b7dee8c" translate="yes" xml:space="preserve">
          <source>As described above properly balanced constructs cannot be described by
  a regular expression. However, the .NET regular expression engine
  provides a few constructs that allow balanced constructs to be
  recognized.</source>
          <target state="translated">Как было описано выше,правильно сбалансированные конструкции не могут быть описаны регулярным выражением.Однако,механизм регулярных выражений .NET предоставляет несколько конструкций,которые позволяют распознавать сбалансированные конструкции.</target>
        </trans-unit>
        <trans-unit id="23f8839aa08cf9ff361179fc788965803d7b92e4" translate="yes" xml:space="preserve">
          <source>As many people have already pointed out, HTML is not a regular language which can make it very difficult to parse. My solution to this is to turn it into a regular language using a tidy program and then to use an XML parser to consume the results. There are a lot of good options for this. My program is written using Java with the &lt;a href=&quot;http://jtidy.sourceforge.net/&quot;&gt;jtidy&lt;/a&gt; library to turn the HTML into XML and then Jaxen to xpath into the result.</source>
          <target state="translated">Как уже указывалось многими людьми, HTML не является обычным языком, который может сильно затруднить анализ. Мое решение этого состоит в том, чтобы превратить его в обычный язык с помощью аккуратной программы, а затем использовать синтаксический анализатор XML для получения результатов. Есть много хороших вариантов для этого. Моя программа написана с использованием Java с библиотекой &lt;a href=&quot;http://jtidy.sourceforge.net/&quot;&gt;jtidy,&lt;/a&gt; чтобы превратить HTML в XML, а затем Jaxen в xpath в результат.</target>
        </trans-unit>
        <trans-unit id="6ec0c091ef78305814e216017d3186d039895a12" translate="yes" xml:space="preserve">
          <source>At the end of the day, use the most appropriate tool for the job, even in the cases when that tool happens to be a regex.</source>
          <target state="translated">В конце концов,используйте наиболее подходящий для работы инструмент,даже в тех случаях,когда этот инструмент является регексом.</target>
        </trans-unit>
        <trans-unit id="ee0292f6ec302ec831d0a3d73bf3ba082b945c21" translate="yes" xml:space="preserve">
          <source>Backreferencing &lt;a href=&quot;http://en.wiktionary.org/wiki/FTW&quot;&gt;FTW&lt;/a&gt;!</source>
          <target state="translated">Обратные &lt;a href=&quot;http://en.wiktionary.org/wiki/FTW&quot;&gt;ссылки FTW&lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="e76721be008ac232fc787ac592a249a6a0b4bb86" translate="yes" xml:space="preserve">
          <source>Based on that you can create a pretty good regexp to handle things like stripping tags.</source>
          <target state="translated">Основываясь на этом,вы можете создать довольно неплохой регэкспресс для обработки таких вещей,как снятие тегов.</target>
        </trans-unit>
        <trans-unit id="74dec6c7e6bd60b234219702f40493e82463304e" translate="yes" xml:space="preserve">
          <source>Basically just define the element node names that are self closing, load the whole html string into a DOM library, grab all elements, loop through and filter out ones which aren't self closing and operate on them.</source>
          <target state="translated">В основном просто определите имена узлов элементов,которые самозакрываются,загрузите всю html строку в DOM-библиотеку,захватите все элементы,пройдите цикл и отфильтруйте те,которые не самозакрываются,и работайте с ними.</target>
        </trans-unit>
        <trans-unit id="2fd99963c03782b18787dfc6cb3594dcb6c80def" translate="yes" xml:space="preserve">
          <source>But many will try, some will even claim success - but until others find the fault and totally mess you up.</source>
          <target state="translated">Но многие будут пытаться,некоторые даже будут претендовать на успех-но пока другие не найдут вину и полностью испортить вам жизнь.</target>
        </trans-unit>
        <trans-unit id="eb3c73a7771d13969490ceb2f225b558c87d11f3" translate="yes" xml:space="preserve">
          <source>But not these:</source>
          <target state="translated">Но не эти:</target>
        </trans-unit>
        <trans-unit id="201b0e9006bea17e6be8fbec59ab5c0fb1baedd0" translate="yes" xml:space="preserve">
          <source>Can you provide a little more information on the problem you're trying to solve?  Are you iterating through tags programatically?</source>
          <target state="translated">Можете ли вы предоставить немного больше информации о проблеме,которую вы пытаетесь решить? Вы итерируете через теги запрограммированно?</target>
        </trans-unit>
        <trans-unit id="b8fde2430ed872968deeaaced84cc8f3cc101507" translate="yes" xml:space="preserve">
          <source>Consider the following regular expression:</source>
          <target state="translated">Рассмотрим следующее регулярное выражение:</target>
        </trans-unit>
        <trans-unit id="dfa51c240f8abc4eddb1aab8ac728fcb6c1daf9a" translate="yes" xml:space="preserve">
          <source>Do I have that right? And more importantly, what do you think?</source>
          <target state="translated">Я имею на это право? И что более важно,что ты думаешь?</target>
        </trans-unit>
        <trans-unit id="89791df6d0913a20e70b1f075f65baa21fec7900" translate="yes" xml:space="preserve">
          <source>Don't listen to these guys. You totally &lt;strong&gt;can&lt;/strong&gt; parse context-free grammars with regex if you break the task into smaller pieces. You can generate the correct pattern with a script that does each of these in order:</source>
          <target state="translated">Не слушай этих парней. Вы &lt;strong&gt;можете&lt;/strong&gt; полностью разобрать грамматики без контекста с помощью регулярных выражений, если разбите задачу на более мелкие части. Вы можете создать правильный шаблон с помощью скрипта, который выполняет каждый из них по порядку:</target>
        </trans-unit>
        <trans-unit id="c40843389e0f5b256a2400a9132a52c445461a2b" translate="yes" xml:space="preserve">
          <source>E MY FACE ᵒh god n&lt;b&gt;o NO NOO̼&lt;/b&gt;</source>
          <target state="translated">E МОЕ ЛИЦО &quot;Боже &lt;b&gt;мой&quot;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4130705574014c580de59636d30628dd3b203bfe" translate="yes" xml:space="preserve">
          <source>Excerpt:</source>
          <target state="translated">Excerpt:</target>
        </trans-unit>
        <trans-unit id="2ad9d9e9824270d481f3774905d98736bcee5670" translate="yes" xml:space="preserve">
          <source>Find (and capture) a-z one or more times, then</source>
          <target state="translated">Найти (и запечатлеть)a-z один или несколько раз,затем</target>
        </trans-unit>
        <trans-unit id="1d62b3cf5e66d1004bdcb37b62e3847fa43f5ea5" translate="yes" xml:space="preserve">
          <source>Find a greater-than</source>
          <target state="translated">Найти что-то большее,чем</target>
        </trans-unit>
        <trans-unit id="e9f182c7233327a73156c429c46ec0bca09513bc" translate="yes" xml:space="preserve">
          <source>Find a less-than, then</source>
          <target state="translated">Найти меньше,чем</target>
        </trans-unit>
        <trans-unit id="ef69898f6d3c5528cdbd0de1bd0fdf314dad1fc8" translate="yes" xml:space="preserve">
          <source>Find any character zero or more times, greedy, except &lt;code&gt;/&lt;/code&gt;, then</source>
          <target state="translated">Найти любой символ ноль или более раз, жадный, кроме &lt;code&gt;/&lt;/code&gt; , затем</target>
        </trans-unit>
        <trans-unit id="4f924d21074cc3fb26507a968919ecf7195b88d8" translate="yes" xml:space="preserve">
          <source>Find zero or more spaces, then</source>
          <target state="translated">Найдите ноль или больше пробелов,тогда</target>
        </trans-unit>
        <trans-unit id="0d7c5280ed7e07e90b90f8658292c92cbadfbd89" translate="yes" xml:space="preserve">
          <source>Follow the var links for &lt;code&gt;QName&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, and &lt;code&gt;Attribute&lt;/code&gt; to get a clearer picture.</source>
          <target state="translated">Перейдите по ссылкам var для &lt;code&gt;QName&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; и &lt;code&gt;Attribute&lt;/code&gt; , чтобы получить более четкую картину.</target>
        </trans-unit>
        <trans-unit id="cf4a4868fa67f0f821777e8c58e576588a83ca85" translate="yes" xml:space="preserve">
          <source>For Python and Java, similar links were posted.</source>
          <target state="translated">Для Python и Java были размещены аналогичные ссылки.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="3835e68a9fb13e4990fe61a2c3a6bb38c1da30a3" translate="yes" xml:space="preserve">
          <source>For the downvoters - I only wrote my class when the XML parsers proved unable to withstand real use. Religious downvoting just prevents useful answers from being posted - keep things within perspective of the question, please.</source>
          <target state="translated">Для даунвотеров-я написал свой класс только тогда,когда парсеры XML оказались неспособными противостоять реальному использованию.Религиозное даунвоттинг только мешает размещать полезные ответы-держите все в рамках вопроса,пожалуйста.</target>
        </trans-unit>
        <trans-unit id="b71baca6025abb3df3fd982ef9ea831e48620ba4" translate="yes" xml:space="preserve">
          <source>For this reason, I believe you CAN parse XML using regular expressions. Note however, that it &lt;strong&gt;must be valid XML&lt;/strong&gt; (&lt;em&gt;browsers are very forgiving of HTML and allow bad XML syntax inside HTML&lt;/em&gt;). This is possible since the &quot;Balancing Group Definition&quot; will allow the regular expression engine to act as a PDA.</source>
          <target state="translated">По этой причине я считаю, что вы МОЖЕТЕ проанализировать XML с помощью регулярных выражений. Однако обратите внимание, что это &lt;strong&gt;должен быть действительный XML&lt;/strong&gt; ( &lt;em&gt;браузеры очень просты для HTML и допускают неверный синтаксис XML внутри HTML&lt;/em&gt; ). Это возможно, поскольку &amp;laquo;Определение балансирующей группы&amp;raquo; позволит механизму регулярных выражений выступать в качестве КПК.</target>
        </trans-unit>
        <trans-unit id="fda26d5e5c5ac0a8c6a86392f4d1739052bb39fc" translate="yes" xml:space="preserve">
          <source>Granted, these don't account for surrounding context and a few edge cases, but even such things could be dealt with if you really wanted to (e.g., by searching between the matches of another regex).</source>
          <target state="translated">Конечно,они не учитывают окружающий контекст и несколько крайних случаев,но даже с такими вещами можно было бы справиться,если бы вы действительно захотели (например,путем поиска между совпадениями другого регекса).</target>
        </trans-unit>
        <trans-unit id="ddfca12da1b8e2626e09bf2de8420516252a5e63" translate="yes" xml:space="preserve">
          <source>HTML Split</source>
          <target state="translated">разделение HTML</target>
        </trans-unit>
        <trans-unit id="6c3bb55dbe0fb3cbcbc40ad1f139eaae779348bd" translate="yes" xml:space="preserve">
          <source>Hacking stackoverflow.com's HTML sanitizer</source>
          <target state="translated">Взлом HTML-дезинфектанта от Stackoverflow.com</target>
        </trans-unit>
        <trans-unit id="9ec955a6d30b0da0f17f1892186c1fa8f07ed132" translate="yes" xml:space="preserve">
          <source>Have you tried using an XML parser instead?</source>
          <target state="translated">Вы пробовали использовать парсер XML вместо него?</target>
        </trans-unit>
        <trans-unit id="62d338caf42aa263445453c7fd40bf4f6302c521" translate="yes" xml:space="preserve">
          <source>Here is a &lt;a href=&quot;http://kingdesk.com/projects/php-parser/&quot;&gt;PHP based parser&lt;/a&gt; that parses HTML using  some ungodly regex. As the author of this project, I can tell you it is possible to parse HTML with regex, but not efficient. If you need a server-side solution (as I did for my &lt;a href=&quot;http://wordpress.org/extend/plugins/wp-typography/&quot;&gt;wp-Typography WordPress plugin&lt;/a&gt;), this works.</source>
          <target state="translated">Вот &lt;a href=&quot;http://kingdesk.com/projects/php-parser/&quot;&gt;синтаксический анализатор&lt;/a&gt; , основанный на PHP, который анализирует HTML, используя какое-то безбожное выражение. Как автор этого проекта, я могу вам сказать, что можно анализировать HTML с помощью регулярных выражений, но это не эффективно. Если вам нужно решение на стороне сервера (как я сделал для моего &lt;a href=&quot;http://wordpress.org/extend/plugins/wp-typography/&quot;&gt;плагина wp-Typography WordPress&lt;/a&gt; ), это работает.</target>
        </trans-unit>
        <trans-unit id="de8fd03b5c9fb5a8404878e31a8e0845726217a3" translate="yes" xml:space="preserve">
          <source>Here's a &lt;strong&gt;sample note on the PHP manual&lt;/strong&gt; I wrote on January: &lt;a href=&quot;http://php.net/manual/en/regexp.reference.recursive.php&quot;&gt;Reference&lt;/a&gt;</source>
          <target state="translated">Вот &lt;strong&gt;пример примечания к руководству по PHP, которое&lt;/strong&gt; я написал в январе:</target>
        </trans-unit>
        <trans-unit id="5c95897a114ae327a0fcd3248ce2f00b0ecf00ea" translate="yes" xml:space="preserve">
          <source>Here's the magic pattern:</source>
          <target state="translated">Вот волшебный узор:</target>
        </trans-unit>
        <trans-unit id="c10b2e598b32c332a06818be23de20fdc89e2f2a" translate="yes" xml:space="preserve">
          <source>Here's the solution:</source>
          <target state="translated">Вот решение:</target>
        </trans-unit>
        <trans-unit id="2cb54d7b11fcfb379247546c25fc8c672912b48c" translate="yes" xml:space="preserve">
          <source>However, a na&amp;iuml;ve implementation of that will end up matching &lt;code&gt;&amp;lt;bar/&amp;gt;&amp;lt;/foo&amp;gt;&lt;/code&gt; in this example document</source>
          <target state="translated">Однако наивная реализация этого в конечном итоге будет соответствовать &lt;code&gt;&amp;lt;bar/&amp;gt;&amp;lt;/foo&amp;gt;&lt;/code&gt; в этом примере документа</target>
        </trans-unit>
        <trans-unit id="5ee1e08a15d19fdb33d20bd07c63e0818a8b9803" translate="yes" xml:space="preserve">
          <source>I agree that the right tool to parse XML and &lt;em&gt;especially HTML&lt;/em&gt; is a parser and not a regular expression engine. However, like others have pointed out, sometimes using a regex is quicker, easier, and gets the job done if you know the data format.</source>
          <target state="translated">Я согласен, что правильный инструмент для анализа XML и &lt;em&gt;особенно HTML&lt;/em&gt; - это анализатор, а не механизм регулярных выражений. Однако, как отмечали другие, иногда использование регулярных выражений происходит быстрее, проще и выполняет работу, если вы знаете формат данных.</target>
        </trans-unit>
        <trans-unit id="65c26198557f567b9e45c7ec5c4d24af104d4dba" translate="yes" xml:space="preserve">
          <source>I also entered tags with:</source>
          <target state="translated">Я также ввел теги с:</target>
        </trans-unit>
        <trans-unit id="f992540f103a26060e050d18a000903263722fe7" translate="yes" xml:space="preserve">
          <source>I believe it says:</source>
          <target state="translated">Кажется,там написано:</target>
        </trans-unit>
        <trans-unit id="67002a6457c576d19392a6bb03d1003175f5f89d" translate="yes" xml:space="preserve">
          <source>I bet I will get downvoted for this.</source>
          <target state="translated">Готов поспорить,что за это меня понизят в цене.</target>
        </trans-unit>
        <trans-unit id="a78333526ec3e39b92b14f68dec9aff52646cd97" translate="yes" xml:space="preserve">
          <source>I came up with this and wanted to make sure I've got it right. I am only capturing the &lt;code&gt;a-z&lt;/code&gt;.</source>
          <target state="translated">Я придумал это и хотел убедиться, что я правильно понял. Я только захватил &lt;code&gt;a-z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c510ddbef2e355def2551ab12c01a3563da7ee62" translate="yes" xml:space="preserve">
          <source>I don't know your exact need for this, but if you are also using .NET, couldn't you use &lt;a href=&quot;http://www.codeplex.com/htmlagilitypack&quot;&gt;Html Agility Pack&lt;/a&gt;?</source>
          <target state="translated">Я не знаю, в чем именно вы нуждаетесь, но если вы также используете .NET, не могли бы вы использовать &lt;a href=&quot;http://www.codeplex.com/htmlagilitypack&quot;&gt;Html Agility Pack&lt;/a&gt; ?</target>
        </trans-unit>
        <trans-unit id="a18f149e6422b3edd9f248402bd13c1e293f7282" translate="yes" xml:space="preserve">
          <source>I guess to make it not match self contained tags, you'd either want to use &lt;a href=&quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732395#1732395&quot;&gt;Kobi&lt;/a&gt;'s negative look-behind:</source>
          <target state="translated">Я полагаю, что для того, чтобы он не совпадал с самодостаточными тегами, вы бы хотели использовать отрицательный взгляд &lt;a href=&quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732395#1732395&quot;&gt;Коби&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="446fea43937f34270d7612150462764e964be907" translate="yes" xml:space="preserve">
          <source>I have also composed a haiku describing the nature of regex in Perl.</source>
          <target state="translated">Я также сочинил хайку,описывающую природу регекса на Perl.</target>
        </trans-unit>
        <trans-unit id="682e33f67784d033cbcf7127d0e8db1135907695" translate="yes" xml:space="preserve">
          <source>I have composed a haiku describing the nature of HTML.</source>
          <target state="translated">Я сочинил хайку,описывающую природу HTML.</target>
        </trans-unit>
        <trans-unit id="b7d276bff4ead75187b5216ebca62ddd0544740b" translate="yes" xml:space="preserve">
          <source>I have never used &lt;a href=&quot;http://querypath.org/&quot;&gt;querypath&lt;/a&gt;, so can't comment on its usefulness.</source>
          <target state="translated">Я никогда не использовал &lt;a href=&quot;http://querypath.org/&quot;&gt;querypath&lt;/a&gt; , поэтому не могу комментировать его полезность.</target>
        </trans-unit>
        <trans-unit id="a3d81722ce02cdd1e1d406605ca28b6afc2989ae" translate="yes" xml:space="preserve">
          <source>I haven't quite finished the last part myself, but I know I'm getting close. It keeps throwing &lt;code&gt;CthulhuRlyehWgahnaglFhtagnException&lt;/code&gt;s for some reason, so I'm going to port it to VB 6 and use &lt;code&gt;On Error Resume Next&lt;/code&gt;. I'll update with the code once I investigate this strange door that just opened in the wall. Hmm.</source>
          <target state="translated">Я еще не совсем закончил последнюю часть, но я знаю, что приближаюсь. По &lt;code&gt;CthulhuRlyehWgahnaglFhtagnException&lt;/code&gt; то причине он продолжает выдавать CthulhuRlyehWgahnaglFhtagnException s, поэтому я собираюсь перенести его на VB 6 и использовать &lt;code&gt;On Error Resume Next&lt;/code&gt; . Я обновлю код, когда буду исследовать эту странную дверь, которая только что открылась в стене. Хм.</target>
        </trans-unit>
        <trans-unit id="57a8d4c706d6a34ee3af3112fdb317e71ff9acca" translate="yes" xml:space="preserve">
          <source>I like to parse HTML with regular expressions. I don't attempt to parse idiot HTML that is deliberately broken. This code is my main parser (Perl edition):</source>
          <target state="translated">Мне нравится разбирать HTML с регулярными выражениями.Я не пытаюсь разобрать идиотский HTML,который сознательно нарушен.Этот код является моим основным синтаксическим анализатором (Perl-версия):</target>
        </trans-unit>
        <trans-unit id="8ea04fa9f527bf7438dfd9b91e87f0721f39b7be" translate="yes" xml:space="preserve">
          <source>I need to match all of these opening tags:</source>
          <target state="translated">Мне нужно сопоставить все эти открывающиеся метки:</target>
        </trans-unit>
        <trans-unit id="f58bfd6885d7586198e4ea7d285dc17ac4158c70" translate="yes" xml:space="preserve">
          <source>I suggest using &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; for parsing XML and HTML in PHP.  It's basically much the same syntax as jQuery, only it's on the server side.</source>
          <target state="translated">Я предлагаю использовать &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; для разбора XML и HTML в PHP. По сути, это тот же синтаксис, что и в jQuery, только на стороне сервера.</target>
        </trans-unit>
        <trans-unit id="ece9292e931d9ba43626cda22fdf3280d35633a6" translate="yes" xml:space="preserve">
          <source>I think the XML case is quite simple. The RegEx (in the .NET syntax), deflated and coded in base64 to make it easier to comprehend by your feeble mind, should be something like this:</source>
          <target state="translated">Я думаю,что XML дело довольно простое.RegEx (в синтаксисе .NET),сдутый и закодированный в base64 для облегчения понимания слабым умом,должен быть чем-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="18040856a3f0eb37bda82501b7d790ae361b0b2d" translate="yes" xml:space="preserve">
          <source>I think the flaw here is that HTML is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;Chomsky Type 2 grammar (context free grammar)&lt;/a&gt; and RegEx is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_grammar&quot;&gt;Chomsky Type 3 grammar (regular grammar)&lt;/a&gt;. Since a Type 2 grammar is fundamentally more complex than a Type 3 grammar (see the &lt;a href=&quot;http://en.wikipedia.org/wiki/Chomsky_hierarchy&quot;&gt;Chomsky hierarchy&lt;/a&gt;), it is &lt;em&gt;mathematically impossible&lt;/em&gt; to parse XML with RegEx.</source>
          <target state="translated">Я думаю, что недостаток в том, что HTML - это &lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;грамматика Chomsky Type 2 (контекстно-свободная грамматика),&lt;/a&gt; а RegEx - это &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_grammar&quot;&gt;грамматика Chomsky Type 3 (обычная грамматика)&lt;/a&gt; . Поскольку грамматика типа 2 является существенно более сложной, чем грамматика типа 3 (см. &lt;a href=&quot;http://en.wikipedia.org/wiki/Chomsky_hierarchy&quot;&gt;Иерархию Хомского&lt;/a&gt; ), &lt;em&gt;математически невозможно&lt;/em&gt; проанализировать XML с помощью RegEx.</target>
        </trans-unit>
        <trans-unit id="46e4bbf54843bf1bf2bb54e48219620db67794ee" translate="yes" xml:space="preserve">
          <source>I used a open source tool called &lt;a href=&quot;http://htmlparser.sourceforge.net/&quot;&gt;HTMLParser&lt;/a&gt; before. It's designed to parse HTML in various ways and serves the purpose quite well. It can parse HTML as different treenode and you can easily use its API to get attributes out of the node. Check it out and see if this can help you.</source>
          <target state="translated">Я использовал инструмент с открытым исходным кодом под названием &lt;a href=&quot;http://htmlparser.sourceforge.net/&quot;&gt;HTMLParser&lt;/a&gt; раньше. Он разработан для анализа HTML различными способами и вполне удовлетворительно выполняет поставленные задачи. Он может анализировать HTML как другой treenode, и вы можете легко использовать его API для получения атрибутов из узла. Проверьте это и посмотрите, может ли это помочь вам.</target>
        </trans-unit>
        <trans-unit id="50830c82c86965110baf1111e9368113230c821b" translate="yes" xml:space="preserve">
          <source>I used the sample source of:</source>
          <target state="translated">Я использовал образец источника:</target>
        </trans-unit>
        <trans-unit id="fb040c717878233cc23503d0d656d6a7c4f3856c" translate="yes" xml:space="preserve">
          <source>I wrote it in 30 seconds, and tested here:
&lt;a href=&quot;http://gskinner.com/RegExr/&quot;&gt;http://gskinner.com/RegExr/&lt;/a&gt;</source>
          <target state="translated">Я написал это за 30 секунд и протестировал здесь: &lt;a href=&quot;http://gskinner.com/RegExr/&quot;&gt;http://gskinner.com/RegExr/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb8a7f1667c9d5eff8cc8d64ddbce9b58e23a699" translate="yes" xml:space="preserve">
          <source>I wrote this pattern to power the &lt;em&gt;recursive descent parser&lt;/em&gt; of a template engine I built in my framework, and performances are really great, both in execution times or in memory usage (nothing to do with other template engines which use the same syntax).</source>
          <target state="translated">Я написал этот шаблон для поддержки &lt;em&gt;анализатора рекурсивного спуска&lt;/em&gt; механизма шаблонов, который я встроил в мою среду, и производительность действительно велика, как во время выполнения, так и в использовании памяти (ничего общего с другими механизмами шаблонов, которые используют тот же синтаксис).</target>
        </trans-unit>
        <trans-unit id="f454869fe61fa45429bc7ee92bc5ad9345d8b481" translate="yes" xml:space="preserve">
          <source>I'm sure you already know by now that you shouldn't use regex for this purpose.</source>
          <target state="translated">Уверен,ты уже знаешь,что не стоит использовать для этого регекс.</target>
        </trans-unit>
        <trans-unit id="40dea22884315ebb5434973f5bb9c5c1ca6166f5" translate="yes" xml:space="preserve">
          <source>If You Like Regular Expressions So Much, Why Don't You Marry Them?</source>
          <target state="translated">Если тебе так нравятся регулярные выражения,почему бы тебе не выйти за них замуж?</target>
        </trans-unit>
        <trans-unit id="cbfa4fd68fca2bc7eab26c99ba711ac9cab9bb23" translate="yes" xml:space="preserve">
          <source>If an (x)HTML parser needs recursion, a RegExp parser without recursion is not enough for the purpose. It's a simple construct.</source>
          <target state="translated">Если парсеру (x)HTML требуется рекурсия,то парсеру RegExp без рекурсии недостаточно.Это простая конструкция.</target>
        </trans-unit>
        <trans-unit id="919388ca02cd994c288549580960ad9ba47f962b" translate="yes" xml:space="preserve">
          <source>If someone is interested in learning more about the pattern, I provide some line:</source>
          <target state="translated">Если кому-то интересно узнать больше о шаблоне,я предоставлю какую-нибудь строчку:</target>
        </trans-unit>
        <trans-unit id="557f9117f8433eb60bbd29cff5259745d632f952" translate="yes" xml:space="preserve">
          <source>If you add something to the regex, by backtracking it can be forced to match silly things like &lt;code&gt;&amp;lt;a &amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;[^/]&lt;/code&gt; is too permissive. Also note that &lt;code&gt;&amp;lt;space&amp;gt;*[^/]*&lt;/code&gt; is redundant, because the &lt;code&gt;[^/]*&lt;/code&gt; can also match spaces.</source>
          <target state="translated">Если вы добавляете что-то к регулярному выражению, при возврате его можно заставить сопоставлять глупые вещи, такие как &lt;code&gt;&amp;lt;a &amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;[^/]&lt;/code&gt; слишком допустимо. Также обратите внимание, что &lt;code&gt;&amp;lt;space&amp;gt;*[^/]*&lt;/code&gt; является избыточным, потому что &lt;code&gt;[^/]*&lt;/code&gt; также может совпадать с пробелами.</target>
        </trans-unit>
        <trans-unit id="a298912d3657e52c67b5f74e85c231c1485f0d0c" translate="yes" xml:space="preserve">
          <source>If you are unsure, no, I'm NOT kidding (but perhaps I'm lying). It WILL work. I've built tons of unit tests to test it, and I have even used (part of) the &lt;a href=&quot;http://www.w3.org/XML/Test/&quot;&gt;conformance tests&lt;/a&gt;. It's a tokenizer, not a full-blown parser, so it will only split the XML into its component tokens. It won't parse/integrate DTDs.</source>
          <target state="translated">Если вы не уверены, нет, я не шучу (но, возможно, я лгу). Это будет работать. Я построил тонны модульных тестов, чтобы протестировать его, и я даже использовал (часть) &lt;a href=&quot;http://www.w3.org/XML/Test/&quot;&gt;тесты&lt;/a&gt; на соответствие . Это токенизатор, а не полноценный синтаксический анализатор, поэтому он будет разбивать только XML на его компонентные токены. Он не будет анализировать / интегрировать DTD.</target>
        </trans-unit>
        <trans-unit id="2b5bc330d9a583246ad4801874fc84163c931493" translate="yes" xml:space="preserve">
          <source>If you have a small set of HTML pages that you want to scrape data from and then stuff into a database, regexes might work fine.  For example, I recently wanted to get the names, parties, and districts of Australian federal Representatives, which I got off of the Parliament's web site.  This was a limited, one-time job.</source>
          <target state="translated">Если у вас есть небольшой набор HTML-страниц,из которых вы хотите соскребать данные,а затем загрузить их в базу данных,то регексы могут работать нормально.Например,недавно я хотел получить имена,партии и округа австралийских федеральных представителей,которые я получил с сайта парламента.Это была ограниченная,одноразовая работа.</target>
        </trans-unit>
        <trans-unit id="d9db7068b93480af65771902d59739a0242c037f" translate="yes" xml:space="preserve">
          <source>If you have problems reconverting it to a human-readable regex, this should help:</source>
          <target state="translated">Если у вас есть проблемы с переоборудованием его в читаемый человеком регекс,это должно помочь:</target>
        </trans-unit>
        <trans-unit id="14633b829212b8b056b036f6830ca7c6a918fe40" translate="yes" xml:space="preserve">
          <source>If you need this for PHP:</source>
          <target state="translated">Если вам это нужно для PHP:</target>
        </trans-unit>
        <trans-unit id="f932b2b6098e1c3395b486c41745029eaaebe046" translate="yes" xml:space="preserve">
          <source>If you're simply trying to find those tags (without ambitions of parsing) try this regular expression:</source>
          <target state="translated">Если вы просто пытаетесь найти эти теги (без амбиций разбора),попробуйте это регулярное выражение:</target>
        </trans-unit>
        <trans-unit id="4b5c78fb6625eec434f0fbf5e5c22e99da727566" translate="yes" xml:space="preserve">
          <source>IgnoreCase (not necessary)</source>
          <target state="translated">ИгнорироватьКейс (не обязательно)</target>
        </trans-unit>
        <trans-unit id="195915971c682a24ad48d1e62483babae5188862" translate="yes" xml:space="preserve">
          <source>IgnorePatternWhitespace (not necessary if you collapse regex and remove all whitespace)</source>
          <target state="translated">IgnorePatternWhitespace (не требуется,если вы свернете регекс и удалите все белые пробелы)</target>
        </trans-unit>
        <trans-unit id="d8142f0416c264b4b799d2c8a0af8d098608064c" translate="yes" xml:space="preserve">
          <source>In shell, you can parse &lt;a href=&quot;https://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; using &lt;a href=&quot;https://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt;:</source>
          <target state="translated">В оболочке вы можете анализировать &lt;a href=&quot;https://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; с помощью &lt;a href=&quot;https://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3e72a4a4bfbcf98641ca469ef038c0e9caca1753" translate="yes" xml:space="preserve">
          <source>In this case your enemy is HTML and you are either yourself or regex.  You might even be Perl with irregular regex. Know HTML.  Know yourself.</source>
          <target state="translated">В этом случае вашим врагом является HTML,а вы либо сами,либо регекс.Вы даже можете быть Perl с нерегулярным регексом.Знайте HTML.Знать себя.</target>
        </trans-unit>
        <trans-unit id="4da0bc6ccd100c1869c39b7908884293a4fdecf6" translate="yes" xml:space="preserve">
          <source>It is said that if you know your enemies and know yourself, you can win a hundred battles without a single loss.
  If you only know yourself, but not your opponent, you may win or may lose.
  If you know neither yourself nor your enemy, you will always endanger yourself.</source>
          <target state="translated">Говорят,что если вы знаете своих врагов и знаете себя,вы можете выиграть сотню сражений без единого проигрыша.Если ты знаешь только себя,но не соперника,ты можешь выиграть или проиграть.Если ты не знаешь ни себя,ни врага,ты всегда будешь подвергать себя опасности.</target>
        </trans-unit>
        <trans-unit id="8cd9da1c9f2693e6ec017e2869a577b714739b63" translate="yes" xml:space="preserve">
          <source>It is similar to yours, but the last &lt;code&gt;&amp;gt;&lt;/code&gt; must not be after a slash, and also accepts &lt;code&gt;h1&lt;/code&gt;.</source>
          <target state="translated">Он похож на ваш, но последний &lt;code&gt;&amp;gt;&lt;/code&gt; не должен быть после косой черты, а также принимает &lt;code&gt;h1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ad138f054cb998fb3ecb181104c2f9f5989e48b" translate="yes" xml:space="preserve">
          <source>It is simple enough to rejig my slurp-everything-first Perl script into a nice streaming thing, if you wish to process enormous web pages. But it's not really necessary.</source>
          <target state="translated">Достаточно просто отвергнуть мой скрипт slurp-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все.Но в этом нет необходимости.</target>
        </trans-unit>
        <trans-unit id="f4114fb01ee1d4a7e528e4b5db702779bb015416" translate="yes" xml:space="preserve">
          <source>It matches the types of tags you mentioned, while ignoring the types you said you wanted to ignore.</source>
          <target state="translated">Он соответствует типам тегов,которые вы упомянули,игнорируя при этом те типы,которые,по вашему мнению,вы хотели бы игнорировать.</target>
        </trans-unit>
        <trans-unit id="e92b765161d9c9393ab926712762103321511c85" translate="yes" xml:space="preserve">
          <source>It may not be perfect, but I ran this code through a &lt;em&gt;lot&lt;/em&gt; of HTML. Note that it even catches strange things like &lt;code&gt;&amp;lt;a name=&quot;badgenerator&quot;&quot;&amp;gt;&lt;/code&gt;, which show up on the web.</source>
          <target state="translated">Возможно, он не идеален, но я пробежал этот код по &lt;em&gt;большому&lt;/em&gt; количеству HTML. Обратите внимание, что он даже ловит странные вещи, такие как &lt;code&gt;&amp;lt;a name=&quot;badgenerator&quot;&quot;&amp;gt;&lt;/code&gt; , которые появляются в Интернете.</target>
        </trans-unit>
        <trans-unit id="3c401fdac65c6774bcadecd58093d69231332e3b" translate="yes" xml:space="preserve">
          <source>It seems to me you're trying to match tags without a &quot;/&quot; at the end. Try this:</source>
          <target state="translated">Мне кажется,что ты пытаешься сопоставить метки без &quot;&quot; в конце.Попробуй это:</target>
        </trans-unit>
        <trans-unit id="f6ca3fc0ed09308a49c656e7527184db98c56489" translate="yes" xml:space="preserve">
          <source>It's called htmlsplit, splits the HTML into lines, with one tag or chunk of text on each line.  The lines can then be processed further with other text tools and scripts, such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt;, Perl, etc. I'm not even joking :) Enjoy.</source>
          <target state="translated">Он называется htmlsplit, разбивает HTML на строки с одним тегом или фрагментом текста в каждой строке. Затем строки могут быть обработаны другими текстовыми инструментами и скриптами, такими как &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt; , &lt;a href=&quot;http://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt; , Perl и т. Д. Я даже не шучу :) Наслаждайтесь.</target>
        </trans-unit>
        <trans-unit id="9ec7139f7024ff295c9ba4a49287ac0b4b6fc319" translate="yes" xml:space="preserve">
          <source>It's true that when programming it's usually best to use dedicated parsers and APIs instead of regular expressions when dealing with HTML, especially if accuracy is paramount (e.g., if your processing might have security implications). However, I don&amp;rsquo;t ascribe to a dogmatic view that XML-style markup should never be processed with regular expressions. There are cases when regular expressions are a great tool for the job, such as when making one-time edits in a text editor, fixing broken XML files, or dealing with file formats that look like but aren&amp;rsquo;t quite XML. There are some issues to be aware of, but they're not insurmountable or even necessarily relevant.</source>
          <target state="translated">Это правда, что при программировании обычно лучше использовать выделенные парсеры и API вместо регулярных выражений при работе с HTML, особенно если точность имеет первостепенное значение (например, если ваша обработка может иметь последствия для безопасности). Однако я не приписываю догматической точке зрения, что разметка в стиле XML никогда не должна обрабатываться с помощью регулярных выражений. Бывают случаи, когда регулярные выражения являются отличным инструментом для работы, например, при одноразовом редактировании в текстовом редакторе, исправлении поврежденных файлов XML или работе с форматами файлов, которые выглядят, но не совсем как XML. Есть некоторые проблемы, о которых нужно знать, но они не являются непреодолимыми или даже необязательно актуальными.</target>
        </trans-unit>
        <trans-unit id="39e7ab248960684eaa9b9f720409b41a17a28cff" translate="yes" xml:space="preserve">
          <source>It's written as a PHP string, so the &quot;s&quot; modifier makes classes include newlines.</source>
          <target state="translated">Он написан как PHP-строка,поэтому модификатор &quot;s&quot; заставляет классы включать новые строки.</target>
        </trans-unit>
        <trans-unit id="427486fffe171253525e01e3f06e796d5676dc63" translate="yes" xml:space="preserve">
          <source>Just to give a sense of what a more &quot;advanced&quot; HTML regex would look like, the following does a fairly respectable job of emulating real-world browser behavior and the HTML5 parsing algorithm:</source>
          <target state="translated">Чтобы дать представление о том,как будет выглядеть более &quot;продвинутый&quot; HTML-регекс,ниже приводится достаточно респектабельная работа по эмуляции поведения реального браузера и алгоритма разбора HTML5:</target>
        </trans-unit>
        <trans-unit id="22605049c94f39fec40c01fc01b8d0235c7512b9" translate="yes" xml:space="preserve">
          <source>Just try it.</source>
          <target state="translated">Просто попробуй.</target>
        </trans-unit>
        <trans-unit id="601daad3ec0906e4e0d799c06fb0f95e6770d70e" translate="yes" xml:space="preserve">
          <source>Lastly, I really enjoyed Jeff Atwood's article:  &lt;a href=&quot;https://blog.codinghorror.com/parsing-html-the-cthulhu-way/&quot;&gt;Parsing Html The Cthulhu Way&lt;/a&gt;. Funny enough, it cites the answer to this question that currently has over 4k votes.</source>
          <target state="translated">Наконец, мне очень понравилась статья Джеффа Этвуда: &lt;a href=&quot;https://blog.codinghorror.com/parsing-html-the-cthulhu-way/&quot;&gt;Parsing Html The Cthulhu Way&lt;/a&gt; . Достаточно забавно, он цитирует ответ на этот вопрос, который в настоящее время имеет более 4 тысяч голосов.</target>
        </trans-unit>
        <trans-unit id="d67da4c32f78ca5c993f0ad4bcd5b49e6538c409" translate="yes" xml:space="preserve">
          <source>Like Lord Marshal (is he a relative of the Marshal .NET class?), I have seen the &lt;strike&gt;Underverse&lt;/strike&gt; Stack Based Regex-Verse and returned with &lt;strike&gt;powers&lt;/strike&gt; knowledge you can't imagine. Yes, I think there were an Old One or two protecting them, but they were watching football on the TV, so it wasn't difficult.</source>
          <target state="translated">Как и лорд-маршал (является ли он родственником класса маршала .NET?), Я видел Regex-Verse, основанный на &lt;strike&gt;обратном стэке,&lt;/strike&gt; и вернулся со знаниями, которые вы не можете себе представить. Да, я думаю, что один или два старика защищали их, но они смотрели футбол по телевизору, так что это было несложно.</target>
        </trans-unit>
        <trans-unit id="1c3e6997e482742cdf179a4397cb018cad2d8564" translate="yes" xml:space="preserve">
          <source>Microsoft actually has a section of &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices&quot;&gt;Best Practices for Regular Expressions in the .NET Framework&lt;/a&gt; and specifically talks about &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices#consider-the-input-source&quot;&gt;Consider[ing] the Input Source&lt;/a&gt;.</source>
          <target state="translated">На самом деле у Microsoft есть раздел &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices&quot;&gt;Best Practices для регулярных выражений в .NET Framework,&lt;/a&gt; и он конкретно говорит о &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices#consider-the-input-source&quot;&gt;рассмотрении источника ввода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba3b99fc49923cc3bbd90f5e080753b12725e9bc" translate="yes" xml:space="preserve">
          <source>My suggestion would be</source>
          <target state="translated">Мое предложение было бы</target>
        </trans-unit>
        <trans-unit id="72810c91afedb33b80069b7076436fecf94d1af6" translate="yes" xml:space="preserve">
          <source>No, holy cow, no match found.</source>
          <target state="translated">Нет,святая корова,совпадений нет.</target>
        </trans-unit>
        <trans-unit id="a474b6597430f9ba4fac174b06490808a6e22af5" translate="yes" xml:space="preserve">
          <source>Note that this allows things like &lt;code&gt;&amp;lt;a/ &amp;gt;&lt;/code&gt; (just like the original regex), so if you want something more restrictive, you need to build a regex to match attribute pairs separated by spaces.</source>
          <target state="translated">Обратите внимание, что это допускает такие вещи, как &lt;code&gt;&amp;lt;a/ &amp;gt;&lt;/code&gt; (точно так же, как и в исходном регулярном выражении), поэтому, если вы хотите что-то более ограничительное, вам нужно создать регулярное выражение для сопоставления пар атрибутов, разделенных пробелами.</target>
        </trans-unit>
        <trans-unit id="aa7cf65bf2ed58b9c07633b4dd41874bd458e314" translate="yes" xml:space="preserve">
          <source>Now, we could speak about the limits of this method from a more informed point of view:</source>
          <target state="translated">Теперь мы можем говорить о пределах этого метода с более информированной точки зрения:</target>
        </trans-unit>
        <trans-unit id="1022301500a966b54ef35dd0b0c702c86a1e6cad" translate="yes" xml:space="preserve">
          <source>Oh... if you want the source code of the regex, with some auxiliary methods:</source>
          <target state="translated">О...если вам нужен исходный код регекса,с некоторыми вспомогательными методами:</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="efc9dd879d5fa6c41b5a8b4a174e9bbeea207c3f" translate="yes" xml:space="preserve">
          <source>P.S. Pierre de Fermat also figured out how to do it, but the margin he was writing in wasn't big enough for the code.</source>
          <target state="translated">P.S.Пьер де Ферма также придумал,как это сделать,но поле,на котором он писал,было недостаточно большим для кода.</target>
        </trans-unit>
        <trans-unit id="fb344f772f606bf069b994b1800b75ad467d5eb0" translate="yes" xml:space="preserve">
          <source>Profit!</source>
          <target state="translated">Profit!</target>
        </trans-unit>
        <trans-unit id="ffe7bde078bc620df9c2922255941de3200d1c7e" translate="yes" xml:space="preserve">
          <source>Quote from article 1 cited above:</source>
          <target state="translated">Цитата из статьи 1,цитируемой выше:</target>
        </trans-unit>
        <trans-unit id="ebb8b5eff359c8e4629b4281a740853315bc1649" translate="yes" xml:space="preserve">
          <source>RegEx match open tags except XHTML self-contained tags</source>
          <target state="translated">RegEx соответствует открытым тегам за исключением автономных тегов XHTML</target>
        </trans-unit>
        <trans-unit id="8336d194052f52769b114f9bc2344752e9b3f02b" translate="yes" xml:space="preserve">
          <source>Regexes worked just fine for me, and were very fast to set up.</source>
          <target state="translated">Регексы отлично сработали для меня,и были очень быстры в настройке.</target>
        </trans-unit>
        <trans-unit id="9ca09288e6a253e0dfa4bc1e29bfae12ab028bb9" translate="yes" xml:space="preserve">
          <source>Regular Expression Explained (inline)</source>
          <target state="translated">Регулярное выражение Пояснения (встроенные)</target>
        </trans-unit>
        <trans-unit id="24b2174abc016feccbfb08853265c6a5a2ea6e89" translate="yes" xml:space="preserve">
          <source>Regular Expressions do have limitations, but have you considered the following?</source>
          <target state="translated">Регулярные выражения действительно имеют ограничения,но рассмотрели ли вы следующее?</target>
        </trans-unit>
        <trans-unit id="f20c01e8fa442e15f50708e2e685f84f38cf9f06" translate="yes" xml:space="preserve">
          <source>Regular Expressions: Now You Have Two Problems</source>
          <target state="translated">Регулярные выражения:Теперь у тебя две проблемы</target>
        </trans-unit>
        <trans-unit id="b49c5b3c647bd9589b36c369c0bc3c5a638f66ed" translate="yes" xml:space="preserve">
          <source>Related (why you shouldn't use regex match):</source>
          <target state="translated">Родственник (почему бы не использовать регекс-матч):</target>
        </trans-unit>
        <trans-unit id="16962bdac3ee084e07372a69f0ada8648f72cfce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.microsoft.com/archive/blogs/bclteam/net-regular-expressions-regex-and-balanced-matching-ryan-byington&quot;&gt;.NET Regular Expressions: Regex and Balanced Matching&lt;/a&gt;</source>
          <target state="translated">См. &lt;a href=&quot;https://docs.microsoft.com/archive/blogs/bclteam/net-regular-expressions-regex-and-balanced-matching-ryan-byington&quot;&gt;Регулярные выражения .NET: регулярные выражения и сбалансированное сопоставление.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de60e0a6c744236d2ff2a2469aa87dabd965b8f9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://weblogs.asp.net/whaggard/377025&quot;&gt;Matching Balanced Constructs with .NET Regular Expressions&lt;/a&gt;</source>
          <target state="translated">См. &lt;a href=&quot;https://weblogs.asp.net/whaggard/377025&quot;&gt;Сопоставление сбалансированных конструкций с регулярными выражениями .NET&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a3ea9fb6afc3bc06c915f2dc863ae7a60ef9464e" translate="yes" xml:space="preserve">
          <source>See Microsoft's docs on &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;Balancing Group Definitions&lt;/a&gt;</source>
          <target state="translated">См. Документы Microsoft по &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;определениям балансировочных групп.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0ad4363c94846f440a3409baad524ee90a091468" translate="yes" xml:space="preserve">
          <source>Should you find something which does not work in the proof of concept above, I am available in analyzing the code to improve my skills.</source>
          <target state="translated">Если вы найдете что-то,что не работает в доказательстве концепции выше,я готов анализировать код,чтобы улучшить свои навыки.</target>
        </trans-unit>
        <trans-unit id="92cfc65b8206d5667dc7ccac83a9a9a793d658df" translate="yes" xml:space="preserve">
          <source>Since nobody mentioned the main mechanism a parser is built onto, I was soon aware that nobody got the point.</source>
          <target state="translated">Так как никто не упомянул о главном механизме,на котором построен парсер,я вскоре понял,что никто не понял смысл.</target>
        </trans-unit>
        <trans-unit id="4e222f3f71ebc82ced1555d79e3896204e2da9f1" translate="yes" xml:space="preserve">
          <source>Singleline</source>
          <target state="translated">Singleline</target>
        </trans-unit>
        <trans-unit id="2e489e37aeb575873f40d9f8a80c3e74b1c26ae6" translate="yes" xml:space="preserve">
          <source>Small tip: to better analyze this code it is necessary looking at the source code generated since I did not provide any HTML special characters escaping.</source>
          <target state="translated">Маленький совет:чтобы лучше анализировать этот код,необходимо посмотреть на сгенерированный исходный код,так как я не предоставлял никаких HTML специальных символов экранирования.</target>
        </trans-unit>
        <trans-unit id="2ccc837c5ed1e3feef77351cd1d620591415719e" translate="yes" xml:space="preserve">
          <source>Solve the Halting Problem.</source>
          <target state="translated">Решить проблему Халтинга.</target>
        </trans-unit>
        <trans-unit id="b8fc19b88ebcae8fab9f0ca6d99cb4a564e9d1d4" translate="yes" xml:space="preserve">
          <source>Square a circle.</source>
          <target state="translated">Квадрат по кругу.</target>
        </trans-unit>
        <trans-unit id="e1c5ebb5af83fa15c6406a756fafb86dfda684e1" translate="yes" xml:space="preserve">
          <source>Sun Tzu, an ancient Chinese strategist, general, and philosopher, said:</source>
          <target state="translated">Сунь Цзы,древний китайский стратег,генерал и философ,сказал:</target>
        </trans-unit>
        <trans-unit id="1361c33aa4292835661dbf5c91a1e629b1a6decc" translate="yes" xml:space="preserve">
          <source>The .NET framework is unique when it comes to regular expressions in that it supports &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;Balancing Group Definitions&lt;/a&gt;.</source>
          <target state="translated">Платформа .NET уникальна в том, что касается регулярных выражений, поскольку она поддерживает &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;определения балансирующих групп&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55da94ce9e0ca8998eabc3076f92485f67f4f2eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.php.net/manual/en/function.dom-import-simplexml.php&quot;&gt;PHP DOM&lt;/a&gt;&lt;a href=&quot;http://php.net/manual/en/class.domdocument.php&quot;&gt;functions&lt;/a&gt; won't work properly unless it is properly formatted XML. No matter how much better their use is for the rest of mankind.</source>
          <target state="translated">Функции &lt;a href=&quot;http://www.php.net/manual/en/function.dom-import-simplexml.php&quot;&gt;PHP DOM&lt;/a&gt; не будут работать должным образом, если не будет правильно отформатирован XML. Неважно, насколько лучше их использование для остального человечества.</target>
        </trans-unit>
        <trans-unit id="4ac395740ae412d2f1cc1a46e41f7844bd6163b7" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;black art of RegExp is hard to master&lt;/strong&gt;, so maybe there are further possibilities we left out while trying and testing our personal solution to capture the whole web in one hand... Well, I am sure about it :)</source>
          <target state="translated">&lt;strong&gt;Черное искусство RegExp сложно освоить&lt;/strong&gt; , поэтому, может быть, есть и другие возможности, которые мы упустили, пытаясь и тестируя наше личное решение для захвата всей сети в одной руке ... Ну, я в этом уверен :)</target>
        </trans-unit>
        <trans-unit id="997812962876e0edf9df4c8486980789ffe0886d" translate="yes" xml:space="preserve">
          <source>The W3C explains parsing in a pseudo regexp form:</source>
          <target state="translated">W3C объясняет парсинг в псевдо-регенеративной форме:</target>
        </trans-unit>
        <trans-unit id="fdcdc94a48b14eafa651bbe7dd5b0b9e404ab530" translate="yes" xml:space="preserve">
          <source>The best way to write regular expressions is in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Lex_%28software%29&quot;&gt;Lex&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; style, not as opaque one-liners or commented multi-line monstrosities. I didn't do that here, yet; these ones barely need it.</source>
          <target state="translated">Лучший способ написания регулярных выражений - в стиле &lt;a href=&quot;http://en.wikipedia.org/wiki/Lex_%28software%29&quot;&gt;Lex&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; , а не в виде непрозрачных однострочников или многострочных комментариев. Я не делал этого здесь, пока; этим едва нужно.</target>
        </trans-unit>
        <trans-unit id="712ab4b4a1f7ed2c6d0a80c8195f21170140f25f" translate="yes" xml:space="preserve">
          <source>The following matches a fairly strict definition of XML tags (although it doesn't account for the full set of Unicode characters allowed in XML names):</source>
          <target state="translated">Следующее соответствует достаточно строгому определению XML-тегов (хотя и не учитывает полный набор символов Юникода,разрешенных в именах XML):</target>
        </trans-unit>
        <trans-unit id="b4cfd79b880dc8c38082dbd0830e9fdee4557b44" translate="yes" xml:space="preserve">
          <source>The options to set is &lt;code&gt;RegexOptions.ExplicitCapture&lt;/code&gt;. The capture group you are looking for is &lt;code&gt;ELEMENTNAME&lt;/code&gt;. If the capture group &lt;code&gt;ERROR&lt;/code&gt; is not empty then there was a parsing error and the Regex stopped.</source>
          <target state="translated">Параметры для установки - &lt;code&gt;RegexOptions.ExplicitCapture&lt;/code&gt; . Группа захвата, которую вы ищете, - &lt;code&gt;ELEMENTNAME&lt;/code&gt; . Если группа захвата &lt;code&gt;ERROR&lt;/code&gt; не пуста, то произошла ошибка синтаксического анализа, и регулярное выражение остановилось.</target>
        </trans-unit>
        <trans-unit id="42afcd3eb11823b2c3d7a0e945433e5d9be383b6" translate="yes" xml:space="preserve">
          <source>The parts explained:</source>
          <target state="translated">Части объяснили:</target>
        </trans-unit>
        <trans-unit id="7b1c98adf4b68d1b5b5505c62c8cdcb98c54e922" translate="yes" xml:space="preserve">
          <source>The pattern will be pretty big, so make sure you have an algorithm that losslessly compresses random data.</source>
          <target state="translated">Шаблон будет довольно большим,поэтому убедитесь,что у вас есть алгоритм,который без потерь сжимает случайные данные.</target>
        </trans-unit>
        <trans-unit id="7216ec9c43638b3c7e394bf44fd4c73431e98cef" translate="yes" xml:space="preserve">
          <source>The suggested regex is wrong, though:</source>
          <target state="translated">Однако предложенный регекс неверен:</target>
        </trans-unit>
        <trans-unit id="9a7f6c57efe365adfc81358edd4c2317e716adc0" translate="yes" xml:space="preserve">
          <source>The tag to match may end with a simple &quot;&amp;gt;&quot; symbol, or a possible XHTML closure, which makes use of the slash before it: (/&amp;gt;|&amp;gt;). The slash is, of course, escaped since it coincides with the regular expression delimiter.</source>
          <target state="translated">Соответствующий тег может заканчиваться простым символом &amp;laquo;&amp;gt;&amp;raquo; или возможным закрытием XHTML, которое использует косую черту перед ним: (/&amp;gt; |&amp;gt;). Косая черта, конечно, экранирована, поскольку она совпадает с разделителем регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="d8320be450cb3daac23d24918c511589e5cc20d4" translate="yes" xml:space="preserve">
          <source>The user @ridgerunner noticed that the pattern does not allow &lt;strong&gt;unquoted attributes&lt;/strong&gt; or &lt;strong&gt;attributes with no value&lt;/strong&gt;. In this case a fine tuning brings us the following pattern:</source>
          <target state="translated">Пользователь @ridgerunner заметил, что шаблон не допускает &lt;strong&gt;атрибутов без&lt;/strong&gt; кавычек или &lt;strong&gt;атрибутов без значения&lt;/strong&gt; . В этом случае тонкая настройка приносит нам следующую схему:</target>
        </trans-unit>
        <trans-unit id="96ae70a6ef53719f5c2ee204876a53bf013a8cbd" translate="yes" xml:space="preserve">
          <source>Then, since a tag may end with a whitespace before the &quot;&amp;gt;&quot; symbol, zero or more whitespaces are matched with the \s* subpattern.</source>
          <target state="translated">Затем, поскольку тег может заканчиваться пробелом перед символом &quot;&amp;gt;&quot;, ноль или более пробелов сопоставляются с подшаблоном \ s *.</target>
        </trans-unit>
        <trans-unit id="868220302ade7af78023c7b85a0b0afbdb075b65" translate="yes" xml:space="preserve">
          <source>There are people that will tell you that Regular Expressions shouldn't be recursive. They are limiting you. They need to subjugate you, and they do it by keeping you in ignorance.</source>
          <target state="translated">Есть люди,которые скажут вам,что регулярные выражения не должны быть рекурсивными.Они ограничивают тебя.Им нужно подчинить тебя,и они делают это,держа тебя в неведении.</target>
        </trans-unit>
        <trans-unit id="62180d2f49459a045257d1d5b700900365c68916" translate="yes" xml:space="preserve">
          <source>There are people that will tell you that the Earth is round (or perhaps that the Earth is an oblate spheroid if they want to use strange words). They are lying.</source>
          <target state="translated">Есть люди,которые скажут вам,что Земля круглая (или,возможно,что Земля является областью сфероида,если они хотят использовать странные слова).Они лгут.</target>
        </trans-unit>
        <trans-unit id="684dfff1de896a122d012445ef544b2496206f87" translate="yes" xml:space="preserve">
          <source>There are some nice regexes for replacing HTML with BBCode &lt;a href=&quot;http://www.garyshood.com/htmltobb/source.txt&quot;&gt;here&lt;/a&gt;. For all you nay-sayers, note that he's not trying to fully parse HTML, just to sanitize it. He can probably afford to kill off tags that his simple &quot;parser&quot; can't understand.</source>
          <target state="translated">Здесь есть несколько хороших регулярных выражений для замены HTML на BBCode. Обратите внимание, что для всех вас, кто говорит &amp;laquo;нет&amp;raquo;, он не пытается полностью разобрать HTML-код, а просто очищает его. Вероятно, он может позволить себе убивать теги, которые его простой &amp;laquo;парсер&amp;raquo; не может понять.</target>
        </trans-unit>
        <trans-unit id="76477d9fdddcc475f5d450550d80b052eec3964d" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;http://blog.stevenlevithan.com/archives/match-innermost-html-element&quot;&gt;definitive blog post&lt;/a&gt; about matching innermost HTML elements written by Steven Levithan.</source>
          <target state="translated">В &lt;a href=&quot;http://blog.stevenlevithan.com/archives/match-innermost-html-element&quot;&gt;блоге&lt;/a&gt; есть подробное сообщение о сопоставлении самых внутренних элементов HTML, написанное Стивеном Левитаном.</target>
        </trans-unit>
        <trans-unit id="a4e1c0773bdde0557a23f8bb7011bb1819bc446f" translate="yes" xml:space="preserve">
          <source>These constructs allow for a .NET regular expression to emulate a
  restricted PDA by essentially allowing simple versions of the stack
  operations: push, pop and empty. The simple operations are pretty much
  equivalent to increment, decrement and compare to zero respectively.
  This allows for the .NET regular expression engine to recognize a
  subset of the context-free languages, in particular the ones that only
  require a simple counter. This in turn allows for the non-traditional
  .NET regular expressions to recognize individual properly balanced
  constructs.</source>
          <target state="translated">Эти конструкции позволяют регулярному выражению .NET эмулировать ограниченный КПК,позволяя,по сути,простые версии операций со стеком:push,pop и empty.Простые операции практически эквивалентны инкременту,декременту и сравнению с нулем соответственно.Это позволяет движку регулярных выражений .NET распознавать подмножество бесконтекстных языков,в частности те,которым требуется только простой счетчик.Это,в свою очередь,позволяет нетрадиционным регулярным выражениям .NET распознавать отдельные правильно сбалансированные конструкции.</target>
        </trans-unit>
        <trans-unit id="83ac605b777d6f693f2b21254eb270d567a76728" translate="yes" xml:space="preserve">
          <source>They are good for XML / XHTML.</source>
          <target state="translated">Они хороши для XML XHTML.</target>
        </trans-unit>
        <trans-unit id="ea04181710e1449f97e72ce6888abc9705be60aa" translate="yes" xml:space="preserve">
          <source>This found the match:</source>
          <target state="translated">Это нашло совпадение:</target>
        </trans-unit>
        <trans-unit id="bbe32d2a62e217c596147afa1c643ecf26c036ca" translate="yes" xml:space="preserve">
          <source>This is the regex I use (!) to match HTML tags:</source>
          <target state="translated">Это регекс,который я использую (!)для соответствия HTML-тегов:</target>
        </trans-unit>
        <trans-unit id="d8d8d6a39df8c08ee1ff1787d57aba7ddbd1bee3" translate="yes" xml:space="preserve">
          <source>This post is locked to prevent inappropriate edits to its content. The post looks exactly as it is supposed to look - there are no problems with its content. Please do not flag it for our attention.</source>
          <target state="translated">Это сообщение заблокировано,чтобы предотвратить некорректное редактирование его содержимого.Сообщение выглядит именно так,как и должно выглядеть-никаких проблем с его содержанием нет.Пожалуйста,не обращайте на него внимания.</target>
        </trans-unit>
        <trans-unit id="20cb5dd39a077afa5b7e29efe1aa539dad4031b6" translate="yes" xml:space="preserve">
          <source>To test it deeply, I entered in the string auto-closing tags like:</source>
          <target state="translated">Чтобы проверить это глубоко,я ввел в строку теги автозакрытия типа:</target>
        </trans-unit>
        <trans-unit id="102acb4ebe4f9295900af5f522c91830395377c0" translate="yes" xml:space="preserve">
          <source>Try:</source>
          <target state="translated">Try:</target>
        </trans-unit>
        <trans-unit id="a26ac4a7ee00f2bdbb69b3a7cd21e43c2ce7b858" translate="yes" xml:space="preserve">
          <source>Turing.sed</source>
          <target state="translated">Turing.sed</target>
        </trans-unit>
        <trans-unit id="a28f42522bb52c00621284c63c8ba53d7dfda10f" translate="yes" xml:space="preserve">
          <source>UNRELATED</source>
          <target state="translated">UNRELATED</target>
        </trans-unit>
        <trans-unit id="e8d3e730d87ce69a125b79edeeb87c6e997fdfb7" translate="yes" xml:space="preserve">
          <source>Understanding the pattern</source>
          <target state="translated">Понимание закономерностей</target>
        </trans-unit>
        <trans-unit id="ada5ca9b4d7507ffcf81b9659577ff9cbe1d1ccf" translate="yes" xml:space="preserve">
          <source>Use the flags:</source>
          <target state="translated">Используйте флаги:</target>
        </trans-unit>
        <trans-unit id="24df9df6515abc09f921403db3f2eb9d44796515" translate="yes" xml:space="preserve">
          <source>W3C Link</source>
          <target state="translated">W3C-ссылка</target>
        </trans-unit>
        <trans-unit id="01acb4cbe019ba6b6ce6e22bcd09638b1774d9c8" translate="yes" xml:space="preserve">
          <source>Whenever I need to quickly extract something from an HTML document, I use Tidy to convert it to XML and then use XPath or XSLT to get what I need.
In your case, something like this:</source>
          <target state="translated">Всякий раз,когда мне нужно быстро извлечь что-то из HTML-документа,я использую Tidy,чтобы преобразовать его в XML,а затем использую XPath или XSLT,чтобы получить то,что мне нужно.В вашем случае,что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="49b8872857a1e031d0578f467b1e399793cd9b96" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;(?&amp;lt;! ... )&lt;/code&gt; is (in Perl regexes) the negative look-behind. It reads &quot;a &amp;lt;, then a word, then anything that's not a &amp;gt;, the last of which may not be a /, followed by &amp;gt;&quot;.</source>
          <target state="translated">Где &lt;code&gt;(?&amp;lt;! ... )&lt;/code&gt; (в регулярных выражениях Perl) отрицательный взгляд. Он читает &amp;laquo;a &amp;lt;, затем слово, затем все, что не является&amp;gt;, последний из которых не может быть /, а затем&amp;gt;&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d88b6a634389ee3ca966ecac67f70a5331dc8d96" translate="yes" xml:space="preserve">
          <source>While &lt;em&gt;arbitrary&lt;/em&gt; HTML with only a regex is impossible, it's sometimes appropriate to use them for parsing a &lt;em&gt;limited, known&lt;/em&gt; set of HTML.</source>
          <target state="translated">В то время как &lt;em&gt;произвольный&lt;/em&gt; HTML с одним регулярным выражением невозможен, иногда целесообразно использовать их для анализа &lt;em&gt;ограниченного, известного&lt;/em&gt; набора HTML.</target>
        </trans-unit>
        <trans-unit id="b1bfbd9fe61d2ecc1e2a19393a476e7388bf0166" translate="yes" xml:space="preserve">
          <source>While the answers that you can't parse HTML with regexes are correct, they don't apply here. The OP just wants to parse one HTML tag with regexes, and that is something that can be done with a regular expression.</source>
          <target state="translated">Хотя ответы,которые вы не можете разобрать HTML с помощью регексов,правильные,они не применяются здесь.Операционная система просто хочет разобрать один HTML-тег с помощью регексов,и это можно сделать с помощью регулярного выражения.</target>
        </trans-unit>
        <trans-unit id="93249a5d51a2ea1bf181a9d0b47641aa389e6924" translate="yes" xml:space="preserve">
          <source>With minor variations, it can cope with messy HTML... or convert the HTML -&amp;gt; XHTML first.</source>
          <target state="translated">С небольшими изменениями, он может справиться с грязным HTML ... или сначала преобразовать HTML -&amp;gt; XHTML.</target>
        </trans-unit>
        <trans-unit id="86912b1a63422276d3fb2e364ae480edfb2fc529" translate="yes" xml:space="preserve">
          <source>Work out the Traveling Salesman Problem in O(log n) or less. If it's any more than that, you'll run out of RAM and the engine will hang.</source>
          <target state="translated">Разработайте проблему Путешествующего продавца в O(log n)или менее.Если это что-то большее,то у вас закончится оперативная память и движок зависнет.</target>
        </trans-unit>
        <trans-unit id="865301223dfe7d72c3b014a14a4edf685de64f15" translate="yes" xml:space="preserve">
          <source>Write HTML parser (homework)</source>
          <target state="translated">Напишите парсер HTML (домашнее задание)</target>
        </trans-unit>
        <trans-unit id="99b34e00427c7bc9e27cce20b1b8167ea540549e" translate="yes" xml:space="preserve">
          <source>You can live in their reality or take the red pill.</source>
          <target state="translated">Вы можете жить в их реальности или принять красную таблетку.</target>
        </trans-unit>
        <trans-unit id="a6a9711b57d9a5eea84e16f2d7ce057f02584407" translate="yes" xml:space="preserve">
          <source>You can try this at &lt;a href=&quot;http://derekslager.com/blog/posts/2007/09/a-better-dotnet-regular-expression-tester.ashx&quot;&gt;A Better .NET Regular Expression Tester&lt;/a&gt;.</source>
          <target state="translated">Вы можете попробовать это в &lt;a href=&quot;http://derekslager.com/blog/posts/2007/09/a-better-dotnet-regular-expression-tester.ashx&quot;&gt;A Better .NET Regular Expression Tester&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b81d0ffa357688587ac76745c399587c1efb48a" translate="yes" xml:space="preserve">
          <source>You can't parse [X]HTML with regex. Because HTML can't be parsed by regex. Regex is not a tool that can be used to correctly parse HTML. As I have answered in HTML-and-regex questions here so many times before, the use of regex will not allow you to consume HTML. Regular expressions are a tool that is insufficiently sophisticated to understand the constructs employed by HTML. HTML is not a regular language and hence cannot be parsed by regular expressions. Regex queries are not equipped to break down HTML into its meaningful parts. so many times but it is not getting to me. Even enhanced irregular regular expressions as used by Perl are not up to the task of parsing HTML. You will never make me crack. HTML is a language of sufficient complexity that it cannot be parsed by regular expressions. Even Jon Skeet cannot parse HTML using regular expressions. Every time you attempt to parse HTML with regular expressions, the unholy child weeps the blood of virgins, and Russian hackers pwn your webapp. Parsing HTML with regex summons tainted souls into the realm of the living. HTML and regex go together like love, marriage, and ritual infanticide. The &amp;lt;center&amp;gt; cannot hold it is too late. The force of regex and HTML together in the same conceptual space will destroy your mind like so much watery putty. If you parse HTML with regex you are giving in to Them and their blasphemous ways which doom us all to inhuman toil for the One whose Name cannot be expressed in the Basic Multilingual Plane, he comes. HTML-plus-regexp will liquify the n​erves of the sentient whilst you observe, your psyche withering in the onslaught of horror. Rege̿̔̉x-based HTML parsers are the cancer that is killing StackOverflow</source>
          <target state="translated">Вы не можете разобрать [X] HTML с регулярным выражением. Потому что HTML не может быть проанализирован с помощью регулярных выражений. Regex - это не инструмент, который можно использовать для правильного разбора HTML. Как я уже много раз отвечал на вопросы HTML-и-регулярных выражений здесь, использование регулярных выражений не позволит вам использовать HTML. Регулярные выражения - это инструмент, который недостаточно сложен, чтобы понимать конструкции, используемые HTML. HTML не является регулярным языком и, следовательно, не может быть проанализирован с помощью регулярных выражений. Запросы Regex не оборудованы для разбиения HTML на его значимые части. так много раз, но это не до меня. Даже расширенные нерегулярные регулярные выражения, используемые Perl, не справляются с задачей анализа HTML. Ты никогда не заставишь меня взломать. HTML - это язык достаточной сложности, который не может быть проанализирован регулярными выражениями. Даже Джон Скит не может анализировать HTML с помощью регулярных выражений. Каждый раз, когда вы пытаетесь разобрать HTML с помощью регулярных выражений, нечестивый ребенок плачет кровью девственниц, а русские хакеры набивают ваше веб-приложение. Разбор HTML с помощью регулярных выражений вызывает испорченные души в мир живых. HTML и регулярные выражения идут вместе, как любовь, брак и ритуальное детоубийство. &amp;lt;Центр&amp;gt; не может удержать это слишком поздно. Сила регулярных выражений и HTML в одном и том же концептуальном пространстве разрушит ваш разум, словно водянистая замазка. Если вы анализируете HTML с помощью регулярных выражений, вы уступаете им и их богохульным путям, которые обрекают нас всех на нечеловеческий труд для Того, чье Имя не может быть выражено на Основном Многоязычном Плане, он придет. HTML-plus-regexp будет разжижать нервы чувствующего, пока вы наблюдаете, как ваша психика увядает в страхе. HTML-парсеры на основе Rege̿̔̉x - это рак, который убивает StackOverflow</target>
        </trans-unit>
        <trans-unit id="d4cc5878bfc8de446a816e62a10b477bf7628da8" translate="yes" xml:space="preserve">
          <source>You want the first &lt;code&gt;&amp;gt;&lt;/code&gt; not preceded by a &lt;code&gt;/&lt;/code&gt;.  Look &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;here&lt;/a&gt; for details on how to do that.  It's referred to as negative lookbehind.</source>
          <target state="translated">Вы хотите, чтобы первый &lt;code&gt;&amp;gt;&lt;/code&gt; не предшествовал &lt;code&gt;/&lt;/code&gt; . Посмотрите &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;здесь&lt;/a&gt; для получения подробной информации о том, как это сделать. Это называется негативным взглядом сзади.</target>
        </trans-unit>
        <trans-unit id="0f094d4f9e70b554306ad025350bec42add64291" translate="yes" xml:space="preserve">
          <source>a&lt;sup&gt;n&lt;/sup&gt;ba&lt;sup&gt;n&lt;/sup&gt;ba&lt;sup&gt;n&lt;/sup&gt; which is not regular and not even context free, can be matched with &lt;code&gt;^(a+)b\1b\1$&lt;/code&gt;</source>
          <target state="translated">a &lt;sup&gt;n&lt;/sup&gt; ba &lt;sup&gt;n&lt;/sup&gt; ba &lt;sup&gt;n,&lt;/sup&gt; который не является регулярным и даже не содержит контекстов, можно сопоставить с &lt;code&gt;^(a+)b\1b\1$&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f7db1a41076f29a8bc513a82d4eeb79c22c4b29" translate="yes" xml:space="preserve">
          <source>according to the specific implementation of the RegExp engine, recursion may have a limit in the &lt;strong&gt;number of nested patterns parsed&lt;/strong&gt;, but it depends on the language used</source>
          <target state="translated">в соответствии с конкретной реализацией механизма RegExp, рекурсия может иметь ограничение на &lt;strong&gt;количество анализируемых вложенных шаблонов&lt;/strong&gt; , но это зависит от используемого языка.</target>
        </trans-unit>
        <trans-unit id="c4d4e32662c88b8424d1c0984fceefe61e4e23a5" translate="yes" xml:space="preserve">
          <source>again, zero or more whitespaces</source>
          <target state="translated">опять же,ноль или больше белых пробелов</target>
        </trans-unit>
        <trans-unit id="416344de81011e88293f4de90995d2f4eb4cfe70" translate="yes" xml:space="preserve">
          <source>ain, the song of re̸gular exp​re&lt;strike&gt;ssion parsing &lt;/strike&gt;will exti</source>
          <target state="translated">песня регулярного &lt;strike&gt;выражения&lt;/strike&gt; будет</target>
        </trans-unit>
        <trans-unit id="dac38d2a71b13841b4f7fa59c2cbb41d8f4fe7c5" translate="yes" xml:space="preserve">
          <source>although corrupted (x)HTML does not drive into severe errors, it is not &lt;em&gt;sanitized&lt;/em&gt;.</source>
          <target state="translated">хотя поврежденный (x) HTML не приводит к серьезным ошибкам, он не &lt;em&gt;очищается&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b2c0c9e8369c247831710c647b81dda3b5b625b1" translate="yes" xml:space="preserve">
          <source>although it actually came out like this:</source>
          <target state="translated">хотя на самом деле все вышло вот так:</target>
        </trans-unit>
        <trans-unit id="b91f3e1f4b4ae9ba5a969df90fc854016c1cfedf" translate="yes" xml:space="preserve">
          <source>and the dread realm of c͒ͪo͛ͫrrupt entities (like SGML entities, but</source>
          <target state="translated">и царство страха c͒ͪo͛ͫrrupt сущностей (например,сущностей SGML,но</target>
        </trans-unit>
        <trans-unit id="789d3b546d80c656a137d6a2dae501ef948c9936" translate="yes" xml:space="preserve">
          <source>attributes containing single quotes when the delimiter is a double quote and vice versa</source>
          <target state="translated">атрибуты,содержащие одиночные кавычки,когда разделитель является двойной кавычкой,и наоборот</target>
        </trans-unit>
        <trans-unit id="83049ba02543c5468a7092d704e728351f015ce0" translate="yes" xml:space="preserve">
          <source>attributes which value is bound either into &lt;strong&gt;single quotes&lt;/strong&gt; or into &lt;strong&gt;double quotes&lt;/strong&gt;</source>
          <target state="translated">атрибуты, значение которых связано либо в &lt;strong&gt;одинарные кавычки,&lt;/strong&gt; либо в &lt;strong&gt;двойные кавычки&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="872af077bba705c60415b90068389b0d9ae136b2" translate="yes" xml:space="preserve">
          <source>ch between this world</source>
          <target state="translated">между нами</target>
        </trans-unit>
        <trans-unit id="b1ccf8aca583f64c44e6498a0abc71300cee934c" translate="yes" xml:space="preserve">
          <source>d of ceaseless screaming, he comes&lt;strike&gt;, the pestilent sl&lt;/strike&gt;ithy regex-infection wil​&lt;b&gt;l devour your HT&lt;/b&gt;​ML parser, application and existence for all time like Visual Basic only worse</source>
          <target state="translated">Придя к непрекращающемуся крику, он приходит &lt;strike&gt;,&lt;/strike&gt; ядовитая, слабая регулярная инфекция, &lt;b&gt;пожрет ваш&lt;/b&gt; парсер &lt;b&gt;HT&lt;/b&gt; ML, приложение и существование на все времена, как Visual Basic, только хуже</target>
        </trans-unit>
        <trans-unit id="fad2a06a8e728d64f3eff45851e3b600bd2bf437" translate="yes" xml:space="preserve">
          <source>dear lord help us how can anyone survive this scourge</source>
          <target state="translated">Дорогой Господь,помоги нам,как кто-нибудь может пережить это бедствие.</target>
        </trans-unit>
        <trans-unit id="5b52a1cb49381cdd269797b153d0660ee9133944" translate="yes" xml:space="preserve">
          <source>do not fi</source>
          <target state="translated">не стрелять</target>
        </trans-unit>
        <trans-unit id="b9dea77ba556480de7588671f4a3d44f039e5d2e" translate="yes" xml:space="preserve">
          <source>e pon̷y he come</source>
          <target state="translated">e pon̷y он приходит</target>
        </trans-unit>
        <trans-unit id="09cd68a2a77b22a312dded612dd0d9988685189f" translate="yes" xml:space="preserve">
          <source>es</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="707cd90a4f77675613cc63dfa16b29bedcf7d2e6" translate="yes" xml:space="preserve">
          <source>es al</source>
          <target state="translated">эс-аль</target>
        </trans-unit>
        <trans-unit id="16829609b87ebecff7cb40016842539439ef333f" translate="yes" xml:space="preserve">
          <source>e̠̅s&lt;code&gt; ͎a̧͈͖r̽̾̈́͒͑e&lt;/code&gt; n&lt;b&gt;​ot rè̑ͧ̌aͨl̘̝̙̃ͤ͂̾̆ ZA̡͊͠͝LGΌ ISͮ̂҉̯͈͕̹̘̱ T&lt;/b&gt;O͇̹̺ͅƝ̴ȳ̳ TH̘&lt;b&gt;Ë͖́̉ ͠P̯͍̭O̚​N̐Y̡ H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝&lt;/b&gt;S̨̥̫͎̭ͯ̿̔̀ͅ</source>
          <target state="translated">e̠̅s &lt;code&gt; ͎a̧͈͖r̽̾̈́͒͑e&lt;/code&gt; n &lt;b&gt;от r&amp;egrave;̑ͧ̌aͨl̘̝̙̃ͤ͂̾̆ ZA̡͊͠͝LGΌ ISͮ̂҉̯͈͕̹̘̱ T&lt;/b&gt; O͇̹̺ͅƝ̴ȳ̳ TH̘ &lt;b&gt;&amp;Euml;͖́̉ ͠P̯͍̭O̚ N̐Y̡ H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝&lt;/b&gt; S̨̥̫͎̭ͯ̿̔̀ͅ</target>
        </trans-unit>
        <trans-unit id="0a971adf10fafe8fe3d724d80e0beaa10f271291" translate="yes" xml:space="preserve">
          <source>f the lie​&lt;b&gt;s of Man ALL IS LOŚ͖̩͇̗̪̏̈́T A&lt;/b&gt;</source>
          <target state="translated">из лжи &lt;b&gt;человека все есть&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6c0c535eae65a352e21a597046b9c71062ef7e32" translate="yes" xml:space="preserve">
          <source>he an​*̶͑̾̾​̅ͫ͏̙̤g͇̫͛͆̾ͫ̑͆l͖͉̗̩̳̟̍ͫͥͨ</source>
          <target state="translated">он*̶͑̾̾̅ͫ͏̙̤g͇̙͖͉̩̳̟̗̗͆͛͆̾ͫ̑ͨ̍ͫͥ.</target>
        </trans-unit>
        <trans-unit id="21f7c212343db1452bf1005fe7bec61697f3efef" translate="yes" xml:space="preserve">
          <source>he comes he com</source>
          <target state="translated">он приходит,он приходит</target>
        </trans-unit>
        <trans-unit id="c1b6858eae6b82f5a342bbfcd9d5505ae8d8b304" translate="yes" xml:space="preserve">
          <source>he f&lt;code&gt;inal snuf&lt;/code&gt;fing o</source>
          <target state="translated">он все &lt;code&gt;inal snuf&lt;/code&gt; нюхает</target>
        </trans-unit>
        <trans-unit id="cba0af89feed0e8e942fec8ed4c10695745c757d" translate="yes" xml:space="preserve">
          <source>here comes the fun: the \4 part is a &lt;strong&gt;backreference operator&lt;/strong&gt;, which refers to a sub-expression defined before in the pattern, in this case, I am referring to the fourth sub-expression, which is the first attribute delimiter found</source>
          <target state="translated">тут самое интересное: часть \ 4 является &lt;strong&gt;оператором обратной&lt;/strong&gt; ссылки, который ссылается на &lt;strong&gt;подвыражение&lt;/strong&gt; , определенное ранее в шаблоне, в данном случае я имею в виду четвертое подвыражение, которое является первым найденным разделителем атрибута</target>
        </trans-unit>
        <trans-unit id="a8ec278d2e709b878840d59f0dc4611cd1bb49d5" translate="yes" xml:space="preserve">
          <source>it is too late it is too late we cannot be saved</source>
          <target state="translated">Слишком поздно,слишком поздно,мы не можем быть спасены.</target>
        </trans-unit>
        <trans-unit id="a38cb8457436d320aa6e6a447ea6ac270b0eb2aa" translate="yes" xml:space="preserve">
          <source>l MY FAC</source>
          <target state="translated">l МОЙ КОД</target>
        </trans-unit>
        <trans-unit id="eb912827300bfa09ffaae9a61a04131d928f17d2" translate="yes" xml:space="preserve">
          <source>more corrupt) a mere glimp</source>
          <target state="translated">более коррумпированный)простой проблеск</target>
        </trans-unit>
        <trans-unit id="5a4bedc53d646eb4f152665ce04f194f119d1230" translate="yes" xml:space="preserve">
          <source>more than one attribute</source>
          <target state="translated">не один признак</target>
        </trans-unit>
        <trans-unit id="0f0f39e938eb9a6927af1fd3169cbf5dc39c8c05" translate="yes" xml:space="preserve">
          <source>nto a w</source>
          <target state="translated">nto a w</target>
        </trans-unit>
        <trans-unit id="f676ebbcb5a6de68fd4cd64947f2f073b0bc183b" translate="yes" xml:space="preserve">
          <source>one attribute</source>
          <target state="translated">один признак</target>
        </trans-unit>
        <trans-unit id="b63094eb585e278a2a9faac15421a9c3b8a73f5d" translate="yes" xml:space="preserve">
          <source>one or more whitespaces \s+</source>
          <target state="translated">один или несколько белых пробелов \s+</target>
        </trans-unit>
        <trans-unit id="a4f0099e46341d0fc7c083fc51657b45fb1eb61a" translate="yes" xml:space="preserve">
          <source>or just combine if and if not.</source>
          <target state="translated">или просто объединить,если и если нет.</target>
        </trans-unit>
        <trans-unit id="90255a902e3a09b87ea94d0074d32fa53f1e3df0" translate="yes" xml:space="preserve">
          <source>orl</source>
          <target state="translated">orl</target>
        </trans-unit>
        <trans-unit id="5beefb69787012b543ff81b246c6096ef31b16cb" translate="yes" xml:space="preserve">
          <source>rogrammer's consciousness i</source>
          <target state="translated">сознание Рограмера i</target>
        </trans-unit>
        <trans-unit id="a529326c3bc272f1c87faf0fc168c3f2b888e5e1" translate="yes" xml:space="preserve">
          <source>s he c̶̮om&lt;strike&gt;es he co&lt;/strike&gt;&lt;b&gt;&lt;strike&gt;me&lt;/strike&gt;s t&lt;i&gt;he&lt;/i&gt; ich​&lt;/b&gt;or permeat</source>
          <target state="translated">если он придет &lt;strike&gt;ко&lt;/strike&gt; &lt;b&gt;&lt;strike&gt;мне,&lt;/strike&gt; &lt;i&gt;он&lt;/i&gt; или он&lt;/b&gt; проникнет</target>
        </trans-unit>
        <trans-unit id="cdc9e9914e559a22d8c2863df88dcc0affd254bb" translate="yes" xml:space="preserve">
          <source>se of the world of reg​&lt;b&gt;ex parsers for HTML will ins&lt;/b&gt;​tantly transport a p</source>
          <target state="translated">Сам по себе мир &lt;b&gt;парсеров&lt;/b&gt; reg ex &lt;b&gt;для HTML будет по-настоящему&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fcd31f61fdd2492a68c910cd84210be08c96a97c" translate="yes" xml:space="preserve">
          <source>stro҉ying all enli̍̈́̂̈́ghtenment, HTML tags &lt;b&gt;lea͠ki̧n͘g fr̶ǫm ̡yo​͟ur eye͢s̸ ̛l̕ik͏e liq&lt;/b&gt;​uid p</source>
          <target state="translated">подчеркивая все, HTML теги &lt;b&gt;lea͠ki̧n͘g fr̶ǫm ̡yo ͟ur eye͢s̸ ̛l̕ik͏e liq&lt;/b&gt; uid p</target>
        </trans-unit>
        <trans-unit id="13cecb0242cc098120804e419e2c0898d7c5f3d9" translate="yes" xml:space="preserve">
          <source>the &quot;=&quot; symbol</source>
          <target state="translated">символ &quot;=&quot;</target>
        </trans-unit>
        <trans-unit id="ef1ddac3121c15757add5489d19c276fcda4e43f" translate="yes" xml:space="preserve">
          <source>the attribute sub-expression ends here, with the specification of zero or more possible occurrences, given by the asterisk.</source>
          <target state="translated">на этом подвыражение атрибута заканчивается спецификацией нуля или более возможных вхождений,отмеченных звездочкой.</target>
        </trans-unit>
        <trans-unit id="9fb82ad748ee217a3d8676ebffa5f977ad107e1b" translate="yes" xml:space="preserve">
          <source>the delimiter of the attribute value, a single or double quote ('|&quot;). In the pattern, the single quote is escaped because it coincides with the PHP string delimiter. This sub-expression is captured with the parentheses so it can be referenced again to parse the closure of the attribute, that's why it is very important.</source>
          <target state="translated">&quot;).In the pattern,the single quote is escaped because it coincides with the PHP string delimiter.This sub-expression is captured with the parentheses so it can be referenced again to parse the closure of the attribute,that's why it is very important.</target>
        </trans-unit>
        <trans-unit id="bf47c953b6d49b59cea7ef6e949bcd244312ad84" translate="yes" xml:space="preserve">
          <source>the first sub-expression (\w+) matches the tag name</source>
          <target state="translated">первое подвыражение (\w+)совпадает с именем тега.</target>
        </trans-unit>
        <trans-unit id="8ff32fe1a0c4d2f2143244e76a1ea25a84d0a50e" translate="yes" xml:space="preserve">
          <source>the name of the attribute (\w+)</source>
          <target state="translated">имя атрибута (\w+).</target>
        </trans-unit>
        <trans-unit id="a63f6d3ba68d8159445680753d6b7dcfea330647" translate="yes" xml:space="preserve">
          <source>the second sub-expression contains the pattern of an attribute. It is composed by:</source>
          <target state="translated">второе подвыражение содержит шаблон атрибута.Он состоит из:</target>
        </trans-unit>
        <trans-unit id="98c53a01bc3d612ea14d5657a8251e38b47274e3" translate="yes" xml:space="preserve">
          <source>the trangession of a chi͡ld ensures regex will consume all living tissue (except for HTML which it cannot, as previously prophesied)</source>
          <target state="translated">переход chi͡ld гарантирует,что регекс будет поглощать все живые ткани (за исключением HTML,который он не может,как было предсказано ранее).</target>
        </trans-unit>
        <trans-unit id="fcae9afa44c8d009bc39cd1558b5bcceb178f9f3" translate="yes" xml:space="preserve">
          <source>the value of the attribute, matched by &lt;em&gt;almost&lt;/em&gt; anything: (.*?); in this specific syntax, using the &lt;strong&gt;greedy match&lt;/strong&gt; (the question mark after the asterisk) the RegExp engine enables a &quot;look-ahead&quot;-like operator, which matches anything but what follows this sub-expression</source>
          <target state="translated">значение атрибута, сопоставляемого &lt;em&gt;практически с&lt;/em&gt; чем угодно: (. *?); в этом специфическом синтаксисе, используя &lt;strong&gt;жадное совпадение&lt;/strong&gt; (знак вопроса после звездочки), механизм RegExp включает оператор, похожий на &amp;laquo;упреждающий&amp;raquo;, который сопоставляет что угодно, кроме того, что следует за этим подвыражением</target>
        </trans-unit>
        <trans-unit id="e8cdc833b2aa479524c91f0c0770ca55cab15dbc" translate="yes" xml:space="preserve">
          <source>using rege</source>
          <target state="translated">с использованием ригеля</target>
        </trans-unit>
        <trans-unit id="05316c08fdd253a1c9a83c01ccb3802a454fbc33" translate="yes" xml:space="preserve">
          <source>using regex to parse HTML has doomed humanity to an eternity of dread torture and security holes</source>
          <target state="translated">использование регекса для разбора HTML обрекает человечество на вечность страшных пыток и дыр в безопасности.</target>
        </trans-unit>
        <trans-unit id="ab44de7440b2ebdde8558b36f16d5f922c19d2d5" translate="yes" xml:space="preserve">
          <source>x as a tool to process HTML establishes a brea</source>
          <target state="translated">x в качестве инструмента для обработки HTML устанавливает бреа</target>
        </trans-unit>
        <trans-unit id="7f524dcbd593bece540d29aea0353dc495423551" translate="yes" xml:space="preserve">
          <source>zero or more whitespaces \s*</source>
          <target state="translated">нулевой или более белых пробельных символов \s*.</target>
        </trans-unit>
        <trans-unit id="9bdd5426b4b4fdd866ac9851215bf267b6e6df44" translate="yes" xml:space="preserve">
          <source>zero or more whitespaces \s* (it is possible or not, leaving blanks here)</source>
          <target state="translated">ноль или больше белых пробелов \s*(это возможно или нет,оставляя здесь пробелы)</target>
        </trans-unit>
        <trans-unit id="1b249f9d22bd1bda62f373b04cdb08126b054557" translate="yes" xml:space="preserve">
          <source>​ght h&lt;b&gt;e com̡e̶s, ̕h̵i&lt;/b&gt;​s un̨ho͞ly radiańcé de</source>
          <target state="translated">&lt;b&gt;Что он делает&lt;/b&gt; ? Он не только радианец</target>
        </trans-unit>
        <trans-unit id="87484f6cbcd5c18c6c4b093d13bc9f9ee13c577f" translate="yes" xml:space="preserve">
          <source>​nguish the voices of mor​&lt;b&gt;tal man from the sp&lt;/b&gt;​here I can see it can you see ̲͚̖͔̙î̩́t̲͎̩̱͔́̋̀ it is beautiful t​</source>
          <target state="translated">Укроти голоса мортальца &lt;b&gt;из sp&lt;/b&gt; здесь я вижу это ты видишь ̲͚̖͔̙&amp;icirc;̩́t̲͎̩̱͔́̋̀ это красиво т</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
