<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1732348">
    <body>
      <group id="1732348">
        <trans-unit id="ccd2e00de6a7833dd11d2079f5b5b099a6e04da7" translate="yes" xml:space="preserve">
          <source>&quot;unpretty&quot; attributes with a space before the &quot;=&quot; symbol, after it and both before and after it.</source>
          <target state="translated">&quot;=&quot;기호 앞뒤에 공백이있는 &quot;정확하지 않은&quot;속성.</target>
        </trans-unit>
        <trans-unit id="392ad88b0cb34d87fa7d4457a6637b91ceafc10b" translate="yes" xml:space="preserve">
          <source>&amp;lt;br&amp;gt;</source>
          <target state="translated">&amp;lt;br&amp;gt;</target>
        </trans-unit>
        <trans-unit id="50709f0c2fc769b8029465696613cd45319835fb" translate="yes" xml:space="preserve">
          <source>&amp;lt;br/&amp;gt;</source>
          <target state="translated">&amp;lt;br/&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ecfb18e3fd89ce3fed2c8046ff8dc43d3ee45bbf" translate="yes" xml:space="preserve">
          <source>&amp;lt;hr /&amp;gt;</source>
          <target state="translated">&amp;lt;시간 /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3239efc545dfa4f75dc0905c388a28a61c34c974" translate="yes" xml:space="preserve">
          <source>(Take care, in that note I wrongly used the &quot;m&quot; modifier; it should be erased, notwithstanding it is discarded by the RegExp engine, since no ^ or $ anchorage was used).</source>
          <target state="translated">(주의 사항에 따르면 &quot;m&quot;수정자를 잘못 사용했습니다. ^ 또는 $ 앵커리지가 사용되지 않았기 때문에 RegExp 엔진에 의해 버려지더라도 지워 져야합니다.)</target>
        </trans-unit>
        <trans-unit id="a8662e799cce40f7a10db5f20413cbc30727a2b7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://pastebin.com/hzYazFVb&quot;&gt;regex to tokenize an xml&lt;/a&gt; or &lt;a href=&quot;http://pastebin.com/HUmPzP5M&quot;&gt;the full plain regex&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://pastebin.com/hzYazFVb&quot;&gt;정규식은 XML&lt;/a&gt; 또는 &lt;a href=&quot;http://pastebin.com/HUmPzP5M&quot;&gt;전체 일반&lt;/a&gt; 정규식을 토큰 화합니다.</target>
        </trans-unit>
        <trans-unit id="832bcd8f1b94df226af144e70783a66198bd3e61" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;simplehtmldom&lt;/a&gt; is good, but I found it a bit buggy, and it is is quite memory heavy [Will crash on large pages.]</source>
          <target state="translated">&lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;simplehtmldom&lt;/a&gt; 은 좋지만 약간의 버그가 있음을 발견했으며 메모리가 너무 큽니다. [큰 페이지에서 충돌이 발생합니다.]</target>
        </trans-unit>
        <trans-unit id="0fb3c21dc29172e2446bc3eb1b052ae2cf60faea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;LL I​S L&lt;/b&gt;OST th</source>
          <target state="translated">&lt;b&gt;LL ISL&lt;/b&gt; OST th</target>
        </trans-unit>
        <trans-unit id="6e79435135c0746fa05560a3972c6d46478d0ea8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Locked&lt;/b&gt;. There are &lt;a href=&quot;/help/locked-posts&quot;&gt;disputes about this answer&amp;rsquo;s content&lt;/a&gt; being resolved at this time. It is not currently accepting new interactions.</source>
          <target state="translated">&lt;b&gt;잠김&lt;/b&gt; . &lt;a href=&quot;/help/locked-posts&quot;&gt;현재이 답변의 내용&lt;/a&gt; 에 대한 분쟁 이 있습니다. 현재 새로운 상호 작용을 수락하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="716a4e892e498fc58500550d231fb8d0142d36b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;O​O N&lt;/b&gt;&amp;Theta; stop t</source>
          <target state="translated">&lt;b&gt;O 켬&lt;/b&gt; 스톱 t</target>
        </trans-unit>
        <trans-unit id="1c101f468dfe424c6604dac4e8ce77d6d85f2f3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;: closing &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; : 마감 &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b62a075d15f1adc779c6d1b0fe159e3b547852c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;: starting character</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; : 시작 문자</target>
        </trans-unit>
        <trans-unit id="edd69111dcbfaec727aaaeb23b7029011a65191a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?&amp;lt;-group&amp;gt;)&lt;/code&gt; - pops the top most capture with the name group off the
  capture stack.</source>
          <target state="translated">&lt;code&gt;(?&amp;lt;-group&amp;gt;)&lt;/code&gt; -group &amp;gt;) -이름 그룹이 캡처 스택에서 가장 많이 캡처됩니다.</target>
        </trans-unit>
        <trans-unit id="d45de3e20cd061b6edb60d843a32a44f30527fa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?&amp;lt;group&amp;gt;)&lt;/code&gt; - pushes the captured result on the capture stack with
  the name group.</source>
          <target state="translated">&lt;code&gt;(?&amp;lt;group&amp;gt;)&lt;/code&gt; -이름 그룹이있는 캡처 스택에서 캡처 된 결과를 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="e8253025aa1e0fb8ada068fc00792760bbe3d0c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?(group)yes|no)&lt;/code&gt; - matches the yes part if there exists a group
  with the name group otherwise matches no part.</source>
          <target state="translated">&lt;code&gt;(?(group)yes|no)&lt;/code&gt; -이름 그룹이있는 그룹이 있으면 예 부분과 일치하고 그렇지 않으면 부분과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56885e7cfe6e3708ab901dd138fd887bd58c790d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(\w+)&lt;/code&gt;: tags can contain letters and numbers (h1). Well, &lt;code&gt;\w&lt;/code&gt; also matches '_', but it does not hurt I guess. If curious use ([a-zA-Z0-9]+) instead.</source>
          <target state="translated">&lt;code&gt;(\w+)&lt;/code&gt; : 태그는 문자와 숫자 (h1)를 포함 할 수 있습니다. 글쎄, &lt;code&gt;\w&lt;/code&gt; 도 '_'와 일치하지만 아프지 않습니다. 궁금하다면 ([a-zA-Z0-9] +)를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="27378fcce2128b2795fafae4f93ebe3ba7c8ec5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[^/&amp;gt;]*&lt;/code&gt;: anything except &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; until closing &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[^/&amp;gt;]*&lt;/code&gt; : 닫을 때까지 &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 를 제외한 모든 것 &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0cdd6edcac3875daf87e4d7a216db2702e63b2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s*&lt;/code&gt;: it may have whitespaces before tag name (ugly but possible).</source>
          <target state="translated">&lt;code&gt;\s*&lt;/code&gt; : 태그 이름 앞에 공백이있을 수 있습니다 (추악하지만 가능).</target>
        </trans-unit>
        <trans-unit id="beb0d3eebbac4ba7a6e556f1885908f5a8b44a54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;It is a .NET code library that allows
  you to parse &quot;out of the web&quot; HTML
  files. The parser is very tolerant
  with &quot;real world&quot; malformed HTML.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&quot;웹 외부&quot;HTML 파일을 구문 분석 할 수있는 .NET 코드 라이브러리입니다.&lt;/em&gt; &lt;em&gt;파서는 &quot;실제&quot;형식의 HTML에 매우 관대합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c6e323e6d7b2404e267e45fec8933c5f11df6f5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;/EDIT&amp;gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;lt;/EDIT&amp;gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4eeca80a434106c9c5953d86b5711b944275e484" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;EDIT&amp;gt;&lt;/strong&gt;
I forgot that the question from the user was to avoid the parsing of self-closing tags.
In this case the pattern is simpler, turning into this:</source>
          <target state="translated">&lt;strong&gt;&amp;lt;EDIT&amp;gt;&lt;/strong&gt; 사용자의 질문은 자체 닫는 태그의 구문 분석을 피하는 것임을 잊었습니다. 이 경우 패턴이 더 단순하여 다음과 같이 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="bfe34076d009a4ea9a539e48cf63cf2660a68659" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;.NET Regular Expression Engine&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;.NET 정규식 엔진&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="84c7b23e39a82950709baca989fe9cf94e0ac7c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caveat&lt;/strong&gt;: I should note that this regex still breaks down in the presence of CDATA blocks, comments, and script and style elements. Good news is, you can get rid of those using a regex...</source>
          <target state="translated">&lt;strong&gt;주의 사항&lt;/strong&gt; :이 정규 표현식은 여전히 ​​CDATA 블록, 주석 및 스크립트 및 스타일 요소가있는 경우 분류됩니다. 좋은 소식은 정규식을 사용하는 사람들을 제거 할 수 있다는 것입니다 ...</target>
        </trans-unit>
        <trans-unit id="45fc82d5456ed3961e342820361d39292947a88e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer&lt;/strong&gt;: use a parser if you have the option. That said...</source>
          <target state="translated">&lt;strong&gt;면책 조항&lt;/strong&gt; : 옵션이있는 경우 파서를 사용하십시오. 그건 ...</target>
        </trans-unit>
        <trans-unit id="28fb9f9055a519baf77c8a0c677593f8a1967066" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Moderator's Note&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;사회 주의자 주&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2412b65f77f0efaca93518e50a127a0ceec7ed35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To downvoters:&lt;/strong&gt; This is working code from an actual product. I doubt anyone reading this page will get the impression that it is socially acceptable to use regexes on HTML.</source>
          <target state="translated">&lt;strong&gt;downvoters :&lt;/strong&gt; 실제 제품의 작동 코드입니다. 이 페이지를 읽는 사람은 누구나 HTML에서 정규 표현식을 사용하는 것이 사회적으로 허용된다는 인상을받을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b00d0a9c4b3ab55c1726cc4d54869fbac2f0d000" translate="yes" xml:space="preserve">
          <source>A RegExp-agnostic colleague notified me this discussion, which is not certainly the first on the web about this old and hot topic.</source>
          <target state="translated">RegExp에 구애받지 않는 동료가이 토론에 대해 알 렸습니다.이 토론은 웹에서이 낡고 화제가 된 주제에 대해 처음은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e3504a93684584a9ba5c4e8dff8fbf39739ee1de" translate="yes" xml:space="preserve">
          <source>A simple regex like &lt;code&gt;&amp;lt;([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; is usually good enough, in cases such as those I just mentioned. It's a naive solution, all things considered, but it does correctly allow unencoded &lt;code&gt;&amp;gt;&lt;/code&gt; symbols in attribute values. If you're looking for, e.g., a &lt;code&gt;table&lt;/code&gt; tag, you could adapt it as &lt;code&gt;&amp;lt;/?table\b([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; 와 같은 간단한 정규식은 방금 언급 한 것과 같은 경우에 충분합니다. 그것은 모든 것을 고려한 순진한 솔루션이지만 속성 값에 인코딩되지 않은 &lt;code&gt;&amp;gt;&lt;/code&gt; 기호를 올바르게 허용합니다. 예를 들어 &lt;code&gt;table&lt;/code&gt; 태그를 찾고 있다면 &lt;code&gt;&amp;lt;/?table\b([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a039c1c26fe0f237cd4c396efb45b67c58a5e34d" translate="yes" xml:space="preserve">
          <source>About the question of the RegExp methods to parse (x)HTML, the answer to all of the ones who spoke about some limits is: you have not been trained enough to rule the force of this powerful weapon, since &lt;strong&gt;NOBODY&lt;/strong&gt; here spoke about &lt;strong&gt;recursion&lt;/strong&gt;.</source>
          <target state="translated">(x) HTML을 구문 분석하는 RegExp 메소드의 질문에 대해, 일부 한계에 대해 이야기 한 모든 사람들에 대한 대답은 다음과 같습니다. 여기서 &lt;strong&gt;NOBODY&lt;/strong&gt; 가 &lt;strong&gt;재귀에&lt;/strong&gt; 대해 이야기했기 때문에이 강력한 무기의 힘을 지배 할만큼 훈련을받지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="489cc8d83fc1a950af1e4ec274f14d5d31165bbc" translate="yes" xml:space="preserve">
          <source>After reading some posts, the first thing I did was looking for the &quot;?R&quot; string in this thread. The second was to search about &quot;recursion&quot;.</source>
          <target state="translated">일부 게시물을 읽은 후, 내가 한 첫 번째 일은이 스레드에서 &quot;? R&quot;문자열을 찾는 것입니다. 두 번째는 &quot;재귀&quot;를 검색하는 것이 었습니다.</target>
        </trans-unit>
        <trans-unit id="a3a75c0c6fe92ec2cda26b61e50e68af1ff0a32b" translate="yes" xml:space="preserve">
          <source>Against my expectation this got some upvotes, so I'll suggest some better regular expressions:</source>
          <target state="translated">내 기대에 반하여 이것은 약간의 찬성을 얻었으므로 더 나은 정규 표현식을 제안 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="d71dc9d3aa06d9d64e4ed0039016360a328e4c22" translate="yes" xml:space="preserve">
          <source>Almost there - just divide the whole thing by zero. Easy-peasy.</source>
          <target state="translated">거의 전부-모든 것을 0으로 나눕니다. 쉬워요.</target>
        </trans-unit>
        <trans-unit id="fee1e23317ba16ad1ccae9d12e0a015990432476" translate="yes" xml:space="preserve">
          <source>Although it's not suitable and effective to use regular expressions for that purpose sometimes regular expressions provide quick solutions for simple match problems and in my view it's not that horrbile to use regular expressions for trivial works.</source>
          <target state="translated">그 목적을 위해 정규 표현식을 사용하는 것이 적합하지 않고 효과적이지는 않지만 때로는 정규 표현식이 간단한 일치 문제에 대한 빠른 해결책을 제공하며 내 관점에서 사소한 작업에 정규 표현식을 사용하는 것이 그렇게 어렵지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a430cebe8e1c6b5026f2667ef4e684539ee6d594" translate="yes" xml:space="preserve">
          <source>And to fellows who underestimate regular expressions saying they are only as powerful as regular languages:</source>
          <target state="translated">정규 표현을 과소 평가하는 동료에게는 정규 언어만큼 강력하다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="1b4c5b09ea0d4dcf09356da001dd69ed7c2e026c" translate="yes" xml:space="preserve">
          <source>Another one to try is my &lt;a href=&quot;http://github.com/siteroller/domparser&quot;&gt;DOMParser&lt;/a&gt; which is very light on resources and I've been using happily for a while. Simple to learn &amp;amp; powerful.</source>
          <target state="translated">시도해야 할 또 하나는 &lt;a href=&quot;http://github.com/siteroller/domparser&quot;&gt;DOMParser&lt;/a&gt; 로 리소스가 매우 적으며 한동안 행복하게 사용하고 있습니다. 배우기 쉽고 강력합니다.</target>
        </trans-unit>
        <trans-unit id="0e63871b8e67058c915c0916cf65a319929856cc" translate="yes" xml:space="preserve">
          <source>Anyhow it is only a RegExp pattern, but it discloses the possibility to develop of a lot of powerful implementations.</source>
          <target state="translated">어쨌든 이것은 RegExp 패턴 일 뿐이지 만 많은 강력한 구현을 개발할 수있는 가능성을 공개합니다.</target>
        </trans-unit>
        <trans-unit id="7bc89deb2a5a51e26b543874949bc6016b7dee8c" translate="yes" xml:space="preserve">
          <source>As described above properly balanced constructs cannot be described by
  a regular expression. However, the .NET regular expression engine
  provides a few constructs that allow balanced constructs to be
  recognized.</source>
          <target state="translated">전술 한 바와 같이, 적절히 균형 잡힌 구성은 정규식으로 기술 될 수 없다. 그러나 .NET 정규식 엔진은 균형 잡힌 구문을 인식 할 수있는 몇 가지 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="23f8839aa08cf9ff361179fc788965803d7b92e4" translate="yes" xml:space="preserve">
          <source>As many people have already pointed out, HTML is not a regular language which can make it very difficult to parse. My solution to this is to turn it into a regular language using a tidy program and then to use an XML parser to consume the results. There are a lot of good options for this. My program is written using Java with the &lt;a href=&quot;http://jtidy.sourceforge.net/&quot;&gt;jtidy&lt;/a&gt; library to turn the HTML into XML and then Jaxen to xpath into the result.</source>
          <target state="translated">많은 사람들이 이미 지적했듯이 HTML은 일반 언어가 아니기 때문에 구문 분석이 매우 어렵습니다. 이것에 대한 나의 해결책은 깔끔한 프로그램을 사용하여 일반 언어로 바꾸고 XML 파서를 사용하여 결과를 소비하는 것입니다. 이에 대한 좋은 옵션이 많이 있습니다. 내 프로그램은 &lt;a href=&quot;http://jtidy.sourceforge.net/&quot;&gt;jtidy&lt;/a&gt; 라이브러리와 함께 Java를 사용하여 HTML을 XML로 변환 한 다음 Jaxen을 xpath로 결과로 작성합니다.</target>
        </trans-unit>
        <trans-unit id="6ec0c091ef78305814e216017d3186d039895a12" translate="yes" xml:space="preserve">
          <source>At the end of the day, use the most appropriate tool for the job, even in the cases when that tool happens to be a regex.</source>
          <target state="translated">하루가 끝나면 해당 도구가 정규식 인 경우에도 작업에 가장 적합한 도구를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee0292f6ec302ec831d0a3d73bf3ba082b945c21" translate="yes" xml:space="preserve">
          <source>Backreferencing &lt;a href=&quot;http://en.wiktionary.org/wiki/FTW&quot;&gt;FTW&lt;/a&gt;!</source>
          <target state="translated">역 참조 &lt;a href=&quot;http://en.wiktionary.org/wiki/FTW&quot;&gt;FTW&lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="e76721be008ac232fc787ac592a249a6a0b4bb86" translate="yes" xml:space="preserve">
          <source>Based on that you can create a pretty good regexp to handle things like stripping tags.</source>
          <target state="translated">이를 바탕으로 태그 제거와 같은 것들을 처리하기 위해 아주 좋은 정규 표현식을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74dec6c7e6bd60b234219702f40493e82463304e" translate="yes" xml:space="preserve">
          <source>Basically just define the element node names that are self closing, load the whole html string into a DOM library, grab all elements, loop through and filter out ones which aren't self closing and operate on them.</source>
          <target state="translated">기본적으로 자체 종료 인 요소 노드 이름을 정의하고 전체 html 문자열을 DOM 라이브러리에로드하고 모든 요소를 ​​잡고 자체 종료되지 않은 요소를 반복하여 필터링하여 작동시킵니다.</target>
        </trans-unit>
        <trans-unit id="2fd99963c03782b18787dfc6cb3594dcb6c80def" translate="yes" xml:space="preserve">
          <source>But many will try, some will even claim success - but until others find the fault and totally mess you up.</source>
          <target state="translated">그러나 많은 사람들이 시도 할 것이고, 어떤 사람들은 성공을 요구할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb3c73a7771d13969490ceb2f225b558c87d11f3" translate="yes" xml:space="preserve">
          <source>But not these:</source>
          <target state="translated">그러나 이것들은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="201b0e9006bea17e6be8fbec59ab5c0fb1baedd0" translate="yes" xml:space="preserve">
          <source>Can you provide a little more information on the problem you're trying to solve?  Are you iterating through tags programatically?</source>
          <target state="translated">해결하려는 문제에 대한 정보를 조금 더 제공 할 수 있습니까? 프로그래밍 방식으로 태그를 반복하고 있습니까?</target>
        </trans-unit>
        <trans-unit id="b8fde2430ed872968deeaaced84cc8f3cc101507" translate="yes" xml:space="preserve">
          <source>Consider the following regular expression:</source>
          <target state="translated">다음 정규식을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="dfa51c240f8abc4eddb1aab8ac728fcb6c1daf9a" translate="yes" xml:space="preserve">
          <source>Do I have that right? And more importantly, what do you think?</source>
          <target state="translated">그 권리가 있습니까? 그리고 더 중요한 것은 어떻게 생각하십니까?</target>
        </trans-unit>
        <trans-unit id="89791df6d0913a20e70b1f075f65baa21fec7900" translate="yes" xml:space="preserve">
          <source>Don't listen to these guys. You totally &lt;strong&gt;can&lt;/strong&gt; parse context-free grammars with regex if you break the task into smaller pieces. You can generate the correct pattern with a script that does each of these in order:</source>
          <target state="translated">이 사람들의 말을 듣지 마십시오. 작업을 더 작은 조각으로 나누면 컨텍스트없는 문법을 정규식으로 구문 분석 &lt;strong&gt;할 수 있습니다&lt;/strong&gt; . 다음 순서대로 각각을 수행하는 스크립트를 사용하여 올바른 패턴을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c40843389e0f5b256a2400a9132a52c445461a2b" translate="yes" xml:space="preserve">
          <source>E MY FACE ᵒh god n&lt;b&gt;o NO NOO̼&lt;/b&gt;</source>
          <target state="translated">E MY FACE ᵒh god n &lt;b&gt;o NO NOO̼&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4130705574014c580de59636d30628dd3b203bfe" translate="yes" xml:space="preserve">
          <source>Excerpt:</source>
          <target state="translated">Excerpt:</target>
        </trans-unit>
        <trans-unit id="2ad9d9e9824270d481f3774905d98736bcee5670" translate="yes" xml:space="preserve">
          <source>Find (and capture) a-z one or more times, then</source>
          <target state="translated">az를 한 번 이상 찾아서 캡처 한 다음</target>
        </trans-unit>
        <trans-unit id="1d62b3cf5e66d1004bdcb37b62e3847fa43f5ea5" translate="yes" xml:space="preserve">
          <source>Find a greater-than</source>
          <target state="translated">보다 큰 찾기</target>
        </trans-unit>
        <trans-unit id="e9f182c7233327a73156c429c46ec0bca09513bc" translate="yes" xml:space="preserve">
          <source>Find a less-than, then</source>
          <target state="translated">보다 작게 찾기</target>
        </trans-unit>
        <trans-unit id="ef69898f6d3c5528cdbd0de1bd0fdf314dad1fc8" translate="yes" xml:space="preserve">
          <source>Find any character zero or more times, greedy, except &lt;code&gt;/&lt;/code&gt;, then</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 를 제외하고 욕심 많은 문자를 0 번 이상 찾은 다음</target>
        </trans-unit>
        <trans-unit id="4f924d21074cc3fb26507a968919ecf7195b88d8" translate="yes" xml:space="preserve">
          <source>Find zero or more spaces, then</source>
          <target state="translated">0 개 이상의 공백을 찾은 다음</target>
        </trans-unit>
        <trans-unit id="0d7c5280ed7e07e90b90f8658292c92cbadfbd89" translate="yes" xml:space="preserve">
          <source>Follow the var links for &lt;code&gt;QName&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, and &lt;code&gt;Attribute&lt;/code&gt; to get a clearer picture.</source>
          <target state="translated">&lt;code&gt;QName&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; 및 &lt;code&gt;Attribute&lt;/code&gt; 에 대한 var 링크를 따라보다 명확한 그림을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="cf4a4868fa67f0f821777e8c58e576588a83ca85" translate="yes" xml:space="preserve">
          <source>For Python and Java, similar links were posted.</source>
          <target state="translated">파이썬과 자바의 경우 비슷한 링크가 게시되었습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3835e68a9fb13e4990fe61a2c3a6bb38c1da30a3" translate="yes" xml:space="preserve">
          <source>For the downvoters - I only wrote my class when the XML parsers proved unable to withstand real use. Religious downvoting just prevents useful answers from being posted - keep things within perspective of the question, please.</source>
          <target state="translated">downvoters-XML 파서가 실제 사용을 견딜 수없는 것으로 판명되었을 때만 수업을 썼습니다. 종교적 다운 보팅은 유용한 답변이 게시되는 것을 방지합니다. 질문의 관점에서 사물을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="b71baca6025abb3df3fd982ef9ea831e48620ba4" translate="yes" xml:space="preserve">
          <source>For this reason, I believe you CAN parse XML using regular expressions. Note however, that it &lt;strong&gt;must be valid XML&lt;/strong&gt; (&lt;em&gt;browsers are very forgiving of HTML and allow bad XML syntax inside HTML&lt;/em&gt;). This is possible since the &quot;Balancing Group Definition&quot; will allow the regular expression engine to act as a PDA.</source>
          <target state="translated">이러한 이유로 정규 표현식을 사용하여 XML을 구문 분석 할 수 있다고 생각합니다. 그러나 &lt;strong&gt;유효한 XML이어야합니다&lt;/strong&gt; ( &lt;em&gt;브라우저는 HTML을 매우 용서하고 HTML 내부에서 잘못된 XML 구문을 허용합니다&lt;/em&gt; ). &quot;밸런싱 그룹 정의&quot;를 통해 정규 표현식 엔진이 PDA로 작동 할 수 있기 때문에 가능합니다.</target>
        </trans-unit>
        <trans-unit id="fda26d5e5c5ac0a8c6a86392f4d1739052bb39fc" translate="yes" xml:space="preserve">
          <source>Granted, these don't account for surrounding context and a few edge cases, but even such things could be dealt with if you really wanted to (e.g., by searching between the matches of another regex).</source>
          <target state="translated">물론, 이것들은 주변 상황과 몇 가지 중요한 경우를 설명하지 않지만 실제로 원한다면 (예를 들어 다른 정규 표현식의 일치 항목을 검색하여) 처리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddfca12da1b8e2626e09bf2de8420516252a5e63" translate="yes" xml:space="preserve">
          <source>HTML Split</source>
          <target state="translated">HTML 분할</target>
        </trans-unit>
        <trans-unit id="6c3bb55dbe0fb3cbcbc40ad1f139eaae779348bd" translate="yes" xml:space="preserve">
          <source>Hacking stackoverflow.com's HTML sanitizer</source>
          <target state="translated">해킹 stackoverflow.com의 HTML 소독제</target>
        </trans-unit>
        <trans-unit id="9ec955a6d30b0da0f17f1892186c1fa8f07ed132" translate="yes" xml:space="preserve">
          <source>Have you tried using an XML parser instead?</source>
          <target state="translated">XML 파서를 대신 사용해 보셨습니까?</target>
        </trans-unit>
        <trans-unit id="62d338caf42aa263445453c7fd40bf4f6302c521" translate="yes" xml:space="preserve">
          <source>Here is a &lt;a href=&quot;http://kingdesk.com/projects/php-parser/&quot;&gt;PHP based parser&lt;/a&gt; that parses HTML using  some ungodly regex. As the author of this project, I can tell you it is possible to parse HTML with regex, but not efficient. If you need a server-side solution (as I did for my &lt;a href=&quot;http://wordpress.org/extend/plugins/wp-typography/&quot;&gt;wp-Typography WordPress plugin&lt;/a&gt;), this works.</source>
          <target state="translated">다음은 불경건 한 정규 표현식을 사용하여 HTML을 구문 분석하는 &lt;a href=&quot;http://kingdesk.com/projects/php-parser/&quot;&gt;PHP 기반 파서&lt;/a&gt; 입니다. 이 프로젝트의 저자로서 정규식으로 HTML을 구문 분석 할 수는 있지만 효율적이지 않다는 것을 알 수 있습니다. &lt;a href=&quot;http://wordpress.org/extend/plugins/wp-typography/&quot;&gt;wp-Typography WordPress 플러그인에서&lt;/a&gt; 와 같이 서버 측 솔루션이 필요한 경우 작동합니다.</target>
        </trans-unit>
        <trans-unit id="de8fd03b5c9fb5a8404878e31a8e0845726217a3" translate="yes" xml:space="preserve">
          <source>Here's a &lt;strong&gt;sample note on the PHP manual&lt;/strong&gt; I wrote on January: &lt;a href=&quot;http://php.net/manual/en/regexp.reference.recursive.php&quot;&gt;Reference&lt;/a&gt;</source>
          <target state="translated">다음은 1 월에 작성한 &lt;strong&gt;PHP 매뉴얼에&lt;/strong&gt; 대한 &lt;strong&gt;샘플 노트입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5c95897a114ae327a0fcd3248ce2f00b0ecf00ea" translate="yes" xml:space="preserve">
          <source>Here's the magic pattern:</source>
          <target state="translated">마술 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c10b2e598b32c332a06818be23de20fdc89e2f2a" translate="yes" xml:space="preserve">
          <source>Here's the solution:</source>
          <target state="translated">해결책은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2cb54d7b11fcfb379247546c25fc8c672912b48c" translate="yes" xml:space="preserve">
          <source>However, a na&amp;iuml;ve implementation of that will end up matching &lt;code&gt;&amp;lt;bar/&amp;gt;&amp;lt;/foo&amp;gt;&lt;/code&gt; in this example document</source>
          <target state="translated">그러나 순진한 구현은이 예제 문서에서 &lt;code&gt;&amp;lt;bar/&amp;gt;&amp;lt;/foo&amp;gt;&lt;/code&gt; 와 일치하게됩니다.</target>
        </trans-unit>
        <trans-unit id="5ee1e08a15d19fdb33d20bd07c63e0818a8b9803" translate="yes" xml:space="preserve">
          <source>I agree that the right tool to parse XML and &lt;em&gt;especially HTML&lt;/em&gt; is a parser and not a regular expression engine. However, like others have pointed out, sometimes using a regex is quicker, easier, and gets the job done if you know the data format.</source>
          <target state="translated">XML과 &lt;em&gt;특히 HTML&lt;/em&gt; 을 구문 분석하는 올바른 도구는 정규식 엔진이 아니라 파서라는 데 동의합니다. 그러나 다른 사람들이 지적했듯이 때로는 정규식을 사용하는 것이 더 빠르고 쉽고 데이터 형식을 알고 있으면 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="65c26198557f567b9e45c7ec5c4d24af104d4dba" translate="yes" xml:space="preserve">
          <source>I also entered tags with:</source>
          <target state="translated">나는 또한 태그를 입력했다 :</target>
        </trans-unit>
        <trans-unit id="f992540f103a26060e050d18a000903263722fe7" translate="yes" xml:space="preserve">
          <source>I believe it says:</source>
          <target state="translated">나는 그것이 말한다 :</target>
        </trans-unit>
        <trans-unit id="67002a6457c576d19392a6bb03d1003175f5f89d" translate="yes" xml:space="preserve">
          <source>I bet I will get downvoted for this.</source>
          <target state="translated">나는 이것에 대해 downvoted 얻을 것 내기.</target>
        </trans-unit>
        <trans-unit id="a78333526ec3e39b92b14f68dec9aff52646cd97" translate="yes" xml:space="preserve">
          <source>I came up with this and wanted to make sure I've got it right. I am only capturing the &lt;code&gt;a-z&lt;/code&gt;.</source>
          <target state="translated">나는 이것을 생각해 냈고 내가 올바르게 가지고 있는지 확인하고 싶었다. 나는 단지 &lt;code&gt;a-z&lt;/code&gt; 붙잡고있다.</target>
        </trans-unit>
        <trans-unit id="c510ddbef2e355def2551ab12c01a3563da7ee62" translate="yes" xml:space="preserve">
          <source>I don't know your exact need for this, but if you are also using .NET, couldn't you use &lt;a href=&quot;http://www.codeplex.com/htmlagilitypack&quot;&gt;Html Agility Pack&lt;/a&gt;?</source>
          <target state="translated">나는 이것이 당신의 정확한 필요성을 모르지만 .NET도 사용하고 있다면 &lt;a href=&quot;http://www.codeplex.com/htmlagilitypack&quot;&gt;Html Agility Pack&lt;/a&gt; 을 사용할 수 없습니까?</target>
        </trans-unit>
        <trans-unit id="a18f149e6422b3edd9f248402bd13c1e293f7282" translate="yes" xml:space="preserve">
          <source>I guess to make it not match self contained tags, you'd either want to use &lt;a href=&quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732395#1732395&quot;&gt;Kobi&lt;/a&gt;'s negative look-behind:</source>
          <target state="translated">자체 포함 태그와 일치하지 않도록 &lt;a href=&quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732395#1732395&quot;&gt;Kobi&lt;/a&gt; 의 부정적인 모양을 사용하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="446fea43937f34270d7612150462764e964be907" translate="yes" xml:space="preserve">
          <source>I have also composed a haiku describing the nature of regex in Perl.</source>
          <target state="translated">나는 또한 Perl에서 정규 표현식의 특성을 설명하는 haiku를 구성했습니다.</target>
        </trans-unit>
        <trans-unit id="682e33f67784d033cbcf7127d0e8db1135907695" translate="yes" xml:space="preserve">
          <source>I have composed a haiku describing the nature of HTML.</source>
          <target state="translated">HTML의 특성을 설명하는 하이쿠를 구성했습니다.</target>
        </trans-unit>
        <trans-unit id="b7d276bff4ead75187b5216ebca62ddd0544740b" translate="yes" xml:space="preserve">
          <source>I have never used &lt;a href=&quot;http://querypath.org/&quot;&gt;querypath&lt;/a&gt;, so can't comment on its usefulness.</source>
          <target state="translated">나는 &lt;a href=&quot;http://querypath.org/&quot;&gt;querypath를&lt;/a&gt; 사용한 적이 없으므로 그 유용성에 대해 언급 할 수 없다.</target>
        </trans-unit>
        <trans-unit id="a3d81722ce02cdd1e1d406605ca28b6afc2989ae" translate="yes" xml:space="preserve">
          <source>I haven't quite finished the last part myself, but I know I'm getting close. It keeps throwing &lt;code&gt;CthulhuRlyehWgahnaglFhtagnException&lt;/code&gt;s for some reason, so I'm going to port it to VB 6 and use &lt;code&gt;On Error Resume Next&lt;/code&gt;. I'll update with the code once I investigate this strange door that just opened in the wall. Hmm.</source>
          <target state="translated">나는 마지막 부분을 스스로 끝내지 못했지만 점점 가까워지고 있음을 알고 있습니다. 어떤 이유로 든 &lt;code&gt;CthulhuRlyehWgahnaglFhtagnException&lt;/code&gt; 이 계속 발생하므로 VB 6으로 이식하고 &lt;code&gt;On Error Resume Next&lt;/code&gt; 사용 합니다. 벽에 열린 이상한 문을 조사하면 코드로 업데이트하겠습니다. 흠.</target>
        </trans-unit>
        <trans-unit id="57a8d4c706d6a34ee3af3112fdb317e71ff9acca" translate="yes" xml:space="preserve">
          <source>I like to parse HTML with regular expressions. I don't attempt to parse idiot HTML that is deliberately broken. This code is my main parser (Perl edition):</source>
          <target state="translated">정규식으로 HTML을 구문 분석하고 싶습니다. 의도적으로 손상된 바보 HTML을 구문 분석하지 않습니다. 이 코드는 내 주요 파서입니다 (Perl 에디션).</target>
        </trans-unit>
        <trans-unit id="8ea04fa9f527bf7438dfd9b91e87f0721f39b7be" translate="yes" xml:space="preserve">
          <source>I need to match all of these opening tags:</source>
          <target state="translated">이 모든 시작 태그와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="f58bfd6885d7586198e4ea7d285dc17ac4158c70" translate="yes" xml:space="preserve">
          <source>I suggest using &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; for parsing XML and HTML in PHP.  It's basically much the same syntax as jQuery, only it's on the server side.</source>
          <target state="translated">PHP에서 XML과 HTML을 구문 분석하기 위해 &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; 를 사용하는 것이 좋습니다. 기본적으로 jQuery와 거의 동일한 구문이며 서버 측에만 있습니다.</target>
        </trans-unit>
        <trans-unit id="ece9292e931d9ba43626cda22fdf3280d35633a6" translate="yes" xml:space="preserve">
          <source>I think the XML case is quite simple. The RegEx (in the .NET syntax), deflated and coded in base64 to make it easier to comprehend by your feeble mind, should be something like this:</source>
          <target state="translated">XML 사례는 매우 간단하다고 생각합니다. base64로 압축을 풀고 코딩 한 RegEx (.NET 구문)는 다음과 같은 방법으로 쉽게 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18040856a3f0eb37bda82501b7d790ae361b0b2d" translate="yes" xml:space="preserve">
          <source>I think the flaw here is that HTML is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;Chomsky Type 2 grammar (context free grammar)&lt;/a&gt; and RegEx is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_grammar&quot;&gt;Chomsky Type 3 grammar (regular grammar)&lt;/a&gt;. Since a Type 2 grammar is fundamentally more complex than a Type 3 grammar (see the &lt;a href=&quot;http://en.wikipedia.org/wiki/Chomsky_hierarchy&quot;&gt;Chomsky hierarchy&lt;/a&gt;), it is &lt;em&gt;mathematically impossible&lt;/em&gt; to parse XML with RegEx.</source>
          <target state="translated">여기에 결함이 있다고 생각하면 HTML은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;Chomsky Type 2 문법 (문맥이없는 문법)&lt;/a&gt; 이고 RegEx는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_grammar&quot;&gt;Chomsky Type 3 문법 (정규 문법)&lt;/a&gt; 입니다. Type 2 문법은 근본적으로 Type 3 문법보다 복잡하기 때문에 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Chomsky_hierarchy&quot;&gt;Chomsky 계층&lt;/a&gt; 참조) RegEx로 XML을 구문 분석하는 것은 &lt;em&gt;수학적으로 불가능&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="46e4bbf54843bf1bf2bb54e48219620db67794ee" translate="yes" xml:space="preserve">
          <source>I used a open source tool called &lt;a href=&quot;http://htmlparser.sourceforge.net/&quot;&gt;HTMLParser&lt;/a&gt; before. It's designed to parse HTML in various ways and serves the purpose quite well. It can parse HTML as different treenode and you can easily use its API to get attributes out of the node. Check it out and see if this can help you.</source>
          <target state="translated">전에는 &lt;a href=&quot;http://htmlparser.sourceforge.net/&quot;&gt;HTMLParser&lt;/a&gt; 라는 오픈 소스 도구를 사용했습니다. 다양한 방식으로 HTML을 구문 분석하고 목적을 잘 수행하도록 설계되었습니다. HTML을 다른 트리 노드로 구문 분석 할 수 있으며 API를 사용하여 노드에서 속성을 쉽게 가져올 수 있습니다. 그것을 확인하고 이것이 당신을 도울 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="50830c82c86965110baf1111e9368113230c821b" translate="yes" xml:space="preserve">
          <source>I used the sample source of:</source>
          <target state="translated">샘플 소스를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="fb040c717878233cc23503d0d656d6a7c4f3856c" translate="yes" xml:space="preserve">
          <source>I wrote it in 30 seconds, and tested here:
&lt;a href=&quot;http://gskinner.com/RegExr/&quot;&gt;http://gskinner.com/RegExr/&lt;/a&gt;</source>
          <target state="translated">나는 그것을 30 초 안에 작성하고 여기에서 테스트했다 : &lt;a href=&quot;http://gskinner.com/RegExr/&quot;&gt;http://gskinner.com/RegExr/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb8a7f1667c9d5eff8cc8d64ddbce9b58e23a699" translate="yes" xml:space="preserve">
          <source>I wrote this pattern to power the &lt;em&gt;recursive descent parser&lt;/em&gt; of a template engine I built in my framework, and performances are really great, both in execution times or in memory usage (nothing to do with other template engines which use the same syntax).</source>
          <target state="translated">필자는이 패턴을 작성하여 프레임 워크에 구축 한 템플릿 엔진의 &lt;em&gt;재귀 강하 파서&lt;/em&gt; 를 강화했으며, 실행 시간이나 메모리 사용량 (동일한 구문을 사용하는 다른 템플릿 엔진과는 상관 없음)에서 성능이 정말 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="f454869fe61fa45429bc7ee92bc5ad9345d8b481" translate="yes" xml:space="preserve">
          <source>I'm sure you already know by now that you shouldn't use regex for this purpose.</source>
          <target state="translated">나는 당신이 이미이 목적으로 정규식을 사용해서는 안된다는 것을 이미 알고 있다고 확신합니다.</target>
        </trans-unit>
        <trans-unit id="40dea22884315ebb5434973f5bb9c5c1ca6166f5" translate="yes" xml:space="preserve">
          <source>If You Like Regular Expressions So Much, Why Don't You Marry Them?</source>
          <target state="translated">정규식을 너무 좋아한다면, 왜 결혼하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="cbfa4fd68fca2bc7eab26c99ba711ac9cab9bb23" translate="yes" xml:space="preserve">
          <source>If an (x)HTML parser needs recursion, a RegExp parser without recursion is not enough for the purpose. It's a simple construct.</source>
          <target state="translated">(x) HTML 파서가 재귀를 필요로하는 경우, 재귀없는 RegExp 파서는 목적에 충분하지 않습니다. 간단한 구조입니다.</target>
        </trans-unit>
        <trans-unit id="919388ca02cd994c288549580960ad9ba47f962b" translate="yes" xml:space="preserve">
          <source>If someone is interested in learning more about the pattern, I provide some line:</source>
          <target state="translated">누군가 패턴에 대해 더 배우고 싶다면 다음과 같은 줄을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="557f9117f8433eb60bbd29cff5259745d632f952" translate="yes" xml:space="preserve">
          <source>If you add something to the regex, by backtracking it can be forced to match silly things like &lt;code&gt;&amp;lt;a &amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;[^/]&lt;/code&gt; is too permissive. Also note that &lt;code&gt;&amp;lt;space&amp;gt;*[^/]*&lt;/code&gt; is redundant, because the &lt;code&gt;[^/]*&lt;/code&gt; can also match spaces.</source>
          <target state="translated">정규식에 무언가를 추가하면 역 추적을 통해 &amp;lt;a&amp;gt; &lt;code&gt;&amp;lt;a &amp;gt;&amp;gt;&lt;/code&gt; 와 같은 어리석은 것들과 일치하도록 할 수 있습니다. &lt;code&gt;[^/]&lt;/code&gt; 은 너무 관대합니다. &lt;code&gt;[^/]*&lt;/code&gt; 도 공백과 일치 할 수 있으므로 &lt;code&gt;&amp;lt;space&amp;gt;*[^/]*&lt;/code&gt; 는 중복됩니다.</target>
        </trans-unit>
        <trans-unit id="a298912d3657e52c67b5f74e85c231c1485f0d0c" translate="yes" xml:space="preserve">
          <source>If you are unsure, no, I'm NOT kidding (but perhaps I'm lying). It WILL work. I've built tons of unit tests to test it, and I have even used (part of) the &lt;a href=&quot;http://www.w3.org/XML/Test/&quot;&gt;conformance tests&lt;/a&gt;. It's a tokenizer, not a full-blown parser, so it will only split the XML into its component tokens. It won't parse/integrate DTDs.</source>
          <target state="translated">당신이 확실하지 않다면, 아니, 나는 농담이 아닙니다 (그러나 아마도 거짓말하고 있습니다). 작동합니다. 나는 그것을 테스트하기 위해 수많은 단위 테스트를 만들었으며 심지어 &lt;a href=&quot;http://www.w3.org/XML/Test/&quot;&gt;적합성 테스트&lt;/a&gt; (일부)를 사용했습니다. 완전한 파서가 아닌 토크 나이저이므로 XML을 구성 요소 토큰으로 만 분할합니다. DTD를 구문 분석 / 통합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b5bc330d9a583246ad4801874fc84163c931493" translate="yes" xml:space="preserve">
          <source>If you have a small set of HTML pages that you want to scrape data from and then stuff into a database, regexes might work fine.  For example, I recently wanted to get the names, parties, and districts of Australian federal Representatives, which I got off of the Parliament's web site.  This was a limited, one-time job.</source>
          <target state="translated">데이터를 긁어 데이터베이스에 넣을 작은 HTML 페이지 집합이 있으면 정규 표현식이 제대로 작동 할 수 있습니다. 예를 들어, 저는 최근에 의회 웹 사이트에서 벗어난 호주 연방 대표의 이름, 정당 및 지구를 얻고 싶었습니다. 이것은 제한된 일회성 직업이었습니다.</target>
        </trans-unit>
        <trans-unit id="d9db7068b93480af65771902d59739a0242c037f" translate="yes" xml:space="preserve">
          <source>If you have problems reconverting it to a human-readable regex, this should help:</source>
          <target state="translated">사람이 읽을 수있는 정규식으로 다시 변환하는 데 문제가 있으면 다음과 같은 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="14633b829212b8b056b036f6830ca7c6a918fe40" translate="yes" xml:space="preserve">
          <source>If you need this for PHP:</source>
          <target state="translated">PHP에 필요한 경우 :</target>
        </trans-unit>
        <trans-unit id="f932b2b6098e1c3395b486c41745029eaaebe046" translate="yes" xml:space="preserve">
          <source>If you're simply trying to find those tags (without ambitions of parsing) try this regular expression:</source>
          <target state="translated">단순히 구문 분석없이 야심으로 해당 태그를 찾으려면 다음 정규 표현식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4b5c78fb6625eec434f0fbf5e5c22e99da727566" translate="yes" xml:space="preserve">
          <source>IgnoreCase (not necessary)</source>
          <target state="translated">케이스 무시 (필요하지 않음)</target>
        </trans-unit>
        <trans-unit id="195915971c682a24ad48d1e62483babae5188862" translate="yes" xml:space="preserve">
          <source>IgnorePatternWhitespace (not necessary if you collapse regex and remove all whitespace)</source>
          <target state="translated">패턴 공백 무시 (정규 표현식을 축소하고 모든 공백을 제거하는 경우 필요하지 않음)</target>
        </trans-unit>
        <trans-unit id="d8142f0416c264b4b799d2c8a0af8d098608064c" translate="yes" xml:space="preserve">
          <source>In shell, you can parse &lt;a href=&quot;https://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; using &lt;a href=&quot;https://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt;:</source>
          <target state="translated">쉘에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Sed&quot;&gt;sed를&lt;/a&gt; 사용하여 &lt;a href=&quot;https://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; 을 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e72a4a4bfbcf98641ca469ef038c0e9caca1753" translate="yes" xml:space="preserve">
          <source>In this case your enemy is HTML and you are either yourself or regex.  You might even be Perl with irregular regex. Know HTML.  Know yourself.</source>
          <target state="translated">이 경우, 당신의 적이 HTML이고 당신은 자신이거나 정규식입니다. 불규칙한 정규 표현식으로 Perl 일 수도 있습니다. HTML을 알아라. 너 자신을 알라.</target>
        </trans-unit>
        <trans-unit id="4da0bc6ccd100c1869c39b7908884293a4fdecf6" translate="yes" xml:space="preserve">
          <source>It is said that if you know your enemies and know yourself, you can win a hundred battles without a single loss.
  If you only know yourself, but not your opponent, you may win or may lose.
  If you know neither yourself nor your enemy, you will always endanger yourself.</source>
          <target state="translated">적을 알고 자신을 알면 한 번의 손실없이 백 번의 전투에서 승리 할 수 ​​있습니다. 자신 만 알지만 상대방은 알지 못하면이기거나 잃을 수 있습니다. 자신도 적도 모르면 항상 위험에 처하게됩니다.</target>
        </trans-unit>
        <trans-unit id="8cd9da1c9f2693e6ec017e2869a577b714739b63" translate="yes" xml:space="preserve">
          <source>It is similar to yours, but the last &lt;code&gt;&amp;gt;&lt;/code&gt; must not be after a slash, and also accepts &lt;code&gt;h1&lt;/code&gt;.</source>
          <target state="translated">그것은 당신과 비슷하지만 마지막 &lt;code&gt;&amp;gt;&lt;/code&gt; 은 슬래시 뒤에 있지 않아야하며 &lt;code&gt;h1&lt;/code&gt; 도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6ad138f054cb998fb3ecb181104c2f9f5989e48b" translate="yes" xml:space="preserve">
          <source>It is simple enough to rejig my slurp-everything-first Perl script into a nice streaming thing, if you wish to process enormous web pages. But it's not really necessary.</source>
          <target state="translated">거대한 웹 페이지를 처리하고 싶다면 내 slurp-everything-first Perl 스크립트를 멋진 스트리밍으로 재구성하는 것이 간단합니다. 그러나 실제로는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4114fb01ee1d4a7e528e4b5db702779bb015416" translate="yes" xml:space="preserve">
          <source>It matches the types of tags you mentioned, while ignoring the types you said you wanted to ignore.</source>
          <target state="translated">무시하려는 태그 유형은 무시하면서 언급 한 태그 유형과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e92b765161d9c9393ab926712762103321511c85" translate="yes" xml:space="preserve">
          <source>It may not be perfect, but I ran this code through a &lt;em&gt;lot&lt;/em&gt; of HTML. Note that it even catches strange things like &lt;code&gt;&amp;lt;a name=&quot;badgenerator&quot;&quot;&amp;gt;&lt;/code&gt;, which show up on the web.</source>
          <target state="translated">완벽하지는 않지만 &lt;em&gt;많은&lt;/em&gt; HTML을 통해이 코드를 실행했습니다. 심지어 웹에 나타나는 &lt;code&gt;&amp;lt;a name=&quot;badgenerator&quot;&quot;&amp;gt;&lt;/code&gt; 와 같은 이상한 것들도 포착합니다.</target>
        </trans-unit>
        <trans-unit id="3c401fdac65c6774bcadecd58093d69231332e3b" translate="yes" xml:space="preserve">
          <source>It seems to me you're trying to match tags without a &quot;/&quot; at the end. Try this:</source>
          <target state="translated">끝에 &quot;/&quot;없이 태그를 일치시키려는 것 같습니다. 이 시도:</target>
        </trans-unit>
        <trans-unit id="f6ca3fc0ed09308a49c656e7527184db98c56489" translate="yes" xml:space="preserve">
          <source>It's called htmlsplit, splits the HTML into lines, with one tag or chunk of text on each line.  The lines can then be processed further with other text tools and scripts, such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt;, Perl, etc. I'm not even joking :) Enjoy.</source>
          <target state="translated">htmlsplit이라고하며 HTML을 한 줄로 나누고 각 줄에 하나의 태그 또는 텍스트 덩어리를 만듭니다. 그런 다음 &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt; , &lt;a href=&quot;http://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt; , Perl 등과 같은 다른 텍스트 도구 및 스크립트를 사용하여 행을 추가로 처리 할 수 ​​있습니다. 농담조차하지 않습니다. :) 즐기십시오.</target>
        </trans-unit>
        <trans-unit id="9ec7139f7024ff295c9ba4a49287ac0b4b6fc319" translate="yes" xml:space="preserve">
          <source>It's true that when programming it's usually best to use dedicated parsers and APIs instead of regular expressions when dealing with HTML, especially if accuracy is paramount (e.g., if your processing might have security implications). However, I don&amp;rsquo;t ascribe to a dogmatic view that XML-style markup should never be processed with regular expressions. There are cases when regular expressions are a great tool for the job, such as when making one-time edits in a text editor, fixing broken XML files, or dealing with file formats that look like but aren&amp;rsquo;t quite XML. There are some issues to be aware of, but they're not insurmountable or even necessarily relevant.</source>
          <target state="translated">프로그래밍 할 때 HTML을 처리 할 때 특히 정확성이 가장 중요한 경우 (예 : 처리에 보안 관련 사항이있는 경우) 정규식 대신 전용 파서 및 API를 사용하는 것이 가장 좋습니다. 그러나 XML 스타일 마크 업을 정규식으로 처리해서는 안된다는 교리 적 견해에 동의하지 않습니다. 정규식이 텍스트 편집기에서 일회성 편집, 손상된 XML 파일 수정 또는 XML처럼 보이지는 않지만 파일 형식을 처리하는 경우와 같이 작업에 유용한 도구 인 경우가 있습니다. 알아야 할 몇 가지 문제가 있지만 극복 할 수 없거나 반드시 관련이없는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="39e7ab248960684eaa9b9f720409b41a17a28cff" translate="yes" xml:space="preserve">
          <source>It's written as a PHP string, so the &quot;s&quot; modifier makes classes include newlines.</source>
          <target state="translated">PHP 문자열로 작성되므로 &quot;s&quot;수정자는 클래스에 개행을 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="427486fffe171253525e01e3f06e796d5676dc63" translate="yes" xml:space="preserve">
          <source>Just to give a sense of what a more &quot;advanced&quot; HTML regex would look like, the following does a fairly respectable job of emulating real-world browser behavior and the HTML5 parsing algorithm:</source>
          <target state="translated">좀 더 &quot;고급&quot;HTML 정규식이 어떻게 보이는지 이해하기 위해 다음은 실제 브라우저 동작과 HTML5 구문 분석 알고리즘을 에뮬레이션하는 상당히 존경스러운 작업입니다.</target>
        </trans-unit>
        <trans-unit id="22605049c94f39fec40c01fc01b8d0235c7512b9" translate="yes" xml:space="preserve">
          <source>Just try it.</source>
          <target state="translated">먹어봐.</target>
        </trans-unit>
        <trans-unit id="601daad3ec0906e4e0d799c06fb0f95e6770d70e" translate="yes" xml:space="preserve">
          <source>Lastly, I really enjoyed Jeff Atwood's article:  &lt;a href=&quot;https://blog.codinghorror.com/parsing-html-the-cthulhu-way/&quot;&gt;Parsing Html The Cthulhu Way&lt;/a&gt;. Funny enough, it cites the answer to this question that currently has over 4k votes.</source>
          <target state="translated">마지막으로 Jeff Atwood의 기사 : &lt;a href=&quot;https://blog.codinghorror.com/parsing-html-the-cthulhu-way/&quot;&gt;Html The Cthulhu Way 파싱을&lt;/a&gt; 정말 좋아했습니다. 재밌게도 현재 4k 이상 투표 한이 질문에 대한 답변을 인용합니다.</target>
        </trans-unit>
        <trans-unit id="d67da4c32f78ca5c993f0ad4bcd5b49e6538c409" translate="yes" xml:space="preserve">
          <source>Like Lord Marshal (is he a relative of the Marshal .NET class?), I have seen the &lt;strike&gt;Underverse&lt;/strike&gt; Stack Based Regex-Verse and returned with &lt;strike&gt;powers&lt;/strike&gt; knowledge you can't imagine. Yes, I think there were an Old One or two protecting them, but they were watching football on the TV, so it wasn't difficult.</source>
          <target state="translated">Lord Marshal과 마찬가지로 (Marshal .NET 클래스의 친척입니까?) &lt;strike&gt;Underverse&lt;/strike&gt; Stack Based Regex-Verse를 &lt;strike&gt;보았고&lt;/strike&gt; 상상할 수없는 &lt;strike&gt;힘&lt;/strike&gt; 지식으로 돌아 왔습니다. 예, 나는 그들을 보호하는 Old One 또는 Two가 있다고 생각하지만 TV에서 축구를보고 있었기 때문에 어렵지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1c3e6997e482742cdf179a4397cb018cad2d8564" translate="yes" xml:space="preserve">
          <source>Microsoft actually has a section of &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices&quot;&gt;Best Practices for Regular Expressions in the .NET Framework&lt;/a&gt; and specifically talks about &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices#consider-the-input-source&quot;&gt;Consider[ing] the Input Source&lt;/a&gt;.</source>
          <target state="translated">Microsoft는 실제로 &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices&quot;&gt;.NET Framework에서 정규 표현식에 대한 모범 사례&lt;/a&gt; 섹션을 보유하고 있으며 특히 &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices#consider-the-input-source&quot;&gt;입력 소스 고려에&lt;/a&gt; 대해 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="ba3b99fc49923cc3bbd90f5e080753b12725e9bc" translate="yes" xml:space="preserve">
          <source>My suggestion would be</source>
          <target state="translated">내 제안은</target>
        </trans-unit>
        <trans-unit id="72810c91afedb33b80069b7076436fecf94d1af6" translate="yes" xml:space="preserve">
          <source>No, holy cow, no match found.</source>
          <target state="translated">아니, 성스러운 소, 일치하는 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a474b6597430f9ba4fac174b06490808a6e22af5" translate="yes" xml:space="preserve">
          <source>Note that this allows things like &lt;code&gt;&amp;lt;a/ &amp;gt;&lt;/code&gt; (just like the original regex), so if you want something more restrictive, you need to build a regex to match attribute pairs separated by spaces.</source>
          <target state="translated">이렇게하면 &lt;code&gt;&amp;lt;a/ &amp;gt;&lt;/code&gt; (원래 정규식과 같은)를 사용할 수 있으므로보다 제한적인 것을 원하면 속성 쌍을 공백으로 구분하여 일치시키는 정규식을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa7cf65bf2ed58b9c07633b4dd41874bd458e314" translate="yes" xml:space="preserve">
          <source>Now, we could speak about the limits of this method from a more informed point of view:</source>
          <target state="translated">이제이 방법의 한계에 대해 더 많은 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1022301500a966b54ef35dd0b0c702c86a1e6cad" translate="yes" xml:space="preserve">
          <source>Oh... if you want the source code of the regex, with some auxiliary methods:</source>
          <target state="translated">아 ... 몇 가지 보조 방법을 사용하여 정규식의 소스 코드를 원한다면 :</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="efc9dd879d5fa6c41b5a8b4a174e9bbeea207c3f" translate="yes" xml:space="preserve">
          <source>P.S. Pierre de Fermat also figured out how to do it, but the margin he was writing in wasn't big enough for the code.</source>
          <target state="translated">PS Pierre de Fermat도 그 방법을 알아 냈지만, 그가 쓴 마진은 코드에 비해 크지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="fb344f772f606bf069b994b1800b75ad467d5eb0" translate="yes" xml:space="preserve">
          <source>Profit!</source>
          <target state="translated">Profit!</target>
        </trans-unit>
        <trans-unit id="ffe7bde078bc620df9c2922255941de3200d1c7e" translate="yes" xml:space="preserve">
          <source>Quote from article 1 cited above:</source>
          <target state="translated">위에서 인용 한 기사 1의 인용문 :</target>
        </trans-unit>
        <trans-unit id="ebb8b5eff359c8e4629b4281a740853315bc1649" translate="yes" xml:space="preserve">
          <source>RegEx match open tags except XHTML self-contained tags</source>
          <target state="translated">XHTML 자체 포함 태그를 제외한 정규식 일치 공개 태그</target>
        </trans-unit>
        <trans-unit id="8336d194052f52769b114f9bc2344752e9b3f02b" translate="yes" xml:space="preserve">
          <source>Regexes worked just fine for me, and were very fast to set up.</source>
          <target state="translated">정규식은 나를 위해 잘 작동했으며 설정이 매우 빨랐습니다.</target>
        </trans-unit>
        <trans-unit id="9ca09288e6a253e0dfa4bc1e29bfae12ab028bb9" translate="yes" xml:space="preserve">
          <source>Regular Expression Explained (inline)</source>
          <target state="translated">정규식 설명 (인라인)</target>
        </trans-unit>
        <trans-unit id="24b2174abc016feccbfb08853265c6a5a2ea6e89" translate="yes" xml:space="preserve">
          <source>Regular Expressions do have limitations, but have you considered the following?</source>
          <target state="translated">정규식에는 제한이 있지만 다음을 고려 했습니까?</target>
        </trans-unit>
        <trans-unit id="f20c01e8fa442e15f50708e2e685f84f38cf9f06" translate="yes" xml:space="preserve">
          <source>Regular Expressions: Now You Have Two Problems</source>
          <target state="translated">정규식 : 이제 두 가지 문제가 있습니다</target>
        </trans-unit>
        <trans-unit id="b49c5b3c647bd9589b36c369c0bc3c5a638f66ed" translate="yes" xml:space="preserve">
          <source>Related (why you shouldn't use regex match):</source>
          <target state="translated">관련 (정규식 일치를 사용하지 않아야하는 이유) :</target>
        </trans-unit>
        <trans-unit id="16962bdac3ee084e07372a69f0ada8648f72cfce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.microsoft.com/archive/blogs/bclteam/net-regular-expressions-regex-and-balanced-matching-ryan-byington&quot;&gt;.NET Regular Expressions: Regex and Balanced Matching&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.microsoft.com/archive/blogs/bclteam/net-regular-expressions-regex-and-balanced-matching-ryan-byington&quot;&gt;.NET 정규식 : 정규식 및 균형 일치를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de60e0a6c744236d2ff2a2469aa87dabd965b8f9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://weblogs.asp.net/whaggard/377025&quot;&gt;Matching Balanced Constructs with .NET Regular Expressions&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://weblogs.asp.net/whaggard/377025&quot;&gt;.NET 정규식과 균형 잡힌 구문 일치를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a3ea9fb6afc3bc06c915f2dc863ae7a60ef9464e" translate="yes" xml:space="preserve">
          <source>See Microsoft's docs on &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;Balancing Group Definitions&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;밸런싱 그룹 정의&lt;/a&gt; 에 대한 Microsoft 문서 참조</target>
        </trans-unit>
        <trans-unit id="0ad4363c94846f440a3409baad524ee90a091468" translate="yes" xml:space="preserve">
          <source>Should you find something which does not work in the proof of concept above, I am available in analyzing the code to improve my skills.</source>
          <target state="translated">위의 개념 증명에서 작동하지 않는 것을 찾으면 코드를 분석하여 기술을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92cfc65b8206d5667dc7ccac83a9a9a793d658df" translate="yes" xml:space="preserve">
          <source>Since nobody mentioned the main mechanism a parser is built onto, I was soon aware that nobody got the point.</source>
          <target state="translated">파서가 구축 된 주요 메커니즘을 아무도 언급하지 않았기 때문에 나는 아무도 그 요점을 알지 못한다는 것을 곧 알게되었다.</target>
        </trans-unit>
        <trans-unit id="4e222f3f71ebc82ced1555d79e3896204e2da9f1" translate="yes" xml:space="preserve">
          <source>Singleline</source>
          <target state="translated">Singleline</target>
        </trans-unit>
        <trans-unit id="2e489e37aeb575873f40d9f8a80c3e74b1c26ae6" translate="yes" xml:space="preserve">
          <source>Small tip: to better analyze this code it is necessary looking at the source code generated since I did not provide any HTML special characters escaping.</source>
          <target state="translated">작은 팁 :이 코드를 더 잘 분석하려면 HTML 특수 문자 이스케이프를 제공하지 않았기 때문에 생성 된 소스 코드를 살펴볼 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ccc837c5ed1e3feef77351cd1d620591415719e" translate="yes" xml:space="preserve">
          <source>Solve the Halting Problem.</source>
          <target state="translated">중단 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="b8fc19b88ebcae8fab9f0ca6d99cb4a564e9d1d4" translate="yes" xml:space="preserve">
          <source>Square a circle.</source>
          <target state="translated">원을 제곱합니다.</target>
        </trans-unit>
        <trans-unit id="e1c5ebb5af83fa15c6406a756fafb86dfda684e1" translate="yes" xml:space="preserve">
          <source>Sun Tzu, an ancient Chinese strategist, general, and philosopher, said:</source>
          <target state="translated">고대 중국의 전략가, 총장, 철학자 인 Sun Tzu는 다음과 같이 말했습니다.</target>
        </trans-unit>
        <trans-unit id="1361c33aa4292835661dbf5c91a1e629b1a6decc" translate="yes" xml:space="preserve">
          <source>The .NET framework is unique when it comes to regular expressions in that it supports &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;Balancing Group Definitions&lt;/a&gt;.</source>
          <target state="translated">.NET 프레임 워크는 &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;Balancing Group Definitions를&lt;/a&gt; 지원한다는 점에서 정규식에있어 고유합니다.</target>
        </trans-unit>
        <trans-unit id="55da94ce9e0ca8998eabc3076f92485f67f4f2eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.php.net/manual/en/function.dom-import-simplexml.php&quot;&gt;PHP DOM&lt;/a&gt;&lt;a href=&quot;http://php.net/manual/en/class.domdocument.php&quot;&gt;functions&lt;/a&gt; won't work properly unless it is properly formatted XML. No matter how much better their use is for the rest of mankind.</source>
          <target state="translated">&lt;a href=&quot;http://www.php.net/manual/en/function.dom-import-simplexml.php&quot;&gt;PHP DOM&lt;/a&gt; &lt;a href=&quot;http://php.net/manual/en/class.domdocument.php&quot;&gt;함수&lt;/a&gt; 는 XML 형식이 적절하지 않으면 제대로 작동하지 않습니다. 그들의 인류가 다른 인류에게 얼마나 잘 사용 되든지간에.</target>
        </trans-unit>
        <trans-unit id="4ac395740ae412d2f1cc1a46e41f7844bd6163b7" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;black art of RegExp is hard to master&lt;/strong&gt;, so maybe there are further possibilities we left out while trying and testing our personal solution to capture the whole web in one hand... Well, I am sure about it :)</source>
          <target state="translated">&lt;strong&gt;RegExp&lt;/strong&gt; 의 &lt;strong&gt;검은 예술은 마스터하기가 어렵 기&lt;/strong&gt; 때문에 개인 웹 전체를 한 손으로 캡처하기 위해 개인 솔루션을 테스트하고 테스트하는 동안 남은 가능성이 더있을 수 있습니다 ... 글쎄, 확실합니다 :)</target>
        </trans-unit>
        <trans-unit id="997812962876e0edf9df4c8486980789ffe0886d" translate="yes" xml:space="preserve">
          <source>The W3C explains parsing in a pseudo regexp form:</source>
          <target state="translated">W3C는 의사 정규 표현식 형식으로 구문 분석을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fdcdc94a48b14eafa651bbe7dd5b0b9e404ab530" translate="yes" xml:space="preserve">
          <source>The best way to write regular expressions is in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Lex_%28software%29&quot;&gt;Lex&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; style, not as opaque one-liners or commented multi-line monstrosities. I didn't do that here, yet; these ones barely need it.</source>
          <target state="translated">정규 표현식을 작성하는 가장 좋은 방법은 불투명 한 한 줄짜리 또는 주석이 달린 다중 행 괴물이 아닌 &lt;a href=&quot;http://en.wikipedia.org/wiki/Lex_%28software%29&quot;&gt;Lex&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; 스타일입니다. 나는 아직 여기서하지 않았다. 이것들은 간신히 필요합니다.</target>
        </trans-unit>
        <trans-unit id="712ab4b4a1f7ed2c6d0a80c8195f21170140f25f" translate="yes" xml:space="preserve">
          <source>The following matches a fairly strict definition of XML tags (although it doesn't account for the full set of Unicode characters allowed in XML names):</source>
          <target state="translated">다음은 XML 태그에 허용되는 전체 유니 코드 문자를 설명하지는 않지만 상당히 엄격한 XML 태그 정의와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b4cfd79b880dc8c38082dbd0830e9fdee4557b44" translate="yes" xml:space="preserve">
          <source>The options to set is &lt;code&gt;RegexOptions.ExplicitCapture&lt;/code&gt;. The capture group you are looking for is &lt;code&gt;ELEMENTNAME&lt;/code&gt;. If the capture group &lt;code&gt;ERROR&lt;/code&gt; is not empty then there was a parsing error and the Regex stopped.</source>
          <target state="translated">설정할 옵션은 &lt;code&gt;RegexOptions.ExplicitCapture&lt;/code&gt; 입니다. 찾고있는 캡처 그룹은 &lt;code&gt;ELEMENTNAME&lt;/code&gt; 입니다. 캡처 그룹 &lt;code&gt;ERROR&lt;/code&gt; 가 비어 있지 않으면 구문 분석 오류가 발생했으며 정규식이 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="42afcd3eb11823b2c3d7a0e945433e5d9be383b6" translate="yes" xml:space="preserve">
          <source>The parts explained:</source>
          <target state="translated">부품 설명 :</target>
        </trans-unit>
        <trans-unit id="7b1c98adf4b68d1b5b5505c62c8cdcb98c54e922" translate="yes" xml:space="preserve">
          <source>The pattern will be pretty big, so make sure you have an algorithm that losslessly compresses random data.</source>
          <target state="translated">패턴이 상당히 커지므로 임의의 데이터를 손실없이 압축하는 알고리즘이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7216ec9c43638b3c7e394bf44fd4c73431e98cef" translate="yes" xml:space="preserve">
          <source>The suggested regex is wrong, though:</source>
          <target state="translated">그러나 제안 된 정규 표현식은 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="9a7f6c57efe365adfc81358edd4c2317e716adc0" translate="yes" xml:space="preserve">
          <source>The tag to match may end with a simple &quot;&amp;gt;&quot; symbol, or a possible XHTML closure, which makes use of the slash before it: (/&amp;gt;|&amp;gt;). The slash is, of course, escaped since it coincides with the regular expression delimiter.</source>
          <target state="translated">일치하는 태그는 간단한 &quot;&amp;gt;&quot;기호 또는 슬래시 (// ||&amp;gt;)를 사용하는 XHTML 클로저로 끝날 수 있습니다. 물론 슬래시는 정규식 구분 기호와 일치하기 때문에 이스케이프 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="d8320be450cb3daac23d24918c511589e5cc20d4" translate="yes" xml:space="preserve">
          <source>The user @ridgerunner noticed that the pattern does not allow &lt;strong&gt;unquoted attributes&lt;/strong&gt; or &lt;strong&gt;attributes with no value&lt;/strong&gt;. In this case a fine tuning brings us the following pattern:</source>
          <target state="translated">@ridgerunner 사용자는 패턴이 &lt;strong&gt;인용되지 않은 속성&lt;/strong&gt; 이나 &lt;strong&gt;값이없는 속성을&lt;/strong&gt; 허용하지 않음을 알았습니다. 이 경우 미세 조정하면 다음과 같은 패턴이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="96ae70a6ef53719f5c2ee204876a53bf013a8cbd" translate="yes" xml:space="preserve">
          <source>Then, since a tag may end with a whitespace before the &quot;&amp;gt;&quot; symbol, zero or more whitespaces are matched with the \s* subpattern.</source>
          <target state="translated">그러면 태그가 &quot;&amp;gt;&quot;기호 앞에 공백으로 끝나기 때문에 0 개 이상의 공백이 \ s * 하위 패턴과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="868220302ade7af78023c7b85a0b0afbdb075b65" translate="yes" xml:space="preserve">
          <source>There are people that will tell you that Regular Expressions shouldn't be recursive. They are limiting you. They need to subjugate you, and they do it by keeping you in ignorance.</source>
          <target state="translated">정규 표현식이 재귀 적이 지 않아야한다고 말하는 사람들이 있습니다. 그들은 당신을 제한하고 있습니다. 그들은 당신을 정복해야하며, 당신을 무지하게 유지함으로써 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="62180d2f49459a045257d1d5b700900365c68916" translate="yes" xml:space="preserve">
          <source>There are people that will tell you that the Earth is round (or perhaps that the Earth is an oblate spheroid if they want to use strange words). They are lying.</source>
          <target state="translated">지구가 둥글다는 말을하는 사람들이 있습니다 (혹은 이상한 단어를 사용하고자한다면 지구가 편 원형의 스페 로이드 일 수도 있습니다). 그들은 거짓말하고있다.</target>
        </trans-unit>
        <trans-unit id="684dfff1de896a122d012445ef544b2496206f87" translate="yes" xml:space="preserve">
          <source>There are some nice regexes for replacing HTML with BBCode &lt;a href=&quot;http://www.garyshood.com/htmltobb/source.txt&quot;&gt;here&lt;/a&gt;. For all you nay-sayers, note that he's not trying to fully parse HTML, just to sanitize it. He can probably afford to kill off tags that his simple &quot;parser&quot; can't understand.</source>
          <target state="translated">여기에 HTML을 BBCode로 대체하는 멋진 정규식이 &lt;a href=&quot;http://www.garyshood.com/htmltobb/source.txt&quot;&gt;있습니다&lt;/a&gt; . 네이저 사람들 모두 HTML을 완전히 파싱하지 않고 위생적으로 처리하려고한다는 점에 주목하자. 그는 자신의 간단한 &quot;파서&quot;가 이해할 수없는 태그를 제거 할 여유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="76477d9fdddcc475f5d450550d80b052eec3964d" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;http://blog.stevenlevithan.com/archives/match-innermost-html-element&quot;&gt;definitive blog post&lt;/a&gt; about matching innermost HTML elements written by Steven Levithan.</source>
          <target state="translated">Steven Levithan이 작성한 가장 안쪽의 HTML 요소를 일치시키는 것에 대한 &lt;a href=&quot;http://blog.stevenlevithan.com/archives/match-innermost-html-element&quot;&gt;결정적인 블로그 게시물&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4e1c0773bdde0557a23f8bb7011bb1819bc446f" translate="yes" xml:space="preserve">
          <source>These constructs allow for a .NET regular expression to emulate a
  restricted PDA by essentially allowing simple versions of the stack
  operations: push, pop and empty. The simple operations are pretty much
  equivalent to increment, decrement and compare to zero respectively.
  This allows for the .NET regular expression engine to recognize a
  subset of the context-free languages, in particular the ones that only
  require a simple counter. This in turn allows for the non-traditional
  .NET regular expressions to recognize individual properly balanced
  constructs.</source>
          <target state="translated">이러한 구문을 통해 .NET 정규식은 간단한 버전의 스택 작업 (푸시, 팝 및 빈)을 기본적으로 허용함으로써 제한된 PDA를 에뮬레이션 할 수 있습니다. 간단한 작업은 각각 증가, 감소 및 0과 비교하는 것과 거의 같습니다. 이를 통해 .NET 정규식 엔진은 컨텍스트가없는 언어의 하위 집합, 특히 간단한 카운터 만 필요한 언어를 인식 할 수 있습니다. 결과적으로 비 전통적인 .NET 정규 표현식이 적절히 균형 잡힌 개별 구성을 인식 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83ac605b777d6f693f2b21254eb270d567a76728" translate="yes" xml:space="preserve">
          <source>They are good for XML / XHTML.</source>
          <target state="translated">XML / XHTML에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ea04181710e1449f97e72ce6888abc9705be60aa" translate="yes" xml:space="preserve">
          <source>This found the match:</source>
          <target state="translated">이것은 일치하는 것을 발견했습니다 :</target>
        </trans-unit>
        <trans-unit id="bbe32d2a62e217c596147afa1c643ecf26c036ca" translate="yes" xml:space="preserve">
          <source>This is the regex I use (!) to match HTML tags:</source>
          <target state="translated">이것은 HTML 태그와 일치시키기 위해 내가 사용하는 정규식입니다!</target>
        </trans-unit>
        <trans-unit id="d8d8d6a39df8c08ee1ff1787d57aba7ddbd1bee3" translate="yes" xml:space="preserve">
          <source>This post is locked to prevent inappropriate edits to its content. The post looks exactly as it is supposed to look - there are no problems with its content. Please do not flag it for our attention.</source>
          <target state="translated">이 게시물은 내용의 부적절한 편집을 방지하기 위해 잠겨 있습니다. 게시물은 모양과 똑같이 보입니다. 내용에 문제가 없습니다. 주의를 끌기 위해 신고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="20cb5dd39a077afa5b7e29efe1aa539dad4031b6" translate="yes" xml:space="preserve">
          <source>To test it deeply, I entered in the string auto-closing tags like:</source>
          <target state="translated">깊이 테스트하기 위해 다음과 같이 문자열 자동 닫기 태그를 입력했습니다.</target>
        </trans-unit>
        <trans-unit id="102acb4ebe4f9295900af5f522c91830395377c0" translate="yes" xml:space="preserve">
          <source>Try:</source>
          <target state="translated">Try:</target>
        </trans-unit>
        <trans-unit id="a26ac4a7ee00f2bdbb69b3a7cd21e43c2ce7b858" translate="yes" xml:space="preserve">
          <source>Turing.sed</source>
          <target state="translated">Turing.sed</target>
        </trans-unit>
        <trans-unit id="a28f42522bb52c00621284c63c8ba53d7dfda10f" translate="yes" xml:space="preserve">
          <source>UNRELATED</source>
          <target state="translated">UNRELATED</target>
        </trans-unit>
        <trans-unit id="e8d3e730d87ce69a125b79edeeb87c6e997fdfb7" translate="yes" xml:space="preserve">
          <source>Understanding the pattern</source>
          <target state="translated">패턴 이해</target>
        </trans-unit>
        <trans-unit id="ada5ca9b4d7507ffcf81b9659577ff9cbe1d1ccf" translate="yes" xml:space="preserve">
          <source>Use the flags:</source>
          <target state="translated">플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="24df9df6515abc09f921403db3f2eb9d44796515" translate="yes" xml:space="preserve">
          <source>W3C Link</source>
          <target state="translated">W3C 링크</target>
        </trans-unit>
        <trans-unit id="01acb4cbe019ba6b6ce6e22bcd09638b1774d9c8" translate="yes" xml:space="preserve">
          <source>Whenever I need to quickly extract something from an HTML document, I use Tidy to convert it to XML and then use XPath or XSLT to get what I need.
In your case, something like this:</source>
          <target state="translated">HTML 문서에서 무언가를 빠르게 추출해야 할 때마다 Tidy를 사용하여 XML로 변환 한 다음 XPath 또는 XSLT를 사용하여 필요한 것을 얻습니다. 귀하의 경우 다음과 같은 것 :</target>
        </trans-unit>
        <trans-unit id="49b8872857a1e031d0578f467b1e399793cd9b96" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;(?&amp;lt;! ... )&lt;/code&gt; is (in Perl regexes) the negative look-behind. It reads &quot;a &amp;lt;, then a word, then anything that's not a &amp;gt;, the last of which may not be a /, followed by &amp;gt;&quot;.</source>
          <target state="translated">&lt;code&gt;(?&amp;lt;! ... )&lt;/code&gt; 는 (Perl 정규식에서) 부정적인이면입니다. &quot;, &amp;lt;, 단어, 그리고&amp;gt;가 아닌 모든 것을 읽습니다. 마지막은 /가 아닐 수 있습니다.&amp;gt;&quot;.</target>
        </trans-unit>
        <trans-unit id="d88b6a634389ee3ca966ecac67f70a5331dc8d96" translate="yes" xml:space="preserve">
          <source>While &lt;em&gt;arbitrary&lt;/em&gt; HTML with only a regex is impossible, it's sometimes appropriate to use them for parsing a &lt;em&gt;limited, known&lt;/em&gt; set of HTML.</source>
          <target state="translated">정규 표현식 만있는 &lt;em&gt;임의의&lt;/em&gt; HTML은 불가능하지만 &lt;em&gt;제한된&lt;/em&gt; HTML 집합을 구문 분석하는 데 사용하는 것이 때로는 적절합니다.</target>
        </trans-unit>
        <trans-unit id="b1bfbd9fe61d2ecc1e2a19393a476e7388bf0166" translate="yes" xml:space="preserve">
          <source>While the answers that you can't parse HTML with regexes are correct, they don't apply here. The OP just wants to parse one HTML tag with regexes, and that is something that can be done with a regular expression.</source>
          <target state="translated">정규 표현식으로 HTML을 구문 분석 할 수없는 대답은 정확하지만 여기에는 적용되지 않습니다. OP는 단지 하나의 HTML 태그를 정규 표현식으로 구문 분석하고 싶어하며 정규 표현식으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93249a5d51a2ea1bf181a9d0b47641aa389e6924" translate="yes" xml:space="preserve">
          <source>With minor variations, it can cope with messy HTML... or convert the HTML -&amp;gt; XHTML first.</source>
          <target state="translated">약간의 변형으로 지저분한 HTML에 대처하거나 HTML-&amp;gt; XHTML을 먼저 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86912b1a63422276d3fb2e364ae480edfb2fc529" translate="yes" xml:space="preserve">
          <source>Work out the Traveling Salesman Problem in O(log n) or less. If it's any more than that, you'll run out of RAM and the engine will hang.</source>
          <target state="translated">출장 세일즈맨 문제를 O (log n) 이하로 해결하십시오. 그 이상이면 RAM이 부족하고 엔진이 정지합니다.</target>
        </trans-unit>
        <trans-unit id="865301223dfe7d72c3b014a14a4edf685de64f15" translate="yes" xml:space="preserve">
          <source>Write HTML parser (homework)</source>
          <target state="translated">HTML 파서 작성 (숙제)</target>
        </trans-unit>
        <trans-unit id="99b34e00427c7bc9e27cce20b1b8167ea540549e" translate="yes" xml:space="preserve">
          <source>You can live in their reality or take the red pill.</source>
          <target state="translated">당신은 그들의 현실에서 살거나 빨간 약을 먹을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6a9711b57d9a5eea84e16f2d7ce057f02584407" translate="yes" xml:space="preserve">
          <source>You can try this at &lt;a href=&quot;http://derekslager.com/blog/posts/2007/09/a-better-dotnet-regular-expression-tester.ashx&quot;&gt;A Better .NET Regular Expression Tester&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://derekslager.com/blog/posts/2007/09/a-better-dotnet-regular-expression-tester.ashx&quot;&gt;A Better .NET Regular Expression Tester&lt;/a&gt; 에서 시도해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b81d0ffa357688587ac76745c399587c1efb48a" translate="yes" xml:space="preserve">
          <source>You can't parse [X]HTML with regex. Because HTML can't be parsed by regex. Regex is not a tool that can be used to correctly parse HTML. As I have answered in HTML-and-regex questions here so many times before, the use of regex will not allow you to consume HTML. Regular expressions are a tool that is insufficiently sophisticated to understand the constructs employed by HTML. HTML is not a regular language and hence cannot be parsed by regular expressions. Regex queries are not equipped to break down HTML into its meaningful parts. so many times but it is not getting to me. Even enhanced irregular regular expressions as used by Perl are not up to the task of parsing HTML. You will never make me crack. HTML is a language of sufficient complexity that it cannot be parsed by regular expressions. Even Jon Skeet cannot parse HTML using regular expressions. Every time you attempt to parse HTML with regular expressions, the unholy child weeps the blood of virgins, and Russian hackers pwn your webapp. Parsing HTML with regex summons tainted souls into the realm of the living. HTML and regex go together like love, marriage, and ritual infanticide. The &amp;lt;center&amp;gt; cannot hold it is too late. The force of regex and HTML together in the same conceptual space will destroy your mind like so much watery putty. If you parse HTML with regex you are giving in to Them and their blasphemous ways which doom us all to inhuman toil for the One whose Name cannot be expressed in the Basic Multilingual Plane, he comes. HTML-plus-regexp will liquify the n​erves of the sentient whilst you observe, your psyche withering in the onslaught of horror. Rege̿̔̉x-based HTML parsers are the cancer that is killing StackOverflow</source>
          <target state="translated">[X] HTML을 정규식으로 구문 분석 할 수 없습니다. 정규식으로 HTML을 파싱 할 수 없기 때문입니다. 정규식은 HTML을 올바르게 구문 분석하는 데 사용할 수있는 도구가 아닙니다. 이전에 HTML 및 정규식 질문에 여러 번 답변 했으므로 정규식을 사용하면 HTML을 사용할 수 없습니다. 정규식은 HTML에 의해 사용 된 구문을 이해하기에 충분히 정교하지 않은 도구입니다. HTML은 정규 언어가 아니므로 정규 표현식으로 구문 분석 할 수 없습니다. 정규식 쿼리는 HTML을 의미있는 부분으로 분류 할 수 없습니다. 너무 많은 시간이지만 그것은 나에게 도착하지 않습니다. Perl이 사용하는 향상된 불규칙 정규 표현식조차도 HTML 구문 분석 작업에 달려 있지 않습니다. 당신은 결코 나를 부수 지 않을 것입니다. HTML은 정규 표현식으로 구문 분석 할 수 없을 정도로 복잡한 언어입니다. Jon Skeet조차도 정규 표현식을 사용하여 HTML을 구문 분석 할 수 없습니다. 정규식으로 HTML을 구문 분석하려고 시도 할 때마다 부정한 아이는 처녀의 피를 흘리고 러시아 해커는 웹앱을 뿌립니다. 정규 표현식 소환으로 HTML을 파싱하면 영혼이 살아있는 영역으로 오염되었습니다. HTML과 정규식은 사랑, 결혼, 의식적인 보살핌과 같이 어울립니다. &amp;lt;center&amp;gt;가 너무 늦을 수 없습니다. 같은 개념 공간에서 정규 표현식과 HTML의 힘이 너무 많은 물 퍼티처럼 당신의 마음을 파괴합니다. 정규식으로 HTML을 파싱하면 기본 다국어 비행기로 이름을 표현할 수없는 분을 위해 비인간적 인 수고로 우리를 파멸시키는 그들과 그 모독적인 방법을 제시합니다. HTML-plus-regexp는 당신이 관찰하는 동안 지각의 신경을 유동화시킬 것입니다. Rege̿̔̉x 기반 HTML 파서는 암을 유발하는 암입니다</target>
        </trans-unit>
        <trans-unit id="d4cc5878bfc8de446a816e62a10b477bf7628da8" translate="yes" xml:space="preserve">
          <source>You want the first &lt;code&gt;&amp;gt;&lt;/code&gt; not preceded by a &lt;code&gt;/&lt;/code&gt;.  Look &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;here&lt;/a&gt; for details on how to do that.  It's referred to as negative lookbehind.</source>
          <target state="translated">첫 번째 &lt;code&gt;&amp;gt;&lt;/code&gt; 앞에 &lt;code&gt;/&lt;/code&gt; 를 사용 하지 않아야합니다. 방법에 대한 자세한 내용은 &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 . 이를 부정적인 lookbehind라고합니다.</target>
        </trans-unit>
        <trans-unit id="0f094d4f9e70b554306ad025350bec42add64291" translate="yes" xml:space="preserve">
          <source>a&lt;sup&gt;n&lt;/sup&gt;ba&lt;sup&gt;n&lt;/sup&gt;ba&lt;sup&gt;n&lt;/sup&gt; which is not regular and not even context free, can be matched with &lt;code&gt;^(a+)b\1b\1$&lt;/code&gt;</source>
          <target state="translated">규칙적이지 않고 컨텍스트가없는 &lt;sup&gt;n&lt;/sup&gt; ba &lt;sup&gt;n&lt;/sup&gt; ba &lt;sup&gt;n&lt;/sup&gt; 은 &lt;code&gt;^(a+)b\1b\1$&lt;/code&gt; 와 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f7db1a41076f29a8bc513a82d4eeb79c22c4b29" translate="yes" xml:space="preserve">
          <source>according to the specific implementation of the RegExp engine, recursion may have a limit in the &lt;strong&gt;number of nested patterns parsed&lt;/strong&gt;, but it depends on the language used</source>
          <target state="translated">RegExp 엔진의 특정 구현에 따르면 재귀에는 &lt;strong&gt;구문 분석 된 중첩 패턴&lt;/strong&gt; 의 &lt;strong&gt;수가&lt;/strong&gt; 제한 될 수 있지만 사용되는 언어에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c4d4e32662c88b8424d1c0984fceefe61e4e23a5" translate="yes" xml:space="preserve">
          <source>again, zero or more whitespaces</source>
          <target state="translated">다시, 0 개 이상의 공백</target>
        </trans-unit>
        <trans-unit id="416344de81011e88293f4de90995d2f4eb4cfe70" translate="yes" xml:space="preserve">
          <source>ain, the song of re̸gular exp​re&lt;strike&gt;ssion parsing &lt;/strike&gt;will exti</source>
          <target state="translated">ain, rerecigular expre &lt;strike&gt;ssion parsing&lt;/strike&gt; 의 노래는 사라질 것입니다</target>
        </trans-unit>
        <trans-unit id="dac38d2a71b13841b4f7fa59c2cbb41d8f4fe7c5" translate="yes" xml:space="preserve">
          <source>although corrupted (x)HTML does not drive into severe errors, it is not &lt;em&gt;sanitized&lt;/em&gt;.</source>
          <target state="translated">손상된 (x) HTML이 심각한 오류를 일으키지 않지만 &lt;em&gt;위생&lt;/em&gt; 상태가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b2c0c9e8369c247831710c647b81dda3b5b625b1" translate="yes" xml:space="preserve">
          <source>although it actually came out like this:</source>
          <target state="translated">실제로 다음과 같이 나왔습니다.</target>
        </trans-unit>
        <trans-unit id="b91f3e1f4b4ae9ba5a969df90fc854016c1cfedf" translate="yes" xml:space="preserve">
          <source>and the dread realm of c͒ͪo͛ͫrrupt entities (like SGML entities, but</source>
          <target state="translated">cGoRͫRrupt 엔티티의 무서운 영역 (SGML 엔티티와 같지만</target>
        </trans-unit>
        <trans-unit id="789d3b546d80c656a137d6a2dae501ef948c9936" translate="yes" xml:space="preserve">
          <source>attributes containing single quotes when the delimiter is a double quote and vice versa</source>
          <target state="translated">분리 문자가 큰 따옴표 인 경우 작은 따옴표를 포함하는 속성</target>
        </trans-unit>
        <trans-unit id="83049ba02543c5468a7092d704e728351f015ce0" translate="yes" xml:space="preserve">
          <source>attributes which value is bound either into &lt;strong&gt;single quotes&lt;/strong&gt; or into &lt;strong&gt;double quotes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;작은 따옴표&lt;/strong&gt; 나 &lt;strong&gt;큰 따옴표&lt;/strong&gt; 로 묶인 값</target>
        </trans-unit>
        <trans-unit id="872af077bba705c60415b90068389b0d9ae136b2" translate="yes" xml:space="preserve">
          <source>ch between this world</source>
          <target state="translated">이 세상 사이</target>
        </trans-unit>
        <trans-unit id="b1ccf8aca583f64c44e6498a0abc71300cee934c" translate="yes" xml:space="preserve">
          <source>d of ceaseless screaming, he comes&lt;strike&gt;, the pestilent sl&lt;/strike&gt;ithy regex-infection wil​&lt;b&gt;l devour your HT&lt;/b&gt;​ML parser, application and existence for all time like Visual Basic only worse</source>
          <target state="translated">그는 끊임없는 비명을 지르고, 그는 온다 &lt;strike&gt;.&lt;/strike&gt; 유쾌한 &lt;strike&gt;sl&lt;/strike&gt; ithy regex-infection은 Visual Basic과 같은 모든 시간 동안 &lt;b&gt;HT&lt;/b&gt; ML 파서, 응용 프로그램 및 존재를 &lt;b&gt;삼킬 것입니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fad2a06a8e728d64f3eff45851e3b600bd2bf437" translate="yes" xml:space="preserve">
          <source>dear lord help us how can anyone survive this scourge</source>
          <target state="translated">친애하는 주님 우리가 어떻게이 재앙에서 살아남을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="5b52a1cb49381cdd269797b153d0660ee9133944" translate="yes" xml:space="preserve">
          <source>do not fi</source>
          <target state="translated">Fi를하지 마십시오</target>
        </trans-unit>
        <trans-unit id="b9dea77ba556480de7588671f4a3d44f039e5d2e" translate="yes" xml:space="preserve">
          <source>e pon̷y he come</source>
          <target state="translated">그가 온다</target>
        </trans-unit>
        <trans-unit id="09cd68a2a77b22a312dded612dd0d9988685189f" translate="yes" xml:space="preserve">
          <source>es</source>
          <target state="translated">es</target>
        </trans-unit>
        <trans-unit id="707cd90a4f77675613cc63dfa16b29bedcf7d2e6" translate="yes" xml:space="preserve">
          <source>es al</source>
          <target state="translated">에스 알</target>
        </trans-unit>
        <trans-unit id="16829609b87ebecff7cb40016842539439ef333f" translate="yes" xml:space="preserve">
          <source>e̠̅s&lt;code&gt; ͎a̧͈͖r̽̾̈́͒͑e&lt;/code&gt; n&lt;b&gt;​ot rè̑ͧ̌aͨl̘̝̙̃ͤ͂̾̆ ZA̡͊͠͝LGΌ ISͮ̂҉̯͈͕̹̘̱ T&lt;/b&gt;O͇̹̺ͅƝ̴ȳ̳ TH̘&lt;b&gt;Ë͖́̉ ͠P̯͍̭O̚​N̐Y̡ H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝&lt;/b&gt;S̨̥̫͎̭ͯ̿̔̀ͅ</source>
          <target state="translated">e̠̅s &lt;code&gt; ͎a̧͈͖r̽̾̈́͒͑e&lt;/code&gt; n &lt;b&gt;ot &amp;agrave;̑ͧ̌lZA̡͊͝ ZA̡͊͠͝LGΌ ISͮ̂҉̯͈͕̹̘̱ T&lt;/b&gt; O͇̹̺ͅƝ̴ȳ̳ &lt;b&gt;TH̘ &amp;Euml;͖́̉ ͠P̯̚&amp;Oacute;̚N̐Y̡ H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̖͊̒ͪͩͬ̚̚͜Ȩ̴̟̟͙̑ͩ͌ͧ̾ͬ͝&lt;/b&gt; S̨̫͎̭ͯ̿̔̀̽ͅ</target>
        </trans-unit>
        <trans-unit id="0a971adf10fafe8fe3d724d80e0beaa10f271291" translate="yes" xml:space="preserve">
          <source>f the lie​&lt;b&gt;s of Man ALL IS LOŚ͖̩͇̗̪̏̈́T A&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;인간&lt;/b&gt; 의 거짓말 &lt;b&gt;에는 모두가 잃어 버렸다&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6c0c535eae65a352e21a597046b9c71062ef7e32" translate="yes" xml:space="preserve">
          <source>he an​*̶͑̾̾​̅ͫ͏̙̤g͇̫͛͆̾ͫ̑͆l͖͉̗̩̳̟̍ͫͥͨ</source>
          <target state="translated">그는 * ̶͑̾̾ ̅ͫ͏̙̤g͇̫͛͆̾ͫ̑͆l͖͉̗̩̳̟̍ͫͥͨ</target>
        </trans-unit>
        <trans-unit id="21f7c212343db1452bf1005fe7bec61697f3efef" translate="yes" xml:space="preserve">
          <source>he comes he com</source>
          <target state="translated">그는 온다</target>
        </trans-unit>
        <trans-unit id="c1b6858eae6b82f5a342bbfcd9d5505ae8d8b304" translate="yes" xml:space="preserve">
          <source>he f&lt;code&gt;inal snuf&lt;/code&gt;fing o</source>
          <target state="translated">그는 &lt;code&gt;inal snuf&lt;/code&gt; 핑 오</target>
        </trans-unit>
        <trans-unit id="cba0af89feed0e8e942fec8ed4c10695745c757d" translate="yes" xml:space="preserve">
          <source>here comes the fun: the \4 part is a &lt;strong&gt;backreference operator&lt;/strong&gt;, which refers to a sub-expression defined before in the pattern, in this case, I am referring to the fourth sub-expression, which is the first attribute delimiter found</source>
          <target state="translated">\ 4 부분은 &lt;strong&gt;역 참조 연산자&lt;/strong&gt; 이며, 패턴에서 이전에 정의 된 하위 표현식을 참조합니다.이 경우에는 첫 번째 속성 구분 기호 인 네 번째 하위 표현식을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="a8ec278d2e709b878840d59f0dc4611cd1bb49d5" translate="yes" xml:space="preserve">
          <source>it is too late it is too late we cannot be saved</source>
          <target state="translated">너무 늦었 어 너무 늦어서 구원받을 수 없어</target>
        </trans-unit>
        <trans-unit id="a38cb8457436d320aa6e6a447ea6ac270b0eb2aa" translate="yes" xml:space="preserve">
          <source>l MY FAC</source>
          <target state="translated">l 내 FAC</target>
        </trans-unit>
        <trans-unit id="eb912827300bfa09ffaae9a61a04131d928f17d2" translate="yes" xml:space="preserve">
          <source>more corrupt) a mere glimp</source>
          <target state="translated">더 부패) 단순한 엿보기</target>
        </trans-unit>
        <trans-unit id="5a4bedc53d646eb4f152665ce04f194f119d1230" translate="yes" xml:space="preserve">
          <source>more than one attribute</source>
          <target state="translated">둘 이상의 속성</target>
        </trans-unit>
        <trans-unit id="0f0f39e938eb9a6927af1fd3169cbf5dc39c8c05" translate="yes" xml:space="preserve">
          <source>nto a w</source>
          <target state="translated">아냐</target>
        </trans-unit>
        <trans-unit id="f676ebbcb5a6de68fd4cd64947f2f073b0bc183b" translate="yes" xml:space="preserve">
          <source>one attribute</source>
          <target state="translated">하나의 속성</target>
        </trans-unit>
        <trans-unit id="b63094eb585e278a2a9faac15421a9c3b8a73f5d" translate="yes" xml:space="preserve">
          <source>one or more whitespaces \s+</source>
          <target state="translated">하나 이상의 공백 \ s +</target>
        </trans-unit>
        <trans-unit id="a4f0099e46341d0fc7c083fc51657b45fb1eb61a" translate="yes" xml:space="preserve">
          <source>or just combine if and if not.</source>
          <target state="translated">또는 그렇지 않은 경우 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="90255a902e3a09b87ea94d0074d32fa53f1e3df0" translate="yes" xml:space="preserve">
          <source>orl</source>
          <target state="translated">orl</target>
        </trans-unit>
        <trans-unit id="5beefb69787012b543ff81b246c6096ef31b16cb" translate="yes" xml:space="preserve">
          <source>rogrammer's consciousness i</source>
          <target state="translated">로그 램머의 의식 i</target>
        </trans-unit>
        <trans-unit id="a529326c3bc272f1c87faf0fc168c3f2b888e5e1" translate="yes" xml:space="preserve">
          <source>s he c̶̮om&lt;strike&gt;es he co&lt;/strike&gt;&lt;b&gt;&lt;strike&gt;me&lt;/strike&gt;s t&lt;i&gt;he&lt;/i&gt; ich​&lt;/b&gt;or permeat</source>
          <target state="translated">그는 자신을 화나게 &lt;b&gt;하거나&lt;/b&gt; 퍼 미트로 데려 온다</target>
        </trans-unit>
        <trans-unit id="cdc9e9914e559a22d8c2863df88dcc0affd254bb" translate="yes" xml:space="preserve">
          <source>se of the world of reg​&lt;b&gt;ex parsers for HTML will ins&lt;/b&gt;​tantly transport a p</source>
          <target state="translated">&lt;b&gt;HTML에 대한&lt;/b&gt; 정규 표현식 &lt;b&gt;파서&lt;/b&gt; 의 세계의 se는 즉시 ap를 전송합니다</target>
        </trans-unit>
        <trans-unit id="fcd31f61fdd2492a68c910cd84210be08c96a97c" translate="yes" xml:space="preserve">
          <source>stro҉ying all enli̍̈́̂̈́ghtenment, HTML tags &lt;b&gt;lea͠ki̧n͘g fr̶ǫm ̡yo​͟ur eye͢s̸ ̛l̕ik͏e liq&lt;/b&gt;​uid p</source>
          <target state="translated">모든 환경을 강화하고 HTML 태그를 사용 &lt;b&gt;하여 눈에 띄지 않게하세요.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="13cecb0242cc098120804e419e2c0898d7c5f3d9" translate="yes" xml:space="preserve">
          <source>the &quot;=&quot; symbol</source>
          <target state="translated">&quot;=&quot;기호</target>
        </trans-unit>
        <trans-unit id="ef1ddac3121c15757add5489d19c276fcda4e43f" translate="yes" xml:space="preserve">
          <source>the attribute sub-expression ends here, with the specification of zero or more possible occurrences, given by the asterisk.</source>
          <target state="translated">속성 하위 표현식은 별표로 제공되는 0 개 이상의 가능한 발생을 지정하여 여기에서 끝납니다.</target>
        </trans-unit>
        <trans-unit id="9fb82ad748ee217a3d8676ebffa5f977ad107e1b" translate="yes" xml:space="preserve">
          <source>the delimiter of the attribute value, a single or double quote ('|&quot;). In the pattern, the single quote is escaped because it coincides with the PHP string delimiter. This sub-expression is captured with the parentheses so it can be referenced again to parse the closure of the attribute, that's why it is very important.</source>
          <target state="translated">속성 값의 구분 기호, 작은 따옴표 또는 큰 따옴표 ( '| &quot;). 패턴에서 작은 따옴표는 PHP 문자열 구분 기호와 일치하기 때문에 이스케이프 처리됩니다.이 하위 표현식은 괄호로 묶여 참조 될 수 있습니다. 속성의 클로저를 다시 파싱하기 위해서는 이것이 매우 중요한 이유입니다.</target>
        </trans-unit>
        <trans-unit id="bf47c953b6d49b59cea7ef6e949bcd244312ad84" translate="yes" xml:space="preserve">
          <source>the first sub-expression (\w+) matches the tag name</source>
          <target state="translated">첫 번째 하위 표현식 (\ w +)은 태그 이름과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8ff32fe1a0c4d2f2143244e76a1ea25a84d0a50e" translate="yes" xml:space="preserve">
          <source>the name of the attribute (\w+)</source>
          <target state="translated">속성의 이름 (\ w +)</target>
        </trans-unit>
        <trans-unit id="a63f6d3ba68d8159445680753d6b7dcfea330647" translate="yes" xml:space="preserve">
          <source>the second sub-expression contains the pattern of an attribute. It is composed by:</source>
          <target state="translated">두 번째 하위 표현식에는 속성 패턴이 포함됩니다. 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="98c53a01bc3d612ea14d5657a8251e38b47274e3" translate="yes" xml:space="preserve">
          <source>the trangession of a chi͡ld ensures regex will consume all living tissue (except for HTML which it cannot, as previously prophesied)</source>
          <target state="translated">chi͡ld의 trangession은 정규 표현식이 모든 살아있는 조직을 소비하도록 보장합니다 (이전에 예언 된대로 HTML은 제외)</target>
        </trans-unit>
        <trans-unit id="fcae9afa44c8d009bc39cd1558b5bcceb178f9f3" translate="yes" xml:space="preserve">
          <source>the value of the attribute, matched by &lt;em&gt;almost&lt;/em&gt; anything: (.*?); in this specific syntax, using the &lt;strong&gt;greedy match&lt;/strong&gt; (the question mark after the asterisk) the RegExp engine enables a &quot;look-ahead&quot;-like operator, which matches anything but what follows this sub-expression</source>
          <target state="translated">&lt;em&gt;거의&lt;/em&gt; 모든 것과 일치하는 속성 값 : (. *?); 이 특정 구문에서 &lt;strong&gt;욕심 일치&lt;/strong&gt; (별표 뒤에 물음표)를 사용하여 RegExp 엔진을 사용하면이 하위 표현 뒤에 나오는 것 외에는 어떤 것과도 일치하는 &quot;look-ahead&quot;와 같은 연산자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8cdc833b2aa479524c91f0c0770ca55cab15dbc" translate="yes" xml:space="preserve">
          <source>using rege</source>
          <target state="translated">리지를 사용하여</target>
        </trans-unit>
        <trans-unit id="05316c08fdd253a1c9a83c01ccb3802a454fbc33" translate="yes" xml:space="preserve">
          <source>using regex to parse HTML has doomed humanity to an eternity of dread torture and security holes</source>
          <target state="translated">정규 표현식을 사용하여 HTML을 구문 분석하면 인류가 영원한 고문과 보안상의 허점으로 끝났습니다.</target>
        </trans-unit>
        <trans-unit id="ab44de7440b2ebdde8558b36f16d5f922c19d2d5" translate="yes" xml:space="preserve">
          <source>x as a tool to process HTML establishes a brea</source>
          <target state="translated">HTML을 처리하기위한 도구로서 x</target>
        </trans-unit>
        <trans-unit id="7f524dcbd593bece540d29aea0353dc495423551" translate="yes" xml:space="preserve">
          <source>zero or more whitespaces \s*</source>
          <target state="translated">0 개 이상의 공백 \ s *</target>
        </trans-unit>
        <trans-unit id="9bdd5426b4b4fdd866ac9851215bf267b6e6df44" translate="yes" xml:space="preserve">
          <source>zero or more whitespaces \s* (it is possible or not, leaving blanks here)</source>
          <target state="translated">0 개 이상의 공백 문자 \ s * (여기서 공백을 남겨 둘 수 있음)</target>
        </trans-unit>
        <trans-unit id="1b249f9d22bd1bda62f373b04cdb08126b054557" translate="yes" xml:space="preserve">
          <source>​ght h&lt;b&gt;e com̡e̶s, ̕h̵i&lt;/b&gt;​s un̨ho͞ly radiańcé de</source>
          <target state="translated">ght h &lt;b&gt;e com̡e̶s, ̕h̵i&lt;/b&gt; ̨ho͞ly radiańc&amp;eacute; de</target>
        </trans-unit>
        <trans-unit id="87484f6cbcd5c18c6c4b093d13bc9f9ee13c577f" translate="yes" xml:space="preserve">
          <source>​nguish the voices of mor​&lt;b&gt;tal man from the sp&lt;/b&gt;​here I can see it can you see ̲͚̖͔̙î̩́t̲͎̩̱͔́̋̀ it is beautiful t​</source>
          <target state="translated">&lt;b&gt;SP에서&lt;/b&gt; 필멸의 &lt;b&gt;인간&lt;/b&gt; 의 목소리를 잃어 버릴 수 있습니다. 여기 &lt;b&gt;에서&lt;/b&gt; 볼 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
