<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1732348">
    <body>
      <group id="1732348">
        <trans-unit id="ccd2e00de6a7833dd11d2079f5b5b099a6e04da7" translate="yes" xml:space="preserve">
          <source>&quot;unpretty&quot; attributes with a space before the &quot;=&quot; symbol, after it and both before and after it.</source>
          <target state="translated">atributos &quot;sin pretensiones&quot; con un espacio antes del símbolo &quot;=&quot;,después de él y tanto antes como después de él.</target>
        </trans-unit>
        <trans-unit id="392ad88b0cb34d87fa7d4457a6637b91ceafc10b" translate="yes" xml:space="preserve">
          <source>&amp;lt;br&amp;gt;</source>
          <target state="translated">&amp;lt;br&amp;gt;</target>
        </trans-unit>
        <trans-unit id="50709f0c2fc769b8029465696613cd45319835fb" translate="yes" xml:space="preserve">
          <source>&amp;lt;br/&amp;gt;</source>
          <target state="translated">&amp;lt;br/&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ecfb18e3fd89ce3fed2c8046ff8dc43d3ee45bbf" translate="yes" xml:space="preserve">
          <source>&amp;lt;hr /&amp;gt;</source>
          <target state="translated">&amp;lt;hr /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3239efc545dfa4f75dc0905c388a28a61c34c974" translate="yes" xml:space="preserve">
          <source>(Take care, in that note I wrongly used the &quot;m&quot; modifier; it should be erased, notwithstanding it is discarded by the RegExp engine, since no ^ or $ anchorage was used).</source>
          <target state="translated">(Cuidado,en esa nota utilicé erróneamente el modificador &quot;m&quot;;debería ser borrado,a pesar de que es descartado por el motor RegExp,ya que no se utilizó ningún anclaje ^ o $).</target>
        </trans-unit>
        <trans-unit id="a8662e799cce40f7a10db5f20413cbc30727a2b7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://pastebin.com/hzYazFVb&quot;&gt;regex to tokenize an xml&lt;/a&gt; or &lt;a href=&quot;http://pastebin.com/HUmPzP5M&quot;&gt;the full plain regex&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://pastebin.com/hzYazFVb&quot;&gt;regex para tokenizar un xml&lt;/a&gt; o &lt;a href=&quot;http://pastebin.com/HUmPzP5M&quot;&gt;la regex simple&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="832bcd8f1b94df226af144e70783a66198bd3e61" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;simplehtmldom&lt;/a&gt; is good, but I found it a bit buggy, and it is is quite memory heavy [Will crash on large pages.]</source>
          <target state="translated">&lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;simplehtmldom&lt;/a&gt; es bueno, pero lo encontr&amp;eacute; un poco defectuoso, y tiene bastante memoria [Se bloquear&amp;aacute; en p&amp;aacute;ginas grandes].</target>
        </trans-unit>
        <trans-unit id="0fb3c21dc29172e2446bc3eb1b052ae2cf60faea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;LL I​S L&lt;/b&gt;OST th</source>
          <target state="translated">&lt;b&gt;LL I SL&lt;/b&gt; OST th</target>
        </trans-unit>
        <trans-unit id="6e79435135c0746fa05560a3972c6d46478d0ea8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Locked&lt;/b&gt;. There are &lt;a href=&quot;/help/locked-posts&quot;&gt;disputes about this answer&amp;rsquo;s content&lt;/a&gt; being resolved at this time. It is not currently accepting new interactions.</source>
          <target state="translated">&lt;b&gt;Bloqueado&lt;/b&gt; Hay &lt;a href=&quot;/help/locked-posts&quot;&gt;disputas sobre el contenido de esta respuesta que se&lt;/a&gt; est&amp;aacute; resolviendo en este momento. Actualmente no acepta nuevas interacciones.</target>
        </trans-unit>
        <trans-unit id="716a4e892e498fc58500550d231fb8d0142d36b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;O​O N&lt;/b&gt;&amp;Theta; stop t</source>
          <target state="translated">&lt;b&gt;O ON&lt;/b&gt; &amp;Theta; detener t</target>
        </trans-unit>
        <trans-unit id="1c101f468dfe424c6604dac4e8ce77d6d85f2f3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;: closing &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; : cierre &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b62a075d15f1adc779c6d1b0fe159e3b547852c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;: starting character</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; : car&amp;aacute;cter inicial</target>
        </trans-unit>
        <trans-unit id="edd69111dcbfaec727aaaeb23b7029011a65191a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?&amp;lt;-group&amp;gt;)&lt;/code&gt; - pops the top most capture with the name group off the
  capture stack.</source>
          <target state="translated">&lt;code&gt;(?&amp;lt;-group&amp;gt;)&lt;/code&gt; : muestra la captura m&amp;aacute;s alta con el grupo de nombres fuera de la pila de captura.</target>
        </trans-unit>
        <trans-unit id="d45de3e20cd061b6edb60d843a32a44f30527fa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?&amp;lt;group&amp;gt;)&lt;/code&gt; - pushes the captured result on the capture stack with
  the name group.</source>
          <target state="translated">&lt;code&gt;(?&amp;lt;group&amp;gt;)&lt;/code&gt; : empuja el resultado capturado en la pila de captura con el nombre del grupo.</target>
        </trans-unit>
        <trans-unit id="e8253025aa1e0fb8ada068fc00792760bbe3d0c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?(group)yes|no)&lt;/code&gt; - matches the yes part if there exists a group
  with the name group otherwise matches no part.</source>
          <target state="translated">&lt;code&gt;(?(group)yes|no)&lt;/code&gt; : coincide con la parte s&amp;iacute; si existe un grupo con el grupo de nombres; de lo contrario, no coincide con ninguna parte.</target>
        </trans-unit>
        <trans-unit id="56885e7cfe6e3708ab901dd138fd887bd58c790d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(\w+)&lt;/code&gt;: tags can contain letters and numbers (h1). Well, &lt;code&gt;\w&lt;/code&gt; also matches '_', but it does not hurt I guess. If curious use ([a-zA-Z0-9]+) instead.</source>
          <target state="translated">&lt;code&gt;(\w+)&lt;/code&gt; : las etiquetas pueden contener letras y n&amp;uacute;meros (h1). Bueno, &lt;code&gt;\w&lt;/code&gt; tambi&amp;eacute;n coincide con '_', pero no duele, supongo. Si tiene curiosidad, use ([a-zA-Z0-9] +) en su lugar.</target>
        </trans-unit>
        <trans-unit id="27378fcce2128b2795fafae4f93ebe3ba7c8ec5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[^/&amp;gt;]*&lt;/code&gt;: anything except &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; until closing &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[^/&amp;gt;]*&lt;/code&gt; : cualquier cosa excepto &lt;code&gt;&amp;gt;&lt;/code&gt; y &lt;code&gt;/&lt;/code&gt; hasta cerrar &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0cdd6edcac3875daf87e4d7a216db2702e63b2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s*&lt;/code&gt;: it may have whitespaces before tag name (ugly but possible).</source>
          <target state="translated">&lt;code&gt;\s*&lt;/code&gt; : puede tener espacios en blanco antes del nombre de la etiqueta (feo pero posible).</target>
        </trans-unit>
        <trans-unit id="beb0d3eebbac4ba7a6e556f1885908f5a8b44a54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;It is a .NET code library that allows
  you to parse &quot;out of the web&quot; HTML
  files. The parser is very tolerant
  with &quot;real world&quot; malformed HTML.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Es una biblioteca de c&amp;oacute;digos .NET que le permite analizar archivos HTML &quot;fuera de la web&quot;.&lt;/em&gt; &lt;em&gt;El analizador es muy tolerante con HTML malformado del &quot;mundo real&quot;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c6e323e6d7b2404e267e45fec8933c5f11df6f5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;/EDIT&amp;gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;lt;/EDIT&amp;gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4eeca80a434106c9c5953d86b5711b944275e484" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lt;EDIT&amp;gt;&lt;/strong&gt;
I forgot that the question from the user was to avoid the parsing of self-closing tags.
In this case the pattern is simpler, turning into this:</source>
          <target state="translated">&lt;strong&gt;&amp;lt;EDIT&amp;gt;&lt;/strong&gt; Olvid&amp;eacute; que la pregunta del usuario era evitar el an&amp;aacute;lisis de etiquetas de cierre autom&amp;aacute;tico. En este caso, el patr&amp;oacute;n es m&amp;aacute;s simple, convirti&amp;eacute;ndose en esto:</target>
        </trans-unit>
        <trans-unit id="bfe34076d009a4ea9a539e48cf63cf2660a68659" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;.NET Regular Expression Engine&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Motor de expresiones regulares .NET&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="84c7b23e39a82950709baca989fe9cf94e0ac7c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caveat&lt;/strong&gt;: I should note that this regex still breaks down in the presence of CDATA blocks, comments, and script and style elements. Good news is, you can get rid of those using a regex...</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : debo tener en cuenta que esta expresi&amp;oacute;n regular todav&amp;iacute;a se rompe en presencia de bloques CDATA, comentarios y elementos de script y estilo. La buena noticia es que puedes deshacerte de aquellos que usan una expresi&amp;oacute;n regular ...</target>
        </trans-unit>
        <trans-unit id="45fc82d5456ed3961e342820361d39292947a88e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer&lt;/strong&gt;: use a parser if you have the option. That said...</source>
          <target state="translated">&lt;strong&gt;Descargo de responsabilidad&lt;/strong&gt; : use un analizador si tiene la opci&amp;oacute;n. Dicho eso ...</target>
        </trans-unit>
        <trans-unit id="28fb9f9055a519baf77c8a0c677593f8a1967066" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Moderator's Note&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Nota del moderador&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2412b65f77f0efaca93518e50a127a0ceec7ed35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To downvoters:&lt;/strong&gt; This is working code from an actual product. I doubt anyone reading this page will get the impression that it is socially acceptable to use regexes on HTML.</source>
          <target state="translated">&lt;strong&gt;Para downvoters:&lt;/strong&gt; este es el c&amp;oacute;digo de trabajo de un producto real. Dudo que cualquiera que lea esta p&amp;aacute;gina tenga la impresi&amp;oacute;n de que es socialmente aceptable usar expresiones regulares en HTML.</target>
        </trans-unit>
        <trans-unit id="b00d0a9c4b3ab55c1726cc4d54869fbac2f0d000" translate="yes" xml:space="preserve">
          <source>A RegExp-agnostic colleague notified me this discussion, which is not certainly the first on the web about this old and hot topic.</source>
          <target state="translated">Un colega agnóstico de RegExp me notificó esta discusión,que no es ciertamente la primera en la web sobre este viejo y caliente tema.</target>
        </trans-unit>
        <trans-unit id="e3504a93684584a9ba5c4e8dff8fbf39739ee1de" translate="yes" xml:space="preserve">
          <source>A simple regex like &lt;code&gt;&amp;lt;([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; is usually good enough, in cases such as those I just mentioned. It's a naive solution, all things considered, but it does correctly allow unencoded &lt;code&gt;&amp;gt;&lt;/code&gt; symbols in attribute values. If you're looking for, e.g., a &lt;code&gt;table&lt;/code&gt; tag, you could adapt it as &lt;code&gt;&amp;lt;/?table\b([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Una expresi&amp;oacute;n regular simple como &lt;code&gt;&amp;lt;([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; suele ser lo suficientemente buena, en casos como los que acabo de mencionar. Es una soluci&amp;oacute;n ingenua, considerando todas las cosas, pero permite correctamente &lt;code&gt;&amp;gt;&lt;/code&gt; s&amp;iacute;mbolos sin codificar en los valores de los atributos. Si est&amp;aacute; buscando, por ejemplo, una etiqueta de &lt;code&gt;table&lt;/code&gt; , puede adaptarla como &lt;code&gt;&amp;lt;/?table\b([^&amp;gt;&quot;']|&quot;[^&quot;]*&quot;|'[^']*')*&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a039c1c26fe0f237cd4c396efb45b67c58a5e34d" translate="yes" xml:space="preserve">
          <source>About the question of the RegExp methods to parse (x)HTML, the answer to all of the ones who spoke about some limits is: you have not been trained enough to rule the force of this powerful weapon, since &lt;strong&gt;NOBODY&lt;/strong&gt; here spoke about &lt;strong&gt;recursion&lt;/strong&gt;.</source>
          <target state="translated">Sobre la cuesti&amp;oacute;n de los m&amp;eacute;todos RegExp para analizar (x) HTML, la respuesta a todos los que hablaron sobre algunos l&amp;iacute;mites es: no se ha entrenado lo suficiente como para gobernar la fuerza de esta poderosa arma, ya que &lt;strong&gt;NADIE&lt;/strong&gt; aqu&amp;iacute; habl&amp;oacute; sobre la &lt;strong&gt;recursividad&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="489cc8d83fc1a950af1e4ec274f14d5d31165bbc" translate="yes" xml:space="preserve">
          <source>After reading some posts, the first thing I did was looking for the &quot;?R&quot; string in this thread. The second was to search about &quot;recursion&quot;.</source>
          <target state="translated">Después de leer algunos mensajes,lo primero que hice fue buscar la cuerda &quot;?R&quot; en este hilo.La segunda fue buscar sobre la &quot;recursividad&quot;.</target>
        </trans-unit>
        <trans-unit id="a3a75c0c6fe92ec2cda26b61e50e68af1ff0a32b" translate="yes" xml:space="preserve">
          <source>Against my expectation this got some upvotes, so I'll suggest some better regular expressions:</source>
          <target state="translated">En contra de lo que esperaba,esto ha tenido algunos votos favorables,así que sugeriré algunas expresiones regulares mejores:</target>
        </trans-unit>
        <trans-unit id="d71dc9d3aa06d9d64e4ed0039016360a328e4c22" translate="yes" xml:space="preserve">
          <source>Almost there - just divide the whole thing by zero. Easy-peasy.</source>
          <target state="translated">Ya casi está,sólo hay que dividirlo todo por cero.Fácil.</target>
        </trans-unit>
        <trans-unit id="fee1e23317ba16ad1ccae9d12e0a015990432476" translate="yes" xml:space="preserve">
          <source>Although it's not suitable and effective to use regular expressions for that purpose sometimes regular expressions provide quick solutions for simple match problems and in my view it's not that horrbile to use regular expressions for trivial works.</source>
          <target state="translated">Aunque no es adecuado y efectivo usar expresiones regulares para ese propósito,a veces las expresiones regulares proporcionan soluciones rápidas para problemas sencillos de emparejamiento y,en mi opinión,no es tan horrible usar expresiones regulares para trabajos triviales.</target>
        </trans-unit>
        <trans-unit id="a430cebe8e1c6b5026f2667ef4e684539ee6d594" translate="yes" xml:space="preserve">
          <source>And to fellows who underestimate regular expressions saying they are only as powerful as regular languages:</source>
          <target state="translated">Y a los compañeros que subestiman las expresiones regulares diciendo que son tan poderosas como los idiomas regulares:</target>
        </trans-unit>
        <trans-unit id="1b4c5b09ea0d4dcf09356da001dd69ed7c2e026c" translate="yes" xml:space="preserve">
          <source>Another one to try is my &lt;a href=&quot;http://github.com/siteroller/domparser&quot;&gt;DOMParser&lt;/a&gt; which is very light on resources and I've been using happily for a while. Simple to learn &amp;amp; powerful.</source>
          <target state="translated">Otro para probar es mi &lt;a href=&quot;http://github.com/siteroller/domparser&quot;&gt;DOMParser,&lt;/a&gt; que es muy ligero en recursos y he estado usando felizmente por un tiempo. Simple de aprender y poderoso.</target>
        </trans-unit>
        <trans-unit id="0e63871b8e67058c915c0916cf65a319929856cc" translate="yes" xml:space="preserve">
          <source>Anyhow it is only a RegExp pattern, but it discloses the possibility to develop of a lot of powerful implementations.</source>
          <target state="translated">De todos modos es sólo un patrón de RegExp,pero revela la posibilidad de desarrollar un montón de implementaciones poderosas.</target>
        </trans-unit>
        <trans-unit id="7bc89deb2a5a51e26b543874949bc6016b7dee8c" translate="yes" xml:space="preserve">
          <source>As described above properly balanced constructs cannot be described by
  a regular expression. However, the .NET regular expression engine
  provides a few constructs that allow balanced constructs to be
  recognized.</source>
          <target state="translated">Como se ha descrito anteriormente,las construcciones correctamente equilibradas no pueden describirse con una expresión regular.Sin embargo,el motor de expresión regular .NET proporciona unas pocas construcciones que permiten reconocer las construcciones equilibradas.</target>
        </trans-unit>
        <trans-unit id="23f8839aa08cf9ff361179fc788965803d7b92e4" translate="yes" xml:space="preserve">
          <source>As many people have already pointed out, HTML is not a regular language which can make it very difficult to parse. My solution to this is to turn it into a regular language using a tidy program and then to use an XML parser to consume the results. There are a lot of good options for this. My program is written using Java with the &lt;a href=&quot;http://jtidy.sourceforge.net/&quot;&gt;jtidy&lt;/a&gt; library to turn the HTML into XML and then Jaxen to xpath into the result.</source>
          <target state="translated">Como muchas personas ya han se&amp;ntilde;alado, el HTML no es un lenguaje normal que puede dificultar el an&amp;aacute;lisis. Mi soluci&amp;oacute;n a esto es convertirlo en un lenguaje normal usando un programa ordenado y luego usar un analizador XML para consumir los resultados. Hay muchas buenas opciones para esto. Mi programa est&amp;aacute; escrito usando Java con la biblioteca &lt;a href=&quot;http://jtidy.sourceforge.net/&quot;&gt;jtidy&lt;/a&gt; para convertir el HTML en XML y luego Jaxen a xpath en el resultado.</target>
        </trans-unit>
        <trans-unit id="6ec0c091ef78305814e216017d3186d039895a12" translate="yes" xml:space="preserve">
          <source>At the end of the day, use the most appropriate tool for the job, even in the cases when that tool happens to be a regex.</source>
          <target state="translated">Al final del día,utilice la herramienta más apropiada para el trabajo,incluso en los casos en que esa herramienta sea un regex.</target>
        </trans-unit>
        <trans-unit id="ee0292f6ec302ec831d0a3d73bf3ba082b945c21" translate="yes" xml:space="preserve">
          <source>Backreferencing &lt;a href=&quot;http://en.wiktionary.org/wiki/FTW&quot;&gt;FTW&lt;/a&gt;!</source>
          <target state="translated">&amp;iexcl;Referencia inversa &lt;a href=&quot;http://en.wiktionary.org/wiki/FTW&quot;&gt;FTW&lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="e76721be008ac232fc787ac592a249a6a0b4bb86" translate="yes" xml:space="preserve">
          <source>Based on that you can create a pretty good regexp to handle things like stripping tags.</source>
          <target state="translated">En base a eso puedes crear un buen regexp para manejar cosas como quitar etiquetas.</target>
        </trans-unit>
        <trans-unit id="74dec6c7e6bd60b234219702f40493e82463304e" translate="yes" xml:space="preserve">
          <source>Basically just define the element node names that are self closing, load the whole html string into a DOM library, grab all elements, loop through and filter out ones which aren't self closing and operate on them.</source>
          <target state="translated">Básicamente sólo hay que definir los nombres de los nodos de los elementos que se cierran automáticamente,cargar toda la cadena html en una biblioteca DOM,tomar todos los elementos,hacer un bucle y filtrar los que no se cierran automáticamente y operar sobre ellos.</target>
        </trans-unit>
        <trans-unit id="2fd99963c03782b18787dfc6cb3594dcb6c80def" translate="yes" xml:space="preserve">
          <source>But many will try, some will even claim success - but until others find the fault and totally mess you up.</source>
          <target state="translated">Pero muchos lo intentarán,algunos incluso reclamarán el éxito-pero hasta que otros encuentren la falla y lo arruinen totalmente.</target>
        </trans-unit>
        <trans-unit id="eb3c73a7771d13969490ceb2f225b558c87d11f3" translate="yes" xml:space="preserve">
          <source>But not these:</source>
          <target state="translated">Pero no estos:</target>
        </trans-unit>
        <trans-unit id="201b0e9006bea17e6be8fbec59ab5c0fb1baedd0" translate="yes" xml:space="preserve">
          <source>Can you provide a little more information on the problem you're trying to solve?  Are you iterating through tags programatically?</source>
          <target state="translated">¿Puede darnos un poco más de información sobre el problema que está tratando de resolver? ¿Está iterando a través de las etiquetas de forma programada?</target>
        </trans-unit>
        <trans-unit id="b8fde2430ed872968deeaaced84cc8f3cc101507" translate="yes" xml:space="preserve">
          <source>Consider the following regular expression:</source>
          <target state="translated">Considere la siguiente expresión regular:</target>
        </trans-unit>
        <trans-unit id="dfa51c240f8abc4eddb1aab8ac728fcb6c1daf9a" translate="yes" xml:space="preserve">
          <source>Do I have that right? And more importantly, what do you think?</source>
          <target state="translated">¿Tengo ese derecho? Y lo más importante,¿qué piensas?</target>
        </trans-unit>
        <trans-unit id="89791df6d0913a20e70b1f075f65baa21fec7900" translate="yes" xml:space="preserve">
          <source>Don't listen to these guys. You totally &lt;strong&gt;can&lt;/strong&gt; parse context-free grammars with regex if you break the task into smaller pieces. You can generate the correct pattern with a script that does each of these in order:</source>
          <target state="translated">No escuches a estos tipos. Puede analizar totalmente las gram&amp;aacute;ticas libres de contexto con expresiones regulares si divide la tarea en partes m&amp;aacute;s peque&amp;ntilde;as. Puede generar el patr&amp;oacute;n correcto con un script que haga cada uno de estos en orden:</target>
        </trans-unit>
        <trans-unit id="c40843389e0f5b256a2400a9132a52c445461a2b" translate="yes" xml:space="preserve">
          <source>E MY FACE ᵒh god n&lt;b&gt;o NO NOO̼&lt;/b&gt;</source>
          <target state="translated">E MI CARA godh dios n &lt;b&gt;NO NO NO̼&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4130705574014c580de59636d30628dd3b203bfe" translate="yes" xml:space="preserve">
          <source>Excerpt:</source>
          <target state="translated">Excerpt:</target>
        </trans-unit>
        <trans-unit id="2ad9d9e9824270d481f3774905d98736bcee5670" translate="yes" xml:space="preserve">
          <source>Find (and capture) a-z one or more times, then</source>
          <target state="translated">Encuentra (y captura)la a-z una o más veces,entonces</target>
        </trans-unit>
        <trans-unit id="1d62b3cf5e66d1004bdcb37b62e3847fa43f5ea5" translate="yes" xml:space="preserve">
          <source>Find a greater-than</source>
          <target state="translated">Encuentra una mayor que</target>
        </trans-unit>
        <trans-unit id="e9f182c7233327a73156c429c46ec0bca09513bc" translate="yes" xml:space="preserve">
          <source>Find a less-than, then</source>
          <target state="translated">Encuentra un menos que,entonces</target>
        </trans-unit>
        <trans-unit id="ef69898f6d3c5528cdbd0de1bd0fdf314dad1fc8" translate="yes" xml:space="preserve">
          <source>Find any character zero or more times, greedy, except &lt;code&gt;/&lt;/code&gt;, then</source>
          <target state="translated">Encuentra cualquier personaje cero o m&amp;aacute;s veces, codicioso, excepto &lt;code&gt;/&lt;/code&gt; , luego</target>
        </trans-unit>
        <trans-unit id="4f924d21074cc3fb26507a968919ecf7195b88d8" translate="yes" xml:space="preserve">
          <source>Find zero or more spaces, then</source>
          <target state="translated">Encuentra cero o más espacios,entonces</target>
        </trans-unit>
        <trans-unit id="0d7c5280ed7e07e90b90f8658292c92cbadfbd89" translate="yes" xml:space="preserve">
          <source>Follow the var links for &lt;code&gt;QName&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, and &lt;code&gt;Attribute&lt;/code&gt; to get a clearer picture.</source>
          <target state="translated">Siga los enlaces var para &lt;code&gt;QName&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; y &lt;code&gt;Attribute&lt;/code&gt; para obtener una imagen m&amp;aacute;s clara.</target>
        </trans-unit>
        <trans-unit id="cf4a4868fa67f0f821777e8c58e576588a83ca85" translate="yes" xml:space="preserve">
          <source>For Python and Java, similar links were posted.</source>
          <target state="translated">Para Python y Java,se publicaron enlaces similares.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="3835e68a9fb13e4990fe61a2c3a6bb38c1da30a3" translate="yes" xml:space="preserve">
          <source>For the downvoters - I only wrote my class when the XML parsers proved unable to withstand real use. Religious downvoting just prevents useful answers from being posted - keep things within perspective of the question, please.</source>
          <target state="translated">Para los &quot;downvoters&quot;-sólo escribí mi clase cuando los analizadores de XML demostraron ser incapaces de soportar el uso real.El downvoting religioso sólo impide que se publiquen respuestas útiles-mantengan las cosas en perspectiva con la pregunta,por favor.</target>
        </trans-unit>
        <trans-unit id="b71baca6025abb3df3fd982ef9ea831e48620ba4" translate="yes" xml:space="preserve">
          <source>For this reason, I believe you CAN parse XML using regular expressions. Note however, that it &lt;strong&gt;must be valid XML&lt;/strong&gt; (&lt;em&gt;browsers are very forgiving of HTML and allow bad XML syntax inside HTML&lt;/em&gt;). This is possible since the &quot;Balancing Group Definition&quot; will allow the regular expression engine to act as a PDA.</source>
          <target state="translated">Por esta raz&amp;oacute;n, creo que PUEDES analizar XML usando expresiones regulares. Sin embargo, &lt;strong&gt;tenga en&lt;/strong&gt; cuenta que &lt;strong&gt;debe ser XML v&amp;aacute;lido&lt;/strong&gt; (los &lt;em&gt;navegadores son muy indulgentes con HTML y permiten una sintaxis XML incorrecta dentro de HTML&lt;/em&gt; ). Esto es posible ya que la &quot;Definici&amp;oacute;n de grupo de equilibrio&quot; permitir&amp;aacute; que el motor de expresi&amp;oacute;n regular act&amp;uacute;e como un PDA.</target>
        </trans-unit>
        <trans-unit id="fda26d5e5c5ac0a8c6a86392f4d1739052bb39fc" translate="yes" xml:space="preserve">
          <source>Granted, these don't account for surrounding context and a few edge cases, but even such things could be dealt with if you really wanted to (e.g., by searching between the matches of another regex).</source>
          <target state="translated">Por supuesto,esto no tiene en cuenta el contexto circundante y unos pocos casos de borde,pero incluso tales cosas podrían ser tratadas si realmente quisieras (por ejemplo,buscando entre las coincidencias de otro regex).</target>
        </trans-unit>
        <trans-unit id="ddfca12da1b8e2626e09bf2de8420516252a5e63" translate="yes" xml:space="preserve">
          <source>HTML Split</source>
          <target state="translated">División de HTML</target>
        </trans-unit>
        <trans-unit id="6c3bb55dbe0fb3cbcbc40ad1f139eaae779348bd" translate="yes" xml:space="preserve">
          <source>Hacking stackoverflow.com's HTML sanitizer</source>
          <target state="translated">Hacking stackoverflow.com's HTML sanitizer</target>
        </trans-unit>
        <trans-unit id="9ec955a6d30b0da0f17f1892186c1fa8f07ed132" translate="yes" xml:space="preserve">
          <source>Have you tried using an XML parser instead?</source>
          <target state="translated">¿Has intentado usar un analizador de XML en su lugar?</target>
        </trans-unit>
        <trans-unit id="62d338caf42aa263445453c7fd40bf4f6302c521" translate="yes" xml:space="preserve">
          <source>Here is a &lt;a href=&quot;http://kingdesk.com/projects/php-parser/&quot;&gt;PHP based parser&lt;/a&gt; that parses HTML using  some ungodly regex. As the author of this project, I can tell you it is possible to parse HTML with regex, but not efficient. If you need a server-side solution (as I did for my &lt;a href=&quot;http://wordpress.org/extend/plugins/wp-typography/&quot;&gt;wp-Typography WordPress plugin&lt;/a&gt;), this works.</source>
          <target state="translated">Aqu&amp;iacute; hay un &lt;a href=&quot;http://kingdesk.com/projects/php-parser/&quot;&gt;analizador basado en PHP&lt;/a&gt; que analiza HTML usando expresiones regulares imp&amp;iacute;as. Como autor de este proyecto, puedo decirle que es posible analizar HTML con expresiones regulares, pero no eficiente. Si necesita una soluci&amp;oacute;n del lado del servidor (como lo hice para mi &lt;a href=&quot;http://wordpress.org/extend/plugins/wp-typography/&quot;&gt;complemento wp-Typography WordPress&lt;/a&gt; ), esto funciona.</target>
        </trans-unit>
        <trans-unit id="de8fd03b5c9fb5a8404878e31a8e0845726217a3" translate="yes" xml:space="preserve">
          <source>Here's a &lt;strong&gt;sample note on the PHP manual&lt;/strong&gt; I wrote on January: &lt;a href=&quot;http://php.net/manual/en/regexp.reference.recursive.php&quot;&gt;Reference&lt;/a&gt;</source>
          <target state="translated">Aqu&amp;iacute; hay una &lt;strong&gt;nota de muestra sobre el manual de PHP&lt;/strong&gt; que escrib&amp;iacute; en enero: &lt;a href=&quot;http://php.net/manual/en/regexp.reference.recursive.php&quot;&gt;Referencia&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c95897a114ae327a0fcd3248ce2f00b0ecf00ea" translate="yes" xml:space="preserve">
          <source>Here's the magic pattern:</source>
          <target state="translated">Aquí está el patrón mágico:</target>
        </trans-unit>
        <trans-unit id="c10b2e598b32c332a06818be23de20fdc89e2f2a" translate="yes" xml:space="preserve">
          <source>Here's the solution:</source>
          <target state="translated">Aquí está la solución:</target>
        </trans-unit>
        <trans-unit id="2cb54d7b11fcfb379247546c25fc8c672912b48c" translate="yes" xml:space="preserve">
          <source>However, a na&amp;iuml;ve implementation of that will end up matching &lt;code&gt;&amp;lt;bar/&amp;gt;&amp;lt;/foo&amp;gt;&lt;/code&gt; in this example document</source>
          <target state="translated">Sin embargo, una implementaci&amp;oacute;n ingenua de eso terminar&amp;aacute; haciendo coincidir &lt;code&gt;&amp;lt;bar/&amp;gt;&amp;lt;/foo&amp;gt;&lt;/code&gt; en este documento de ejemplo</target>
        </trans-unit>
        <trans-unit id="5ee1e08a15d19fdb33d20bd07c63e0818a8b9803" translate="yes" xml:space="preserve">
          <source>I agree that the right tool to parse XML and &lt;em&gt;especially HTML&lt;/em&gt; is a parser and not a regular expression engine. However, like others have pointed out, sometimes using a regex is quicker, easier, and gets the job done if you know the data format.</source>
          <target state="translated">Estoy de acuerdo en que la herramienta adecuada para analizar XML y &lt;em&gt;especialmente HTML&lt;/em&gt; es un analizador sint&amp;aacute;ctico y no un motor de expresiones regulares. Sin embargo, como otros han se&amp;ntilde;alado, a veces usar una expresi&amp;oacute;n regular es m&amp;aacute;s r&amp;aacute;pido, m&amp;aacute;s f&amp;aacute;cil y hace el trabajo si conoce el formato de datos.</target>
        </trans-unit>
        <trans-unit id="65c26198557f567b9e45c7ec5c4d24af104d4dba" translate="yes" xml:space="preserve">
          <source>I also entered tags with:</source>
          <target state="translated">También introduje etiquetas con:</target>
        </trans-unit>
        <trans-unit id="f992540f103a26060e050d18a000903263722fe7" translate="yes" xml:space="preserve">
          <source>I believe it says:</source>
          <target state="translated">Creo que dice:</target>
        </trans-unit>
        <trans-unit id="67002a6457c576d19392a6bb03d1003175f5f89d" translate="yes" xml:space="preserve">
          <source>I bet I will get downvoted for this.</source>
          <target state="translated">Apuesto a que me bajarán la votación por esto.</target>
        </trans-unit>
        <trans-unit id="a78333526ec3e39b92b14f68dec9aff52646cd97" translate="yes" xml:space="preserve">
          <source>I came up with this and wanted to make sure I've got it right. I am only capturing the &lt;code&gt;a-z&lt;/code&gt;.</source>
          <target state="translated">Se me ocurri&amp;oacute; esto y quer&amp;iacute;a asegurarme de que estaba bien. Solo estoy capturando el &lt;code&gt;a-z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c510ddbef2e355def2551ab12c01a3563da7ee62" translate="yes" xml:space="preserve">
          <source>I don't know your exact need for this, but if you are also using .NET, couldn't you use &lt;a href=&quot;http://www.codeplex.com/htmlagilitypack&quot;&gt;Html Agility Pack&lt;/a&gt;?</source>
          <target state="translated">No s&amp;eacute; cu&amp;aacute;l es su necesidad exacta de esto, pero si tambi&amp;eacute;n est&amp;aacute; usando .NET, &amp;iquest;no podr&amp;iacute;a usar &lt;a href=&quot;http://www.codeplex.com/htmlagilitypack&quot;&gt;Html Agility Pack&lt;/a&gt; ?</target>
        </trans-unit>
        <trans-unit id="a18f149e6422b3edd9f248402bd13c1e293f7282" translate="yes" xml:space="preserve">
          <source>I guess to make it not match self contained tags, you'd either want to use &lt;a href=&quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732395#1732395&quot;&gt;Kobi&lt;/a&gt;'s negative look-behind:</source>
          <target state="translated">Supongo que para que no coincida con las etiquetas autocontenidas, querr&amp;aacute;s usar el aspecto negativo de &lt;a href=&quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732395#1732395&quot;&gt;Kobi&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="446fea43937f34270d7612150462764e964be907" translate="yes" xml:space="preserve">
          <source>I have also composed a haiku describing the nature of regex in Perl.</source>
          <target state="translated">También he compuesto un haiku que describe la naturaleza de regex en Perl.</target>
        </trans-unit>
        <trans-unit id="682e33f67784d033cbcf7127d0e8db1135907695" translate="yes" xml:space="preserve">
          <source>I have composed a haiku describing the nature of HTML.</source>
          <target state="translated">He compuesto un haiku que describe la naturaleza del HTML.</target>
        </trans-unit>
        <trans-unit id="b7d276bff4ead75187b5216ebca62ddd0544740b" translate="yes" xml:space="preserve">
          <source>I have never used &lt;a href=&quot;http://querypath.org/&quot;&gt;querypath&lt;/a&gt;, so can't comment on its usefulness.</source>
          <target state="translated">Nunca he usado &lt;a href=&quot;http://querypath.org/&quot;&gt;querypath&lt;/a&gt; , as&amp;iacute; que no puedo comentar sobre su utilidad.</target>
        </trans-unit>
        <trans-unit id="a3d81722ce02cdd1e1d406605ca28b6afc2989ae" translate="yes" xml:space="preserve">
          <source>I haven't quite finished the last part myself, but I know I'm getting close. It keeps throwing &lt;code&gt;CthulhuRlyehWgahnaglFhtagnException&lt;/code&gt;s for some reason, so I'm going to port it to VB 6 and use &lt;code&gt;On Error Resume Next&lt;/code&gt;. I'll update with the code once I investigate this strange door that just opened in the wall. Hmm.</source>
          <target state="translated">No he terminado la &amp;uacute;ltima parte, pero s&amp;eacute; que me estoy acercando. Sigue arrojando &lt;code&gt;CthulhuRlyehWgahnaglFhtagnException&lt;/code&gt; s por alguna raz&amp;oacute;n, as&amp;iacute; que voy a portarlo a VB 6 y usar &lt;code&gt;On Error Resume Next&lt;/code&gt; . Actualizar&amp;eacute; con el c&amp;oacute;digo una vez que investigue esta extra&amp;ntilde;a puerta que se acaba de abrir en la pared. Hmm</target>
        </trans-unit>
        <trans-unit id="57a8d4c706d6a34ee3af3112fdb317e71ff9acca" translate="yes" xml:space="preserve">
          <source>I like to parse HTML with regular expressions. I don't attempt to parse idiot HTML that is deliberately broken. This code is my main parser (Perl edition):</source>
          <target state="translated">Me gusta analizar el HTML con expresiones regulares.No intento analizar el HTML idiota que se rompe deliberadamente.Este código es mi principal analizador (edición Perl):</target>
        </trans-unit>
        <trans-unit id="8ea04fa9f527bf7438dfd9b91e87f0721f39b7be" translate="yes" xml:space="preserve">
          <source>I need to match all of these opening tags:</source>
          <target state="translated">Necesito comparar todas estas etiquetas de apertura:</target>
        </trans-unit>
        <trans-unit id="f58bfd6885d7586198e4ea7d285dc17ac4158c70" translate="yes" xml:space="preserve">
          <source>I suggest using &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; for parsing XML and HTML in PHP.  It's basically much the same syntax as jQuery, only it's on the server side.</source>
          <target state="translated">Sugiero usar &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; para analizar XML y HTML en PHP. Es b&amp;aacute;sicamente la misma sintaxis que jQuery, solo que est&amp;aacute; en el lado del servidor.</target>
        </trans-unit>
        <trans-unit id="ece9292e931d9ba43626cda22fdf3280d35633a6" translate="yes" xml:space="preserve">
          <source>I think the XML case is quite simple. The RegEx (in the .NET syntax), deflated and coded in base64 to make it easier to comprehend by your feeble mind, should be something like this:</source>
          <target state="translated">Creo que el caso del XML es bastante simple.El RegEx (en la sintaxis .NET),desinflado y codificado en base64 para que sea más fácil de comprender por tu débil mente,debería ser algo así:</target>
        </trans-unit>
        <trans-unit id="18040856a3f0eb37bda82501b7d790ae361b0b2d" translate="yes" xml:space="preserve">
          <source>I think the flaw here is that HTML is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;Chomsky Type 2 grammar (context free grammar)&lt;/a&gt; and RegEx is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_grammar&quot;&gt;Chomsky Type 3 grammar (regular grammar)&lt;/a&gt;. Since a Type 2 grammar is fundamentally more complex than a Type 3 grammar (see the &lt;a href=&quot;http://en.wikipedia.org/wiki/Chomsky_hierarchy&quot;&gt;Chomsky hierarchy&lt;/a&gt;), it is &lt;em&gt;mathematically impossible&lt;/em&gt; to parse XML with RegEx.</source>
          <target state="translated">Creo que la falla aqu&amp;iacute; es que HTML es una &lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;gram&amp;aacute;tica Chomsky Tipo 2 (gram&amp;aacute;tica libre de contexto)&lt;/a&gt; y RegEx es una &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_grammar&quot;&gt;gram&amp;aacute;tica Chomsky Tipo 3 (gram&amp;aacute;tica regular)&lt;/a&gt; . Dado que una gram&amp;aacute;tica de tipo 2 es fundamentalmente m&amp;aacute;s compleja que una gram&amp;aacute;tica de tipo 3 (ver la &lt;a href=&quot;http://en.wikipedia.org/wiki/Chomsky_hierarchy&quot;&gt;jerarqu&amp;iacute;a de Chomsky&lt;/a&gt; ), es &lt;em&gt;matem&amp;aacute;ticamente imposible&lt;/em&gt; analizar XML con RegEx.</target>
        </trans-unit>
        <trans-unit id="46e4bbf54843bf1bf2bb54e48219620db67794ee" translate="yes" xml:space="preserve">
          <source>I used a open source tool called &lt;a href=&quot;http://htmlparser.sourceforge.net/&quot;&gt;HTMLParser&lt;/a&gt; before. It's designed to parse HTML in various ways and serves the purpose quite well. It can parse HTML as different treenode and you can easily use its API to get attributes out of the node. Check it out and see if this can help you.</source>
          <target state="translated">Utilic&amp;eacute; una herramienta de c&amp;oacute;digo abierto llamada &lt;a href=&quot;http://htmlparser.sourceforge.net/&quot;&gt;HTMLParser&lt;/a&gt; antes. Est&amp;aacute; dise&amp;ntilde;ado para analizar HTML de varias maneras y cumple bastante bien el prop&amp;oacute;sito. Puede analizar HTML como un treenode diferente y puede usar f&amp;aacute;cilmente su API para obtener atributos del nodo. Compru&amp;eacute;belo y vea si esto puede ayudarlo.</target>
        </trans-unit>
        <trans-unit id="50830c82c86965110baf1111e9368113230c821b" translate="yes" xml:space="preserve">
          <source>I used the sample source of:</source>
          <target state="translated">Utilicé la fuente de la muestra de:</target>
        </trans-unit>
        <trans-unit id="fb040c717878233cc23503d0d656d6a7c4f3856c" translate="yes" xml:space="preserve">
          <source>I wrote it in 30 seconds, and tested here:
&lt;a href=&quot;http://gskinner.com/RegExr/&quot;&gt;http://gskinner.com/RegExr/&lt;/a&gt;</source>
          <target state="translated">Lo escrib&amp;iacute; en 30 segundos y prob&amp;eacute; aqu&amp;iacute;: &lt;a href=&quot;http://gskinner.com/RegExr/&quot;&gt;http://gskinner.com/RegExr/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb8a7f1667c9d5eff8cc8d64ddbce9b58e23a699" translate="yes" xml:space="preserve">
          <source>I wrote this pattern to power the &lt;em&gt;recursive descent parser&lt;/em&gt; of a template engine I built in my framework, and performances are really great, both in execution times or in memory usage (nothing to do with other template engines which use the same syntax).</source>
          <target state="translated">Escrib&amp;iacute; este patr&amp;oacute;n para potenciar el &lt;em&gt;analizador&lt;/em&gt; de &lt;em&gt;descenso recursivo&lt;/em&gt; de un motor de plantillas que constru&amp;iacute; en mi marco, y el rendimiento es realmente excelente, tanto en tiempos de ejecuci&amp;oacute;n como en el uso de memoria (nada que ver con otros motores de plantillas que usan la misma sintaxis).</target>
        </trans-unit>
        <trans-unit id="f454869fe61fa45429bc7ee92bc5ad9345d8b481" translate="yes" xml:space="preserve">
          <source>I'm sure you already know by now that you shouldn't use regex for this purpose.</source>
          <target state="translated">Estoy seguro de que ya sabes que no deberías usar a Rex para este propósito.</target>
        </trans-unit>
        <trans-unit id="40dea22884315ebb5434973f5bb9c5c1ca6166f5" translate="yes" xml:space="preserve">
          <source>If You Like Regular Expressions So Much, Why Don't You Marry Them?</source>
          <target state="translated">Si te gustan tanto las expresiones regulares,¿por qué no te casas con ellas?</target>
        </trans-unit>
        <trans-unit id="cbfa4fd68fca2bc7eab26c99ba711ac9cab9bb23" translate="yes" xml:space="preserve">
          <source>If an (x)HTML parser needs recursion, a RegExp parser without recursion is not enough for the purpose. It's a simple construct.</source>
          <target state="translated">Si un analizador (x)HTML necesita recursividad,un analizador RegExp sin recursividad no es suficiente para el propósito.Es una construcción simple.</target>
        </trans-unit>
        <trans-unit id="919388ca02cd994c288549580960ad9ba47f962b" translate="yes" xml:space="preserve">
          <source>If someone is interested in learning more about the pattern, I provide some line:</source>
          <target state="translated">Si alguien está interesado en aprender más sobre el patrón,le proporciono alguna línea:</target>
        </trans-unit>
        <trans-unit id="557f9117f8433eb60bbd29cff5259745d632f952" translate="yes" xml:space="preserve">
          <source>If you add something to the regex, by backtracking it can be forced to match silly things like &lt;code&gt;&amp;lt;a &amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;[^/]&lt;/code&gt; is too permissive. Also note that &lt;code&gt;&amp;lt;space&amp;gt;*[^/]*&lt;/code&gt; is redundant, because the &lt;code&gt;[^/]*&lt;/code&gt; can also match spaces.</source>
          <target state="translated">Si agrega algo a la expresi&amp;oacute;n regular, al retroceder puede verse obligado a coincidir con cosas tontas como &lt;code&gt;&amp;lt;a &amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;[^/]&lt;/code&gt; es demasiado permisivo. Tambi&amp;eacute;n tenga en cuenta que &lt;code&gt;&amp;lt;space&amp;gt;*[^/]*&lt;/code&gt; es redundante, porque &lt;code&gt;[^/]*&lt;/code&gt; tambi&amp;eacute;n puede coincidir con espacios.</target>
        </trans-unit>
        <trans-unit id="a298912d3657e52c67b5f74e85c231c1485f0d0c" translate="yes" xml:space="preserve">
          <source>If you are unsure, no, I'm NOT kidding (but perhaps I'm lying). It WILL work. I've built tons of unit tests to test it, and I have even used (part of) the &lt;a href=&quot;http://www.w3.org/XML/Test/&quot;&gt;conformance tests&lt;/a&gt;. It's a tokenizer, not a full-blown parser, so it will only split the XML into its component tokens. It won't parse/integrate DTDs.</source>
          <target state="translated">Si no est&amp;aacute; seguro, no, NO estoy bromeando (pero tal vez estoy mintiendo). Funcionar&amp;aacute;. He construido toneladas de pruebas unitarias para probarlo, e incluso he usado (parte de) las &lt;a href=&quot;http://www.w3.org/XML/Test/&quot;&gt;pruebas de conformidad&lt;/a&gt; . Es un tokenizador, no un analizador completo, por lo que solo dividir&amp;aacute; el XML en sus tokens componentes. No analizar&amp;aacute; / integrar&amp;aacute; DTD.</target>
        </trans-unit>
        <trans-unit id="2b5bc330d9a583246ad4801874fc84163c931493" translate="yes" xml:space="preserve">
          <source>If you have a small set of HTML pages that you want to scrape data from and then stuff into a database, regexes might work fine.  For example, I recently wanted to get the names, parties, and districts of Australian federal Representatives, which I got off of the Parliament's web site.  This was a limited, one-time job.</source>
          <target state="translated">Si tienes un pequeño conjunto de páginas HTML de las que quieres raspar datos y luego rellenarlas en una base de datos,los regexes podrían funcionar bien.Por ejemplo,recientemente quise obtener los nombres,partidos y distritos de los representantes federales australianos,que obtuve del sitio web del Parlamento.Este fue un trabajo limitado,de una sola vez.</target>
        </trans-unit>
        <trans-unit id="d9db7068b93480af65771902d59739a0242c037f" translate="yes" xml:space="preserve">
          <source>If you have problems reconverting it to a human-readable regex, this should help:</source>
          <target state="translated">Si tienes problemas para reconvertirlo en un regex legible para los humanos,esto debería ayudar:</target>
        </trans-unit>
        <trans-unit id="14633b829212b8b056b036f6830ca7c6a918fe40" translate="yes" xml:space="preserve">
          <source>If you need this for PHP:</source>
          <target state="translated">Si necesitas esto para PHP:</target>
        </trans-unit>
        <trans-unit id="f932b2b6098e1c3395b486c41745029eaaebe046" translate="yes" xml:space="preserve">
          <source>If you're simply trying to find those tags (without ambitions of parsing) try this regular expression:</source>
          <target state="translated">Si simplemente estás tratando de encontrar esas etiquetas (sin ambiciones de analizar)intenta esta expresión regular:</target>
        </trans-unit>
        <trans-unit id="4b5c78fb6625eec434f0fbf5e5c22e99da727566" translate="yes" xml:space="preserve">
          <source>IgnoreCase (not necessary)</source>
          <target state="translated">IgnorarCaso (no es necesario)</target>
        </trans-unit>
        <trans-unit id="195915971c682a24ad48d1e62483babae5188862" translate="yes" xml:space="preserve">
          <source>IgnorePatternWhitespace (not necessary if you collapse regex and remove all whitespace)</source>
          <target state="translated">IgnorarPatrónEspacioBlanco (no es necesario si colapsas regex y eliminas todos los espacios blancos)</target>
        </trans-unit>
        <trans-unit id="d8142f0416c264b4b799d2c8a0af8d098608064c" translate="yes" xml:space="preserve">
          <source>In shell, you can parse &lt;a href=&quot;https://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; using &lt;a href=&quot;https://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt;:</source>
          <target state="translated">En shell, puede analizar &lt;a href=&quot;https://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; usando &lt;a href=&quot;https://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3e72a4a4bfbcf98641ca469ef038c0e9caca1753" translate="yes" xml:space="preserve">
          <source>In this case your enemy is HTML and you are either yourself or regex.  You might even be Perl with irregular regex. Know HTML.  Know yourself.</source>
          <target state="translated">En este caso tu enemigo es HTML y tú eres tú mismo o regex.Incluso podrías ser Perl con regex irregular.Conoce el HTML.Conócete a ti mismo.</target>
        </trans-unit>
        <trans-unit id="4da0bc6ccd100c1869c39b7908884293a4fdecf6" translate="yes" xml:space="preserve">
          <source>It is said that if you know your enemies and know yourself, you can win a hundred battles without a single loss.
  If you only know yourself, but not your opponent, you may win or may lose.
  If you know neither yourself nor your enemy, you will always endanger yourself.</source>
          <target state="translated">Se dice que si conoces a tus enemigos y te conoces a ti mismo,puedes ganar cien batallas sin una sola pérdida.Si sólo te conoces a ti mismo,pero no a tu oponente,puedes ganar o perder.Si no te conoces ni a ti mismo ni a tu enemigo,siempre te pondrás en peligro.</target>
        </trans-unit>
        <trans-unit id="8cd9da1c9f2693e6ec017e2869a577b714739b63" translate="yes" xml:space="preserve">
          <source>It is similar to yours, but the last &lt;code&gt;&amp;gt;&lt;/code&gt; must not be after a slash, and also accepts &lt;code&gt;h1&lt;/code&gt;.</source>
          <target state="translated">Es similar al tuyo, pero el &amp;uacute;ltimo &lt;code&gt;&amp;gt;&lt;/code&gt; no debe ser despu&amp;eacute;s de una barra inclinada, y tambi&amp;eacute;n acepta &lt;code&gt;h1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ad138f054cb998fb3ecb181104c2f9f5989e48b" translate="yes" xml:space="preserve">
          <source>It is simple enough to rejig my slurp-everything-first Perl script into a nice streaming thing, if you wish to process enormous web pages. But it's not really necessary.</source>
          <target state="translated">Es bastante simple para volver a convertir mi primer guión de Perl en un bonito streaming,si quieres procesar páginas web enormes.Pero no es realmente necesario.</target>
        </trans-unit>
        <trans-unit id="f4114fb01ee1d4a7e528e4b5db702779bb015416" translate="yes" xml:space="preserve">
          <source>It matches the types of tags you mentioned, while ignoring the types you said you wanted to ignore.</source>
          <target state="translated">Coincide con los tipos de etiquetas que mencionaste,mientras que ignora los tipos que dijiste que querías ignorar.</target>
        </trans-unit>
        <trans-unit id="e92b765161d9c9393ab926712762103321511c85" translate="yes" xml:space="preserve">
          <source>It may not be perfect, but I ran this code through a &lt;em&gt;lot&lt;/em&gt; of HTML. Note that it even catches strange things like &lt;code&gt;&amp;lt;a name=&quot;badgenerator&quot;&quot;&amp;gt;&lt;/code&gt;, which show up on the web.</source>
          <target state="translated">Puede que no sea perfecto, pero ejecut&amp;eacute; este c&amp;oacute;digo a trav&amp;eacute;s de &lt;em&gt;mucho&lt;/em&gt; HTML. Tenga en cuenta que incluso &lt;code&gt;&amp;lt;a name=&quot;badgenerator&quot;&quot;&amp;gt;&lt;/code&gt; cosas extra&amp;ntilde;as como &amp;lt;a name=&quot;badgenerator&quot;&quot;&amp;gt; , que aparecen en la web.</target>
        </trans-unit>
        <trans-unit id="3c401fdac65c6774bcadecd58093d69231332e3b" translate="yes" xml:space="preserve">
          <source>It seems to me you're trying to match tags without a &quot;/&quot; at the end. Try this:</source>
          <target state="translated">Me parece que estás tratando de hacer coincidir las etiquetas sin una &quot;&quot; al final.Pruebe esto:</target>
        </trans-unit>
        <trans-unit id="f6ca3fc0ed09308a49c656e7527184db98c56489" translate="yes" xml:space="preserve">
          <source>It's called htmlsplit, splits the HTML into lines, with one tag or chunk of text on each line.  The lines can then be processed further with other text tools and scripts, such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt;, Perl, etc. I'm not even joking :) Enjoy.</source>
          <target state="translated">Se llama htmlsplit, divide el HTML en l&amp;iacute;neas, con una etiqueta o fragmento de texto en cada l&amp;iacute;nea. Las l&amp;iacute;neas pueden procesarse luego con otras herramientas de texto y scripts, como &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt; , &lt;a href=&quot;http://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt; , Perl, etc. Ni siquiera estoy bromeando :) Disfruta.</target>
        </trans-unit>
        <trans-unit id="9ec7139f7024ff295c9ba4a49287ac0b4b6fc319" translate="yes" xml:space="preserve">
          <source>It's true that when programming it's usually best to use dedicated parsers and APIs instead of regular expressions when dealing with HTML, especially if accuracy is paramount (e.g., if your processing might have security implications). However, I don&amp;rsquo;t ascribe to a dogmatic view that XML-style markup should never be processed with regular expressions. There are cases when regular expressions are a great tool for the job, such as when making one-time edits in a text editor, fixing broken XML files, or dealing with file formats that look like but aren&amp;rsquo;t quite XML. There are some issues to be aware of, but they're not insurmountable or even necessarily relevant.</source>
          <target state="translated">Es cierto que, cuando se programa, generalmente es mejor usar analizadores y API dedicados en lugar de expresiones regulares cuando se trata de HTML, especialmente si la precisi&amp;oacute;n es primordial (por ejemplo, si su procesamiento puede tener implicaciones de seguridad). Sin embargo, no atribuyo a una vista dogm&amp;aacute;tica que el marcado de estilo XML nunca debe procesarse con expresiones regulares. Hay casos en que las expresiones regulares son una gran herramienta para el trabajo, como cuando se realizan ediciones &amp;uacute;nicas en un editor de texto, se corrigen archivos XML rotos o se tratan formatos de archivo que se ven pero no son XML. Hay algunos problemas a tener en cuenta, pero no son insuperables ni necesariamente relevantes.</target>
        </trans-unit>
        <trans-unit id="39e7ab248960684eaa9b9f720409b41a17a28cff" translate="yes" xml:space="preserve">
          <source>It's written as a PHP string, so the &quot;s&quot; modifier makes classes include newlines.</source>
          <target state="translated">Está escrito como una cadena PHP,así que el modificador &quot;s&quot; hace que las clases incluyan nuevas líneas.</target>
        </trans-unit>
        <trans-unit id="427486fffe171253525e01e3f06e796d5676dc63" translate="yes" xml:space="preserve">
          <source>Just to give a sense of what a more &quot;advanced&quot; HTML regex would look like, the following does a fairly respectable job of emulating real-world browser behavior and the HTML5 parsing algorithm:</source>
          <target state="translated">Sólo para dar una idea de cómo se vería un regex HTML más &quot;avanzado&quot;,lo siguiente hace un trabajo bastante respetable de emular el comportamiento del navegador en el mundo real y el algoritmo de análisis de HTML5:</target>
        </trans-unit>
        <trans-unit id="22605049c94f39fec40c01fc01b8d0235c7512b9" translate="yes" xml:space="preserve">
          <source>Just try it.</source>
          <target state="translated">Sólo inténtalo.</target>
        </trans-unit>
        <trans-unit id="601daad3ec0906e4e0d799c06fb0f95e6770d70e" translate="yes" xml:space="preserve">
          <source>Lastly, I really enjoyed Jeff Atwood's article:  &lt;a href=&quot;https://blog.codinghorror.com/parsing-html-the-cthulhu-way/&quot;&gt;Parsing Html The Cthulhu Way&lt;/a&gt;. Funny enough, it cites the answer to this question that currently has over 4k votes.</source>
          <target state="translated">Por &amp;uacute;ltimo, realmente disfrut&amp;eacute; el art&amp;iacute;culo de Jeff Atwood: &lt;a href=&quot;https://blog.codinghorror.com/parsing-html-the-cthulhu-way/&quot;&gt;Parsing Html The Cthulhu Way&lt;/a&gt; . Curiosamente, cita la respuesta a esta pregunta que actualmente tiene m&amp;aacute;s de 4k votos.</target>
        </trans-unit>
        <trans-unit id="d67da4c32f78ca5c993f0ad4bcd5b49e6538c409" translate="yes" xml:space="preserve">
          <source>Like Lord Marshal (is he a relative of the Marshal .NET class?), I have seen the &lt;strike&gt;Underverse&lt;/strike&gt; Stack Based Regex-Verse and returned with &lt;strike&gt;powers&lt;/strike&gt; knowledge you can't imagine. Yes, I think there were an Old One or two protecting them, but they were watching football on the TV, so it wasn't difficult.</source>
          <target state="translated">Al igual que Lord Marshal (&amp;iquest;es un pariente de la clase Marshal .NET?), He visto el Regex-Verse basado en pila inversa y he regresado con &lt;strike&gt;poderes&lt;/strike&gt; que no puedes imaginar. S&amp;iacute;, creo que hab&amp;iacute;a uno o dos viejos protegi&amp;eacute;ndolos, pero estaban viendo f&amp;uacute;tbol en la televisi&amp;oacute;n, as&amp;iacute; que no fue dif&amp;iacute;cil.</target>
        </trans-unit>
        <trans-unit id="1c3e6997e482742cdf179a4397cb018cad2d8564" translate="yes" xml:space="preserve">
          <source>Microsoft actually has a section of &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices&quot;&gt;Best Practices for Regular Expressions in the .NET Framework&lt;/a&gt; and specifically talks about &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices#consider-the-input-source&quot;&gt;Consider[ing] the Input Source&lt;/a&gt;.</source>
          <target state="translated">Microsoft en realidad tiene una secci&amp;oacute;n de &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices&quot;&gt;Mejores Pr&amp;aacute;cticas para Expresiones Regulares en .NET Framework&lt;/a&gt; y habla espec&amp;iacute;ficamente sobre &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/best-practices#consider-the-input-source&quot;&gt;Considerar [ing] la Fuente de Entrada&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba3b99fc49923cc3bbd90f5e080753b12725e9bc" translate="yes" xml:space="preserve">
          <source>My suggestion would be</source>
          <target state="translated">Mi sugerencia sería</target>
        </trans-unit>
        <trans-unit id="72810c91afedb33b80069b7076436fecf94d1af6" translate="yes" xml:space="preserve">
          <source>No, holy cow, no match found.</source>
          <target state="translated">No,santo cielo,no se ha encontrado ninguna coincidencia.</target>
        </trans-unit>
        <trans-unit id="a474b6597430f9ba4fac174b06490808a6e22af5" translate="yes" xml:space="preserve">
          <source>Note that this allows things like &lt;code&gt;&amp;lt;a/ &amp;gt;&lt;/code&gt; (just like the original regex), so if you want something more restrictive, you need to build a regex to match attribute pairs separated by spaces.</source>
          <target state="translated">Tenga en cuenta que esto permite cosas como &lt;code&gt;&amp;lt;a/ &amp;gt;&lt;/code&gt; (al igual que la expresi&amp;oacute;n regular original), por lo que si desea algo m&amp;aacute;s restrictivo, debe crear una expresi&amp;oacute;n regular para que coincida con los pares de atributos separados por espacios.</target>
        </trans-unit>
        <trans-unit id="aa7cf65bf2ed58b9c07633b4dd41874bd458e314" translate="yes" xml:space="preserve">
          <source>Now, we could speak about the limits of this method from a more informed point of view:</source>
          <target state="translated">Ahora,podríamos hablar de los límites de este método desde un punto de vista más informado:</target>
        </trans-unit>
        <trans-unit id="1022301500a966b54ef35dd0b0c702c86a1e6cad" translate="yes" xml:space="preserve">
          <source>Oh... if you want the source code of the regex, with some auxiliary methods:</source>
          <target state="translated">Oh...si quieres el código fuente de la regex,con algunos métodos auxiliares:</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="efc9dd879d5fa6c41b5a8b4a174e9bbeea207c3f" translate="yes" xml:space="preserve">
          <source>P.S. Pierre de Fermat also figured out how to do it, but the margin he was writing in wasn't big enough for the code.</source>
          <target state="translated">P.S.Pierre de Fermat también averiguó cómo hacerlo,pero el margen en el que escribía no era lo suficientemente grande para el código.</target>
        </trans-unit>
        <trans-unit id="fb344f772f606bf069b994b1800b75ad467d5eb0" translate="yes" xml:space="preserve">
          <source>Profit!</source>
          <target state="translated">Profit!</target>
        </trans-unit>
        <trans-unit id="ffe7bde078bc620df9c2922255941de3200d1c7e" translate="yes" xml:space="preserve">
          <source>Quote from article 1 cited above:</source>
          <target state="translated">Cita del artículo 1 citado anteriormente:</target>
        </trans-unit>
        <trans-unit id="ebb8b5eff359c8e4629b4281a740853315bc1649" translate="yes" xml:space="preserve">
          <source>RegEx match open tags except XHTML self-contained tags</source>
          <target state="translated">RegEx coincide con las etiquetas abiertas,excepto las etiquetas XHTML autocontenidas.</target>
        </trans-unit>
        <trans-unit id="8336d194052f52769b114f9bc2344752e9b3f02b" translate="yes" xml:space="preserve">
          <source>Regexes worked just fine for me, and were very fast to set up.</source>
          <target state="translated">Los regexes funcionaron muy bien para mí,y fueron muy rápidos para establecerlos.</target>
        </trans-unit>
        <trans-unit id="9ca09288e6a253e0dfa4bc1e29bfae12ab028bb9" translate="yes" xml:space="preserve">
          <source>Regular Expression Explained (inline)</source>
          <target state="translated">Explicación de la expresión regular (en línea)</target>
        </trans-unit>
        <trans-unit id="24b2174abc016feccbfb08853265c6a5a2ea6e89" translate="yes" xml:space="preserve">
          <source>Regular Expressions do have limitations, but have you considered the following?</source>
          <target state="translated">Las expresiones regulares tienen limitaciones,pero ¿ha considerado lo siguiente?</target>
        </trans-unit>
        <trans-unit id="f20c01e8fa442e15f50708e2e685f84f38cf9f06" translate="yes" xml:space="preserve">
          <source>Regular Expressions: Now You Have Two Problems</source>
          <target state="translated">Expresiones regulares:Ahora tienes dos problemas</target>
        </trans-unit>
        <trans-unit id="b49c5b3c647bd9589b36c369c0bc3c5a638f66ed" translate="yes" xml:space="preserve">
          <source>Related (why you shouldn't use regex match):</source>
          <target state="translated">Relacionado (por qué no deberías usar regex match):</target>
        </trans-unit>
        <trans-unit id="16962bdac3ee084e07372a69f0ada8648f72cfce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.microsoft.com/archive/blogs/bclteam/net-regular-expressions-regex-and-balanced-matching-ryan-byington&quot;&gt;.NET Regular Expressions: Regex and Balanced Matching&lt;/a&gt;</source>
          <target state="translated">Consulte &lt;a href=&quot;https://docs.microsoft.com/archive/blogs/bclteam/net-regular-expressions-regex-and-balanced-matching-ryan-byington&quot;&gt;Expresiones regulares de .NET: expresiones regulares y coincidencia equilibrada&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de60e0a6c744236d2ff2a2469aa87dabd965b8f9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://weblogs.asp.net/whaggard/377025&quot;&gt;Matching Balanced Constructs with .NET Regular Expressions&lt;/a&gt;</source>
          <target state="translated">Consulte &lt;a href=&quot;https://weblogs.asp.net/whaggard/377025&quot;&gt;Construcciones equilibradas coincidentes con expresiones regulares .NET&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a3ea9fb6afc3bc06c915f2dc863ae7a60ef9464e" translate="yes" xml:space="preserve">
          <source>See Microsoft's docs on &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;Balancing Group Definitions&lt;/a&gt;</source>
          <target state="translated">Consulte los documentos de Microsoft sobre las &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;definiciones de grupos de equilibrio&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0ad4363c94846f440a3409baad524ee90a091468" translate="yes" xml:space="preserve">
          <source>Should you find something which does not work in the proof of concept above, I am available in analyzing the code to improve my skills.</source>
          <target state="translated">Si encuentras algo que no funciona en la prueba de concepto anterior,estoy disponible para analizar el código para mejorar mis habilidades.</target>
        </trans-unit>
        <trans-unit id="92cfc65b8206d5667dc7ccac83a9a9a793d658df" translate="yes" xml:space="preserve">
          <source>Since nobody mentioned the main mechanism a parser is built onto, I was soon aware that nobody got the point.</source>
          <target state="translated">Como nadie mencionó el mecanismo principal en el que se basa un analizador,pronto me di cuenta de que nadie lo entendía.</target>
        </trans-unit>
        <trans-unit id="4e222f3f71ebc82ced1555d79e3896204e2da9f1" translate="yes" xml:space="preserve">
          <source>Singleline</source>
          <target state="translated">Singleline</target>
        </trans-unit>
        <trans-unit id="2e489e37aeb575873f40d9f8a80c3e74b1c26ae6" translate="yes" xml:space="preserve">
          <source>Small tip: to better analyze this code it is necessary looking at the source code generated since I did not provide any HTML special characters escaping.</source>
          <target state="translated">Pequeño consejo:para analizar mejor este código es necesario mirar el código fuente generado ya que no he proporcionado ningún carácter especial de HTML que se escape.</target>
        </trans-unit>
        <trans-unit id="2ccc837c5ed1e3feef77351cd1d620591415719e" translate="yes" xml:space="preserve">
          <source>Solve the Halting Problem.</source>
          <target state="translated">Resolver el problema de la detención.</target>
        </trans-unit>
        <trans-unit id="b8fc19b88ebcae8fab9f0ca6d99cb4a564e9d1d4" translate="yes" xml:space="preserve">
          <source>Square a circle.</source>
          <target state="translated">Cuadrar un círculo.</target>
        </trans-unit>
        <trans-unit id="e1c5ebb5af83fa15c6406a756fafb86dfda684e1" translate="yes" xml:space="preserve">
          <source>Sun Tzu, an ancient Chinese strategist, general, and philosopher, said:</source>
          <target state="translated">Sun Tzu,un antiguo estratega,general y filósofo chino,dijo:</target>
        </trans-unit>
        <trans-unit id="1361c33aa4292835661dbf5c91a1e629b1a6decc" translate="yes" xml:space="preserve">
          <source>The .NET framework is unique when it comes to regular expressions in that it supports &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;Balancing Group Definitions&lt;/a&gt;.</source>
          <target state="translated">El marco .NET es &amp;uacute;nico cuando se trata de expresiones regulares, ya que admite &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition&quot;&gt;definiciones de grupos de equilibrio&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55da94ce9e0ca8998eabc3076f92485f67f4f2eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.php.net/manual/en/function.dom-import-simplexml.php&quot;&gt;PHP DOM&lt;/a&gt;&lt;a href=&quot;http://php.net/manual/en/class.domdocument.php&quot;&gt;functions&lt;/a&gt; won't work properly unless it is properly formatted XML. No matter how much better their use is for the rest of mankind.</source>
          <target state="translated">Las &lt;a href=&quot;http://php.net/manual/en/class.domdocument.php&quot;&gt;funciones&lt;/a&gt; &lt;a href=&quot;http://www.php.net/manual/en/function.dom-import-simplexml.php&quot;&gt;DOM de PHP&lt;/a&gt; no funcionar&amp;aacute;n correctamente a menos que tenga el formato XML correcto. No importa cu&amp;aacute;n mejor sea su uso para el resto de la humanidad.</target>
        </trans-unit>
        <trans-unit id="4ac395740ae412d2f1cc1a46e41f7844bd6163b7" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;black art of RegExp is hard to master&lt;/strong&gt;, so maybe there are further possibilities we left out while trying and testing our personal solution to capture the whole web in one hand... Well, I am sure about it :)</source>
          <target state="translated">El &lt;strong&gt;arte negro de RegExp es dif&amp;iacute;cil de dominar&lt;/strong&gt; , por lo que tal vez hay m&amp;aacute;s posibilidades que dejamos de lado al intentar y probar nuestra soluci&amp;oacute;n personal para capturar toda la web con una mano ... Bueno, estoy seguro de eso :)</target>
        </trans-unit>
        <trans-unit id="997812962876e0edf9df4c8486980789ffe0886d" translate="yes" xml:space="preserve">
          <source>The W3C explains parsing in a pseudo regexp form:</source>
          <target state="translated">El W3C explica el análisis sintáctico en una forma pseudo-regexp:</target>
        </trans-unit>
        <trans-unit id="fdcdc94a48b14eafa651bbe7dd5b0b9e404ab530" translate="yes" xml:space="preserve">
          <source>The best way to write regular expressions is in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Lex_%28software%29&quot;&gt;Lex&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; style, not as opaque one-liners or commented multi-line monstrosities. I didn't do that here, yet; these ones barely need it.</source>
          <target state="translated">La mejor manera de escribir expresiones regulares es en el estilo &lt;a href=&quot;http://en.wikipedia.org/wiki/Lex_%28software%29&quot;&gt;Lex&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; , no como l&amp;iacute;neas opacas o monstruosidades de varias l&amp;iacute;neas comentadas. Todav&amp;iacute;a no hice eso aqu&amp;iacute;; estos apenas lo necesitan.</target>
        </trans-unit>
        <trans-unit id="712ab4b4a1f7ed2c6d0a80c8195f21170140f25f" translate="yes" xml:space="preserve">
          <source>The following matches a fairly strict definition of XML tags (although it doesn't account for the full set of Unicode characters allowed in XML names):</source>
          <target state="translated">Lo siguiente corresponde a una definición bastante estricta de las etiquetas XML (aunque no tiene en cuenta el conjunto completo de caracteres Unicode permitidos en los nombres XML):</target>
        </trans-unit>
        <trans-unit id="b4cfd79b880dc8c38082dbd0830e9fdee4557b44" translate="yes" xml:space="preserve">
          <source>The options to set is &lt;code&gt;RegexOptions.ExplicitCapture&lt;/code&gt;. The capture group you are looking for is &lt;code&gt;ELEMENTNAME&lt;/code&gt;. If the capture group &lt;code&gt;ERROR&lt;/code&gt; is not empty then there was a parsing error and the Regex stopped.</source>
          <target state="translated">Las opciones para establecer es &lt;code&gt;RegexOptions.ExplicitCapture&lt;/code&gt; . El grupo de captura que est&amp;aacute; buscando es &lt;code&gt;ELEMENTNAME&lt;/code&gt; . Si el &lt;code&gt;ERROR&lt;/code&gt; del grupo de captura no est&amp;aacute; vac&amp;iacute;o, se produjo un error de an&amp;aacute;lisis y Regex se detuvo.</target>
        </trans-unit>
        <trans-unit id="42afcd3eb11823b2c3d7a0e945433e5d9be383b6" translate="yes" xml:space="preserve">
          <source>The parts explained:</source>
          <target state="translated">Las partes explicadas:</target>
        </trans-unit>
        <trans-unit id="7b1c98adf4b68d1b5b5505c62c8cdcb98c54e922" translate="yes" xml:space="preserve">
          <source>The pattern will be pretty big, so make sure you have an algorithm that losslessly compresses random data.</source>
          <target state="translated">El patrón será bastante grande,así que asegúrate de tener un algoritmo que comprima sin pérdidas los datos aleatorios.</target>
        </trans-unit>
        <trans-unit id="7216ec9c43638b3c7e394bf44fd4c73431e98cef" translate="yes" xml:space="preserve">
          <source>The suggested regex is wrong, though:</source>
          <target state="translated">Sin embargo,la sugerencia de regex está equivocada:</target>
        </trans-unit>
        <trans-unit id="9a7f6c57efe365adfc81358edd4c2317e716adc0" translate="yes" xml:space="preserve">
          <source>The tag to match may end with a simple &quot;&amp;gt;&quot; symbol, or a possible XHTML closure, which makes use of the slash before it: (/&amp;gt;|&amp;gt;). The slash is, of course, escaped since it coincides with the regular expression delimiter.</source>
          <target state="translated">La etiqueta para que coincida puede terminar con un simple s&amp;iacute;mbolo &quot;&amp;gt;&quot;, o un posible cierre XHTML, que utiliza la barra inclinada antes: (/&amp;gt; |&amp;gt;). La barra oblicua se escapa, por supuesto, ya que coincide con el delimitador de expresi&amp;oacute;n regular.</target>
        </trans-unit>
        <trans-unit id="d8320be450cb3daac23d24918c511589e5cc20d4" translate="yes" xml:space="preserve">
          <source>The user @ridgerunner noticed that the pattern does not allow &lt;strong&gt;unquoted attributes&lt;/strong&gt; or &lt;strong&gt;attributes with no value&lt;/strong&gt;. In this case a fine tuning brings us the following pattern:</source>
          <target state="translated">El usuario @ridgerunner not&amp;oacute; que el patr&amp;oacute;n no permite &lt;strong&gt;atributos sin comillas&lt;/strong&gt; o &lt;strong&gt;atributos sin valor&lt;/strong&gt; . En este caso, un ajuste fino nos trae el siguiente patr&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="96ae70a6ef53719f5c2ee204876a53bf013a8cbd" translate="yes" xml:space="preserve">
          <source>Then, since a tag may end with a whitespace before the &quot;&amp;gt;&quot; symbol, zero or more whitespaces are matched with the \s* subpattern.</source>
          <target state="translated">Luego, dado que una etiqueta puede terminar con un espacio en blanco antes del s&amp;iacute;mbolo &quot;&amp;gt;&quot;, cero o m&amp;aacute;s espacios en blanco coinciden con el subpatr&amp;oacute;n \ s *.</target>
        </trans-unit>
        <trans-unit id="868220302ade7af78023c7b85a0b0afbdb075b65" translate="yes" xml:space="preserve">
          <source>There are people that will tell you that Regular Expressions shouldn't be recursive. They are limiting you. They need to subjugate you, and they do it by keeping you in ignorance.</source>
          <target state="translated">Hay gente que le dirá que las expresiones regulares no deben ser recursivas.Te están limitando.Necesitan subyugarte,y lo hacen manteniéndote en la ignorancia.</target>
        </trans-unit>
        <trans-unit id="62180d2f49459a045257d1d5b700900365c68916" translate="yes" xml:space="preserve">
          <source>There are people that will tell you that the Earth is round (or perhaps that the Earth is an oblate spheroid if they want to use strange words). They are lying.</source>
          <target state="translated">Hay gente que le dirá que la Tierra es redonda (o tal vez que la Tierra es un esferoide oblato si quieren usar palabras extrañas).Están mintiendo.</target>
        </trans-unit>
        <trans-unit id="684dfff1de896a122d012445ef544b2496206f87" translate="yes" xml:space="preserve">
          <source>There are some nice regexes for replacing HTML with BBCode &lt;a href=&quot;http://www.garyshood.com/htmltobb/source.txt&quot;&gt;here&lt;/a&gt;. For all you nay-sayers, note that he's not trying to fully parse HTML, just to sanitize it. He can probably afford to kill off tags that his simple &quot;parser&quot; can't understand.</source>
          <target state="translated">Hay algunas expresiones regulares agradables para reemplazar HTML con BBCode &lt;a href=&quot;http://www.garyshood.com/htmltobb/source.txt&quot;&gt;aqu&amp;iacute;&lt;/a&gt; . Para todos los que no lo dicen, tenga en cuenta que no est&amp;aacute; tratando de analizar HTML completamente, solo para desinfectarlo. Probablemente puede permitirse matar etiquetas que su simple &quot;analizador&quot; no puede entender.</target>
        </trans-unit>
        <trans-unit id="76477d9fdddcc475f5d450550d80b052eec3964d" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;http://blog.stevenlevithan.com/archives/match-innermost-html-element&quot;&gt;definitive blog post&lt;/a&gt; about matching innermost HTML elements written by Steven Levithan.</source>
          <target state="translated">Hay una &lt;a href=&quot;http://blog.stevenlevithan.com/archives/match-innermost-html-element&quot;&gt;publicaci&amp;oacute;n de blog definitiva&lt;/a&gt; sobre la coincidencia de elementos HTML m&amp;aacute;s internos escrita por Steven Levithan.</target>
        </trans-unit>
        <trans-unit id="a4e1c0773bdde0557a23f8bb7011bb1819bc446f" translate="yes" xml:space="preserve">
          <source>These constructs allow for a .NET regular expression to emulate a
  restricted PDA by essentially allowing simple versions of the stack
  operations: push, pop and empty. The simple operations are pretty much
  equivalent to increment, decrement and compare to zero respectively.
  This allows for the .NET regular expression engine to recognize a
  subset of the context-free languages, in particular the ones that only
  require a simple counter. This in turn allows for the non-traditional
  .NET regular expressions to recognize individual properly balanced
  constructs.</source>
          <target state="translated">Estas construcciones permiten una expresión regular .NET para emular una PDA restringida permitiendo esencialmente versiones simples de las operaciones de apilamiento:push,pop y empty.Las operaciones simples son más o menos equivalentes a incrementar,disminuir y comparar con cero respectivamente.Esto permite que el motor de expresión regular .NET reconozca un subconjunto de los lenguajes libres de contexto,en particular los que sólo requieren un contador simple.Esto a su vez permite que las expresiones regulares no tradicionales .NET reconozcan construcciones individuales debidamente equilibradas.</target>
        </trans-unit>
        <trans-unit id="83ac605b777d6f693f2b21254eb270d567a76728" translate="yes" xml:space="preserve">
          <source>They are good for XML / XHTML.</source>
          <target state="translated">Son buenos para XML XHTML.</target>
        </trans-unit>
        <trans-unit id="ea04181710e1449f97e72ce6888abc9705be60aa" translate="yes" xml:space="preserve">
          <source>This found the match:</source>
          <target state="translated">Esto encontró la coincidencia:</target>
        </trans-unit>
        <trans-unit id="bbe32d2a62e217c596147afa1c643ecf26c036ca" translate="yes" xml:space="preserve">
          <source>This is the regex I use (!) to match HTML tags:</source>
          <target state="translated">Este es el regex que utilizo (!)para hacer coincidir las etiquetas HTML:</target>
        </trans-unit>
        <trans-unit id="d8d8d6a39df8c08ee1ff1787d57aba7ddbd1bee3" translate="yes" xml:space="preserve">
          <source>This post is locked to prevent inappropriate edits to its content. The post looks exactly as it is supposed to look - there are no problems with its content. Please do not flag it for our attention.</source>
          <target state="translated">Esta publicación está bloqueada para evitar ediciones inapropiadas de su contenido.El post se ve exactamente como se supone que debe verse,no hay problemas con su contenido.Por favor,no lo marque para llamar nuestra atención.</target>
        </trans-unit>
        <trans-unit id="20cb5dd39a077afa5b7e29efe1aa539dad4031b6" translate="yes" xml:space="preserve">
          <source>To test it deeply, I entered in the string auto-closing tags like:</source>
          <target state="translated">Para probarlo a fondo,introduje en la cadena etiquetas de autocierre como:</target>
        </trans-unit>
        <trans-unit id="102acb4ebe4f9295900af5f522c91830395377c0" translate="yes" xml:space="preserve">
          <source>Try:</source>
          <target state="translated">Try:</target>
        </trans-unit>
        <trans-unit id="a26ac4a7ee00f2bdbb69b3a7cd21e43c2ce7b858" translate="yes" xml:space="preserve">
          <source>Turing.sed</source>
          <target state="translated">Turing.sed</target>
        </trans-unit>
        <trans-unit id="a28f42522bb52c00621284c63c8ba53d7dfda10f" translate="yes" xml:space="preserve">
          <source>UNRELATED</source>
          <target state="translated">UNRELATED</target>
        </trans-unit>
        <trans-unit id="e8d3e730d87ce69a125b79edeeb87c6e997fdfb7" translate="yes" xml:space="preserve">
          <source>Understanding the pattern</source>
          <target state="translated">Entendiendo el patrón</target>
        </trans-unit>
        <trans-unit id="ada5ca9b4d7507ffcf81b9659577ff9cbe1d1ccf" translate="yes" xml:space="preserve">
          <source>Use the flags:</source>
          <target state="translated">Usa las banderas:</target>
        </trans-unit>
        <trans-unit id="24df9df6515abc09f921403db3f2eb9d44796515" translate="yes" xml:space="preserve">
          <source>W3C Link</source>
          <target state="translated">Enlace del W3C</target>
        </trans-unit>
        <trans-unit id="01acb4cbe019ba6b6ce6e22bcd09638b1774d9c8" translate="yes" xml:space="preserve">
          <source>Whenever I need to quickly extract something from an HTML document, I use Tidy to convert it to XML and then use XPath or XSLT to get what I need.
In your case, something like this:</source>
          <target state="translated">Siempre que necesito extraer rápidamente algo de un documento HTML,utilizo Tidy para convertirlo a XML y luego uso XPath o XSLT para obtener lo que necesito.En tu caso,algo como esto:</target>
        </trans-unit>
        <trans-unit id="49b8872857a1e031d0578f467b1e399793cd9b96" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;(?&amp;lt;! ... )&lt;/code&gt; is (in Perl regexes) the negative look-behind. It reads &quot;a &amp;lt;, then a word, then anything that's not a &amp;gt;, the last of which may not be a /, followed by &amp;gt;&quot;.</source>
          <target state="translated">Donde &lt;code&gt;(?&amp;lt;! ... )&lt;/code&gt; es (en expresiones regulares de Perl) la mirada negativa hacia atr&amp;aacute;s. Se lee &quot;a &amp;lt;, luego una palabra, luego todo lo que no sea un&amp;gt;, el &amp;uacute;ltimo de los cuales puede no ser un /, seguido de&amp;gt;&quot;.</target>
        </trans-unit>
        <trans-unit id="d88b6a634389ee3ca966ecac67f70a5331dc8d96" translate="yes" xml:space="preserve">
          <source>While &lt;em&gt;arbitrary&lt;/em&gt; HTML with only a regex is impossible, it's sometimes appropriate to use them for parsing a &lt;em&gt;limited, known&lt;/em&gt; set of HTML.</source>
          <target state="translated">Si bien &lt;em&gt;el&lt;/em&gt; HTML &lt;em&gt;arbitrario&lt;/em&gt; con solo una expresi&amp;oacute;n regular es imposible, a veces es apropiado usarlos para analizar un conjunto &lt;em&gt;limitado y conocido&lt;/em&gt; de HTML.</target>
        </trans-unit>
        <trans-unit id="b1bfbd9fe61d2ecc1e2a19393a476e7388bf0166" translate="yes" xml:space="preserve">
          <source>While the answers that you can't parse HTML with regexes are correct, they don't apply here. The OP just wants to parse one HTML tag with regexes, and that is something that can be done with a regular expression.</source>
          <target state="translated">Mientras que las respuestas que no puedes analizar el HTML con regexes son correctas,no se aplican aquí.La OP sólo quiere analizar una etiqueta HTML con regexes,y eso es algo que se puede hacer con una expresión regular.</target>
        </trans-unit>
        <trans-unit id="93249a5d51a2ea1bf181a9d0b47641aa389e6924" translate="yes" xml:space="preserve">
          <source>With minor variations, it can cope with messy HTML... or convert the HTML -&amp;gt; XHTML first.</source>
          <target state="translated">Con peque&amp;ntilde;as variaciones, puede hacer frente a HTML desordenado ... o convertir el HTML -&amp;gt; XHTML primero.</target>
        </trans-unit>
        <trans-unit id="86912b1a63422276d3fb2e364ae480edfb2fc529" translate="yes" xml:space="preserve">
          <source>Work out the Traveling Salesman Problem in O(log n) or less. If it's any more than that, you'll run out of RAM and the engine will hang.</source>
          <target state="translated">Resolver el problema del vendedor ambulante en O(log n)o menos.Si es más que eso,te quedarás sin memoria RAM y el motor se colgará.</target>
        </trans-unit>
        <trans-unit id="865301223dfe7d72c3b014a14a4edf685de64f15" translate="yes" xml:space="preserve">
          <source>Write HTML parser (homework)</source>
          <target state="translated">Escribir el analizador de HTML (tarea)</target>
        </trans-unit>
        <trans-unit id="99b34e00427c7bc9e27cce20b1b8167ea540549e" translate="yes" xml:space="preserve">
          <source>You can live in their reality or take the red pill.</source>
          <target state="translated">Puedes vivir en su realidad o tomar la píldora roja.</target>
        </trans-unit>
        <trans-unit id="a6a9711b57d9a5eea84e16f2d7ce057f02584407" translate="yes" xml:space="preserve">
          <source>You can try this at &lt;a href=&quot;http://derekslager.com/blog/posts/2007/09/a-better-dotnet-regular-expression-tester.ashx&quot;&gt;A Better .NET Regular Expression Tester&lt;/a&gt;.</source>
          <target state="translated">Puede probar esto en &lt;a href=&quot;http://derekslager.com/blog/posts/2007/09/a-better-dotnet-regular-expression-tester.ashx&quot;&gt;A Better .NET Regular Expression Tester&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b81d0ffa357688587ac76745c399587c1efb48a" translate="yes" xml:space="preserve">
          <source>You can't parse [X]HTML with regex. Because HTML can't be parsed by regex. Regex is not a tool that can be used to correctly parse HTML. As I have answered in HTML-and-regex questions here so many times before, the use of regex will not allow you to consume HTML. Regular expressions are a tool that is insufficiently sophisticated to understand the constructs employed by HTML. HTML is not a regular language and hence cannot be parsed by regular expressions. Regex queries are not equipped to break down HTML into its meaningful parts. so many times but it is not getting to me. Even enhanced irregular regular expressions as used by Perl are not up to the task of parsing HTML. You will never make me crack. HTML is a language of sufficient complexity that it cannot be parsed by regular expressions. Even Jon Skeet cannot parse HTML using regular expressions. Every time you attempt to parse HTML with regular expressions, the unholy child weeps the blood of virgins, and Russian hackers pwn your webapp. Parsing HTML with regex summons tainted souls into the realm of the living. HTML and regex go together like love, marriage, and ritual infanticide. The &amp;lt;center&amp;gt; cannot hold it is too late. The force of regex and HTML together in the same conceptual space will destroy your mind like so much watery putty. If you parse HTML with regex you are giving in to Them and their blasphemous ways which doom us all to inhuman toil for the One whose Name cannot be expressed in the Basic Multilingual Plane, he comes. HTML-plus-regexp will liquify the n​erves of the sentient whilst you observe, your psyche withering in the onslaught of horror. Rege̿̔̉x-based HTML parsers are the cancer that is killing StackOverflow</source>
          <target state="translated">No puede analizar HTML [X] con regex. Porque HTML no puede ser analizado por regex. Regex no es una herramienta que se pueda utilizar para analizar HTML correctamente. Como he respondido en preguntas de HTML y expresiones regulares aqu&amp;iacute; tantas veces antes, el uso de expresiones regulares no le permitir&amp;aacute; consumir HTML. Las expresiones regulares son una herramienta que no es lo suficientemente sofisticada para comprender las construcciones empleadas por HTML. HTML no es un lenguaje regular y, por lo tanto, no se puede analizar mediante expresiones regulares. Las consultas Regex no est&amp;aacute;n equipadas para descomponer HTML en sus partes significativas. muchas veces pero no me est&amp;aacute; afectando. Incluso las expresiones regulares irregulares mejoradas que usa Perl no est&amp;aacute;n a la altura de analizar HTML. Nunca me har&amp;aacute;s romper. HTML es un lenguaje de suficiente complejidad que no puede ser analizado por expresiones regulares. Incluso Jon Skeet no puede analizar HTML usando expresiones regulares. Cada vez que intentas analizar HTML con expresiones regulares, el ni&amp;ntilde;o imp&amp;iacute;o llora la sangre de las v&amp;iacute;rgenes y los hackers rusos tiran tu aplicaci&amp;oacute;n web. Analizar HTML con expresiones regulares convoca a almas contaminadas en el reino de los vivos. HTML y regex van juntos como el amor, el matrimonio y el infanticidio ritual. El &amp;lt;centro&amp;gt; no puede mantenerlo, es demasiado tarde. La fuerza de expresiones regulares y HTML juntas en el mismo espacio conceptual destruir&amp;aacute; tu mente como una masilla acuosa. Si analizas HTML con regex, te est&amp;aacute;s entregando a Ellos y sus formas blasfemas que nos condenan a todos a un trabajo inhumano para Aquel cuyo Nombre no puede expresarse en el Plano Multiling&amp;uuml;e B&amp;aacute;sico, &amp;eacute;l viene. HTML-plus-regexp licuar&amp;aacute; las nervios del sensible mientras observas, tu psique se marchita en la embestida del horror. Los analizadores HTML basados ​​en Rege̿̔̉x son el c&amp;aacute;ncer que est&amp;aacute; matando a StackOverflow</target>
        </trans-unit>
        <trans-unit id="d4cc5878bfc8de446a816e62a10b477bf7628da8" translate="yes" xml:space="preserve">
          <source>You want the first &lt;code&gt;&amp;gt;&lt;/code&gt; not preceded by a &lt;code&gt;/&lt;/code&gt;.  Look &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;here&lt;/a&gt; for details on how to do that.  It's referred to as negative lookbehind.</source>
          <target state="translated">Desea el primero &lt;code&gt;&amp;gt;&lt;/code&gt; no precedido por un &lt;code&gt;/&lt;/code&gt; . Mire &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;aqu&amp;iacute;&lt;/a&gt; para obtener detalles sobre c&amp;oacute;mo hacerlo. Se conoce como mirar hacia atr&amp;aacute;s negativo.</target>
        </trans-unit>
        <trans-unit id="0f094d4f9e70b554306ad025350bec42add64291" translate="yes" xml:space="preserve">
          <source>a&lt;sup&gt;n&lt;/sup&gt;ba&lt;sup&gt;n&lt;/sup&gt;ba&lt;sup&gt;n&lt;/sup&gt; which is not regular and not even context free, can be matched with &lt;code&gt;^(a+)b\1b\1$&lt;/code&gt;</source>
          <target state="translated">a &lt;sup&gt;n&lt;/sup&gt; ba &lt;sup&gt;n&lt;/sup&gt; ba &lt;sup&gt;n&lt;/sup&gt; que no es regular y ni siquiera est&amp;aacute; libre de contexto, se puede combinar con &lt;code&gt;^(a+)b\1b\1$&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f7db1a41076f29a8bc513a82d4eeb79c22c4b29" translate="yes" xml:space="preserve">
          <source>according to the specific implementation of the RegExp engine, recursion may have a limit in the &lt;strong&gt;number of nested patterns parsed&lt;/strong&gt;, but it depends on the language used</source>
          <target state="translated">De acuerdo con la implementaci&amp;oacute;n espec&amp;iacute;fica del motor RegExp, la recursi&amp;oacute;n puede tener un l&amp;iacute;mite en el &lt;strong&gt;n&amp;uacute;mero de patrones anidados analizados&lt;/strong&gt; , pero depende del idioma utilizado</target>
        </trans-unit>
        <trans-unit id="c4d4e32662c88b8424d1c0984fceefe61e4e23a5" translate="yes" xml:space="preserve">
          <source>again, zero or more whitespaces</source>
          <target state="translated">otra vez,cero o más espacios en blanco</target>
        </trans-unit>
        <trans-unit id="416344de81011e88293f4de90995d2f4eb4cfe70" translate="yes" xml:space="preserve">
          <source>ain, the song of re̸gular exp​re&lt;strike&gt;ssion parsing &lt;/strike&gt;will exti</source>
          <target state="translated">de nuevo, la canci&amp;oacute;n de an&amp;aacute;lisis de expresi&amp;oacute;n regular continuar&amp;aacute;</target>
        </trans-unit>
        <trans-unit id="dac38d2a71b13841b4f7fa59c2cbb41d8f4fe7c5" translate="yes" xml:space="preserve">
          <source>although corrupted (x)HTML does not drive into severe errors, it is not &lt;em&gt;sanitized&lt;/em&gt;.</source>
          <target state="translated">aunque el HTML (x) corrupto no genera errores graves, no se &lt;em&gt;desinfecta&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b2c0c9e8369c247831710c647b81dda3b5b625b1" translate="yes" xml:space="preserve">
          <source>although it actually came out like this:</source>
          <target state="translated">aunque en realidad salió así:</target>
        </trans-unit>
        <trans-unit id="b91f3e1f4b4ae9ba5a969df90fc854016c1cfedf" translate="yes" xml:space="preserve">
          <source>and the dread realm of c͒ͪo͛ͫrrupt entities (like SGML entities, but</source>
          <target state="translated">y el temible reino de c͒ͪo͛ͫrrupt entidades (como las entidades SGML,pero</target>
        </trans-unit>
        <trans-unit id="789d3b546d80c656a137d6a2dae501ef948c9936" translate="yes" xml:space="preserve">
          <source>attributes containing single quotes when the delimiter is a double quote and vice versa</source>
          <target state="translated">atributos que contienen comillas simples cuando el delimitador es una comilla doble y viceversa</target>
        </trans-unit>
        <trans-unit id="83049ba02543c5468a7092d704e728351f015ce0" translate="yes" xml:space="preserve">
          <source>attributes which value is bound either into &lt;strong&gt;single quotes&lt;/strong&gt; or into &lt;strong&gt;double quotes&lt;/strong&gt;</source>
          <target state="translated">atributos cuyo valor est&amp;aacute; unido a &lt;strong&gt;comillas simples&lt;/strong&gt; o &lt;strong&gt;comillas dobles&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="872af077bba705c60415b90068389b0d9ae136b2" translate="yes" xml:space="preserve">
          <source>ch between this world</source>
          <target state="translated">ch entre este mundo</target>
        </trans-unit>
        <trans-unit id="b1ccf8aca583f64c44e6498a0abc71300cee934c" translate="yes" xml:space="preserve">
          <source>d of ceaseless screaming, he comes&lt;strike&gt;, the pestilent sl&lt;/strike&gt;ithy regex-infection wil​&lt;b&gt;l devour your HT&lt;/b&gt;​ML parser, application and existence for all time like Visual Basic only worse</source>
          <target state="translated">d de gritos incesantes, &amp;eacute;l viene &lt;strike&gt;, la&lt;/strike&gt; infecci&amp;oacute;n de expresi&amp;oacute;n regular &lt;strike&gt;pestilente y&lt;/strike&gt; lenta &lt;b&gt;devorar&amp;aacute; su&lt;/b&gt; analizador, aplicaci&amp;oacute;n y existencia &lt;b&gt;HT&lt;/b&gt; ML para siempre como Visual Basic, peor a&amp;uacute;n</target>
        </trans-unit>
        <trans-unit id="fad2a06a8e728d64f3eff45851e3b600bd2bf437" translate="yes" xml:space="preserve">
          <source>dear lord help us how can anyone survive this scourge</source>
          <target state="translated">Querido Señor,ayúdanos a sobrevivir a este azote...</target>
        </trans-unit>
        <trans-unit id="5b52a1cb49381cdd269797b153d0660ee9133944" translate="yes" xml:space="preserve">
          <source>do not fi</source>
          <target state="translated">no se fije</target>
        </trans-unit>
        <trans-unit id="b9dea77ba556480de7588671f4a3d44f039e5d2e" translate="yes" xml:space="preserve">
          <source>e pon̷y he come</source>
          <target state="translated">e pon̷y él viene</target>
        </trans-unit>
        <trans-unit id="09cd68a2a77b22a312dded612dd0d9988685189f" translate="yes" xml:space="preserve">
          <source>es</source>
          <target state="translated">es</target>
        </trans-unit>
        <trans-unit id="707cd90a4f77675613cc63dfa16b29bedcf7d2e6" translate="yes" xml:space="preserve">
          <source>es al</source>
          <target state="translated">es al</target>
        </trans-unit>
        <trans-unit id="16829609b87ebecff7cb40016842539439ef333f" translate="yes" xml:space="preserve">
          <source>e̠̅s&lt;code&gt; ͎a̧͈͖r̽̾̈́͒͑e&lt;/code&gt; n&lt;b&gt;​ot rè̑ͧ̌aͨl̘̝̙̃ͤ͂̾̆ ZA̡͊͠͝LGΌ ISͮ̂҉̯͈͕̹̘̱ T&lt;/b&gt;O͇̹̺ͅƝ̴ȳ̳ TH̘&lt;b&gt;Ë͖́̉ ͠P̯͍̭O̚​N̐Y̡ H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝&lt;/b&gt;S̨̥̫͎̭ͯ̿̔̀ͅ</source>
          <target state="translated">e̠̅s &lt;code&gt; ͎a̧͈͖r̽̾̈́͒͑e&lt;/code&gt; n &lt;b&gt;ot r&amp;egrave;̑ͧ̌aͨl̘̝̙̃ͤ͂̾̆ ZA̡͊͠͝LGΌ ISͮ̂҉̯͈͕̹̘̱ T&lt;/b&gt; O͇̹̺ͅƝ̴ȳ̳ TH̘ &lt;b&gt;&amp;Euml;͖́̉ ͠P̯͍̭O̚ N̐Y̡ H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝&lt;/b&gt; S̨̥̫͎̭ͯ̿̔̀ͅ</target>
        </trans-unit>
        <trans-unit id="0a971adf10fafe8fe3d724d80e0beaa10f271291" translate="yes" xml:space="preserve">
          <source>f the lie​&lt;b&gt;s of Man ALL IS LOŚ͖̩͇̗̪̏̈́T A&lt;/b&gt;</source>
          <target state="translated">f las mentiras &lt;b&gt;del hombre TODO ES LOŚ͖̩͇̗̪̏̈́T A&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6c0c535eae65a352e21a597046b9c71062ef7e32" translate="yes" xml:space="preserve">
          <source>he an​*̶͑̾̾​̅ͫ͏̙̤g͇̫͛͆̾ͫ̑͆l͖͉̗̩̳̟̍ͫͥͨ</source>
          <target state="translated">he an*̶͑̾̾̅ͫ͏̙̤g͇an͉̩̳̟̗͛͆̾ͫ̍͆ͨ̍ͫͥ</target>
        </trans-unit>
        <trans-unit id="21f7c212343db1452bf1005fe7bec61697f3efef" translate="yes" xml:space="preserve">
          <source>he comes he com</source>
          <target state="translated">viene,viene,viene</target>
        </trans-unit>
        <trans-unit id="c1b6858eae6b82f5a342bbfcd9d5505ae8d8b304" translate="yes" xml:space="preserve">
          <source>he f&lt;code&gt;inal snuf&lt;/code&gt;fing o</source>
          <target state="translated">&amp;eacute;l f &lt;code&gt;inal snuf&lt;/code&gt; snuf fing o</target>
        </trans-unit>
        <trans-unit id="cba0af89feed0e8e942fec8ed4c10695745c757d" translate="yes" xml:space="preserve">
          <source>here comes the fun: the \4 part is a &lt;strong&gt;backreference operator&lt;/strong&gt;, which refers to a sub-expression defined before in the pattern, in this case, I am referring to the fourth sub-expression, which is the first attribute delimiter found</source>
          <target state="translated">Aqu&amp;iacute; viene la diversi&amp;oacute;n: la parte \ 4 es un &lt;strong&gt;operador de&lt;/strong&gt; referencia, que se refiere a una sub-expresi&amp;oacute;n definida anteriormente en el patr&amp;oacute;n, en este caso, me refiero a la cuarta sub-expresi&amp;oacute;n, que es el primer delimitador de atributos encontrado</target>
        </trans-unit>
        <trans-unit id="a8ec278d2e709b878840d59f0dc4611cd1bb49d5" translate="yes" xml:space="preserve">
          <source>it is too late it is too late we cannot be saved</source>
          <target state="translated">es demasiado tarde es demasiado tarde no podemos ser salvados</target>
        </trans-unit>
        <trans-unit id="a38cb8457436d320aa6e6a447ea6ac270b0eb2aa" translate="yes" xml:space="preserve">
          <source>l MY FAC</source>
          <target state="translated">l MI FAC</target>
        </trans-unit>
        <trans-unit id="eb912827300bfa09ffaae9a61a04131d928f17d2" translate="yes" xml:space="preserve">
          <source>more corrupt) a mere glimp</source>
          <target state="translated">más corrupto)un mero vistazo</target>
        </trans-unit>
        <trans-unit id="5a4bedc53d646eb4f152665ce04f194f119d1230" translate="yes" xml:space="preserve">
          <source>more than one attribute</source>
          <target state="translated">más de un atributo</target>
        </trans-unit>
        <trans-unit id="0f0f39e938eb9a6927af1fd3169cbf5dc39c8c05" translate="yes" xml:space="preserve">
          <source>nto a w</source>
          <target state="translated">nto a w</target>
        </trans-unit>
        <trans-unit id="f676ebbcb5a6de68fd4cd64947f2f073b0bc183b" translate="yes" xml:space="preserve">
          <source>one attribute</source>
          <target state="translated">un atributo</target>
        </trans-unit>
        <trans-unit id="b63094eb585e278a2a9faac15421a9c3b8a73f5d" translate="yes" xml:space="preserve">
          <source>one or more whitespaces \s+</source>
          <target state="translated">uno o más espacios en blanco.</target>
        </trans-unit>
        <trans-unit id="a4f0099e46341d0fc7c083fc51657b45fb1eb61a" translate="yes" xml:space="preserve">
          <source>or just combine if and if not.</source>
          <target state="translated">o simplemente combinar si y si no.</target>
        </trans-unit>
        <trans-unit id="90255a902e3a09b87ea94d0074d32fa53f1e3df0" translate="yes" xml:space="preserve">
          <source>orl</source>
          <target state="translated">orl</target>
        </trans-unit>
        <trans-unit id="5beefb69787012b543ff81b246c6096ef31b16cb" translate="yes" xml:space="preserve">
          <source>rogrammer's consciousness i</source>
          <target state="translated">la conciencia de rogrammer i</target>
        </trans-unit>
        <trans-unit id="a529326c3bc272f1c87faf0fc168c3f2b888e5e1" translate="yes" xml:space="preserve">
          <source>s he c̶̮om&lt;strike&gt;es he co&lt;/strike&gt;&lt;b&gt;&lt;strike&gt;me&lt;/strike&gt;s t&lt;i&gt;he&lt;/i&gt; ich​&lt;/b&gt;or permeat</source>
          <target state="translated">s &amp;eacute;l viene, &amp;eacute;l se junta con el &lt;b&gt;ich o&lt;/b&gt; permeat</target>
        </trans-unit>
        <trans-unit id="cdc9e9914e559a22d8c2863df88dcc0affd254bb" translate="yes" xml:space="preserve">
          <source>se of the world of reg​&lt;b&gt;ex parsers for HTML will ins&lt;/b&gt;​tantly transport a p</source>
          <target state="translated">El mundo de los &lt;b&gt;analizadores&lt;/b&gt; de registros &lt;b&gt;para HTML&lt;/b&gt; transportar&amp;aacute; instant&amp;aacute;neamente una aplicaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="fcd31f61fdd2492a68c910cd84210be08c96a97c" translate="yes" xml:space="preserve">
          <source>stro҉ying all enli̍̈́̂̈́ghtenment, HTML tags &lt;b&gt;lea͠ki̧n͘g fr̶ǫm ̡yo​͟ur eye͢s̸ ̛l̕ik͏e liq&lt;/b&gt;​uid p</source>
          <target state="translated">Stro҉ying todo enli̍̈́̂̈́ghtenment, etiquetas HTML &lt;b&gt;lea͠ki̧n͘g fr̶ǫm ̡yo ͟ur eye͢s̸ ̛l̕ik͏e liq&lt;/b&gt; uid p</target>
        </trans-unit>
        <trans-unit id="13cecb0242cc098120804e419e2c0898d7c5f3d9" translate="yes" xml:space="preserve">
          <source>the &quot;=&quot; symbol</source>
          <target state="translated">el símbolo &quot;=&quot;</target>
        </trans-unit>
        <trans-unit id="ef1ddac3121c15757add5489d19c276fcda4e43f" translate="yes" xml:space="preserve">
          <source>the attribute sub-expression ends here, with the specification of zero or more possible occurrences, given by the asterisk.</source>
          <target state="translated">la subexpresión del atributo termina aquí,con la especificación de cero o más ocurrencias posibles,dadas por el asterisco.</target>
        </trans-unit>
        <trans-unit id="9fb82ad748ee217a3d8676ebffa5f977ad107e1b" translate="yes" xml:space="preserve">
          <source>the delimiter of the attribute value, a single or double quote ('|&quot;). In the pattern, the single quote is escaped because it coincides with the PHP string delimiter. This sub-expression is captured with the parentheses so it can be referenced again to parse the closure of the attribute, that's why it is very important.</source>
          <target state="translated">&quot;).In the pattern,the single quote is escaped because it coincides with the PHP string delimiter.This sub-expression is captured with the parentheses so it can be referenced again to parse the closure of the attribute,that's why it is very important.</target>
        </trans-unit>
        <trans-unit id="bf47c953b6d49b59cea7ef6e949bcd244312ad84" translate="yes" xml:space="preserve">
          <source>the first sub-expression (\w+) matches the tag name</source>
          <target state="translated">la primera sub-expresión (\w+)coincide con el nombre de la etiqueta</target>
        </trans-unit>
        <trans-unit id="8ff32fe1a0c4d2f2143244e76a1ea25a84d0a50e" translate="yes" xml:space="preserve">
          <source>the name of the attribute (\w+)</source>
          <target state="translated">el nombre del atributo (\w+)</target>
        </trans-unit>
        <trans-unit id="a63f6d3ba68d8159445680753d6b7dcfea330647" translate="yes" xml:space="preserve">
          <source>the second sub-expression contains the pattern of an attribute. It is composed by:</source>
          <target state="translated">la segunda subexpresión contiene el patrón de un atributo.Está compuesto por:</target>
        </trans-unit>
        <trans-unit id="98c53a01bc3d612ea14d5657a8251e38b47274e3" translate="yes" xml:space="preserve">
          <source>the trangession of a chi͡ld ensures regex will consume all living tissue (except for HTML which it cannot, as previously prophesied)</source>
          <target state="translated">la trangesión de un chi͡ld asegura que regex consumirá todo el tejido vivo (excepto el HTML que no puede,como se profetizó anteriormente)</target>
        </trans-unit>
        <trans-unit id="fcae9afa44c8d009bc39cd1558b5bcceb178f9f3" translate="yes" xml:space="preserve">
          <source>the value of the attribute, matched by &lt;em&gt;almost&lt;/em&gt; anything: (.*?); in this specific syntax, using the &lt;strong&gt;greedy match&lt;/strong&gt; (the question mark after the asterisk) the RegExp engine enables a &quot;look-ahead&quot;-like operator, which matches anything but what follows this sub-expression</source>
          <target state="translated">el valor del atributo, igualado por &lt;em&gt;casi&lt;/em&gt; cualquier cosa: (. *?); En esta sintaxis espec&amp;iacute;fica, usando la &lt;strong&gt;coincidencia codiciosa&lt;/strong&gt; (el signo de interrogaci&amp;oacute;n despu&amp;eacute;s del asterisco), el motor RegExp habilita un operador similar al &quot;look-ahead&quot;, que coincide con todo menos lo que sigue a esta sub-expresi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="e8cdc833b2aa479524c91f0c0770ca55cab15dbc" translate="yes" xml:space="preserve">
          <source>using rege</source>
          <target state="translated">usando rege</target>
        </trans-unit>
        <trans-unit id="05316c08fdd253a1c9a83c01ccb3802a454fbc33" translate="yes" xml:space="preserve">
          <source>using regex to parse HTML has doomed humanity to an eternity of dread torture and security holes</source>
          <target state="translated">El uso de regex para analizar el HTML ha condenado a la humanidad a una eternidad de temibles torturas y agujeros de seguridad.</target>
        </trans-unit>
        <trans-unit id="ab44de7440b2ebdde8558b36f16d5f922c19d2d5" translate="yes" xml:space="preserve">
          <source>x as a tool to process HTML establishes a brea</source>
          <target state="translated">x como herramienta para procesar HTML establece un brea</target>
        </trans-unit>
        <trans-unit id="7f524dcbd593bece540d29aea0353dc495423551" translate="yes" xml:space="preserve">
          <source>zero or more whitespaces \s*</source>
          <target state="translated">cero o más espacios en blanco.</target>
        </trans-unit>
        <trans-unit id="9bdd5426b4b4fdd866ac9851215bf267b6e6df44" translate="yes" xml:space="preserve">
          <source>zero or more whitespaces \s* (it is possible or not, leaving blanks here)</source>
          <target state="translated">cero o más espacios en blanco*(es posible o no,dejando espacios en blanco aquí)</target>
        </trans-unit>
        <trans-unit id="1b249f9d22bd1bda62f373b04cdb08126b054557" translate="yes" xml:space="preserve">
          <source>​ght h&lt;b&gt;e com̡e̶s, ̕h̵i&lt;/b&gt;​s un̨ho͞ly radiańcé de</source>
          <target state="translated">&lt;b&gt;Ght&lt;/b&gt; h &lt;b&gt;e com̡e̶s, ̕h̵i&lt;/b&gt; s un̨ho͞ly radiańc&amp;eacute; de</target>
        </trans-unit>
        <trans-unit id="87484f6cbcd5c18c6c4b093d13bc9f9ee13c577f" translate="yes" xml:space="preserve">
          <source>​nguish the voices of mor​&lt;b&gt;tal man from the sp&lt;/b&gt;​here I can see it can you see ̲͚̖͔̙î̩́t̲͎̩̱͔́̋̀ it is beautiful t​</source>
          <target state="translated">Escuche las voces de un &lt;b&gt;hombre m&amp;aacute;s&lt;/b&gt; fuerte &lt;b&gt;de la sp&lt;/b&gt; aqu&amp;iacute; puedo verlo puedes ver you&amp;icirc;̩́t̲͎̩̱͔́̋̀ es hermoso t</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
