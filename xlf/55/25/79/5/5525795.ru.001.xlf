<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/5525795">
    <body>
      <group id="5525795">
        <trans-unit id="da3687cfe7631d821ba35f4e012caced3b66cd22" translate="yes" xml:space="preserve">
          <source>(emphasis mine).</source>
          <target state="translated">(акцент мой).</target>
        </trans-unit>
        <trans-unit id="506a92cc597c8229d7c4a2bed4f4e9b88c6d9d1b" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; [the object being iterated] that is an integer index, in ascending numeric index order</source>
          <target state="translated">... каждый собственный ключ свойства &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; [объект, который повторяется], который является целочисленным индексом, в порядке возрастания числового индекса</target>
        </trans-unit>
        <trans-unit id="b1431eb62a77c3957a1a90ad8c2ee19b35d73184" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; that is a String but is not an integer index, in property creation order</source>
          <target state="translated">... каждый собственный ключ свойства &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; , который является строкой, но не является целочисленным индексом, в порядке создания свойств</target>
        </trans-unit>
        <trans-unit id="41f72be3edc7209f752acd3f28c3b1078665a04e" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; that is a Symbol, in property creation order</source>
          <target state="translated">... каждый собственный ключ свойства &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; , представляющий собой символ, в порядке создания свойств</target>
        </trans-unit>
        <trans-unit id="617676d9406eee86e16ed250ff2bd786d055b06f" translate="yes" xml:space="preserve">
          <source>4.3.3 Object</source>
          <target state="translated">4.3.3 Объект</target>
        </trans-unit>
        <trans-unit id="629e86072909febc69cff039b31e251bfb5bcef7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;, &lt;code&gt;Reflect.ownKeys()&lt;/code&gt;, &lt;code&gt;Object.getOwnPropertySymbols(O)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt; , &lt;code&gt;Reflect.ownKeys()&lt;/code&gt; , &lt;code&gt;Object.getOwnPropertySymbols(O)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="906437decdad0d2084e279baa2e2d923b430539c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.keys&lt;/code&gt;, &lt;code&gt;Object.values&lt;/code&gt;, &lt;code&gt;Object.entries&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.keys&lt;/code&gt; , &lt;code&gt;Object.values&lt;/code&gt; , &lt;code&gt;Object.entries&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac72976f1fd79543ad7172b5c48fa8ec5cc520a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..in&lt;/code&gt; loops</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; петлях</target>
        </trans-unit>
        <trans-unit id="3f7356ed9c8dad2efb0205e5f9f24151517669d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In what context?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;В каком контексте?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d30fe30d4258ac32279a10fad11a23661e24d1fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But, soon (probably in ES2020), property order for these previously untrustworthy methods &lt;em&gt;will&lt;/em&gt; be guaranteed by the specification&lt;/strong&gt; to be iterated over in the same deterministic manner as the others, due to to the &lt;a href=&quot;https://github.com/tc39/proposals/blob/master/finished-proposals.md&quot;&gt;stage 4&lt;/a&gt; proposal: &lt;a href=&quot;http://tc39.es/proposal-for-in-order/&quot;&gt;For-in enumeration order&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Но вскоре (возможно, в ES2020) порядок свойств для этих ранее ненадежных методов &lt;em&gt;будет&lt;/em&gt; гарантированно&lt;/strong&gt; итерирован &lt;strong&gt;в спецификации&lt;/strong&gt; таким же детерминированным образом, что и другие, благодаря предложению &lt;a href=&quot;https://github.com/tc39/proposals/blob/master/finished-proposals.md&quot;&gt;этапа 4&lt;/a&gt; : &lt;a href=&quot;http://tc39.es/proposal-for-in-order/&quot;&gt;Порядок перечисления &amp;laquo;в порядке&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43cf735af1addba43cf6135a9e6cd5fd77f69b83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusion: Even in ES2015 you shouldn't rely on the property order of normal objects in Javascript. It is prone to errors. Use &lt;code&gt;Map&lt;/code&gt; instead.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вывод: даже в ES2015 вы не должны полагаться на порядок свойств обычных объектов в Javascript.&lt;/strong&gt; &lt;strong&gt;Это склонно к ошибкам.&lt;/strong&gt; &lt;strong&gt;Используйте &lt;code&gt;Map&lt;/code&gt; вместо.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be9ffe71c53127990a370c8d47eb77ce87f4c69b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Current Language Spec (since ES2015)&lt;/strong&gt; insertion order is preserved, except in the case of keys that parse as integers (eg &quot;7&quot; or &quot;99&quot;), where behavior varies between browsers. For example, Chrome/V8 does not respect insertion order when the keys are parse as numeric.</source>
          <target state="translated">&lt;strong&gt;Текущие языковые спецификации (начиная с ES2015)&lt;/strong&gt; порядок вставки сохраняется, за исключением случая, когда ключи разбираются как целые числа (например, &amp;laquo;7&amp;raquo; или &amp;laquo;99&amp;raquo;), где поведение варьируется в разных браузерах. Например, Chrome / V8 не учитывает порядок вставки, когда ключи анализируются как числовые.</target>
        </trans-unit>
        <trans-unit id="8c848754eb60df7eadf93fb71befdc94139eef6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Old Language Spec (before ES2015)&lt;/strong&gt;: Iteration order was technically undefined, but all major browsers complied with the ES2015 behavior.</source>
          <target state="translated">&lt;strong&gt;Спецификация старого языка (до ES2015)&lt;/strong&gt; : Порядок &lt;strong&gt;итераций&lt;/strong&gt; был технически не определен, но все основные браузеры соответствовали поведению ES2015.</target>
        </trans-unit>
        <trans-unit id="a5cabd9db5130fe850fc14a9f035d862d77edcae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;YES (for non-integer keys).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ДА (для нецелых ключей).&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ddc2dc2dbcd4516457a87d0f7f30c97209aab02" translate="yes" xml:space="preserve">
          <source>A Map object can iterate its elements in insertion order...</source>
          <target state="translated">Объект &quot;Карта&quot; может выполнить итерацию своих элементов в порядке вставки...</target>
        </trans-unit>
        <trans-unit id="8272a49555285dae357452d8b3518864897ab434" translate="yes" xml:space="preserve">
          <source>All &lt;em&gt;integer index&lt;/em&gt; keys (stuff like &lt;code&gt;&quot;1123&quot;&lt;/code&gt;, &lt;code&gt;&quot;55&quot;&lt;/code&gt;, etc) in ascending numeric order.</source>
          <target state="translated">Все &lt;em&gt;целочисленные индексные&lt;/em&gt; ключи (например, &lt;code&gt;&quot;1123&quot;&lt;/code&gt; , &lt;code&gt;&quot;55&quot;&lt;/code&gt; и т. Д.) В порядке возрастания номеров.</target>
        </trans-unit>
        <trans-unit id="6d0d086e05c3f95500e0ef71cccca3dcbbf3ee81" translate="yes" xml:space="preserve">
          <source>All other non-Symbol keys, in insertion order</source>
          <target state="translated">Все остальные несимвольные ключи,в порядке вставки</target>
        </trans-unit>
        <trans-unit id="6931239bebc33c69fddecf7cf1a400bef63e3d2e" translate="yes" xml:space="preserve">
          <source>All string keys which are not integer indices, in order of creation (oldest-first).</source>
          <target state="translated">Все строковые ключи,не являющиеся целыми индексами,в порядке создания (самый старый-первый).</target>
        </trans-unit>
        <trans-unit id="9cc7882625e1fa1848c2d4d2d56f6e182d7ff836" translate="yes" xml:space="preserve">
          <source>All symbol keys, in order of creation (oldest-first).</source>
          <target state="translated">Все символьные клавиши,в порядке создания (самая старая-первая).</target>
        </trans-unit>
        <trans-unit id="d99ee358a61be9c08f8e3663248de7c6ea7386a1" translate="yes" xml:space="preserve">
          <source>Although the current specification leaves for..in iteration order &quot;&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-enumerate-object-properties&quot;&gt;almost totally unspecified&lt;/a&gt;, real engines tend to be more consistent:&quot;</source>
          <target state="translated">Хотя текущая спецификация оставляет для&amp;hellip; в итерационном порядке &amp;laquo; &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-enumerate-object-properties&quot;&gt;почти полностью неопределенные&lt;/a&gt; , реальные движки имеют тенденцию быть более последовательными:&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="9f541eac51b245397dfc1dd505657af7d28c26b2" translate="yes" xml:space="preserve">
          <source>An object is a member of the
  type Object. &lt;strong&gt;It is an unordered collection of properties&lt;/strong&gt; each of which
  contains a primitive value, object, or
  function. A function stored in a
  property of an object is called a
  method.</source>
          <target state="translated">Объект является членом типа Object. &lt;strong&gt;Это неупорядоченный набор свойств,&lt;/strong&gt; каждое из которых содержит примитивное значение, объект или функцию. Функция, хранящаяся в свойстве объекта, называется методом.</target>
        </trans-unit>
        <trans-unit id="3f1e99d603dc8c534f17c37e7680125db1255ec4" translate="yes" xml:space="preserve">
          <source>An object is an &lt;strong&gt;unordered&lt;/strong&gt; collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array.</source>
          <target state="translated">Объект - это &lt;strong&gt;неупорядоченный&lt;/strong&gt; набор из нуля или более пар имя / значение, где имя - это строка, а значение - строка, число, логическое значение, значение null, объект или массив.</target>
        </trans-unit>
        <trans-unit id="0ce441a742a81f4f9ec981fd12c2ec069bde986b" translate="yes" xml:space="preserve">
          <source>As a note, properties order in objects weren&amp;rsquo;t guaranteed at all before ES2015. Definition of an Object from &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf&quot;&gt;ECMAScript Third Edition (pdf)&lt;/a&gt;:</source>
          <target state="translated">Как примечание, порядок свойств в объектах не был гарантирован до ES2015. Определение объекта из &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf&quot;&gt;ECMAScript Third Edition (pdf)&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="89359f1939ff8169993255536817a0eeb023f70f" translate="yes" xml:space="preserve">
          <source>As of ES2015, property order is guaranteed for certain methods that iterate over properties. &lt;a href=&quot;https://stackoverflow.com/a/30919039/&quot;&gt;but not others&lt;/a&gt;. Unfortunately, the methods which are not guaranteed to have an order are generally the most often used:</source>
          <target state="translated">Начиная с ES2015, порядок свойств гарантирован для определенных методов, которые перебирают свойства. &lt;a href=&quot;https://stackoverflow.com/a/30919039/&quot;&gt;но не другие&lt;/a&gt; . К сожалению, методы, порядок которых не гарантирован, обычно используются чаще всего:</target>
        </trans-unit>
        <trans-unit id="f0701b9ee5dc8738764e68bb472acd3938023043" translate="yes" xml:space="preserve">
          <source>As others have stated, you have no guarantee as to the order when you iterate over the properties of an object. If you need an ordered list of multiple fields I suggested creating an array of objects.</source>
          <target state="translated">Как уже говорили другие,у вас нет гарантии на порядок при итерации над свойствами объекта.Если вам нужен упорядоченный список из нескольких полей,я предложил создать массив объектов.</target>
        </trans-unit>
        <trans-unit id="4444585e7d19b4c0af133a98d6096e8c852f3f8b" translate="yes" xml:space="preserve">
          <source>At the time of writing, most browsers did return properties in the same order as they were inserted, but it was explicitly not guaranteed behaviour so shouldn't have been relied upon.</source>
          <target state="translated">На момент написания статьи большинство браузеров возвращали свойства в том же порядке,в каком они были вставлены,но это было явно не гарантированное поведение,на которое не следовало полагаться.</target>
        </trans-unit>
        <trans-unit id="98f97678eae35879cc93487177bce8991d7bde31" translate="yes" xml:space="preserve">
          <source>Because every implementation already iterates over properties predictably, it can be put into the specification without breaking backwards compatibility.</source>
          <target state="translated">Так как каждая реализация уже предсказуемо итературирует над свойствами,ее можно поместить в спецификацию,не нарушая обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="1ac1c2bd0aec0e13d9c387f83cc8b463ba74df8f" translate="yes" xml:space="preserve">
          <source>Developer mozilla &amp;gt; Map</source>
          <target state="translated">Разработчик mozilla&amp;gt; Карта</target>
        </trans-unit>
        <trans-unit id="099a01ed9dd31f9684e8375f7034b12c3bb1a630" translate="yes" xml:space="preserve">
          <source>Does JavaScript Guarantee Object Property Order</source>
          <target state="translated">Гарантирует ли JavaScript заказ имущества объекта</target>
        </trans-unit>
        <trans-unit id="cc80c2d78cd6d75a58d4466354ff030d12c0c74d" translate="yes" xml:space="preserve">
          <source>ES2015 compliant engine</source>
          <target state="translated">двигатель ES2015</target>
        </trans-unit>
        <trans-unit id="0acc2d215fca04ea6cc5ff432bfc48e007f86d3f" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot;&gt;JSON standard&lt;/a&gt;:</source>
          <target state="translated">Из &lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot;&gt;стандарта JSON&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2a4e536fd55e0da3c613262b2b50225cf7c78b01" translate="yes" xml:space="preserve">
          <source>Generally, no</source>
          <target state="translated">Вообще-то,нет.</target>
        </trans-unit>
        <trans-unit id="4226982480d45f93dd459e9b1117c39c199447db" translate="yes" xml:space="preserve">
          <source>Here is where you can count on property key order for plain &lt;code&gt;Objects&lt;/code&gt;:</source>
          <target state="translated">Здесь вы можете рассчитывать на порядок ключей свойств для простых &lt;code&gt;Objects&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="52147a0993d04e70a8e544d610fb45da923bbc68" translate="yes" xml:space="preserve">
          <source>However in ES2015 and later non-integer keys will be returned in insertion order.</source>
          <target state="translated">Однако в ES2015 и более поздних версиях ключи без учёта регистра будут возвращены в порядке вставки.</target>
        </trans-unit>
        <trans-unit id="4961c2d8675f28a3fc5ef4a18b41c9201056b692" translate="yes" xml:space="preserve">
          <source>However, in ES2015 in &lt;em&gt;was&lt;/em&gt; specified. Like many things in JavaScript, this was done for compatibility purposes and generally reflected an existing unofficial standard among most JS engines (with you-know-who being an exception).</source>
          <target state="translated">Тем не менее, в ES2015 в &lt;em&gt;был&lt;/em&gt; указан. Как и многие вещи в JavaScript, это было сделано в целях совместимости и, как правило, отражало существующий неофициальный стандарт среди большинства движков JS (за исключением, что вы знаете кто).</target>
        </trans-unit>
        <trans-unit id="b0828e60d703c26f73af1747c4d90e291c0a0d65" translate="yes" xml:space="preserve">
          <source>If I create an object like this:</source>
          <target state="translated">Если я создам такой объект:</target>
        </trans-unit>
        <trans-unit id="faabc3e0f5d76ebc58393833b7e692b3510ba07c" translate="yes" xml:space="preserve">
          <source>If you're interested in ordered maps you should consider using the &lt;code&gt;Map&lt;/code&gt; type introduced in ES2015 instead of plain &lt;code&gt;Objects&lt;/code&gt;.</source>
          <target state="translated">Если вас интересуют упорядоченные карты, вам следует рассмотреть возможность использования типа &lt;code&gt;Map&lt;/code&gt; представленного в ES2015, вместо простых &lt;code&gt;Objects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b627572cf43af1c9edcc2a011b2dbb4addc1a4f5" translate="yes" xml:space="preserve">
          <source>In ES2015, it does, but not to what you might think</source>
          <target state="translated">В ES2015,это так,но не так,как вы могли бы подумать.</target>
        </trans-unit>
        <trans-unit id="c53c091a8a1dc6a4941c3d127b1c3f5926252001" translate="yes" xml:space="preserve">
          <source>In all cases these methods include non-enumerable property keys and order keys as specified by &lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt; (see below). They differ in the type of key values they include (&lt;code&gt;String&lt;/code&gt; and / or &lt;code&gt;Symbol&lt;/code&gt;). In this context &lt;code&gt;String&lt;/code&gt; includes integer values.</source>
          <target state="translated">Во всех случаях эти методы включают не перечисляемые ключи свойств и ключи порядка, как указано в &lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt; (см. Ниже). Они различаются по типу значений ключей, которые они включают ( &lt;code&gt;String&lt;/code&gt; и / или &lt;code&gt;Symbol&lt;/code&gt; ). В этом контексте &lt;code&gt;String&lt;/code&gt; включает целочисленные значения.</target>
        </trans-unit>
        <trans-unit id="a66377df8463c41ca80dbcbc5b839a498d9c49dd" translate="yes" xml:space="preserve">
          <source>In modern browsers you can use the &lt;code&gt;Map&lt;/code&gt; data structure instead of a object.</source>
          <target state="translated">В современных браузерах вы можете использовать структуру данных &lt;code&gt;Map&lt;/code&gt; вместо объекта.</target>
        </trans-unit>
        <trans-unit id="149f5ce9ce098e7b86f9afc0516dad29d57de442" translate="yes" xml:space="preserve">
          <source>Integer keys in ascending order (and strings like &quot;1&quot; that parse as ints)</source>
          <target state="translated">Целочисленные ключи в порядке возрастания (и строки типа &quot;1&quot;,которые разбираются как инсценировки)</target>
        </trans-unit>
        <trans-unit id="ee46467fe2fdf494dcc7270423065b1d077f30f2" translate="yes" xml:space="preserve">
          <source>It's silly to say that the order is unreliable - it is reliable, it's just probably not what you want, and modern browsers implement this order correctly.</source>
          <target state="translated">Глупо говорить,что заказ ненадежен-это надежно,это просто,наверное,не то,что вы хотите,и современные браузеры корректно реализуют этот заказ.</target>
        </trans-unit>
        <trans-unit id="64b5375f0360e9044ba38df47f55f6d563d59252" translate="yes" xml:space="preserve">
          <source>JSON.parse</source>
          <target state="translated">JSON.parse</target>
        </trans-unit>
        <trans-unit id="3898286ce044bc87123989a97e0cdf2ef51669ae" translate="yes" xml:space="preserve">
          <source>JSON.stringify</source>
          <target state="translated">JSON.stringify</target>
        </trans-unit>
        <trans-unit id="b266d7c42c66244150bfc03d76098bb073e86d28" translate="yes" xml:space="preserve">
          <source>Just found this out the hard way.</source>
          <target state="translated">Только что узнал,что это тяжело.</target>
        </trans-unit>
        <trans-unit id="8e16c53d1bbc95155c6ceb4bb722f567d58cc184" translate="yes" xml:space="preserve">
          <source>Just like with the methods which have a guaranteed iteration order (like &lt;code&gt;Reflect.ownKeys&lt;/code&gt; and &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;), the previously-unspecified methods will also iterate in the following order:</source>
          <target state="translated">Как и в случае методов, имеющих гарантированный порядок итераций (например, &lt;code&gt;Reflect.ownKeys&lt;/code&gt; и &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt; ), ранее неуказанные методы также будут выполнять итерацию в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="4dda5a1c505242ff9f21a80d9c0ec24fcd977189" translate="yes" xml:space="preserve">
          <source>Most Browsers iterate object properties as:</source>
          <target state="translated">Большинство браузеров выполняют итерацию свойств объектов как:</target>
        </trans-unit>
        <trans-unit id="eca0d6e5ddb7e8e19c66b315455277ac55d52648" translate="yes" xml:space="preserve">
          <source>Neither the object being iterated nor anything in its prototype chain is a proxy, typed array, module namespace object, or host exotic object.</source>
          <target state="translated">Ни итератируемый объект,ни что-либо в его цепочке прототипов не является прокси-сервером,типизированным массивом,объектом пространства имён модулей или экзотическим объектом хоста.</target>
        </trans-unit>
        <trans-unit id="1d4ab0a6df04c34dd48b584b2a415ab43129c02b" translate="yes" xml:space="preserve">
          <source>Neither the object nor anything in its prototype chain has a property deleted during iteration.</source>
          <target state="translated">Ни объект,ни что-либо в его цепочке прототипов не имеет свойства,удаленного во время итерации.</target>
        </trans-unit>
        <trans-unit id="4dc6577720fdc085f0e42c0d8290ba58b994327e" translate="yes" xml:space="preserve">
          <source>Neither the object nor anything in its prototype chain has its prototype change during iteration.</source>
          <target state="translated">Ни объект,ни что-либо в его цепочке прототипов не меняет свой прототип во время итерации.</target>
        </trans-unit>
        <trans-unit id="0e995b5f9a057b2527e1b6be18d9f747fa5a5ffe" translate="yes" xml:space="preserve">
          <source>No non-enumerable property shadows an enumerable one.</source>
          <target state="translated">Никакое неисчислимое имущество не отбрасывает тени на бесчисленное количество.</target>
        </trans-unit>
        <trans-unit id="d658441f85cb60696e476538b61044fc4858c1a6" translate="yes" xml:space="preserve">
          <source>No property of the object or anything in its prototype chain has its enumerability change during iteration.</source>
          <target state="translated">Ни одно свойство объекта или что-либо в его цепочке прототипов не имеет изменений в пересчёте во время итерации.</target>
        </trans-unit>
        <trans-unit id="89c320a56b18231c4a841ab136d9db9f9cc15237" translate="yes" xml:space="preserve">
          <source>Note that the ES2015 behavior was a good example of the language spec being driven by existing behavior, and not the other way round. To get a deeper sense of that backwards-compatibility mindset, see &lt;a href=&quot;http://code.google.com/p/v8/issues/detail?id=164&quot;&gt;http://code.google.com/p/v8/issues/detail?id=164&lt;/a&gt;, a Chrome bug that covers in detail the design decisions behind Chrome's iteration order behavior.
Per one of the (rather opinionated) comments on that bug report:</source>
          <target state="translated">Обратите внимание, что поведение ES2015 было хорошим примером языковой спецификации, обусловленной существующим поведением, а не наоборот. Чтобы получить более глубокое представление об этом образе мышления с обратной совместимостью, см. &lt;a href=&quot;http://code.google.com/p/v8/issues/detail?id=164&quot;&gt;Http://code.google.com/p/v8/issues/detail?id=164&lt;/a&gt; , ошибку Chrome, которая подробно описывает решения по разработке поведения порядка итерации Chrome , За один из (довольно самоуверенных) комментариев к этому сообщению об ошибке:</target>
        </trans-unit>
        <trans-unit id="a4d61c2f54a1ad70200ca0ee70c2977c4eb1f610" translate="yes" xml:space="preserve">
          <source>Nothing in the object's prototype chain has a property added during iteration.</source>
          <target state="translated">Ничто в цепочке прототипов объекта не имеет свойства,добавленного во время итерации.</target>
        </trans-unit>
        <trans-unit id="0194eee4f03b556be8832cea08ed12de31c2d9b2" translate="yes" xml:space="preserve">
          <source>Numeric array keys, in ascending numeric order</source>
          <target state="translated">Ключи числового массива,в возрастающем числовом порядке</target>
        </trans-unit>
        <trans-unit id="1d51672345557c0f022fd737f9b7489d16b30459" translate="yes" xml:space="preserve">
          <source>Object.assign</source>
          <target state="translated">Object.assign</target>
        </trans-unit>
        <trans-unit id="792a27c424ad52e5a9356f3722643e927041e20f" translate="yes" xml:space="preserve">
          <source>Object.defineProperties</source>
          <target state="translated">Object.defineProperties</target>
        </trans-unit>
        <trans-unit id="a37c98a6f5f7ca5863f83538b43a1b90ce0f8d42" translate="yes" xml:space="preserve">
          <source>Object.getOwnPropertyNames</source>
          <target state="translated">Object.getOwnPropertyNames</target>
        </trans-unit>
        <trans-unit id="1061044277b2b1b91a3ad9fd72b96a926df8e0ad" translate="yes" xml:space="preserve">
          <source>Object.getOwnPropertySymbols</source>
          <target state="translated">Object.getOwnPropertySymbols</target>
        </trans-unit>
        <trans-unit id="c5a933e00dc39b7be5f3039f9caf7a7ff8b476c8" translate="yes" xml:space="preserve">
          <source>Object.keys</source>
          <target state="translated">Object.keys</target>
        </trans-unit>
        <trans-unit id="9766dcc2678dca29aca27b7034272c421f110e70" translate="yes" xml:space="preserve">
          <source>Own properties</source>
          <target state="translated">Собственные свойства</target>
        </trans-unit>
        <trans-unit id="2ea9d512846684027cf3f09daee60e1b4fb1823d" translate="yes" xml:space="preserve">
          <source>Property order in normal Objects is a complex subject in Javascript.</source>
          <target state="translated">Порядок собственности в обычных Объектах является сложным предметом в Javascript.</target>
        </trans-unit>
        <trans-unit id="0efb52a164d2557eb51e9d57bef3b03f3cfa6ce2" translate="yes" xml:space="preserve">
          <source>Reflect.ownKeys</source>
          <target state="translated">Reflect.ownKeys</target>
        </trans-unit>
        <trans-unit id="8c7c6e0edbbe7036c351801472457895f35b7ca5" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;String&lt;/code&gt;- and &lt;code&gt;Symbol&lt;/code&gt;-keyed properties.</source>
          <target state="translated">Возвращает собственные &lt;code&gt;String&lt;/code&gt; и символьные свойства.</target>
        </trans-unit>
        <trans-unit id="073ddc07bb314332dd4af4685c8be8359a5e671a" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;String&lt;/code&gt;-keyed properties (&lt;em&gt;property names&lt;/em&gt;).</source>
          <target state="translated">Возвращает собственные &lt;code&gt;String&lt;/code&gt; свойства ключа ( &lt;em&gt;имена свойств&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="cec74648d029ac27ae652baf8d58c1a15e7cb459" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;Symbol&lt;/code&gt;-keyed properties.</source>
          <target state="translated">Возвращает собственные свойства &lt;code&gt;Symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77f8e27f1eed61991843e7511c8740205287dc40" translate="yes" xml:space="preserve">
          <source>So, no you can't guarantee the order.</source>
          <target state="translated">Так что нет,вы не можете гарантировать заказ.</target>
        </trans-unit>
        <trans-unit id="9127c30b90d11e6061555ee1cae2d848f30da10c" translate="yes" xml:space="preserve">
          <source>Some exceptions include methods of enumerating inherited keys, such as the &lt;code&gt;for .. in&lt;/code&gt; loop. The &lt;code&gt;for .. in&lt;/code&gt; loop doesn't guarantee order according to the specification.</source>
          <target state="translated">Некоторые исключения включают методы перечисления унаследованных ключей, такие как цикл &lt;code&gt;for .. in&lt;/code&gt; . Цикл &lt;code&gt;for .. in&lt;/code&gt; не гарантирует порядок в соответствии со спецификацией.</target>
        </trans-unit>
        <trans-unit id="aeb78bd417a7768c123cd38651d774129e3176fc" translate="yes" xml:space="preserve">
          <source>Some older browsers combine categories #1 and #2, iterating all keys in insertion order. If your keys might parse as integers, it's best not to rely on any specific iteration order.</source>
          <target state="translated">Некоторые старые браузеры совмещают категории #1 и #2,итерация всех ключей в порядке их вставки.Если ваши ключи могут быть разобраны как целые числа,то лучше не полагаться на какой-либо конкретный порядок итераций.</target>
        </trans-unit>
        <trans-unit id="bedb8cd8e036c17b94b5d6c22f537e6cd438946f" translate="yes" xml:space="preserve">
          <source>Sometimes, yes</source>
          <target state="translated">Иногда,да.</target>
        </trans-unit>
        <trans-unit id="03696b013ec729f79ff55615110524b6d377d9c3" translate="yes" xml:space="preserve">
          <source>Standards always follow implementations, that's where XHR came from, and Google does the same thing by implementing Gears and then embracing equivalent HTML5 functionality.  The right fix is to have ECMA formally incorporate the de-facto standard behavior into the next rev of the spec.</source>
          <target state="translated">Стандарты всегда следуют за реализацией,откуда взялся XHR,и Google делает то же самое,реализуя Gears,а затем охватывая эквивалентную функциональность HTML5.Правильным исправлением является формальное включение ECMA де-факто стандартного поведения в следующую редакцию спецификации.</target>
        </trans-unit>
        <trans-unit id="df387116de084996fa33cc5b4ccad3778e284d52" translate="yes" xml:space="preserve">
          <source>String keys, in insertion order (ES2015 guarantees this and all browsers comply)</source>
          <target state="translated">Клавиши строк,в порядке вставки (ES2015 гарантирует это,и все браузеры соответствуют этому)</target>
        </trans-unit>
        <trans-unit id="369d7c7a7aad2cd01d5e02f587face2623161f7f" translate="yes" xml:space="preserve">
          <source>Symbol keys, in insertion order</source>
          <target state="translated">Символьные клавиши,в порядке ввода</target>
        </trans-unit>
        <trans-unit id="8454bd456035f63689f1f7538dbb3e71c5e28c85" translate="yes" xml:space="preserve">
          <source>Symbol names, in insertion order (ES2015 guarantees this and all browsers comply)</source>
          <target state="translated">Названия символов,в порядке их вставки (ES2015 гарантирует это,и все браузеры соответствуют этому).</target>
        </trans-unit>
        <trans-unit id="a9ff19a745e63e404d88d621888c4ff8971c082e" translate="yes" xml:space="preserve">
          <source>Symbols in insertion order</source>
          <target state="translated">Символы в порядке их вставки</target>
        </trans-unit>
        <trans-unit id="3b2092c1a98be999603f3c961d4be7889be676c3" translate="yes" xml:space="preserve">
          <source>That is, will the properties be in the same order that I added them?</source>
          <target state="translated">То есть,будут ли свойства в том же порядке,в котором я их добавил?</target>
        </trans-unit>
        <trans-unit id="4d2de9daf855204938fd9e3b04c0ed0d327682b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMAScript specification&lt;/a&gt; used to say:</source>
          <target state="translated">Спецификация &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMAScript&lt;/a&gt; используется, чтобы сказать:</target>
        </trans-unit>
        <trans-unit id="29fa3e4243bed714bd28cdcc5a439b305d27dff3" translate="yes" xml:space="preserve">
          <source>The actual question is very vague.</source>
          <target state="translated">На самом деле вопрос очень расплывчатый.</target>
        </trans-unit>
        <trans-unit id="d9bb6366ecce97d1a3154d5144e1244355d132c5" translate="yes" xml:space="preserve">
          <source>The answer is: it depends on a number of factors. In general, &lt;em&gt;no&lt;/em&gt;.</source>
          <target state="translated">Ответ: это зависит от ряда факторов. В общем &lt;em&gt;нет&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3112a8a32dbd36dfe4b46a1d1df283f2bffaf5" translate="yes" xml:space="preserve">
          <source>The following methods guarantee the order shown:</source>
          <target state="translated">Следующие методы гарантируют показанный заказ:</target>
        </trans-unit>
        <trans-unit id="b8bb19c6e5330bcaa59b97be556c1675a287f34b" translate="yes" xml:space="preserve">
          <source>The following methods/loops guarantee no order at all:</source>
          <target state="translated">Следующие методические петли гарантируют отсутствие заказа:</target>
        </trans-unit>
        <trans-unit id="dbdc2d4c67254f98b99f13c6b0dc25f2e511fb83" translate="yes" xml:space="preserve">
          <source>The iteration order for objects follows &lt;a href=&quot;https://stackoverflow.com/a/38218582/292500&quot;&gt;a certain set of rules&lt;/a&gt; since ES2015, but &lt;strong&gt;it does not (always) follow the insertion order&lt;/strong&gt;. Simply put, the iteration order is a combination of the insertion order for strings keys, and ascending order for number-like keys:</source>
          <target state="translated">Порядок итерации для объектов следует &lt;a href=&quot;https://stackoverflow.com/a/38218582/292500&quot;&gt;определенному набору правил,&lt;/a&gt; начиная с ES2015, но &lt;strong&gt;он не всегда следует за порядком вставки&lt;/strong&gt; . Проще говоря, порядок итераций представляет собой комбинацию порядка вставки для строковых ключей и возрастающего порядка для числовых ключей:</target>
        </trans-unit>
        <trans-unit id="b4a4e6f068dfc6cd8381634fb9999b8edbd5d5cc" translate="yes" xml:space="preserve">
          <source>The keys in Map are ordered while keys added to object are not. Thus, when iterating over it, a Map object returns keys in order of insertion. (Note that in the ECMAScript 2015 spec objects do preserve creation order for string and Symbol keys, so traversal of an object with ie only string keys would yield keys in order of insertion)</source>
          <target state="translated">Клавиши на карте упорядочены,а клавиши,добавляемые к объекту,нет.Таким образом,при итерации по нему объект Map возвращает ключи в порядке их вставки.(Обратите внимание,что в ECMAScript 2015 spec объекты сохраняют порядок создания для строковых и символьных ключей,поэтому обход объекта со строковыми ключами даст ключи в порядке их вставки).</target>
        </trans-unit>
        <trans-unit id="ed7cecaff2b2b865d7552ddaf655c499e0ab0a33" translate="yes" xml:space="preserve">
          <source>The lack of specificity in ECMA-262 does not reflect reality. In discussion going back years, implementors have observed that there are some constraints on the behavior of for-in which anyone who wants to run code on the web needs to follow.</source>
          <target state="translated">Отсутствие специфичности в ECMA-262 не отражает реальность.В ходе обсуждения,ведущегося уже много лет назад,разработчики заметили,что существуют некоторые ограничения в поведении,которым должен следовать каждый,кто хочет запускать код в сети.</target>
        </trans-unit>
        <trans-unit id="99cdafe7bfb6d937df7209d8848443a7e20e02fd" translate="yes" xml:space="preserve">
          <source>The mechanics and order of enumerating the properties ... is not specified.</source>
          <target state="translated">Механика и порядок перечисления свойств ...не уточняется.</target>
        </trans-unit>
        <trans-unit id="111c3077a9bab7d0eb66f628b1f52704d6558d5c" translate="yes" xml:space="preserve">
          <source>The order is defined in the spec, under the abstract operation &lt;a href=&quot;https://www.ecma-international.org/ecma-262/9.0/index.html#sec-ordinaryownpropertykeys&quot;&gt;OrdinaryOwnPropertyKeys&lt;/a&gt;, which underpins all methods of iterating over an object's own keys. Paraphrased, the order is as follows:</source>
          <target state="translated">Порядок определяется в спецификации в рамках абстрактной операции &lt;a href=&quot;https://www.ecma-international.org/ecma-262/9.0/index.html#sec-ordinaryownpropertykeys&quot;&gt;OrdinaryOwnPropertyKeys&lt;/a&gt; , которая лежит в основе всех методов итерации по собственным ключам объекта. Перефразируя, порядок выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="10e68ba3d24da3f1a6c55e57fc43a01f2310bb93" translate="yes" xml:space="preserve">
          <source>The order is essentially: integer-like &lt;code&gt;Strings&lt;/code&gt; in ascending order, non-integer-like &lt;code&gt;Strings&lt;/code&gt; in creation order, Symbols in creation order. Depending which function invokes this, some of these types may not be included.</source>
          <target state="translated">По сути, порядок: целочисленные &lt;code&gt;Strings&lt;/code&gt; в порядке возрастания, нецелочисленные &lt;code&gt;Strings&lt;/code&gt; в порядке создания, символы в порядке создания. В зависимости от того, какая функция вызывает это, некоторые из этих типов могут быть не включены.</target>
        </trans-unit>
        <trans-unit id="b3287cf2d6f8c1f23bb792abaeefb0a8c1cbeba7" translate="yes" xml:space="preserve">
          <source>The order of keys in an object wasn't guaranteed until ES2015. It was implementation-defined.</source>
          <target state="translated">Порядок ключей на объекте не гарантировался до ES2015.Он был имплементационно-определен.</target>
        </trans-unit>
        <trans-unit id="cc78fa8b6dadd0f1f48d48f9402a99419d560fbd" translate="yes" xml:space="preserve">
          <source>The question is, for what methods this order is guaranteed in the ES2015 spec?</source>
          <target state="translated">Вопрос в том,для каких методов гарантирован этот порядок в спецификации ES2015?</target>
        </trans-unit>
        <trans-unit id="a5b1e52a5ac36573960704b3789b1a8d268ccf5a" translate="yes" xml:space="preserve">
          <source>The specific language is that keys are returned in the following order:</source>
          <target state="translated">Конкретный язык заключается в том,что клавиши возвращаются в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="0dce972e73d0a4fac0a155ed2f727b3110d2cad9" translate="yes" xml:space="preserve">
          <source>There are a few weird cases which implementations currently do &lt;em&gt;not&lt;/em&gt; agree on, and in such cases, the resulting order will continue be unspecified. For property order &lt;a href=&quot;https://github.com/tc39/proposal-for-in-order#a-conservative-underapproximation-of-interop-semantics&quot;&gt;to be guaranteed&lt;/a&gt;:</source>
          <target state="translated">Есть несколько странных случаев, с которыми реализации в настоящее время &lt;em&gt;не&lt;/em&gt; согласуются, и в таких случаях результирующий порядок будет по-прежнему не определен. Для &lt;a href=&quot;https://github.com/tc39/proposal-for-in-order#a-conservative-underapproximation-of-interop-semantics&quot;&gt;гарантированного&lt;/a&gt; заказа недвижимости:</target>
        </trans-unit>
        <trans-unit id="55b19b14da72f8c7f30f65d3c0821fb28bb19664" translate="yes" xml:space="preserve">
          <source>This is what pretty much every implementation does already, but the new proposal will make it official.</source>
          <target state="translated">Это то,что уже делает практически каждая реализация,но новое предложение сделает его официальным.</target>
        </trans-unit>
        <trans-unit id="49f03181403db0a6631b9c892e5eb9016ddb9775" translate="yes" xml:space="preserve">
          <source>This results in the following order (in certain cases):</source>
          <target state="translated">Это приводит к следующему порядку (в некоторых случаях):</target>
        </trans-unit>
        <trans-unit id="2a2d2ebbf23e9e14a50e49a2ebb2718a4d31e0ae" translate="yes" xml:space="preserve">
          <source>This way you can use a regular for loop and have the insert order. You could then use the Array sort method to sort this into a new array if needed.</source>
          <target state="translated">Таким образом,вы можете использовать обычный для петли и иметь порядок вставки.Затем,при необходимости,можно использовать метод сортировки по массиву для сортировки по новому массиву.</target>
        </trans-unit>
        <trans-unit id="db70c450e37560ad700c843433664c3f72d27c97" translate="yes" xml:space="preserve">
          <source>This whole answer is in the context of spec compliance, not what any engine does at a particular moment or historically.</source>
          <target state="translated">Весь этот ответ находится в контексте соответствия спецификации,а не того,что делает любой двигатель в определенный момент или исторически.</target>
        </trans-unit>
        <trans-unit id="36e7408731ad7eda18219f4f3ecf847b4d50bd86" translate="yes" xml:space="preserve">
          <source>Thus, in order to take &lt;code&gt;Object.keys(valueFromStore)&lt;/code&gt; I used &lt;code&gt;Object.keys(valueFromStore).sort()&lt;/code&gt;, so that I at least now have an alphabetical order for the keys.</source>
          <target state="translated">Таким образом, чтобы взять &lt;code&gt;Object.keys(valueFromStore)&lt;/code&gt; я использовал &lt;code&gt;Object.keys(valueFromStore).sort()&lt;/code&gt; , так что теперь у меня по крайней мере теперь есть алфавитный порядок для ключей.</target>
        </trans-unit>
        <trans-unit id="6c15ca0416904aeea36408d198c5a736ea187af3" translate="yes" xml:space="preserve">
          <source>Thus, there are three segments, which may alter the insertion order (as happened in the example). And integer-like keys don't stick to the insertion order at all.</source>
          <target state="translated">Таким образом,существует три сегмента,которые могут изменить порядок вставки (как это произошло в примере).А целочисленные клавиши вообще не придерживаются порядка вставки.</target>
        </trans-unit>
        <trans-unit id="42f21f6edccf6b7e965aa6753e10344cefc870e1" translate="yes" xml:space="preserve">
          <source>Using React with Redux, the state container of which's keys I want to traverse in order to generate children is refreshed everytime the store is changed (as per Redux's immutability concepts).</source>
          <target state="translated">При использовании React with Redux,контейнер состояний,по которым я хочу пройти,чтобы сгенерировать детей,обновляется каждый раз при изменении магазина (в соответствии с концепцией неизменности Redux).</target>
        </trans-unit>
        <trans-unit id="158b0728eeda2f2e43e242eab00a657882339035" translate="yes" xml:space="preserve">
          <source>Using an array or a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;&lt;code&gt;Map&lt;/code&gt; object&lt;/a&gt; can be a better way to achieve this. &lt;code&gt;Map&lt;/code&gt; shares some similarities with &lt;code&gt;Object&lt;/code&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_and_maps_compared&quot;&gt;guarantees the keys to be iterated in order of insertion&lt;/a&gt;, without exception:</source>
          <target state="translated">Использование массива или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;объекта &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; может быть лучшим способом для достижения этой цели. &lt;code&gt;Map&lt;/code&gt; имеет некоторые сходства с &lt;code&gt;Object&lt;/code&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_and_maps_compared&quot;&gt;гарантирует, что ключи будут повторяться в порядке вставки&lt;/a&gt; без исключения:</target>
        </trans-unit>
        <trans-unit id="717e9d7bd21b2bf25179048c23b8139ebca1d0df" translate="yes" xml:space="preserve">
          <source>While in ES5 explicitly no order has been specified, ES2015 has an order in certain cases. Given is the following object:</source>
          <target state="translated">Если в ES5 явно не указано ни одного заказа,то в ES2015 в определенных случаях есть заказ.Приводится следующий объект:</target>
        </trans-unit>
        <trans-unit id="2c4f5a24bafe473e423771440ba63f17544d239e" translate="yes" xml:space="preserve">
          <source>Will the resulting object &lt;em&gt;always&lt;/em&gt; look like this?</source>
          <target state="translated">Будет ли результирующий объект &lt;em&gt;всегда&lt;/em&gt; выглядеть так?</target>
        </trans-unit>
        <trans-unit id="64e3dd86e22797f5de12c4dcc57dae70834e7300" translate="yes" xml:space="preserve">
          <source>for..in</source>
          <target state="translated">for..in</target>
        </trans-unit>
        <trans-unit id="139528a85e8b998035ad6a5c85b4e51ace8b55c2" translate="yes" xml:space="preserve">
          <source>integer-like keys in ascending order</source>
          <target state="translated">целочисленные клавиши в порядке возрастания</target>
        </trans-unit>
        <trans-unit id="4412ac0ae820171fd5f4fb0263ad6679aaf6cf9c" translate="yes" xml:space="preserve">
          <source>normal keys in insertion order</source>
          <target state="translated">нормальные ключи в порядке ввода</target>
        </trans-unit>
        <trans-unit id="41d84f4f169439986c15f630c7f2198df104449c" translate="yes" xml:space="preserve">
          <source>will the properties be in the same order that I added them</source>
          <target state="translated">будут ли свойства в том же порядке,в котором я их добавил.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
