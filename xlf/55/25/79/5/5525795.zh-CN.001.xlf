<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/5525795">
    <body>
      <group id="5525795">
        <trans-unit id="da3687cfe7631d821ba35f4e012caced3b66cd22" translate="yes" xml:space="preserve">
          <source>(emphasis mine).</source>
          <target state="translated">(强调是我的)。</target>
        </trans-unit>
        <trans-unit id="506a92cc597c8229d7c4a2bed4f4e9b88c6d9d1b" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; [the object being iterated] that is an integer index, in ascending numeric index order</source>
          <target state="translated">... &lt;code&gt;O&lt;/code&gt; 的每个自己的属性键 &lt;code&gt;P&lt;/code&gt; [要迭代的对象]，它是按整数索引顺序升序的整数索引</target>
        </trans-unit>
        <trans-unit id="b1431eb62a77c3957a1a90ad8c2ee19b35d73184" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; that is a String but is not an integer index, in property creation order</source>
          <target state="translated">...每个 &lt;code&gt;O&lt;/code&gt; 的属性键 &lt;code&gt;P&lt;/code&gt; （按字符串创建，但不是整数索引），按属性创建顺序</target>
        </trans-unit>
        <trans-unit id="41f72be3edc7209f752acd3f28c3b1078665a04e" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; that is a Symbol, in property creation order</source>
          <target state="translated">...按照属性创建顺序，每个属于符号的 &lt;code&gt;O&lt;/code&gt; 的属性键 &lt;code&gt;P&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="617676d9406eee86e16ed250ff2bd786d055b06f" translate="yes" xml:space="preserve">
          <source>4.3.3 Object</source>
          <target state="translated">4.3.3 对象</target>
        </trans-unit>
        <trans-unit id="629e86072909febc69cff039b31e251bfb5bcef7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;, &lt;code&gt;Reflect.ownKeys()&lt;/code&gt;, &lt;code&gt;Object.getOwnPropertySymbols(O)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt; ， &lt;code&gt;Reflect.ownKeys()&lt;/code&gt; ， &lt;code&gt;Object.getOwnPropertySymbols(O)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="906437decdad0d2084e279baa2e2d923b430539c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.keys&lt;/code&gt;, &lt;code&gt;Object.values&lt;/code&gt;, &lt;code&gt;Object.entries&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.keys&lt;/code&gt; ， &lt;code&gt;Object.values&lt;/code&gt; ， &lt;code&gt;Object.entries&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac72976f1fd79543ad7172b5c48fa8ec5cc520a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..in&lt;/code&gt; loops</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; 循环</target>
        </trans-unit>
        <trans-unit id="3f7356ed9c8dad2efb0205e5f9f24151517669d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In what context?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;在什么情况下？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d30fe30d4258ac32279a10fad11a23661e24d1fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But, soon (probably in ES2020), property order for these previously untrustworthy methods &lt;em&gt;will&lt;/em&gt; be guaranteed by the specification&lt;/strong&gt; to be iterated over in the same deterministic manner as the others, due to to the &lt;a href=&quot;https://github.com/tc39/proposals/blob/master/finished-proposals.md&quot;&gt;stage 4&lt;/a&gt; proposal: &lt;a href=&quot;http://tc39.es/proposal-for-in-order/&quot;&gt;For-in enumeration order&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;但是，&lt;/strong&gt;由于&lt;a href=&quot;https://github.com/tc39/proposals/blob/master/finished-proposals.md&quot;&gt;第4阶段的&lt;/a&gt;提议： &lt;a href=&quot;http://tc39.es/proposal-for-in-order/&quot;&gt;按枚举顺序&lt;/a&gt; &lt;strong&gt;，不久（可能在ES2020中），规范&lt;em&gt;将&lt;/em&gt;保证这些以前不可信方法的属性顺序&lt;/strong&gt;以与其他方法相同的确定性方式进行迭代。</target>
        </trans-unit>
        <trans-unit id="43cf735af1addba43cf6135a9e6cd5fd77f69b83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusion: Even in ES2015 you shouldn't rely on the property order of normal objects in Javascript. It is prone to errors. Use &lt;code&gt;Map&lt;/code&gt; instead.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;结论：即使在ES2015中，您也不应依赖Javascript中普通对象的属性顺序。&lt;/strong&gt; &lt;strong&gt;容易出错。&lt;/strong&gt; &lt;strong&gt;请改用 &lt;code&gt;Map&lt;/code&gt; 。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be9ffe71c53127990a370c8d47eb77ce87f4c69b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Current Language Spec (since ES2015)&lt;/strong&gt; insertion order is preserved, except in the case of keys that parse as integers (eg &quot;7&quot; or &quot;99&quot;), where behavior varies between browsers. For example, Chrome/V8 does not respect insertion order when the keys are parse as numeric.</source>
          <target state="translated">保留&lt;strong&gt;当前语言规范（自ES2015起）的&lt;/strong&gt;插入顺序，但键解析为整数（例如&amp;ldquo; 7&amp;rdquo;或&amp;ldquo; 99&amp;rdquo;）的情况除外，在这种情况下浏览器的行为会有所不同。 例如，当键解析为数字时，Chrome / V8不遵守插入顺序。</target>
        </trans-unit>
        <trans-unit id="8c848754eb60df7eadf93fb71befdc94139eef6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Old Language Spec (before ES2015)&lt;/strong&gt;: Iteration order was technically undefined, but all major browsers complied with the ES2015 behavior.</source>
          <target state="translated">&lt;strong&gt;旧语言规范（ES2015之前）&lt;/strong&gt; ：迭代顺序在技术上未定义，但所有主流浏览器均符合ES2015行为。</target>
        </trans-unit>
        <trans-unit id="a5cabd9db5130fe850fc14a9f035d862d77edcae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;YES (for non-integer keys).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;是（用于非整数键）。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ddc2dc2dbcd4516457a87d0f7f30c97209aab02" translate="yes" xml:space="preserve">
          <source>A Map object can iterate its elements in insertion order...</source>
          <target state="translated">一个Map对象可以按插入顺序迭代其元素.....</target>
        </trans-unit>
        <trans-unit id="8272a49555285dae357452d8b3518864897ab434" translate="yes" xml:space="preserve">
          <source>All &lt;em&gt;integer index&lt;/em&gt; keys (stuff like &lt;code&gt;&quot;1123&quot;&lt;/code&gt;, &lt;code&gt;&quot;55&quot;&lt;/code&gt;, etc) in ascending numeric order.</source>
          <target state="translated">所有&lt;em&gt;整数索引&lt;/em&gt;键（诸如 &lt;code&gt;&quot;1123&quot;&lt;/code&gt; ， &lt;code&gt;&quot;55&quot;&lt;/code&gt; 等之类的数字）以升序排列。</target>
        </trans-unit>
        <trans-unit id="6d0d086e05c3f95500e0ef71cccca3dcbbf3ee81" translate="yes" xml:space="preserve">
          <source>All other non-Symbol keys, in insertion order</source>
          <target state="translated">所有其他非符号键,按插入顺序排列。</target>
        </trans-unit>
        <trans-unit id="6931239bebc33c69fddecf7cf1a400bef63e3d2e" translate="yes" xml:space="preserve">
          <source>All string keys which are not integer indices, in order of creation (oldest-first).</source>
          <target state="translated">所有非整数索引的字符串键,按创建顺序(最老的优先)。</target>
        </trans-unit>
        <trans-unit id="9cc7882625e1fa1848c2d4d2d56f6e182d7ff836" translate="yes" xml:space="preserve">
          <source>All symbol keys, in order of creation (oldest-first).</source>
          <target state="translated">所有的符号键,按创造的顺序(先老先衰)。</target>
        </trans-unit>
        <trans-unit id="d99ee358a61be9c08f8e3663248de7c6ea7386a1" translate="yes" xml:space="preserve">
          <source>Although the current specification leaves for..in iteration order &quot;&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-enumerate-object-properties&quot;&gt;almost totally unspecified&lt;/a&gt;, real engines tend to be more consistent:&quot;</source>
          <target state="translated">尽管当前规范以迭代顺序&amp;ldquo; &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-enumerate-object-properties&quot;&gt;几乎完全未指定&lt;/a&gt; ，但实际引擎趋向于更加一致：&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="9f541eac51b245397dfc1dd505657af7d28c26b2" translate="yes" xml:space="preserve">
          <source>An object is a member of the
  type Object. &lt;strong&gt;It is an unordered collection of properties&lt;/strong&gt; each of which
  contains a primitive value, object, or
  function. A function stored in a
  property of an object is called a
  method.</source>
          <target state="translated">对象是对象类型的成员。 &lt;strong&gt;它是属性的无序集合，&lt;/strong&gt;每个&lt;strong&gt;属性&lt;/strong&gt;都包含原始值，对象或函数。 存储在对象属性中的函数称为方法。</target>
        </trans-unit>
        <trans-unit id="3f1e99d603dc8c534f17c37e7680125db1255ec4" translate="yes" xml:space="preserve">
          <source>An object is an &lt;strong&gt;unordered&lt;/strong&gt; collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array.</source>
          <target state="translated">对象是零个或多个名称/值对的&lt;strong&gt;无序&lt;/strong&gt;集合，其中名称是字符串，值是字符串，数字，布尔值，null，对象或数组。</target>
        </trans-unit>
        <trans-unit id="0ce441a742a81f4f9ec981fd12c2ec069bde986b" translate="yes" xml:space="preserve">
          <source>As a note, properties order in objects weren&amp;rsquo;t guaranteed at all before ES2015. Definition of an Object from &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf&quot;&gt;ECMAScript Third Edition (pdf)&lt;/a&gt;:</source>
          <target state="translated">请注意，在ES2015之前根本无法保证对象中的属性顺序。 &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf&quot;&gt;ECMAScript第三版（pdf）中&lt;/a&gt;对象的定义：</target>
        </trans-unit>
        <trans-unit id="89359f1939ff8169993255536817a0eeb023f70f" translate="yes" xml:space="preserve">
          <source>As of ES2015, property order is guaranteed for certain methods that iterate over properties. &lt;a href=&quot;https://stackoverflow.com/a/30919039/&quot;&gt;but not others&lt;/a&gt;. Unfortunately, the methods which are not guaranteed to have an order are generally the most often used:</source>
          <target state="translated">从ES2015开始，某些迭代属性的方法将保证属性顺序。 &lt;a href=&quot;https://stackoverflow.com/a/30919039/&quot;&gt;但是没有其他人&lt;/a&gt; 。 不幸的是，不能保证有顺序的方法通常是最常用的：</target>
        </trans-unit>
        <trans-unit id="f0701b9ee5dc8738764e68bb472acd3938023043" translate="yes" xml:space="preserve">
          <source>As others have stated, you have no guarantee as to the order when you iterate over the properties of an object. If you need an ordered list of multiple fields I suggested creating an array of objects.</source>
          <target state="translated">正如其他人所言,当你迭代一个对象的属性时,你无法保证顺序。如果你需要多个字段的有序列表,我建议创建一个对象的数组。</target>
        </trans-unit>
        <trans-unit id="4444585e7d19b4c0af133a98d6096e8c852f3f8b" translate="yes" xml:space="preserve">
          <source>At the time of writing, most browsers did return properties in the same order as they were inserted, but it was explicitly not guaranteed behaviour so shouldn't have been relied upon.</source>
          <target state="translated">在写这篇文章的时候,大多数浏览器确实是按照插入的顺序返回属性,但这并不是明文规定的行为,所以不应该被依赖。</target>
        </trans-unit>
        <trans-unit id="98f97678eae35879cc93487177bce8991d7bde31" translate="yes" xml:space="preserve">
          <source>Because every implementation already iterates over properties predictably, it can be put into the specification without breaking backwards compatibility.</source>
          <target state="translated">因为每个实现都已经对属性进行了可预测的迭代,所以可以在不破坏向后兼容性的情况下,将其放入规范中。</target>
        </trans-unit>
        <trans-unit id="1ac1c2bd0aec0e13d9c387f83cc8b463ba74df8f" translate="yes" xml:space="preserve">
          <source>Developer mozilla &amp;gt; Map</source>
          <target state="translated">开发人员mozilla&amp;gt;地图</target>
        </trans-unit>
        <trans-unit id="099a01ed9dd31f9684e8375f7034b12c3bb1a630" translate="yes" xml:space="preserve">
          <source>Does JavaScript Guarantee Object Property Order</source>
          <target state="translated">JavaScript是否保证对象属性顺序</target>
        </trans-unit>
        <trans-unit id="cc80c2d78cd6d75a58d4466354ff030d12c0c74d" translate="yes" xml:space="preserve">
          <source>ES2015 compliant engine</source>
          <target state="translated">符合ES2015标准的发动机</target>
        </trans-unit>
        <trans-unit id="0acc2d215fca04ea6cc5ff432bfc48e007f86d3f" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot;&gt;JSON standard&lt;/a&gt;:</source>
          <target state="translated">根据&lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot;&gt;JSON标准&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="2a4e536fd55e0da3c613262b2b50225cf7c78b01" translate="yes" xml:space="preserve">
          <source>Generally, no</source>
          <target state="translated">一般来说,没有</target>
        </trans-unit>
        <trans-unit id="4226982480d45f93dd459e9b1117c39c199447db" translate="yes" xml:space="preserve">
          <source>Here is where you can count on property key order for plain &lt;code&gt;Objects&lt;/code&gt;:</source>
          <target state="translated">在这里，您可以指望普通 &lt;code&gt;Objects&lt;/code&gt; 属性键顺序：</target>
        </trans-unit>
        <trans-unit id="52147a0993d04e70a8e544d610fb45da923bbc68" translate="yes" xml:space="preserve">
          <source>However in ES2015 and later non-integer keys will be returned in insertion order.</source>
          <target state="translated">但在ES2015及以后的ES2015中,非整数键将按插入顺序返回。</target>
        </trans-unit>
        <trans-unit id="4961c2d8675f28a3fc5ef4a18b41c9201056b692" translate="yes" xml:space="preserve">
          <source>However, in ES2015 in &lt;em&gt;was&lt;/em&gt; specified. Like many things in JavaScript, this was done for compatibility purposes and generally reflected an existing unofficial standard among most JS engines (with you-know-who being an exception).</source>
          <target state="translated">但是，在ES2015中&lt;em&gt;已&lt;/em&gt;指定。 像JavaScript中的许多事情一样，这样做是出于兼容性目的，并且通常反映了大多数JS引擎中的现有非官方标准（您知道-谁是例外）。</target>
        </trans-unit>
        <trans-unit id="b0828e60d703c26f73af1747c4d90e291c0a0d65" translate="yes" xml:space="preserve">
          <source>If I create an object like this:</source>
          <target state="translated">如果我创建一个像这样的对象。</target>
        </trans-unit>
        <trans-unit id="faabc3e0f5d76ebc58393833b7e692b3510ba07c" translate="yes" xml:space="preserve">
          <source>If you're interested in ordered maps you should consider using the &lt;code&gt;Map&lt;/code&gt; type introduced in ES2015 instead of plain &lt;code&gt;Objects&lt;/code&gt;.</source>
          <target state="translated">如果您对有序地图感兴趣，则应考虑使用ES2015中引入的 &lt;code&gt;Map&lt;/code&gt; 类型，而不是普通的 &lt;code&gt;Objects&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b627572cf43af1c9edcc2a011b2dbb4addc1a4f5" translate="yes" xml:space="preserve">
          <source>In ES2015, it does, but not to what you might think</source>
          <target state="translated">在ES2015中,它做到了,但不是你所想的那样</target>
        </trans-unit>
        <trans-unit id="c53c091a8a1dc6a4941c3d127b1c3f5926252001" translate="yes" xml:space="preserve">
          <source>In all cases these methods include non-enumerable property keys and order keys as specified by &lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt; (see below). They differ in the type of key values they include (&lt;code&gt;String&lt;/code&gt; and / or &lt;code&gt;Symbol&lt;/code&gt;). In this context &lt;code&gt;String&lt;/code&gt; includes integer values.</source>
          <target state="translated">在所有情况下，这些方法都包含不可枚举的属性键和 &lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt; 指定的命令键（请参见下文）。 它们包括的键值类型不同（ &lt;code&gt;String&lt;/code&gt; 和/或 &lt;code&gt;Symbol&lt;/code&gt; ）。 在这种情况下， &lt;code&gt;String&lt;/code&gt; 包括整数值。</target>
        </trans-unit>
        <trans-unit id="a66377df8463c41ca80dbcbc5b839a498d9c49dd" translate="yes" xml:space="preserve">
          <source>In modern browsers you can use the &lt;code&gt;Map&lt;/code&gt; data structure instead of a object.</source>
          <target state="translated">在现代浏览器中，您可以使用 &lt;code&gt;Map&lt;/code&gt; 数据结构代替对象。</target>
        </trans-unit>
        <trans-unit id="149f5ce9ce098e7b86f9afc0516dad29d57de442" translate="yes" xml:space="preserve">
          <source>Integer keys in ascending order (and strings like &quot;1&quot; that parse as ints)</source>
          <target state="translated">按升序排列的整数键(以及像 &quot;1 &quot;这样的字符串,可以解析为ints)。</target>
        </trans-unit>
        <trans-unit id="ee46467fe2fdf494dcc7270423065b1d077f30f2" translate="yes" xml:space="preserve">
          <source>It's silly to say that the order is unreliable - it is reliable, it's just probably not what you want, and modern browsers implement this order correctly.</source>
          <target state="translated">说这个顺序不可靠是很傻的--它是可靠的,只是很可能不是你想要的,现代的浏览器正确地实现了这个顺序。</target>
        </trans-unit>
        <trans-unit id="64b5375f0360e9044ba38df47f55f6d563d59252" translate="yes" xml:space="preserve">
          <source>JSON.parse</source>
          <target state="translated">JSON.parse</target>
        </trans-unit>
        <trans-unit id="3898286ce044bc87123989a97e0cdf2ef51669ae" translate="yes" xml:space="preserve">
          <source>JSON.stringify</source>
          <target state="translated">JSON.stringify</target>
        </trans-unit>
        <trans-unit id="b266d7c42c66244150bfc03d76098bb073e86d28" translate="yes" xml:space="preserve">
          <source>Just found this out the hard way.</source>
          <target state="translated">刚发现这个问题的时候,很难受。</target>
        </trans-unit>
        <trans-unit id="8e16c53d1bbc95155c6ceb4bb722f567d58cc184" translate="yes" xml:space="preserve">
          <source>Just like with the methods which have a guaranteed iteration order (like &lt;code&gt;Reflect.ownKeys&lt;/code&gt; and &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;), the previously-unspecified methods will also iterate in the following order:</source>
          <target state="translated">就像具有保证迭代顺序的方法（如 &lt;code&gt;Reflect.ownKeys&lt;/code&gt; 和 &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt; ）一样，先前未指定的方法也将按以下顺序进行迭代：</target>
        </trans-unit>
        <trans-unit id="4dda5a1c505242ff9f21a80d9c0ec24fcd977189" translate="yes" xml:space="preserve">
          <source>Most Browsers iterate object properties as:</source>
          <target state="translated">大多数浏览器迭代对象属性为。</target>
        </trans-unit>
        <trans-unit id="eca0d6e5ddb7e8e19c66b315455277ac55d52648" translate="yes" xml:space="preserve">
          <source>Neither the object being iterated nor anything in its prototype chain is a proxy, typed array, module namespace object, or host exotic object.</source>
          <target state="translated">被迭代的对象和它的原型链中的任何东西都不是代理、类型化数组、模块命名空间对象或主机异形对象。</target>
        </trans-unit>
        <trans-unit id="1d4ab0a6df04c34dd48b584b2a415ab43129c02b" translate="yes" xml:space="preserve">
          <source>Neither the object nor anything in its prototype chain has a property deleted during iteration.</source>
          <target state="translated">对象和它的原型链中的任何东西都没有在迭代过程中删除属性。</target>
        </trans-unit>
        <trans-unit id="4dc6577720fdc085f0e42c0d8290ba58b994327e" translate="yes" xml:space="preserve">
          <source>Neither the object nor anything in its prototype chain has its prototype change during iteration.</source>
          <target state="translated">对象和其原型链中的任何东西都不会在迭代过程中发生原型变化。</target>
        </trans-unit>
        <trans-unit id="0e995b5f9a057b2527e1b6be18d9f747fa5a5ffe" translate="yes" xml:space="preserve">
          <source>No non-enumerable property shadows an enumerable one.</source>
          <target state="translated">没有不可数财产的影子,没有不可数财产的影子。</target>
        </trans-unit>
        <trans-unit id="d658441f85cb60696e476538b61044fc4858c1a6" translate="yes" xml:space="preserve">
          <source>No property of the object or anything in its prototype chain has its enumerability change during iteration.</source>
          <target state="translated">在迭代过程中,对象的任何属性或其原型链中的任何东西都不会在迭代过程中改变其可数性。</target>
        </trans-unit>
        <trans-unit id="89c320a56b18231c4a841ab136d9db9f9cc15237" translate="yes" xml:space="preserve">
          <source>Note that the ES2015 behavior was a good example of the language spec being driven by existing behavior, and not the other way round. To get a deeper sense of that backwards-compatibility mindset, see &lt;a href=&quot;http://code.google.com/p/v8/issues/detail?id=164&quot;&gt;http://code.google.com/p/v8/issues/detail?id=164&lt;/a&gt;, a Chrome bug that covers in detail the design decisions behind Chrome's iteration order behavior.
Per one of the (rather opinionated) comments on that bug report:</source>
          <target state="translated">请注意，ES2015行为是语言规范受现有行为驱动的一个很好的例子，而不是相反。 要更深入地了解这种向后兼容的心态，请参阅&lt;a href=&quot;http://code.google.com/p/v8/issues/detail?id=164&quot;&gt;http://code.google.com/p/v8/issues/detail?id=164&lt;/a&gt; ，这是一个Chrome错误，其中详细介绍了Chrome迭代顺序行为背后的设计决策。 在该错误报告中，每（有一些自以为是）评论：</target>
        </trans-unit>
        <trans-unit id="a4d61c2f54a1ad70200ca0ee70c2977c4eb1f610" translate="yes" xml:space="preserve">
          <source>Nothing in the object's prototype chain has a property added during iteration.</source>
          <target state="translated">对象的原型链中没有任何东西在迭代过程中添加属性。</target>
        </trans-unit>
        <trans-unit id="0194eee4f03b556be8832cea08ed12de31c2d9b2" translate="yes" xml:space="preserve">
          <source>Numeric array keys, in ascending numeric order</source>
          <target state="translated">数字数组键,按数字升序排列</target>
        </trans-unit>
        <trans-unit id="1d51672345557c0f022fd737f9b7489d16b30459" translate="yes" xml:space="preserve">
          <source>Object.assign</source>
          <target state="translated">Object.assign</target>
        </trans-unit>
        <trans-unit id="792a27c424ad52e5a9356f3722643e927041e20f" translate="yes" xml:space="preserve">
          <source>Object.defineProperties</source>
          <target state="translated">Object.defineProperties</target>
        </trans-unit>
        <trans-unit id="a37c98a6f5f7ca5863f83538b43a1b90ce0f8d42" translate="yes" xml:space="preserve">
          <source>Object.getOwnPropertyNames</source>
          <target state="translated">Object.getOwnPropertyNames</target>
        </trans-unit>
        <trans-unit id="1061044277b2b1b91a3ad9fd72b96a926df8e0ad" translate="yes" xml:space="preserve">
          <source>Object.getOwnPropertySymbols</source>
          <target state="translated">Object.getOwnPropertySymbols</target>
        </trans-unit>
        <trans-unit id="c5a933e00dc39b7be5f3039f9caf7a7ff8b476c8" translate="yes" xml:space="preserve">
          <source>Object.keys</source>
          <target state="translated">Object.keys</target>
        </trans-unit>
        <trans-unit id="9766dcc2678dca29aca27b7034272c421f110e70" translate="yes" xml:space="preserve">
          <source>Own properties</source>
          <target state="translated">自有财产</target>
        </trans-unit>
        <trans-unit id="2ea9d512846684027cf3f09daee60e1b4fb1823d" translate="yes" xml:space="preserve">
          <source>Property order in normal Objects is a complex subject in Javascript.</source>
          <target state="translated">普通对象中的属性顺序在Javascript中是一个复杂的话题。</target>
        </trans-unit>
        <trans-unit id="0efb52a164d2557eb51e9d57bef3b03f3cfa6ce2" translate="yes" xml:space="preserve">
          <source>Reflect.ownKeys</source>
          <target state="translated">Reflect.ownKeys</target>
        </trans-unit>
        <trans-unit id="8c7c6e0edbbe7036c351801472457895f35b7ca5" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;String&lt;/code&gt;- and &lt;code&gt;Symbol&lt;/code&gt;-keyed properties.</source>
          <target state="translated">返回 &lt;code&gt;O&lt;/code&gt; 自己的 &lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;Symbol&lt;/code&gt; 键属性。</target>
        </trans-unit>
        <trans-unit id="073ddc07bb314332dd4af4685c8be8359a5e671a" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;String&lt;/code&gt;-keyed properties (&lt;em&gt;property names&lt;/em&gt;).</source>
          <target state="translated">返回 &lt;code&gt;O&lt;/code&gt; 自己的 &lt;code&gt;String&lt;/code&gt; 键属性（ &lt;em&gt;属性名&lt;/em&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cec74648d029ac27ae652baf8d58c1a15e7cb459" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;Symbol&lt;/code&gt;-keyed properties.</source>
          <target state="translated">返回 &lt;code&gt;O&lt;/code&gt; 自己的 &lt;code&gt;Symbol&lt;/code&gt; 键属性。</target>
        </trans-unit>
        <trans-unit id="77f8e27f1eed61991843e7511c8740205287dc40" translate="yes" xml:space="preserve">
          <source>So, no you can't guarantee the order.</source>
          <target state="translated">所以,没有你不能保证订单。</target>
        </trans-unit>
        <trans-unit id="9127c30b90d11e6061555ee1cae2d848f30da10c" translate="yes" xml:space="preserve">
          <source>Some exceptions include methods of enumerating inherited keys, such as the &lt;code&gt;for .. in&lt;/code&gt; loop. The &lt;code&gt;for .. in&lt;/code&gt; loop doesn't guarantee order according to the specification.</source>
          <target state="translated">一些例外情况包括枚举继承键的方法，例如 &lt;code&gt;for .. in&lt;/code&gt; 循环。 &lt;code&gt;for .. in&lt;/code&gt; 循环不保证根据规范的顺序。</target>
        </trans-unit>
        <trans-unit id="aeb78bd417a7768c123cd38651d774129e3176fc" translate="yes" xml:space="preserve">
          <source>Some older browsers combine categories #1 and #2, iterating all keys in insertion order. If your keys might parse as integers, it's best not to rely on any specific iteration order.</source>
          <target state="translated">一些旧的浏览器将#1和#2类别结合起来,按插入顺序迭代所有的键。如果你的键可能是整数,最好不要依赖任何特定的迭代顺序。</target>
        </trans-unit>
        <trans-unit id="bedb8cd8e036c17b94b5d6c22f537e6cd438946f" translate="yes" xml:space="preserve">
          <source>Sometimes, yes</source>
          <target state="translated">有时候,是的</target>
        </trans-unit>
        <trans-unit id="03696b013ec729f79ff55615110524b6d377d9c3" translate="yes" xml:space="preserve">
          <source>Standards always follow implementations, that's where XHR came from, and Google does the same thing by implementing Gears and then embracing equivalent HTML5 functionality.  The right fix is to have ECMA formally incorporate the de-facto standard behavior into the next rev of the spec.</source>
          <target state="translated">标准总是跟随实现,这就是XHR的由来,而Google也是这样做的,通过实现Gears,然后拥抱等效的HTML5功能。正确的解决方法是让ECMA正式将事实上的标准行为纳入到下一个版本的规范中。</target>
        </trans-unit>
        <trans-unit id="df387116de084996fa33cc5b4ccad3778e284d52" translate="yes" xml:space="preserve">
          <source>String keys, in insertion order (ES2015 guarantees this and all browsers comply)</source>
          <target state="translated">字符串键,按插入顺序(ES2015保证了这一点,所有的浏览器都会遵守。</target>
        </trans-unit>
        <trans-unit id="369d7c7a7aad2cd01d5e02f587face2623161f7f" translate="yes" xml:space="preserve">
          <source>Symbol keys, in insertion order</source>
          <target state="translated">符号键,按插入顺序</target>
        </trans-unit>
        <trans-unit id="8454bd456035f63689f1f7538dbb3e71c5e28c85" translate="yes" xml:space="preserve">
          <source>Symbol names, in insertion order (ES2015 guarantees this and all browsers comply)</source>
          <target state="translated">符号名称,按插入顺序排列(ES2015保证,所有浏览器都遵守此规定</target>
        </trans-unit>
        <trans-unit id="a9ff19a745e63e404d88d621888c4ff8971c082e" translate="yes" xml:space="preserve">
          <source>Symbols in insertion order</source>
          <target state="translated">符号的插入顺序</target>
        </trans-unit>
        <trans-unit id="3b2092c1a98be999603f3c961d4be7889be676c3" translate="yes" xml:space="preserve">
          <source>That is, will the properties be in the same order that I added them?</source>
          <target state="translated">也就是说,属性会和我添加的顺序一样吗?</target>
        </trans-unit>
        <trans-unit id="4d2de9daf855204938fd9e3b04c0ed0d327682b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMAScript specification&lt;/a&gt; used to say:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMAScript规范&lt;/a&gt;过去曾说过：</target>
        </trans-unit>
        <trans-unit id="29fa3e4243bed714bd28cdcc5a439b305d27dff3" translate="yes" xml:space="preserve">
          <source>The actual question is very vague.</source>
          <target state="translated">实际问题是很模糊的。</target>
        </trans-unit>
        <trans-unit id="d9bb6366ecce97d1a3154d5144e1244355d132c5" translate="yes" xml:space="preserve">
          <source>The answer is: it depends on a number of factors. In general, &lt;em&gt;no&lt;/em&gt;.</source>
          <target state="translated">答案是：这取决于许多因素。 一般来说， &lt;em&gt;没有&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb3112a8a32dbd36dfe4b46a1d1df283f2bffaf5" translate="yes" xml:space="preserve">
          <source>The following methods guarantee the order shown:</source>
          <target state="translated">以下方法保证了所显示的订单。</target>
        </trans-unit>
        <trans-unit id="b8bb19c6e5330bcaa59b97be556c1675a287f34b" translate="yes" xml:space="preserve">
          <source>The following methods/loops guarantee no order at all:</source>
          <target state="translated">下面的方法循环保证完全没有订单。</target>
        </trans-unit>
        <trans-unit id="dbdc2d4c67254f98b99f13c6b0dc25f2e511fb83" translate="yes" xml:space="preserve">
          <source>The iteration order for objects follows &lt;a href=&quot;https://stackoverflow.com/a/38218582/292500&quot;&gt;a certain set of rules&lt;/a&gt; since ES2015, but &lt;strong&gt;it does not (always) follow the insertion order&lt;/strong&gt;. Simply put, the iteration order is a combination of the insertion order for strings keys, and ascending order for number-like keys:</source>
          <target state="translated">自ES2015起，对象的迭代顺序遵循&lt;a href=&quot;https://stackoverflow.com/a/38218582/292500&quot;&gt;一组特定的规则&lt;/a&gt; ，但&lt;strong&gt;不（始终）遵循插入顺序&lt;/strong&gt; 。 简而言之，迭代顺序是字符串键的插入顺序和数字键的升序的组合：</target>
        </trans-unit>
        <trans-unit id="b4a4e6f068dfc6cd8381634fb9999b8edbd5d5cc" translate="yes" xml:space="preserve">
          <source>The keys in Map are ordered while keys added to object are not. Thus, when iterating over it, a Map object returns keys in order of insertion. (Note that in the ECMAScript 2015 spec objects do preserve creation order for string and Symbol keys, so traversal of an object with ie only string keys would yield keys in order of insertion)</source>
          <target state="translated">Map中的键是有序的,而添加到对象中的键则不是。因此,当迭代时,Map对象会按照插入的顺序返回键。(注意,在ECMAScript 2015规范中,对象保留了字符串和符号键的创建顺序,因此遍历一个对象时,只有字符串键的对象才会产生按插入顺序的键值)</target>
        </trans-unit>
        <trans-unit id="ed7cecaff2b2b865d7552ddaf655c499e0ab0a33" translate="yes" xml:space="preserve">
          <source>The lack of specificity in ECMA-262 does not reflect reality. In discussion going back years, implementors have observed that there are some constraints on the behavior of for-in which anyone who wants to run code on the web needs to follow.</source>
          <target state="translated">ECMA-262中缺乏特殊性并不能反映现实。在多年前的讨论中,实现者们注意到,对于for-in的行为有一些限制,任何想在web上运行代码的人都需要遵循这些限制。</target>
        </trans-unit>
        <trans-unit id="99cdafe7bfb6d937df7209d8848443a7e20e02fd" translate="yes" xml:space="preserve">
          <source>The mechanics and order of enumerating the properties ... is not specified.</source>
          <target state="translated">列举属性的机理和顺序...........没有说明。</target>
        </trans-unit>
        <trans-unit id="111c3077a9bab7d0eb66f628b1f52704d6558d5c" translate="yes" xml:space="preserve">
          <source>The order is defined in the spec, under the abstract operation &lt;a href=&quot;https://www.ecma-international.org/ecma-262/9.0/index.html#sec-ordinaryownpropertykeys&quot;&gt;OrdinaryOwnPropertyKeys&lt;/a&gt;, which underpins all methods of iterating over an object's own keys. Paraphrased, the order is as follows:</source>
          <target state="translated">该顺序在规范中的抽​​象操作&lt;a href=&quot;https://www.ecma-international.org/ecma-262/9.0/index.html#sec-ordinaryownpropertykeys&quot;&gt;OrdinaryOwnPropertyKeys&lt;/a&gt;下定义，该操作支持对对象自己的键进行迭代的所有方法。 释义，顺序如下：</target>
        </trans-unit>
        <trans-unit id="10e68ba3d24da3f1a6c55e57fc43a01f2310bb93" translate="yes" xml:space="preserve">
          <source>The order is essentially: integer-like &lt;code&gt;Strings&lt;/code&gt; in ascending order, non-integer-like &lt;code&gt;Strings&lt;/code&gt; in creation order, Symbols in creation order. Depending which function invokes this, some of these types may not be included.</source>
          <target state="translated">顺序本质上是：升序的类整数 &lt;code&gt;Strings&lt;/code&gt; ，创建顺序的类非整数字符串 ，创建顺序的符号。 根据哪个函数调用此函数，可能不包括其中某些类型。</target>
        </trans-unit>
        <trans-unit id="b3287cf2d6f8c1f23bb792abaeefb0a8c1cbeba7" translate="yes" xml:space="preserve">
          <source>The order of keys in an object wasn't guaranteed until ES2015. It was implementation-defined.</source>
          <target state="translated">在ES2015之前,对象中的键的顺序并没有得到保证。它是由实现定义的。</target>
        </trans-unit>
        <trans-unit id="cc78fa8b6dadd0f1f48d48f9402a99419d560fbd" translate="yes" xml:space="preserve">
          <source>The question is, for what methods this order is guaranteed in the ES2015 spec?</source>
          <target state="translated">问题是,在ES2015的规范中,这个顺序对哪些方法有保障?</target>
        </trans-unit>
        <trans-unit id="a5b1e52a5ac36573960704b3789b1a8d268ccf5a" translate="yes" xml:space="preserve">
          <source>The specific language is that keys are returned in the following order:</source>
          <target state="translated">具体的语言是,按键按以下顺序返回。</target>
        </trans-unit>
        <trans-unit id="0dce972e73d0a4fac0a155ed2f727b3110d2cad9" translate="yes" xml:space="preserve">
          <source>There are a few weird cases which implementations currently do &lt;em&gt;not&lt;/em&gt; agree on, and in such cases, the resulting order will continue be unspecified. For property order &lt;a href=&quot;https://github.com/tc39/proposal-for-in-order#a-conservative-underapproximation-of-interop-semantics&quot;&gt;to be guaranteed&lt;/a&gt;:</source>
          <target state="translated">当前有几种奇怪的情况，实现尚&lt;em&gt;无法&lt;/em&gt;达成共识，在这种情况下，结果顺序将继续不确定。 为了&lt;a href=&quot;https://github.com/tc39/proposal-for-in-order#a-conservative-underapproximation-of-interop-semantics&quot;&gt;保证&lt;/a&gt;财产顺序：</target>
        </trans-unit>
        <trans-unit id="55b19b14da72f8c7f30f65d3c0821fb28bb19664" translate="yes" xml:space="preserve">
          <source>This is what pretty much every implementation does already, but the new proposal will make it official.</source>
          <target state="translated">这几乎是每个实施者都已经在做的事情,但新的提案将使其正式化。</target>
        </trans-unit>
        <trans-unit id="49f03181403db0a6631b9c892e5eb9016ddb9775" translate="yes" xml:space="preserve">
          <source>This results in the following order (in certain cases):</source>
          <target state="translated">这样做的结果是(在某些情况下):</target>
        </trans-unit>
        <trans-unit id="2a2d2ebbf23e9e14a50e49a2ebb2718a4d31e0ae" translate="yes" xml:space="preserve">
          <source>This way you can use a regular for loop and have the insert order. You could then use the Array sort method to sort this into a new array if needed.</source>
          <target state="translated">这样,你可以使用一个正则的for循环,并有插入顺序。如果需要的话,你可以使用Array sort方法将其排序成一个新的数组。</target>
        </trans-unit>
        <trans-unit id="db70c450e37560ad700c843433664c3f72d27c97" translate="yes" xml:space="preserve">
          <source>This whole answer is in the context of spec compliance, not what any engine does at a particular moment or historically.</source>
          <target state="translated">这整个答案是在符合规格的情况下,而不是任何发动机在某一特定时刻或历史上做了什么。</target>
        </trans-unit>
        <trans-unit id="36e7408731ad7eda18219f4f3ecf847b4d50bd86" translate="yes" xml:space="preserve">
          <source>Thus, in order to take &lt;code&gt;Object.keys(valueFromStore)&lt;/code&gt; I used &lt;code&gt;Object.keys(valueFromStore).sort()&lt;/code&gt;, so that I at least now have an alphabetical order for the keys.</source>
          <target state="translated">因此，为了使用 &lt;code&gt;Object.keys(valueFromStore)&lt;/code&gt; ,我使用了 &lt;code&gt;Object.keys(valueFromStore).sort()&lt;/code&gt; ，这样我至少现在对这些键具有字母顺序。</target>
        </trans-unit>
        <trans-unit id="6c15ca0416904aeea36408d198c5a736ea187af3" translate="yes" xml:space="preserve">
          <source>Thus, there are three segments, which may alter the insertion order (as happened in the example). And integer-like keys don't stick to the insertion order at all.</source>
          <target state="translated">因此,有三个段,可能会改变插入顺序(就像例子中发生的那样)。而类似于整数的键完全不坚持插入顺序。</target>
        </trans-unit>
        <trans-unit id="42f21f6edccf6b7e965aa6753e10344cefc870e1" translate="yes" xml:space="preserve">
          <source>Using React with Redux, the state container of which's keys I want to traverse in order to generate children is refreshed everytime the store is changed (as per Redux's immutability concepts).</source>
          <target state="translated">使用React与Redux,我想通过React来遍历哪家的状态容器,以便生成子代,每当商店发生变化时,都会刷新状态容器(按照Redux的不变性概念)。</target>
        </trans-unit>
        <trans-unit id="158b0728eeda2f2e43e242eab00a657882339035" translate="yes" xml:space="preserve">
          <source>Using an array or a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;&lt;code&gt;Map&lt;/code&gt; object&lt;/a&gt; can be a better way to achieve this. &lt;code&gt;Map&lt;/code&gt; shares some similarities with &lt;code&gt;Object&lt;/code&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_and_maps_compared&quot;&gt;guarantees the keys to be iterated in order of insertion&lt;/a&gt;, without exception:</source>
          <target state="translated">使用数组或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; 对象&lt;/a&gt;可能是实现此目的的更好方法。 &lt;code&gt;Map&lt;/code&gt; 与 &lt;code&gt;Object&lt;/code&gt; 有一些相似之处，并&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_and_maps_compared&quot;&gt;保证按插入顺序对键进行迭代&lt;/a&gt; ，无一例外：</target>
        </trans-unit>
        <trans-unit id="717e9d7bd21b2bf25179048c23b8139ebca1d0df" translate="yes" xml:space="preserve">
          <source>While in ES5 explicitly no order has been specified, ES2015 has an order in certain cases. Given is the following object:</source>
          <target state="translated">虽然在ES5中没有明确指定顺序,但ES2015在某些情况下有一个顺序。给出的是以下对象。</target>
        </trans-unit>
        <trans-unit id="2c4f5a24bafe473e423771440ba63f17544d239e" translate="yes" xml:space="preserve">
          <source>Will the resulting object &lt;em&gt;always&lt;/em&gt; look like this?</source>
          <target state="translated">生成的对象会&lt;em&gt;总是&lt;/em&gt;这样吗？</target>
        </trans-unit>
        <trans-unit id="64e3dd86e22797f5de12c4dcc57dae70834e7300" translate="yes" xml:space="preserve">
          <source>for..in</source>
          <target state="translated">for..in</target>
        </trans-unit>
        <trans-unit id="139528a85e8b998035ad6a5c85b4e51ace8b55c2" translate="yes" xml:space="preserve">
          <source>integer-like keys in ascending order</source>
          <target state="translated">类整数键</target>
        </trans-unit>
        <trans-unit id="4412ac0ae820171fd5f4fb0263ad6679aaf6cf9c" translate="yes" xml:space="preserve">
          <source>normal keys in insertion order</source>
          <target state="translated">普通键的插入顺序</target>
        </trans-unit>
        <trans-unit id="41d84f4f169439986c15f630c7f2198df104449c" translate="yes" xml:space="preserve">
          <source>will the properties be in the same order that I added them</source>
          <target state="translated">属性是否与我添加的顺序相同</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
