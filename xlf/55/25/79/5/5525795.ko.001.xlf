<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/5525795">
    <body>
      <group id="5525795">
        <trans-unit id="da3687cfe7631d821ba35f4e012caced3b66cd22" translate="yes" xml:space="preserve">
          <source>(emphasis mine).</source>
          <target state="translated">(강조 광산).</target>
        </trans-unit>
        <trans-unit id="506a92cc597c8229d7c4a2bed4f4e9b88c6d9d1b" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; [the object being iterated] that is an integer index, in ascending numeric index order</source>
          <target state="translated">... 오름차순 숫자 인덱스 순서로 정수 인덱스 인 &lt;code&gt;O&lt;/code&gt; [반복되는 객체]의 각각의 속성 키 &lt;code&gt;P&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1431eb62a77c3957a1a90ad8c2ee19b35d73184" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; that is a String but is not an integer index, in property creation order</source>
          <target state="translated">... 속성 생성 순서에서 문자열이지만 정수 인덱스가 아닌 &lt;code&gt;O&lt;/code&gt; 의 각각의 속성 키 &lt;code&gt;P&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41f72be3edc7209f752acd3f28c3b1078665a04e" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; that is a Symbol, in property creation order</source>
          <target state="translated">... 속성 생성 순서에서 기호 인 &lt;code&gt;O&lt;/code&gt; 의 고유 한 특성 키 &lt;code&gt;P&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="617676d9406eee86e16ed250ff2bd786d055b06f" translate="yes" xml:space="preserve">
          <source>4.3.3 Object</source>
          <target state="translated">4.3.3 객체</target>
        </trans-unit>
        <trans-unit id="629e86072909febc69cff039b31e251bfb5bcef7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;, &lt;code&gt;Reflect.ownKeys()&lt;/code&gt;, &lt;code&gt;Object.getOwnPropertySymbols(O)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt; , &lt;code&gt;Reflect.ownKeys()&lt;/code&gt; , &lt;code&gt;Object.getOwnPropertySymbols(O)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="906437decdad0d2084e279baa2e2d923b430539c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.keys&lt;/code&gt;, &lt;code&gt;Object.values&lt;/code&gt;, &lt;code&gt;Object.entries&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.keys&lt;/code&gt; , &lt;code&gt;Object.values&lt;/code&gt; , &lt;code&gt;Object.entries&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac72976f1fd79543ad7172b5c48fa8ec5cc520a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..in&lt;/code&gt; loops</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; 루프</target>
        </trans-unit>
        <trans-unit id="3f7356ed9c8dad2efb0205e5f9f24151517669d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In what context?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;어떤 맥락에서?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d30fe30d4258ac32279a10fad11a23661e24d1fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But, soon (probably in ES2020), property order for these previously untrustworthy methods &lt;em&gt;will&lt;/em&gt; be guaranteed by the specification&lt;/strong&gt; to be iterated over in the same deterministic manner as the others, due to to the &lt;a href=&quot;https://github.com/tc39/proposals/blob/master/finished-proposals.md&quot;&gt;stage 4&lt;/a&gt; proposal: &lt;a href=&quot;http://tc39.es/proposal-for-in-order/&quot;&gt;For-in enumeration order&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;그러나 곧 (아마도 ES2020에서)&lt;/strong&gt; &lt;a href=&quot;https://github.com/tc39/proposals/blob/master/finished-proposals.md&quot;&gt;단계 4&lt;/a&gt; 제안 : &lt;a href=&quot;http://tc39.es/proposal-for-in-order/&quot;&gt;For-in 열거 순서&lt;/a&gt; 로 인해 &lt;strong&gt;이전에 신뢰할 수 없었던 이러한 방법의 속성 순서&lt;/strong&gt; 가 다른 방법과 동일한 결정 론적 방식으로 반복 &lt;strong&gt;되도록 보장 &lt;em&gt;할 것&lt;/em&gt;&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="43cf735af1addba43cf6135a9e6cd5fd77f69b83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusion: Even in ES2015 you shouldn't rely on the property order of normal objects in Javascript. It is prone to errors. Use &lt;code&gt;Map&lt;/code&gt; instead.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;결론 : ES2015에서도 Javascript에서 일반 객체의 속성 순서에 의존해서는 안됩니다.&lt;/strong&gt; &lt;strong&gt;오류가 발생하기 쉽습니다.&lt;/strong&gt; &lt;strong&gt;대신 &lt;code&gt;Map&lt;/code&gt; 을 사용하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be9ffe71c53127990a370c8d47eb77ce87f4c69b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Current Language Spec (since ES2015)&lt;/strong&gt; insertion order is preserved, except in the case of keys that parse as integers (eg &quot;7&quot; or &quot;99&quot;), where behavior varies between browsers. For example, Chrome/V8 does not respect insertion order when the keys are parse as numeric.</source>
          <target state="translated">브라우저마다 동작이 달라지는 정수 (예 : &quot;7&quot;또는 &quot;99&quot;)로 구문 분석되는 키의 경우를 제외하고 &lt;strong&gt;현재 언어 사양 (ES2015 이후)&lt;/strong&gt; 삽입 순서가 유지됩니다. 예를 들어, 키가 숫자로 구문 분석 될 때 Chrome / V8은 삽입 순서를 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c848754eb60df7eadf93fb71befdc94139eef6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Old Language Spec (before ES2015)&lt;/strong&gt;: Iteration order was technically undefined, but all major browsers complied with the ES2015 behavior.</source>
          <target state="translated">&lt;strong&gt;이전 언어 사양 (ES2015 이전)&lt;/strong&gt; : 반복 순서는 기술적으로 정의되지 않았지만 모든 주요 브라우저는 ES2015 동작을 준수했습니다.</target>
        </trans-unit>
        <trans-unit id="a5cabd9db5130fe850fc14a9f035d862d77edcae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;YES (for non-integer keys).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예 (정수가 아닌 키의 경우).&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ddc2dc2dbcd4516457a87d0f7f30c97209aab02" translate="yes" xml:space="preserve">
          <source>A Map object can iterate its elements in insertion order...</source>
          <target state="translated">Map 객체는 삽입 순서대로 요소를 반복 할 수 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="8272a49555285dae357452d8b3518864897ab434" translate="yes" xml:space="preserve">
          <source>All &lt;em&gt;integer index&lt;/em&gt; keys (stuff like &lt;code&gt;&quot;1123&quot;&lt;/code&gt;, &lt;code&gt;&quot;55&quot;&lt;/code&gt;, etc) in ascending numeric order.</source>
          <target state="translated">모든 &lt;em&gt;정수 인덱스&lt;/em&gt; 키 ( &lt;code&gt;&quot;1123&quot;&lt;/code&gt; , &lt;code&gt;&quot;55&quot;&lt;/code&gt; 등)가 오름차순으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6d0d086e05c3f95500e0ef71cccca3dcbbf3ee81" translate="yes" xml:space="preserve">
          <source>All other non-Symbol keys, in insertion order</source>
          <target state="translated">삽입 순서대로 다른 모든 비 기호 키</target>
        </trans-unit>
        <trans-unit id="6931239bebc33c69fddecf7cf1a400bef63e3d2e" translate="yes" xml:space="preserve">
          <source>All string keys which are not integer indices, in order of creation (oldest-first).</source>
          <target state="translated">생성 순서대로 정수 인덱스가 아닌 모든 문자열 키 (가장 오래된 것부터).</target>
        </trans-unit>
        <trans-unit id="9cc7882625e1fa1848c2d4d2d56f6e182d7ff836" translate="yes" xml:space="preserve">
          <source>All symbol keys, in order of creation (oldest-first).</source>
          <target state="translated">생성 순서에 따른 모든 기호 키 (가장 오래된 것부터).</target>
        </trans-unit>
        <trans-unit id="d99ee358a61be9c08f8e3663248de7c6ea7386a1" translate="yes" xml:space="preserve">
          <source>Although the current specification leaves for..in iteration order &quot;&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-enumerate-object-properties&quot;&gt;almost totally unspecified&lt;/a&gt;, real engines tend to be more consistent:&quot;</source>
          <target state="translated">현재 사양은 반복 순서대로 &quot; &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-enumerate-object-properties&quot;&gt;거의 완전히 지정되지 않았지만&lt;/a&gt; 실제 엔진은 더 일관된 경향이 있습니다.&quot;</target>
        </trans-unit>
        <trans-unit id="9f541eac51b245397dfc1dd505657af7d28c26b2" translate="yes" xml:space="preserve">
          <source>An object is a member of the
  type Object. &lt;strong&gt;It is an unordered collection of properties&lt;/strong&gt; each of which
  contains a primitive value, object, or
  function. A function stored in a
  property of an object is called a
  method.</source>
          <target state="translated">객체는 Object 유형의 멤버입니다. &lt;strong&gt;순서가없는 속성 모음으로&lt;/strong&gt; 각각 기본 값, 객체 또는 함수를 포함합니다. 객체의 속성에 저장된 함수를 메서드라고합니다.</target>
        </trans-unit>
        <trans-unit id="3f1e99d603dc8c534f17c37e7680125db1255ec4" translate="yes" xml:space="preserve">
          <source>An object is an &lt;strong&gt;unordered&lt;/strong&gt; collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array.</source>
          <target state="translated">객체는 0 개 이상의 이름 / 값 쌍으로 &lt;strong&gt;정렬되지 않은&lt;/strong&gt; 컬렉션입니다. 여기서 이름은 문자열이고 값은 문자열, 숫자, 부울, null, 객체 또는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="0ce441a742a81f4f9ec981fd12c2ec069bde986b" translate="yes" xml:space="preserve">
          <source>As a note, properties order in objects weren&amp;rsquo;t guaranteed at all before ES2015. Definition of an Object from &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf&quot;&gt;ECMAScript Third Edition (pdf)&lt;/a&gt;:</source>
          <target state="translated">참고로 ES2015 이전에는 객체의 속성 순서가 전혀 보장되지 않았습니다. &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf&quot;&gt;ECMAScript Third Edition&lt;/a&gt; 의 객체 정의 (pdf) :</target>
        </trans-unit>
        <trans-unit id="89359f1939ff8169993255536817a0eeb023f70f" translate="yes" xml:space="preserve">
          <source>As of ES2015, property order is guaranteed for certain methods that iterate over properties. &lt;a href=&quot;https://stackoverflow.com/a/30919039/&quot;&gt;but not others&lt;/a&gt;. Unfortunately, the methods which are not guaranteed to have an order are generally the most often used:</source>
          <target state="translated">ES2015부터는 속성을 반복하는 특정 방법에 대해 속성 순서가 보장됩니다. &lt;a href=&quot;https://stackoverflow.com/a/30919039/&quot;&gt;그러나 다른 사람은 아닙니다&lt;/a&gt; . 불행히도, 주문을 보장하지 않는 방법이 일반적으로 가장 많이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f0701b9ee5dc8738764e68bb472acd3938023043" translate="yes" xml:space="preserve">
          <source>As others have stated, you have no guarantee as to the order when you iterate over the properties of an object. If you need an ordered list of multiple fields I suggested creating an array of objects.</source>
          <target state="translated">다른 사람들이 언급했듯이 객체의 속성을 반복 할 때 순서에 대해 보장하지 않습니다. 여러 필드의 순서가 지정된 목록이 필요한 경우 객체 배열을 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4444585e7d19b4c0af133a98d6096e8c852f3f8b" translate="yes" xml:space="preserve">
          <source>At the time of writing, most browsers did return properties in the same order as they were inserted, but it was explicitly not guaranteed behaviour so shouldn't have been relied upon.</source>
          <target state="translated">작성 당시 대부분의 브라우저는 삽입 된 순서와 동일한 순서로 속성을 반환했지만 동작이 명시 적으로 보장되지는 않았으므로 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="98f97678eae35879cc93487177bce8991d7bde31" translate="yes" xml:space="preserve">
          <source>Because every implementation already iterates over properties predictably, it can be put into the specification without breaking backwards compatibility.</source>
          <target state="translated">모든 구현은 이미 예측 가능한 속성을 반복하기 때문에 이전 버전과의 호환성을 유지하면서 사양에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ac1c2bd0aec0e13d9c387f83cc8b463ba74df8f" translate="yes" xml:space="preserve">
          <source>Developer mozilla &amp;gt; Map</source>
          <target state="translated">개발자 mozilla&amp;gt;지도</target>
        </trans-unit>
        <trans-unit id="099a01ed9dd31f9684e8375f7034b12c3bb1a630" translate="yes" xml:space="preserve">
          <source>Does JavaScript Guarantee Object Property Order</source>
          <target state="translated">JavaScript는 객체 속성 순서를 보장합니다</target>
        </trans-unit>
        <trans-unit id="cc80c2d78cd6d75a58d4466354ff030d12c0c74d" translate="yes" xml:space="preserve">
          <source>ES2015 compliant engine</source>
          <target state="translated">ES2015 호환 엔진</target>
        </trans-unit>
        <trans-unit id="0acc2d215fca04ea6cc5ff432bfc48e007f86d3f" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot;&gt;JSON standard&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot;&gt;JSON 표준에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2a4e536fd55e0da3c613262b2b50225cf7c78b01" translate="yes" xml:space="preserve">
          <source>Generally, no</source>
          <target state="translated">일반적으로</target>
        </trans-unit>
        <trans-unit id="4226982480d45f93dd459e9b1117c39c199447db" translate="yes" xml:space="preserve">
          <source>Here is where you can count on property key order for plain &lt;code&gt;Objects&lt;/code&gt;:</source>
          <target state="translated">일반 &lt;code&gt;Objects&lt;/code&gt; 속성 키 순서를 신뢰할 수있는 위치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52147a0993d04e70a8e544d610fb45da923bbc68" translate="yes" xml:space="preserve">
          <source>However in ES2015 and later non-integer keys will be returned in insertion order.</source>
          <target state="translated">그러나 ES2015 이상에서는 정수가 아닌 키가 삽입 순서대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4961c2d8675f28a3fc5ef4a18b41c9201056b692" translate="yes" xml:space="preserve">
          <source>However, in ES2015 in &lt;em&gt;was&lt;/em&gt; specified. Like many things in JavaScript, this was done for compatibility purposes and generally reflected an existing unofficial standard among most JS engines (with you-know-who being an exception).</source>
          <target state="translated">그러나 ES2015에서는 in &lt;em&gt;이&lt;/em&gt; 지정되었습니다. JavaScript의 많은 것들과 마찬가지로, 이것은 호환성을 목적으로 수행되었으며 일반적으로 대부분의 JS 엔진에있는 기존의 비공식 표준을 반영합니다 (예외를 아는 사람).</target>
        </trans-unit>
        <trans-unit id="b0828e60d703c26f73af1747c4d90e291c0a0d65" translate="yes" xml:space="preserve">
          <source>If I create an object like this:</source>
          <target state="translated">이런 객체를 만들면 :</target>
        </trans-unit>
        <trans-unit id="faabc3e0f5d76ebc58393833b7e692b3510ba07c" translate="yes" xml:space="preserve">
          <source>If you're interested in ordered maps you should consider using the &lt;code&gt;Map&lt;/code&gt; type introduced in ES2015 instead of plain &lt;code&gt;Objects&lt;/code&gt;.</source>
          <target state="translated">정렬 된 맵에 관심이있는 경우 일반 &lt;code&gt;Objects&lt;/code&gt; 대신 ES2015에 도입 된 &lt;code&gt;Map&lt;/code&gt; 유형을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b627572cf43af1c9edcc2a011b2dbb4addc1a4f5" translate="yes" xml:space="preserve">
          <source>In ES2015, it does, but not to what you might think</source>
          <target state="translated">ES2015에서는 생각하지만 그렇게 생각하지 않습니다</target>
        </trans-unit>
        <trans-unit id="c53c091a8a1dc6a4941c3d127b1c3f5926252001" translate="yes" xml:space="preserve">
          <source>In all cases these methods include non-enumerable property keys and order keys as specified by &lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt; (see below). They differ in the type of key values they include (&lt;code&gt;String&lt;/code&gt; and / or &lt;code&gt;Symbol&lt;/code&gt;). In this context &lt;code&gt;String&lt;/code&gt; includes integer values.</source>
          <target state="translated">모든 경우에 이러한 메소드에는 &lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt; 에 지정된대로 열거 할 수없는 특성 키 및 주문 키가 포함됩니다 (아래 참조). 포함하는 키 값의 유형이 다릅니다 ( &lt;code&gt;String&lt;/code&gt; 및 / 또는 &lt;code&gt;Symbol&lt;/code&gt; ). 이 문맥에서 &lt;code&gt;String&lt;/code&gt; 은 정수 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a66377df8463c41ca80dbcbc5b839a498d9c49dd" translate="yes" xml:space="preserve">
          <source>In modern browsers you can use the &lt;code&gt;Map&lt;/code&gt; data structure instead of a object.</source>
          <target state="translated">최신 브라우저에서는 객체 대신 &lt;code&gt;Map&lt;/code&gt; 데이터 구조를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="149f5ce9ce098e7b86f9afc0516dad29d57de442" translate="yes" xml:space="preserve">
          <source>Integer keys in ascending order (and strings like &quot;1&quot; that parse as ints)</source>
          <target state="translated">오름차순의 정수 키 (및 int로 구문 분석하는 &quot;1&quot;과 같은 문자열)</target>
        </trans-unit>
        <trans-unit id="ee46467fe2fdf494dcc7270423065b1d077f30f2" translate="yes" xml:space="preserve">
          <source>It's silly to say that the order is unreliable - it is reliable, it's just probably not what you want, and modern browsers implement this order correctly.</source>
          <target state="translated">순서가 신뢰할 수 없다고 말하는 것은 어리석은 일입니다. 신뢰할 수 있고, 아마도 원하는 것이 아니며, 최신 브라우저는이 순서를 올바르게 구현합니다.</target>
        </trans-unit>
        <trans-unit id="64b5375f0360e9044ba38df47f55f6d563d59252" translate="yes" xml:space="preserve">
          <source>JSON.parse</source>
          <target state="translated">JSON.parse</target>
        </trans-unit>
        <trans-unit id="3898286ce044bc87123989a97e0cdf2ef51669ae" translate="yes" xml:space="preserve">
          <source>JSON.stringify</source>
          <target state="translated">JSON.stringify</target>
        </trans-unit>
        <trans-unit id="b266d7c42c66244150bfc03d76098bb073e86d28" translate="yes" xml:space="preserve">
          <source>Just found this out the hard way.</source>
          <target state="translated">이 방법이 어려운 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="8e16c53d1bbc95155c6ceb4bb722f567d58cc184" translate="yes" xml:space="preserve">
          <source>Just like with the methods which have a guaranteed iteration order (like &lt;code&gt;Reflect.ownKeys&lt;/code&gt; and &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;), the previously-unspecified methods will also iterate in the following order:</source>
          <target state="translated">반복 순서가 보장 된 메소드 ( &lt;code&gt;Reflect.ownKeys&lt;/code&gt; 및 &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt; 등 )와 마찬가지로 이전에 지정되지 않은 메소드도 다음 순서로 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="4dda5a1c505242ff9f21a80d9c0ec24fcd977189" translate="yes" xml:space="preserve">
          <source>Most Browsers iterate object properties as:</source>
          <target state="translated">대부분의 브라우저는 다음과 같이 객체 속성을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="eca0d6e5ddb7e8e19c66b315455277ac55d52648" translate="yes" xml:space="preserve">
          <source>Neither the object being iterated nor anything in its prototype chain is a proxy, typed array, module namespace object, or host exotic object.</source>
          <target state="translated">반복되는 객체 나 프로토 타입 체인의 어떤 것도 프록시, 형식화 된 배열, 모듈 네임 스페이스 객체 또는 호스트 이국적인 객체가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1d4ab0a6df04c34dd48b584b2a415ab43129c02b" translate="yes" xml:space="preserve">
          <source>Neither the object nor anything in its prototype chain has a property deleted during iteration.</source>
          <target state="translated">객체 나 프로토 타입 체인의 어떤 것도 반복하는 동안 속성이 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4dc6577720fdc085f0e42c0d8290ba58b994327e" translate="yes" xml:space="preserve">
          <source>Neither the object nor anything in its prototype chain has its prototype change during iteration.</source>
          <target state="translated">프로토 타입 체인의 객체 나 어떤 것도 반복하는 동안 프로토 타입이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e995b5f9a057b2527e1b6be18d9f747fa5a5ffe" translate="yes" xml:space="preserve">
          <source>No non-enumerable property shadows an enumerable one.</source>
          <target state="translated">열거 할 수없는 속성 그림자는 열거 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d658441f85cb60696e476538b61044fc4858c1a6" translate="yes" xml:space="preserve">
          <source>No property of the object or anything in its prototype chain has its enumerability change during iteration.</source>
          <target state="translated">프로토 타입 체인의 객체 또는 기타 객체의 속성은 반복 동안 열거 성이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89c320a56b18231c4a841ab136d9db9f9cc15237" translate="yes" xml:space="preserve">
          <source>Note that the ES2015 behavior was a good example of the language spec being driven by existing behavior, and not the other way round. To get a deeper sense of that backwards-compatibility mindset, see &lt;a href=&quot;http://code.google.com/p/v8/issues/detail?id=164&quot;&gt;http://code.google.com/p/v8/issues/detail?id=164&lt;/a&gt;, a Chrome bug that covers in detail the design decisions behind Chrome's iteration order behavior.
Per one of the (rather opinionated) comments on that bug report:</source>
          <target state="translated">ES2015 동작은 기존 동작에 의해 구동되는 언어 사양의 좋은 예이며 다른 방식은 아닙니다. 이전 버전과의 호환성에 대한 심도를 더 깊이 이해하려면 Chrome의 반복 순서 동작에 대한 디자인 결정을 자세히 다루는 Chrome 버그 인 &lt;a href=&quot;http://code.google.com/p/v8/issues/detail?id=164&quot;&gt;http://code.google.com/p/v8/issues/detail?id=164를&lt;/a&gt; 참조하십시오 . . 해당 버그 보고서에 대한 의견이 아닌 의견 중 하나에 대해 :</target>
        </trans-unit>
        <trans-unit id="a4d61c2f54a1ad70200ca0ee70c2977c4eb1f610" translate="yes" xml:space="preserve">
          <source>Nothing in the object's prototype chain has a property added during iteration.</source>
          <target state="translated">객체의 프로토 타입 체인에는 반복 중에 추가 된 속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0194eee4f03b556be8832cea08ed12de31c2d9b2" translate="yes" xml:space="preserve">
          <source>Numeric array keys, in ascending numeric order</source>
          <target state="translated">숫자 배열 키 (오름차순)</target>
        </trans-unit>
        <trans-unit id="1d51672345557c0f022fd737f9b7489d16b30459" translate="yes" xml:space="preserve">
          <source>Object.assign</source>
          <target state="translated">Object.assign</target>
        </trans-unit>
        <trans-unit id="792a27c424ad52e5a9356f3722643e927041e20f" translate="yes" xml:space="preserve">
          <source>Object.defineProperties</source>
          <target state="translated">Object.defineProperties</target>
        </trans-unit>
        <trans-unit id="a37c98a6f5f7ca5863f83538b43a1b90ce0f8d42" translate="yes" xml:space="preserve">
          <source>Object.getOwnPropertyNames</source>
          <target state="translated">Object.getOwnPropertyNames</target>
        </trans-unit>
        <trans-unit id="1061044277b2b1b91a3ad9fd72b96a926df8e0ad" translate="yes" xml:space="preserve">
          <source>Object.getOwnPropertySymbols</source>
          <target state="translated">Object.getOwnPropertySymbols</target>
        </trans-unit>
        <trans-unit id="c5a933e00dc39b7be5f3039f9caf7a7ff8b476c8" translate="yes" xml:space="preserve">
          <source>Object.keys</source>
          <target state="translated">Object.keys</target>
        </trans-unit>
        <trans-unit id="9766dcc2678dca29aca27b7034272c421f110e70" translate="yes" xml:space="preserve">
          <source>Own properties</source>
          <target state="translated">자신의 속성</target>
        </trans-unit>
        <trans-unit id="2ea9d512846684027cf3f09daee60e1b4fb1823d" translate="yes" xml:space="preserve">
          <source>Property order in normal Objects is a complex subject in Javascript.</source>
          <target state="translated">일반 객체의 속성 순서는 Javascript의 복잡한 주제입니다.</target>
        </trans-unit>
        <trans-unit id="0efb52a164d2557eb51e9d57bef3b03f3cfa6ce2" translate="yes" xml:space="preserve">
          <source>Reflect.ownKeys</source>
          <target state="translated">Reflect.ownKeys</target>
        </trans-unit>
        <trans-unit id="8c7c6e0edbbe7036c351801472457895f35b7ca5" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;String&lt;/code&gt;- and &lt;code&gt;Symbol&lt;/code&gt;-keyed properties.</source>
          <target state="translated">&lt;code&gt;O&lt;/code&gt; 의 자체 &lt;code&gt;String&lt;/code&gt; 및 &lt;code&gt;Symbol&lt;/code&gt; 키 속성을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="073ddc07bb314332dd4af4685c8be8359a5e671a" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;String&lt;/code&gt;-keyed properties (&lt;em&gt;property names&lt;/em&gt;).</source>
          <target state="translated">&lt;code&gt;O&lt;/code&gt; 자체의 &lt;code&gt;String&lt;/code&gt; 키 속성 ( &lt;em&gt;속성 이름&lt;/em&gt; )을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cec74648d029ac27ae652baf8d58c1a15e7cb459" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;Symbol&lt;/code&gt;-keyed properties.</source>
          <target state="translated">&lt;code&gt;O&lt;/code&gt; 의 고유 한 &lt;code&gt;Symbol&lt;/code&gt; 키 속성을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="77f8e27f1eed61991843e7511c8740205287dc40" translate="yes" xml:space="preserve">
          <source>So, no you can't guarantee the order.</source>
          <target state="translated">따라서 주문을 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="9127c30b90d11e6061555ee1cae2d848f30da10c" translate="yes" xml:space="preserve">
          <source>Some exceptions include methods of enumerating inherited keys, such as the &lt;code&gt;for .. in&lt;/code&gt; loop. The &lt;code&gt;for .. in&lt;/code&gt; loop doesn't guarantee order according to the specification.</source>
          <target state="translated">&lt;code&gt;for .. in&lt;/code&gt; 루프와 같은 상속 된 키를 열거하는 메소드는 예외입니다. &lt;code&gt;for .. in&lt;/code&gt; 루프는 사양에 따른 순서를 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aeb78bd417a7768c123cd38651d774129e3176fc" translate="yes" xml:space="preserve">
          <source>Some older browsers combine categories #1 and #2, iterating all keys in insertion order. If your keys might parse as integers, it's best not to rely on any specific iteration order.</source>
          <target state="translated">일부 구형 브라우저는 카테고리 # 1과 # 2를 결합하여 모든 키를 삽입 순서대로 반복합니다. 키가 정수로 구문 분석 될 수있는 경우 특정 반복 순서에 의존하지 않는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bedb8cd8e036c17b94b5d6c22f537e6cd438946f" translate="yes" xml:space="preserve">
          <source>Sometimes, yes</source>
          <target state="translated">어쩔 땐 그래</target>
        </trans-unit>
        <trans-unit id="03696b013ec729f79ff55615110524b6d377d9c3" translate="yes" xml:space="preserve">
          <source>Standards always follow implementations, that's where XHR came from, and Google does the same thing by implementing Gears and then embracing equivalent HTML5 functionality.  The right fix is to have ECMA formally incorporate the de-facto standard behavior into the next rev of the spec.</source>
          <target state="translated">표준은 항상 XHR의 출처 인 구현을 따르며 Google은 Gears를 구현 한 다음 동등한 HTML5 기능을 수용함으로써 동일한 작업을 수행합니다. 올바른 수정은 ECMA가 사실상의 표준 동작을 사양의 다음 개정판에 공식적으로 통합하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="df387116de084996fa33cc5b4ccad3778e284d52" translate="yes" xml:space="preserve">
          <source>String keys, in insertion order (ES2015 guarantees this and all browsers comply)</source>
          <target state="translated">삽입 순서의 문자열 키 (ES2015는이 브라우저와 모든 브라우저가 준수 함을 보장합니다)</target>
        </trans-unit>
        <trans-unit id="369d7c7a7aad2cd01d5e02f587face2623161f7f" translate="yes" xml:space="preserve">
          <source>Symbol keys, in insertion order</source>
          <target state="translated">삽입 순서의 기호 키</target>
        </trans-unit>
        <trans-unit id="8454bd456035f63689f1f7538dbb3e71c5e28c85" translate="yes" xml:space="preserve">
          <source>Symbol names, in insertion order (ES2015 guarantees this and all browsers comply)</source>
          <target state="translated">삽입 순서의 기호 이름 (ES2015는이를 준수하며 모든 브라우저는이를 준수 함)</target>
        </trans-unit>
        <trans-unit id="a9ff19a745e63e404d88d621888c4ff8971c082e" translate="yes" xml:space="preserve">
          <source>Symbols in insertion order</source>
          <target state="translated">삽입 순서의 기호</target>
        </trans-unit>
        <trans-unit id="3b2092c1a98be999603f3c961d4be7889be676c3" translate="yes" xml:space="preserve">
          <source>That is, will the properties be in the same order that I added them?</source>
          <target state="translated">즉, 속성은 내가 추가 한 순서와 동일합니까?</target>
        </trans-unit>
        <trans-unit id="4d2de9daf855204938fd9e3b04c0ed0d327682b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMAScript specification&lt;/a&gt; used to say:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMAScript 사양&lt;/a&gt; 은 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="29fa3e4243bed714bd28cdcc5a439b305d27dff3" translate="yes" xml:space="preserve">
          <source>The actual question is very vague.</source>
          <target state="translated">실제 질문은 매우 모호합니다.</target>
        </trans-unit>
        <trans-unit id="d9bb6366ecce97d1a3154d5144e1244355d132c5" translate="yes" xml:space="preserve">
          <source>The answer is: it depends on a number of factors. In general, &lt;em&gt;no&lt;/em&gt;.</source>
          <target state="translated">답은 여러 가지 요소에 따라 다릅니다. 일반적으로.</target>
        </trans-unit>
        <trans-unit id="eb3112a8a32dbd36dfe4b46a1d1df283f2bffaf5" translate="yes" xml:space="preserve">
          <source>The following methods guarantee the order shown:</source>
          <target state="translated">다음 방법은 표시된 순서를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="b8bb19c6e5330bcaa59b97be556c1675a287f34b" translate="yes" xml:space="preserve">
          <source>The following methods/loops guarantee no order at all:</source>
          <target state="translated">다음 방법 / 루프는 전혀 순서를 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbdc2d4c67254f98b99f13c6b0dc25f2e511fb83" translate="yes" xml:space="preserve">
          <source>The iteration order for objects follows &lt;a href=&quot;https://stackoverflow.com/a/38218582/292500&quot;&gt;a certain set of rules&lt;/a&gt; since ES2015, but &lt;strong&gt;it does not (always) follow the insertion order&lt;/strong&gt;. Simply put, the iteration order is a combination of the insertion order for strings keys, and ascending order for number-like keys:</source>
          <target state="translated">ES2015 이후 개체의 반복 순서 &lt;a href=&quot;https://stackoverflow.com/a/38218582/292500&quot;&gt;는 특정 규칙 집합을&lt;/a&gt; 따르지만 &lt;strong&gt;항상 삽입 순서를 따르지 않습니다&lt;/strong&gt; . 간단히 말해서, 반복 순서는 문자열 키의 삽입 순서와 숫자와 같은 키의 오름차순의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="b4a4e6f068dfc6cd8381634fb9999b8edbd5d5cc" translate="yes" xml:space="preserve">
          <source>The keys in Map are ordered while keys added to object are not. Thus, when iterating over it, a Map object returns keys in order of insertion. (Note that in the ECMAScript 2015 spec objects do preserve creation order for string and Symbol keys, so traversal of an object with ie only string keys would yield keys in order of insertion)</source>
          <target state="translated">객체에 추가 된 키가 아닌 맵의 키가 정렬됩니다. 따라서 반복 할 때 Map 객체는 삽입 순서대로 키를 반환합니다. (ECMAScript 2015 사양 객체는 문자열 및 심볼 키의 생성 순서를 유지하므로 문자열 키만있는 객체의 순회는 삽입 순서에 따라 키를 생성합니다)</target>
        </trans-unit>
        <trans-unit id="ed7cecaff2b2b865d7552ddaf655c499e0ab0a33" translate="yes" xml:space="preserve">
          <source>The lack of specificity in ECMA-262 does not reflect reality. In discussion going back years, implementors have observed that there are some constraints on the behavior of for-in which anyone who wants to run code on the web needs to follow.</source>
          <target state="translated">ECMA-262의 특이성 부족은 현실을 반영하지 않습니다. 몇 년 전 토론에서 구현 자들은 웹에서 코드를 실행하려는 사람이 따라야하는 for-in의 동작에 일부 제약이 있음을 관찰했습니다.</target>
        </trans-unit>
        <trans-unit id="99cdafe7bfb6d937df7209d8848443a7e20e02fd" translate="yes" xml:space="preserve">
          <source>The mechanics and order of enumerating the properties ... is not specified.</source>
          <target state="translated">속성을 열거하는 메커니즘과 순서는 지정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="111c3077a9bab7d0eb66f628b1f52704d6558d5c" translate="yes" xml:space="preserve">
          <source>The order is defined in the spec, under the abstract operation &lt;a href=&quot;https://www.ecma-international.org/ecma-262/9.0/index.html#sec-ordinaryownpropertykeys&quot;&gt;OrdinaryOwnPropertyKeys&lt;/a&gt;, which underpins all methods of iterating over an object's own keys. Paraphrased, the order is as follows:</source>
          <target state="translated">순서는 추상 조작 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/9.0/index.html#sec-ordinaryownpropertykeys&quot;&gt;OrdinaryOwnPropertyKeys&lt;/a&gt; 아래의 스펙에 정의되어 오브젝트 자체의 키를 반복하는 모든 메소드를 뒷받침합니다. 해석하면 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10e68ba3d24da3f1a6c55e57fc43a01f2310bb93" translate="yes" xml:space="preserve">
          <source>The order is essentially: integer-like &lt;code&gt;Strings&lt;/code&gt; in ascending order, non-integer-like &lt;code&gt;Strings&lt;/code&gt; in creation order, Symbols in creation order. Depending which function invokes this, some of these types may not be included.</source>
          <target state="translated">순서는 본질적으로 오름차순의 정수형 &lt;code&gt;Strings&lt;/code&gt; , 작성 순서의 정수가 아닌 문자열 , 작성 순서의 기호입니다. 어떤 함수가이를 호출하는지에 따라 이러한 유형 중 일부는 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3287cf2d6f8c1f23bb792abaeefb0a8c1cbeba7" translate="yes" xml:space="preserve">
          <source>The order of keys in an object wasn't guaranteed until ES2015. It was implementation-defined.</source>
          <target state="translated">ES2015까지는 객체의 키 순서가 보장되지 않았습니다. 구현 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="cc78fa8b6dadd0f1f48d48f9402a99419d560fbd" translate="yes" xml:space="preserve">
          <source>The question is, for what methods this order is guaranteed in the ES2015 spec?</source>
          <target state="translated">문제는 ES2015 사양 에서이 순서가 보장되는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a5b1e52a5ac36573960704b3789b1a8d268ccf5a" translate="yes" xml:space="preserve">
          <source>The specific language is that keys are returned in the following order:</source>
          <target state="translated">특정 언어는 키가 다음 순서로 반환된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0dce972e73d0a4fac0a155ed2f727b3110d2cad9" translate="yes" xml:space="preserve">
          <source>There are a few weird cases which implementations currently do &lt;em&gt;not&lt;/em&gt; agree on, and in such cases, the resulting order will continue be unspecified. For property order &lt;a href=&quot;https://github.com/tc39/proposal-for-in-order#a-conservative-underapproximation-of-interop-semantics&quot;&gt;to be guaranteed&lt;/a&gt;:</source>
          <target state="translated">구현이 현재 동의하지 &lt;em&gt;않는&lt;/em&gt; 몇 가지 이상한 경우가 있으며,이 경우 결과 순서는 지정되지 않습니다. 부동산 주문 &lt;a href=&quot;https://github.com/tc39/proposal-for-in-order#a-conservative-underapproximation-of-interop-semantics&quot;&gt;이 보장&lt;/a&gt; 되려면 :</target>
        </trans-unit>
        <trans-unit id="55b19b14da72f8c7f30f65d3c0821fb28bb19664" translate="yes" xml:space="preserve">
          <source>This is what pretty much every implementation does already, but the new proposal will make it official.</source>
          <target state="translated">이것은 거의 모든 구현이 이미 수행하고 있지만 새로운 제안으로 공식화 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="49f03181403db0a6631b9c892e5eb9016ddb9775" translate="yes" xml:space="preserve">
          <source>This results in the following order (in certain cases):</source>
          <target state="translated">결과는 다음과 같습니다 (특정 경우).</target>
        </trans-unit>
        <trans-unit id="2a2d2ebbf23e9e14a50e49a2ebb2718a4d31e0ae" translate="yes" xml:space="preserve">
          <source>This way you can use a regular for loop and have the insert order. You could then use the Array sort method to sort this into a new array if needed.</source>
          <target state="translated">이런 식으로 정규 for 루프를 사용하고 삽입 순서를 가질 수 있습니다. 그런 다음 Array sort 메소드를 사용하여 필요한 경우 새 배열로 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db70c450e37560ad700c843433664c3f72d27c97" translate="yes" xml:space="preserve">
          <source>This whole answer is in the context of spec compliance, not what any engine does at a particular moment or historically.</source>
          <target state="translated">이 전체 답변은 특정 순간이나 역사적으로 엔진이하는 것이 아니라 사양 준수의 맥락에 있습니다.</target>
        </trans-unit>
        <trans-unit id="36e7408731ad7eda18219f4f3ecf847b4d50bd86" translate="yes" xml:space="preserve">
          <source>Thus, in order to take &lt;code&gt;Object.keys(valueFromStore)&lt;/code&gt; I used &lt;code&gt;Object.keys(valueFromStore).sort()&lt;/code&gt;, so that I at least now have an alphabetical order for the keys.</source>
          <target state="translated">따라서 &lt;code&gt;Object.keys(valueFromStore)&lt;/code&gt; 를 가져 오기 위해 &lt;code&gt;Object.keys(valueFromStore).sort()&lt;/code&gt; 를 사용하여 적어도 키의 알파벳 순서를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6c15ca0416904aeea36408d198c5a736ea187af3" translate="yes" xml:space="preserve">
          <source>Thus, there are three segments, which may alter the insertion order (as happened in the example). And integer-like keys don't stick to the insertion order at all.</source>
          <target state="translated">따라서 삽입 순서를 변경할 수있는 세 개의 세그먼트가 있습니다 (예제에서와 같이). 그리고 정수와 같은 키는 삽입 순서에 전혀 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42f21f6edccf6b7e965aa6753e10344cefc870e1" translate="yes" xml:space="preserve">
          <source>Using React with Redux, the state container of which's keys I want to traverse in order to generate children is refreshed everytime the store is changed (as per Redux's immutability concepts).</source>
          <target state="translated">Redux와 함께 React를 사용하면 하위를 생성하기 위해 통과하려는 키의 상태 컨테이너가 저장소가 변경 될 때마다 (Reux의 불변성 개념에 따라) 새로 고쳐집니다.</target>
        </trans-unit>
        <trans-unit id="158b0728eeda2f2e43e242eab00a657882339035" translate="yes" xml:space="preserve">
          <source>Using an array or a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;&lt;code&gt;Map&lt;/code&gt; object&lt;/a&gt; can be a better way to achieve this. &lt;code&gt;Map&lt;/code&gt; shares some similarities with &lt;code&gt;Object&lt;/code&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_and_maps_compared&quot;&gt;guarantees the keys to be iterated in order of insertion&lt;/a&gt;, without exception:</source>
          <target state="translated">이를 위해서는 배열 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; 객체를&lt;/a&gt; 사용하는 것이 더 좋습니다. &lt;code&gt;Map&lt;/code&gt; 은 &lt;code&gt;Object&lt;/code&gt; 와 일부 유사점을 공유하며 예외없이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_and_maps_compared&quot;&gt;삽입 순서대로 키가 반복되도록합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="717e9d7bd21b2bf25179048c23b8139ebca1d0df" translate="yes" xml:space="preserve">
          <source>While in ES5 explicitly no order has been specified, ES2015 has an order in certain cases. Given is the following object:</source>
          <target state="translated">ES5에서는 명시 적으로 주문이 지정되어 있지 않지만 ES2015는 특정 주문이 있습니다. 다음과 같은 객체가 주어진다 :</target>
        </trans-unit>
        <trans-unit id="2c4f5a24bafe473e423771440ba63f17544d239e" translate="yes" xml:space="preserve">
          <source>Will the resulting object &lt;em&gt;always&lt;/em&gt; look like this?</source>
          <target state="translated">결과 객체는 &lt;em&gt;항상 이런&lt;/em&gt; 모양입니까?</target>
        </trans-unit>
        <trans-unit id="64e3dd86e22797f5de12c4dcc57dae70834e7300" translate="yes" xml:space="preserve">
          <source>for..in</source>
          <target state="translated">for..in</target>
        </trans-unit>
        <trans-unit id="139528a85e8b998035ad6a5c85b4e51ace8b55c2" translate="yes" xml:space="preserve">
          <source>integer-like keys in ascending order</source>
          <target state="translated">정수형 키 (오름차순)</target>
        </trans-unit>
        <trans-unit id="4412ac0ae820171fd5f4fb0263ad6679aaf6cf9c" translate="yes" xml:space="preserve">
          <source>normal keys in insertion order</source>
          <target state="translated">삽입 순서의 일반 키</target>
        </trans-unit>
        <trans-unit id="41d84f4f169439986c15f630c7f2198df104449c" translate="yes" xml:space="preserve">
          <source>will the properties be in the same order that I added them</source>
          <target state="translated">속성을 내가 추가 한 순서와 동일하게</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
