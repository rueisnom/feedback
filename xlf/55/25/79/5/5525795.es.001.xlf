<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/5525795">
    <body>
      <group id="5525795">
        <trans-unit id="da3687cfe7631d821ba35f4e012caced3b66cd22" translate="yes" xml:space="preserve">
          <source>(emphasis mine).</source>
          <target state="translated">(énfasis mío).</target>
        </trans-unit>
        <trans-unit id="506a92cc597c8229d7c4a2bed4f4e9b88c6d9d1b" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; [the object being iterated] that is an integer index, in ascending numeric index order</source>
          <target state="translated">... cada clave de propiedad propia &lt;code&gt;P&lt;/code&gt; de &lt;code&gt;O&lt;/code&gt; [el objeto que se est&amp;aacute; iterando] que es un &amp;iacute;ndice entero, en orden de &amp;iacute;ndice num&amp;eacute;rico ascendente</target>
        </trans-unit>
        <trans-unit id="b1431eb62a77c3957a1a90ad8c2ee19b35d73184" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; that is a String but is not an integer index, in property creation order</source>
          <target state="translated">... cada clave de propiedad propia &lt;code&gt;P&lt;/code&gt; de &lt;code&gt;O&lt;/code&gt; que es una cadena pero no un &amp;iacute;ndice entero, en orden de creaci&amp;oacute;n de propiedades</target>
        </trans-unit>
        <trans-unit id="41f72be3edc7209f752acd3f28c3b1078665a04e" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; that is a Symbol, in property creation order</source>
          <target state="translated">... cada clave de propiedad propia &lt;code&gt;P&lt;/code&gt; de &lt;code&gt;O&lt;/code&gt; que es un s&amp;iacute;mbolo, en orden de creaci&amp;oacute;n de propiedad</target>
        </trans-unit>
        <trans-unit id="617676d9406eee86e16ed250ff2bd786d055b06f" translate="yes" xml:space="preserve">
          <source>4.3.3 Object</source>
          <target state="translated">4.3.3 Objeto</target>
        </trans-unit>
        <trans-unit id="629e86072909febc69cff039b31e251bfb5bcef7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;, &lt;code&gt;Reflect.ownKeys()&lt;/code&gt;, &lt;code&gt;Object.getOwnPropertySymbols(O)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt; , &lt;code&gt;Reflect.ownKeys()&lt;/code&gt; , &lt;code&gt;Object.getOwnPropertySymbols(O)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="906437decdad0d2084e279baa2e2d923b430539c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.keys&lt;/code&gt;, &lt;code&gt;Object.values&lt;/code&gt;, &lt;code&gt;Object.entries&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.keys&lt;/code&gt; , &lt;code&gt;Object.values&lt;/code&gt; , &lt;code&gt;Object.entries&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac72976f1fd79543ad7172b5c48fa8ec5cc520a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..in&lt;/code&gt; loops</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; bucles</target>
        </trans-unit>
        <trans-unit id="3f7356ed9c8dad2efb0205e5f9f24151517669d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In what context?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;iquest;En que contexto?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d30fe30d4258ac32279a10fad11a23661e24d1fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But, soon (probably in ES2020), property order for these previously untrustworthy methods &lt;em&gt;will&lt;/em&gt; be guaranteed by the specification&lt;/strong&gt; to be iterated over in the same deterministic manner as the others, due to to the &lt;a href=&quot;https://github.com/tc39/proposals/blob/master/finished-proposals.md&quot;&gt;stage 4&lt;/a&gt; proposal: &lt;a href=&quot;http://tc39.es/proposal-for-in-order/&quot;&gt;For-in enumeration order&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Pero, pronto (probablemente en ES2020), la especificaci&amp;oacute;n garantizar&amp;aacute; que el orden de propiedad para estos m&amp;eacute;todos previamente no confiables &lt;em&gt;se&lt;/em&gt; repita de&lt;/strong&gt; la misma manera determinista que los dem&amp;aacute;s, debido a la propuesta de la &lt;a href=&quot;https://github.com/tc39/proposals/blob/master/finished-proposals.md&quot;&gt;etapa 4&lt;/a&gt; : &lt;a href=&quot;http://tc39.es/proposal-for-in-order/&quot;&gt;orden de enumeraci&amp;oacute;n for-in&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43cf735af1addba43cf6135a9e6cd5fd77f69b83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusion: Even in ES2015 you shouldn't rely on the property order of normal objects in Javascript. It is prone to errors. Use &lt;code&gt;Map&lt;/code&gt; instead.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusi&amp;oacute;n: Incluso en ES2015, no debe confiar en el orden de propiedad de los objetos normales en Javascript.&lt;/strong&gt; &lt;strong&gt;Es propenso a errores.&lt;/strong&gt; &lt;strong&gt;Use el &lt;code&gt;Map&lt;/code&gt; a en su lugar.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be9ffe71c53127990a370c8d47eb77ce87f4c69b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Current Language Spec (since ES2015)&lt;/strong&gt; insertion order is preserved, except in the case of keys that parse as integers (eg &quot;7&quot; or &quot;99&quot;), where behavior varies between browsers. For example, Chrome/V8 does not respect insertion order when the keys are parse as numeric.</source>
          <target state="translated">&lt;strong&gt;El&lt;/strong&gt; orden de inserci&amp;oacute;n de la &lt;strong&gt;especificaci&amp;oacute;n de idioma actual (desde ES2015)&lt;/strong&gt; se conserva, excepto en el caso de claves que se analizan como enteros (por ejemplo, &quot;7&quot; o &quot;99&quot;), donde el comportamiento var&amp;iacute;a entre los navegadores. Por ejemplo, Chrome / V8 no respeta el orden de inserci&amp;oacute;n cuando las claves se analizan como num&amp;eacute;ricas.</target>
        </trans-unit>
        <trans-unit id="8c848754eb60df7eadf93fb71befdc94139eef6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Old Language Spec (before ES2015)&lt;/strong&gt;: Iteration order was technically undefined, but all major browsers complied with the ES2015 behavior.</source>
          <target state="translated">&lt;strong&gt;Especificaci&amp;oacute;n de idioma antiguo (antes de ES2015)&lt;/strong&gt; : el orden de iteraci&amp;oacute;n era t&amp;eacute;cnicamente indefinido, pero todos los principales navegadores cumpl&amp;iacute;an con el comportamiento de ES2015.</target>
        </trans-unit>
        <trans-unit id="a5cabd9db5130fe850fc14a9f035d862d77edcae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;YES (for non-integer keys).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;S&amp;Iacute; (para claves no enteras).&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ddc2dc2dbcd4516457a87d0f7f30c97209aab02" translate="yes" xml:space="preserve">
          <source>A Map object can iterate its elements in insertion order...</source>
          <target state="translated">Un objeto del mapa puede iterar sus elementos en orden de inserción...</target>
        </trans-unit>
        <trans-unit id="8272a49555285dae357452d8b3518864897ab434" translate="yes" xml:space="preserve">
          <source>All &lt;em&gt;integer index&lt;/em&gt; keys (stuff like &lt;code&gt;&quot;1123&quot;&lt;/code&gt;, &lt;code&gt;&quot;55&quot;&lt;/code&gt;, etc) in ascending numeric order.</source>
          <target state="translated">Todas las claves de &lt;em&gt;&amp;iacute;ndice de enteros&lt;/em&gt; (cosas como &lt;code&gt;&quot;1123&quot;&lt;/code&gt; , &lt;code&gt;&quot;55&quot;&lt;/code&gt; , etc.) en orden num&amp;eacute;rico ascendente.</target>
        </trans-unit>
        <trans-unit id="6d0d086e05c3f95500e0ef71cccca3dcbbf3ee81" translate="yes" xml:space="preserve">
          <source>All other non-Symbol keys, in insertion order</source>
          <target state="translated">Todas las demás teclas que no son de símbolos,en orden de inserción</target>
        </trans-unit>
        <trans-unit id="6931239bebc33c69fddecf7cf1a400bef63e3d2e" translate="yes" xml:space="preserve">
          <source>All string keys which are not integer indices, in order of creation (oldest-first).</source>
          <target state="translated">Todas las claves de cadena que no son índices enteros,en orden de creación (primero el más antiguo).</target>
        </trans-unit>
        <trans-unit id="9cc7882625e1fa1848c2d4d2d56f6e182d7ff836" translate="yes" xml:space="preserve">
          <source>All symbol keys, in order of creation (oldest-first).</source>
          <target state="translated">Todas las claves de los símbolos,en orden de creación (el más antiguo primero).</target>
        </trans-unit>
        <trans-unit id="d99ee358a61be9c08f8e3663248de7c6ea7386a1" translate="yes" xml:space="preserve">
          <source>Although the current specification leaves for..in iteration order &quot;&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-enumerate-object-properties&quot;&gt;almost totally unspecified&lt;/a&gt;, real engines tend to be more consistent:&quot;</source>
          <target state="translated">Aunque la especificaci&amp;oacute;n actual deja ... en orden de iteraci&amp;oacute;n &quot; &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-enumerate-object-properties&quot;&gt;casi totalmente sin especificar&lt;/a&gt; , los motores reales tienden a ser m&amp;aacute;s consistentes:&quot;</target>
        </trans-unit>
        <trans-unit id="9f541eac51b245397dfc1dd505657af7d28c26b2" translate="yes" xml:space="preserve">
          <source>An object is a member of the
  type Object. &lt;strong&gt;It is an unordered collection of properties&lt;/strong&gt; each of which
  contains a primitive value, object, or
  function. A function stored in a
  property of an object is called a
  method.</source>
          <target state="translated">Un objeto es un miembro del tipo Objeto. &lt;strong&gt;Es una colecci&amp;oacute;n desordenada de propiedades,&lt;/strong&gt; cada una de las cuales contiene un valor primitivo, objeto o funci&amp;oacute;n. Una funci&amp;oacute;n almacenada en una propiedad de un objeto se llama m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="3f1e99d603dc8c534f17c37e7680125db1255ec4" translate="yes" xml:space="preserve">
          <source>An object is an &lt;strong&gt;unordered&lt;/strong&gt; collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array.</source>
          <target state="translated">Un objeto es una colecci&amp;oacute;n &lt;strong&gt;desordenada&lt;/strong&gt; de cero o m&amp;aacute;s pares de nombre / valor, donde un nombre es una cadena y un valor es una cadena, n&amp;uacute;mero, booleano, nulo, objeto o matriz.</target>
        </trans-unit>
        <trans-unit id="0ce441a742a81f4f9ec981fd12c2ec069bde986b" translate="yes" xml:space="preserve">
          <source>As a note, properties order in objects weren&amp;rsquo;t guaranteed at all before ES2015. Definition of an Object from &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf&quot;&gt;ECMAScript Third Edition (pdf)&lt;/a&gt;:</source>
          <target state="translated">Como nota, el orden de las propiedades en los objetos no estaba garantizado antes de ES2015. Definici&amp;oacute;n de un objeto de &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf&quot;&gt;ECMAScript Tercera edici&amp;oacute;n (pdf)&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="89359f1939ff8169993255536817a0eeb023f70f" translate="yes" xml:space="preserve">
          <source>As of ES2015, property order is guaranteed for certain methods that iterate over properties. &lt;a href=&quot;https://stackoverflow.com/a/30919039/&quot;&gt;but not others&lt;/a&gt;. Unfortunately, the methods which are not guaranteed to have an order are generally the most often used:</source>
          <target state="translated">A partir de ES2015, el orden de las propiedades est&amp;aacute; garantizado para ciertos m&amp;eacute;todos que iteran sobre las propiedades. &lt;a href=&quot;https://stackoverflow.com/a/30919039/&quot;&gt;Pero no otros&lt;/a&gt; . Desafortunadamente, los m&amp;eacute;todos que no se garantiza que tengan un pedido son generalmente los m&amp;aacute;s utilizados:</target>
        </trans-unit>
        <trans-unit id="f0701b9ee5dc8738764e68bb472acd3938023043" translate="yes" xml:space="preserve">
          <source>As others have stated, you have no guarantee as to the order when you iterate over the properties of an object. If you need an ordered list of multiple fields I suggested creating an array of objects.</source>
          <target state="translated">Como otros han afirmado,no se tiene ninguna garantía en cuanto al orden cuando se itera sobre las propiedades de un objeto.Si necesitas una lista ordenada de múltiples campos,sugerí crear un conjunto de objetos.</target>
        </trans-unit>
        <trans-unit id="4444585e7d19b4c0af133a98d6096e8c852f3f8b" translate="yes" xml:space="preserve">
          <source>At the time of writing, most browsers did return properties in the same order as they were inserted, but it was explicitly not guaranteed behaviour so shouldn't have been relied upon.</source>
          <target state="translated">En el momento de escribir este artículo,la mayoría de los navegadores devolvían las propiedades en el mismo orden en que fueron insertadas,pero no se garantizaba explícitamente su comportamiento,por lo que no se debería haber confiado en él.</target>
        </trans-unit>
        <trans-unit id="98f97678eae35879cc93487177bce8991d7bde31" translate="yes" xml:space="preserve">
          <source>Because every implementation already iterates over properties predictably, it can be put into the specification without breaking backwards compatibility.</source>
          <target state="translated">Debido a que cada implementación ya itera sobre las propiedades de manera predecible,se puede poner en la especificación sin romper la compatibilidad hacia atrás.</target>
        </trans-unit>
        <trans-unit id="1ac1c2bd0aec0e13d9c387f83cc8b463ba74df8f" translate="yes" xml:space="preserve">
          <source>Developer mozilla &amp;gt; Map</source>
          <target state="translated">Desarrollador mozilla&amp;gt; Mapa</target>
        </trans-unit>
        <trans-unit id="099a01ed9dd31f9684e8375f7034b12c3bb1a630" translate="yes" xml:space="preserve">
          <source>Does JavaScript Guarantee Object Property Order</source>
          <target state="translated">¿JavaScript garantiza el orden de propiedad de los objetos</target>
        </trans-unit>
        <trans-unit id="cc80c2d78cd6d75a58d4466354ff030d12c0c74d" translate="yes" xml:space="preserve">
          <source>ES2015 compliant engine</source>
          <target state="translated">Motor compatible con ES2015</target>
        </trans-unit>
        <trans-unit id="0acc2d215fca04ea6cc5ff432bfc48e007f86d3f" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot;&gt;JSON standard&lt;/a&gt;:</source>
          <target state="translated">Del &lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot;&gt;est&amp;aacute;ndar JSON&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2a4e536fd55e0da3c613262b2b50225cf7c78b01" translate="yes" xml:space="preserve">
          <source>Generally, no</source>
          <target state="translated">Generalmente,no</target>
        </trans-unit>
        <trans-unit id="4226982480d45f93dd459e9b1117c39c199447db" translate="yes" xml:space="preserve">
          <source>Here is where you can count on property key order for plain &lt;code&gt;Objects&lt;/code&gt;:</source>
          <target state="translated">Aqu&amp;iacute; es donde puede contar con el orden de las claves de propiedad para &lt;code&gt;Objects&lt;/code&gt; simples:</target>
        </trans-unit>
        <trans-unit id="52147a0993d04e70a8e544d610fb45da923bbc68" translate="yes" xml:space="preserve">
          <source>However in ES2015 and later non-integer keys will be returned in insertion order.</source>
          <target state="translated">Sin embargo en ES2015 y posteriores las claves no enteras serán devueltas en orden de inserción.</target>
        </trans-unit>
        <trans-unit id="4961c2d8675f28a3fc5ef4a18b41c9201056b692" translate="yes" xml:space="preserve">
          <source>However, in ES2015 in &lt;em&gt;was&lt;/em&gt; specified. Like many things in JavaScript, this was done for compatibility purposes and generally reflected an existing unofficial standard among most JS engines (with you-know-who being an exception).</source>
          <target state="translated">Sin embargo, en ES2015 &lt;em&gt;se&lt;/em&gt; especific&amp;oacute; en. Al igual que muchas cosas en JavaScript, esto se hizo con fines de compatibilidad y, en general, reflejaba un est&amp;aacute;ndar no oficial existente entre la mayor&amp;iacute;a de los motores JS (con una excepci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="b0828e60d703c26f73af1747c4d90e291c0a0d65" translate="yes" xml:space="preserve">
          <source>If I create an object like this:</source>
          <target state="translated">Si creo un objeto como este:</target>
        </trans-unit>
        <trans-unit id="faabc3e0f5d76ebc58393833b7e692b3510ba07c" translate="yes" xml:space="preserve">
          <source>If you're interested in ordered maps you should consider using the &lt;code&gt;Map&lt;/code&gt; type introduced in ES2015 instead of plain &lt;code&gt;Objects&lt;/code&gt;.</source>
          <target state="translated">Si est&amp;aacute; interesado en los mapas ordenados, deber&amp;iacute;a considerar usar el tipo de &lt;code&gt;Map&lt;/code&gt; a introducido en ES2015 en lugar de &lt;code&gt;Objects&lt;/code&gt; simples.</target>
        </trans-unit>
        <trans-unit id="b627572cf43af1c9edcc2a011b2dbb4addc1a4f5" translate="yes" xml:space="preserve">
          <source>In ES2015, it does, but not to what you might think</source>
          <target state="translated">En ES2015,lo hace,pero no a lo que podrías pensar</target>
        </trans-unit>
        <trans-unit id="c53c091a8a1dc6a4941c3d127b1c3f5926252001" translate="yes" xml:space="preserve">
          <source>In all cases these methods include non-enumerable property keys and order keys as specified by &lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt; (see below). They differ in the type of key values they include (&lt;code&gt;String&lt;/code&gt; and / or &lt;code&gt;Symbol&lt;/code&gt;). In this context &lt;code&gt;String&lt;/code&gt; includes integer values.</source>
          <target state="translated">En todos los casos, estos m&amp;eacute;todos incluyen claves de propiedad no enumerables y claves de pedido seg&amp;uacute;n lo especificado por &lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt; (ver m&amp;aacute;s abajo). Difieren en el tipo de valores clave que incluyen ( &lt;code&gt;String&lt;/code&gt; y / o &lt;code&gt;Symbol&lt;/code&gt; ). En este contexto, la &lt;code&gt;String&lt;/code&gt; incluye valores enteros.</target>
        </trans-unit>
        <trans-unit id="a66377df8463c41ca80dbcbc5b839a498d9c49dd" translate="yes" xml:space="preserve">
          <source>In modern browsers you can use the &lt;code&gt;Map&lt;/code&gt; data structure instead of a object.</source>
          <target state="translated">En los navegadores modernos, puede usar la estructura de datos del &lt;code&gt;Map&lt;/code&gt; a en lugar de un objeto.</target>
        </trans-unit>
        <trans-unit id="149f5ce9ce098e7b86f9afc0516dad29d57de442" translate="yes" xml:space="preserve">
          <source>Integer keys in ascending order (and strings like &quot;1&quot; that parse as ints)</source>
          <target state="translated">Teclas enteras en orden ascendente (y cadenas como &quot;1&quot; que se analizan como ints)</target>
        </trans-unit>
        <trans-unit id="ee46467fe2fdf494dcc7270423065b1d077f30f2" translate="yes" xml:space="preserve">
          <source>It's silly to say that the order is unreliable - it is reliable, it's just probably not what you want, and modern browsers implement this order correctly.</source>
          <target state="translated">Es una tontería decir que el orden no es fiable-es fiable,probablemente no es lo que quieres,y los navegadores modernos implementan este orden correctamente.</target>
        </trans-unit>
        <trans-unit id="64b5375f0360e9044ba38df47f55f6d563d59252" translate="yes" xml:space="preserve">
          <source>JSON.parse</source>
          <target state="translated">JSON.parse</target>
        </trans-unit>
        <trans-unit id="3898286ce044bc87123989a97e0cdf2ef51669ae" translate="yes" xml:space="preserve">
          <source>JSON.stringify</source>
          <target state="translated">JSON.stringify</target>
        </trans-unit>
        <trans-unit id="b266d7c42c66244150bfc03d76098bb073e86d28" translate="yes" xml:space="preserve">
          <source>Just found this out the hard way.</source>
          <target state="translated">Acabo de descubrir esto de la manera difícil.</target>
        </trans-unit>
        <trans-unit id="8e16c53d1bbc95155c6ceb4bb722f567d58cc184" translate="yes" xml:space="preserve">
          <source>Just like with the methods which have a guaranteed iteration order (like &lt;code&gt;Reflect.ownKeys&lt;/code&gt; and &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;), the previously-unspecified methods will also iterate in the following order:</source>
          <target state="translated">Al igual que con los m&amp;eacute;todos que tienen un orden de iteraci&amp;oacute;n garantizado (como &lt;code&gt;Reflect.ownKeys&lt;/code&gt; y &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt; ), los m&amp;eacute;todos no especificados previamente tambi&amp;eacute;n iterar&amp;aacute;n en el siguiente orden:</target>
        </trans-unit>
        <trans-unit id="4dda5a1c505242ff9f21a80d9c0ec24fcd977189" translate="yes" xml:space="preserve">
          <source>Most Browsers iterate object properties as:</source>
          <target state="translated">La mayoría de los navegadores iteran las propiedades de los objetos como:</target>
        </trans-unit>
        <trans-unit id="eca0d6e5ddb7e8e19c66b315455277ac55d52648" translate="yes" xml:space="preserve">
          <source>Neither the object being iterated nor anything in its prototype chain is a proxy, typed array, module namespace object, or host exotic object.</source>
          <target state="translated">Ni el objeto que se está iterando ni nada en su cadena de prototipos es un proxy,una matriz mecanografiada,un objeto de espacio de nombres de módulos o un objeto exótico anfitrión.</target>
        </trans-unit>
        <trans-unit id="1d4ab0a6df04c34dd48b584b2a415ab43129c02b" translate="yes" xml:space="preserve">
          <source>Neither the object nor anything in its prototype chain has a property deleted during iteration.</source>
          <target state="translated">Ni el objeto ni nada en su cadena de prototipos tiene una propiedad borrada durante la iteración.</target>
        </trans-unit>
        <trans-unit id="4dc6577720fdc085f0e42c0d8290ba58b994327e" translate="yes" xml:space="preserve">
          <source>Neither the object nor anything in its prototype chain has its prototype change during iteration.</source>
          <target state="translated">Ni el objeto ni nada en su cadena de prototipos tiene su prototipo cambiado durante la iteración.</target>
        </trans-unit>
        <trans-unit id="0e995b5f9a057b2527e1b6be18d9f747fa5a5ffe" translate="yes" xml:space="preserve">
          <source>No non-enumerable property shadows an enumerable one.</source>
          <target state="translated">Ningún bien no numerable ensombrece a uno enumerable.</target>
        </trans-unit>
        <trans-unit id="d658441f85cb60696e476538b61044fc4858c1a6" translate="yes" xml:space="preserve">
          <source>No property of the object or anything in its prototype chain has its enumerability change during iteration.</source>
          <target state="translated">Ninguna propiedad del objeto o de cualquier cosa en su cadena de prototipos tiene su cambio de enumeración durante la iteración.</target>
        </trans-unit>
        <trans-unit id="89c320a56b18231c4a841ab136d9db9f9cc15237" translate="yes" xml:space="preserve">
          <source>Note that the ES2015 behavior was a good example of the language spec being driven by existing behavior, and not the other way round. To get a deeper sense of that backwards-compatibility mindset, see &lt;a href=&quot;http://code.google.com/p/v8/issues/detail?id=164&quot;&gt;http://code.google.com/p/v8/issues/detail?id=164&lt;/a&gt;, a Chrome bug that covers in detail the design decisions behind Chrome's iteration order behavior.
Per one of the (rather opinionated) comments on that bug report:</source>
          <target state="translated">Tenga en cuenta que el comportamiento de ES2015 fue un buen ejemplo de la especificaci&amp;oacute;n del lenguaje impulsada por el comportamiento existente, y no al rev&amp;eacute;s. Para tener una idea m&amp;aacute;s profunda de esa mentalidad de compatibilidad con versiones anteriores, consulte &lt;a href=&quot;http://code.google.com/p/v8/issues/detail?id=164&quot;&gt;http://code.google.com/p/v8/issues/detail?id=164&lt;/a&gt; , un error de Chrome que cubre en detalle las decisiones de dise&amp;ntilde;o detr&amp;aacute;s del comportamiento de orden de iteraci&amp;oacute;n de Chrome . Seg&amp;uacute;n uno de los comentarios (bastante obstinados) sobre ese informe de error:</target>
        </trans-unit>
        <trans-unit id="a4d61c2f54a1ad70200ca0ee70c2977c4eb1f610" translate="yes" xml:space="preserve">
          <source>Nothing in the object's prototype chain has a property added during iteration.</source>
          <target state="translated">Nada en la cadena del prototipo del objeto tiene una propiedad añadida durante la iteración.</target>
        </trans-unit>
        <trans-unit id="0194eee4f03b556be8832cea08ed12de31c2d9b2" translate="yes" xml:space="preserve">
          <source>Numeric array keys, in ascending numeric order</source>
          <target state="translated">Teclas de matriz numérica,en orden numérico ascendente</target>
        </trans-unit>
        <trans-unit id="1d51672345557c0f022fd737f9b7489d16b30459" translate="yes" xml:space="preserve">
          <source>Object.assign</source>
          <target state="translated">Object.assign</target>
        </trans-unit>
        <trans-unit id="792a27c424ad52e5a9356f3722643e927041e20f" translate="yes" xml:space="preserve">
          <source>Object.defineProperties</source>
          <target state="translated">Object.defineProperties</target>
        </trans-unit>
        <trans-unit id="a37c98a6f5f7ca5863f83538b43a1b90ce0f8d42" translate="yes" xml:space="preserve">
          <source>Object.getOwnPropertyNames</source>
          <target state="translated">Object.getOwnPropertyNames</target>
        </trans-unit>
        <trans-unit id="1061044277b2b1b91a3ad9fd72b96a926df8e0ad" translate="yes" xml:space="preserve">
          <source>Object.getOwnPropertySymbols</source>
          <target state="translated">Object.getOwnPropertySymbols</target>
        </trans-unit>
        <trans-unit id="c5a933e00dc39b7be5f3039f9caf7a7ff8b476c8" translate="yes" xml:space="preserve">
          <source>Object.keys</source>
          <target state="translated">Object.keys</target>
        </trans-unit>
        <trans-unit id="9766dcc2678dca29aca27b7034272c421f110e70" translate="yes" xml:space="preserve">
          <source>Own properties</source>
          <target state="translated">Propiedades propias</target>
        </trans-unit>
        <trans-unit id="2ea9d512846684027cf3f09daee60e1b4fb1823d" translate="yes" xml:space="preserve">
          <source>Property order in normal Objects is a complex subject in Javascript.</source>
          <target state="translated">El orden de las propiedades en los objetos normales es un tema complejo en Javascript.</target>
        </trans-unit>
        <trans-unit id="0efb52a164d2557eb51e9d57bef3b03f3cfa6ce2" translate="yes" xml:space="preserve">
          <source>Reflect.ownKeys</source>
          <target state="translated">Reflect.ownKeys</target>
        </trans-unit>
        <trans-unit id="8c7c6e0edbbe7036c351801472457895f35b7ca5" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;String&lt;/code&gt;- and &lt;code&gt;Symbol&lt;/code&gt;-keyed properties.</source>
          <target state="translated">Devuelve las propiedades de &lt;code&gt;String&lt;/code&gt; y &lt;code&gt;Symbol&lt;/code&gt; O propias.</target>
        </trans-unit>
        <trans-unit id="073ddc07bb314332dd4af4685c8be8359a5e671a" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;String&lt;/code&gt;-keyed properties (&lt;em&gt;property names&lt;/em&gt;).</source>
          <target state="translated">Devuelve las propiedades de &lt;code&gt;O&lt;/code&gt; ' &lt;code&gt;String&lt;/code&gt; -keyed ( &lt;em&gt;nombres de propiedad&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="cec74648d029ac27ae652baf8d58c1a15e7cb459" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;Symbol&lt;/code&gt;-keyed properties.</source>
          <target state="translated">Devuelve las propiedades propias de &lt;code&gt;O&lt;/code&gt; - &lt;code&gt;Symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77f8e27f1eed61991843e7511c8740205287dc40" translate="yes" xml:space="preserve">
          <source>So, no you can't guarantee the order.</source>
          <target state="translated">Así que no,no puedes garantizar el pedido.</target>
        </trans-unit>
        <trans-unit id="9127c30b90d11e6061555ee1cae2d848f30da10c" translate="yes" xml:space="preserve">
          <source>Some exceptions include methods of enumerating inherited keys, such as the &lt;code&gt;for .. in&lt;/code&gt; loop. The &lt;code&gt;for .. in&lt;/code&gt; loop doesn't guarantee order according to the specification.</source>
          <target state="translated">Algunas excepciones incluyen m&amp;eacute;todos para enumerar claves heredadas, como el &lt;code&gt;for .. in&lt;/code&gt; loop. El &lt;code&gt;for .. in&lt;/code&gt; loop no garantiza el orden de acuerdo con la especificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="aeb78bd417a7768c123cd38651d774129e3176fc" translate="yes" xml:space="preserve">
          <source>Some older browsers combine categories #1 and #2, iterating all keys in insertion order. If your keys might parse as integers, it's best not to rely on any specific iteration order.</source>
          <target state="translated">Algunos navegadores más antiguos combinan las categorías #1 y #2,iterando todas las teclas en el orden de inserción.Si tus teclas pueden ser analizadas como enteros,es mejor no confiar en ningún orden de iteración específico.</target>
        </trans-unit>
        <trans-unit id="bedb8cd8e036c17b94b5d6c22f537e6cd438946f" translate="yes" xml:space="preserve">
          <source>Sometimes, yes</source>
          <target state="translated">A veces,sí</target>
        </trans-unit>
        <trans-unit id="03696b013ec729f79ff55615110524b6d377d9c3" translate="yes" xml:space="preserve">
          <source>Standards always follow implementations, that's where XHR came from, and Google does the same thing by implementing Gears and then embracing equivalent HTML5 functionality.  The right fix is to have ECMA formally incorporate the de-facto standard behavior into the next rev of the spec.</source>
          <target state="translated">Los estándares siempre siguen a las implementaciones,de ahí viene XHR,y Google hace lo mismo implementando Gears y luego adoptando la funcionalidad HTML5 equivalente.La solución correcta es que la ECMA incorpore formalmente el comportamiento estándar de facto en la próxima revisión de las especificaciones.</target>
        </trans-unit>
        <trans-unit id="df387116de084996fa33cc5b4ccad3778e284d52" translate="yes" xml:space="preserve">
          <source>String keys, in insertion order (ES2015 guarantees this and all browsers comply)</source>
          <target state="translated">Teclas de cadena,en orden de inserción (ES2015 garantiza esto y todos los navegadores cumplen)</target>
        </trans-unit>
        <trans-unit id="369d7c7a7aad2cd01d5e02f587face2623161f7f" translate="yes" xml:space="preserve">
          <source>Symbol keys, in insertion order</source>
          <target state="translated">Teclas de símbolos,en orden de inserción</target>
        </trans-unit>
        <trans-unit id="8454bd456035f63689f1f7538dbb3e71c5e28c85" translate="yes" xml:space="preserve">
          <source>Symbol names, in insertion order (ES2015 guarantees this and all browsers comply)</source>
          <target state="translated">Nombres de los símbolos,en orden de inserción (ES2015 garantiza esto y todos los navegadores cumplen)</target>
        </trans-unit>
        <trans-unit id="a9ff19a745e63e404d88d621888c4ff8971c082e" translate="yes" xml:space="preserve">
          <source>Symbols in insertion order</source>
          <target state="translated">Símbolos en orden de inserción</target>
        </trans-unit>
        <trans-unit id="3b2092c1a98be999603f3c961d4be7889be676c3" translate="yes" xml:space="preserve">
          <source>That is, will the properties be in the same order that I added them?</source>
          <target state="translated">Es decir,¿estarán las propiedades en el mismo orden en que las añadí?</target>
        </trans-unit>
        <trans-unit id="4d2de9daf855204938fd9e3b04c0ed0d327682b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMAScript specification&lt;/a&gt; used to say:</source>
          <target state="translated">La &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;especificaci&amp;oacute;n ECMAScript&lt;/a&gt; sol&amp;iacute;a decir:</target>
        </trans-unit>
        <trans-unit id="29fa3e4243bed714bd28cdcc5a439b305d27dff3" translate="yes" xml:space="preserve">
          <source>The actual question is very vague.</source>
          <target state="translated">La pregunta en sí es muy vaga.</target>
        </trans-unit>
        <trans-unit id="d9bb6366ecce97d1a3154d5144e1244355d132c5" translate="yes" xml:space="preserve">
          <source>The answer is: it depends on a number of factors. In general, &lt;em&gt;no&lt;/em&gt;.</source>
          <target state="translated">La respuesta es: depende de varios factores. En general, &lt;em&gt;no&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3112a8a32dbd36dfe4b46a1d1df283f2bffaf5" translate="yes" xml:space="preserve">
          <source>The following methods guarantee the order shown:</source>
          <target state="translated">Los siguientes métodos garantizan el orden mostrado:</target>
        </trans-unit>
        <trans-unit id="b8bb19c6e5330bcaa59b97be556c1675a287f34b" translate="yes" xml:space="preserve">
          <source>The following methods/loops guarantee no order at all:</source>
          <target state="translated">Los siguientes bucles de método garantizan que no haya ningún pedido:</target>
        </trans-unit>
        <trans-unit id="dbdc2d4c67254f98b99f13c6b0dc25f2e511fb83" translate="yes" xml:space="preserve">
          <source>The iteration order for objects follows &lt;a href=&quot;https://stackoverflow.com/a/38218582/292500&quot;&gt;a certain set of rules&lt;/a&gt; since ES2015, but &lt;strong&gt;it does not (always) follow the insertion order&lt;/strong&gt;. Simply put, the iteration order is a combination of the insertion order for strings keys, and ascending order for number-like keys:</source>
          <target state="translated">El orden de iteraci&amp;oacute;n para los objetos sigue &lt;a href=&quot;https://stackoverflow.com/a/38218582/292500&quot;&gt;un cierto conjunto de reglas&lt;/a&gt; desde ES2015, pero &lt;strong&gt;no (siempre) sigue el orden de inserci&amp;oacute;n&lt;/strong&gt; . En pocas palabras, el orden de iteraci&amp;oacute;n es una combinaci&amp;oacute;n del orden de inserci&amp;oacute;n para las teclas de cadenas y el orden ascendente para las teclas num&amp;eacute;ricas:</target>
        </trans-unit>
        <trans-unit id="b4a4e6f068dfc6cd8381634fb9999b8edbd5d5cc" translate="yes" xml:space="preserve">
          <source>The keys in Map are ordered while keys added to object are not. Thus, when iterating over it, a Map object returns keys in order of insertion. (Note that in the ECMAScript 2015 spec objects do preserve creation order for string and Symbol keys, so traversal of an object with ie only string keys would yield keys in order of insertion)</source>
          <target state="translated">Las claves en el mapa están ordenadas mientras que las claves añadidas al objeto no lo están.Por lo tanto,al iterar sobre él,un objeto del mapa devuelve las claves en el orden de inserción.(Observe que en el ECMAScript 2015 los objetos preservan el orden de creación de las claves de cadena y de los símbolos,por lo que el desplazamiento de un objeto con claves de cadena sólo produciría claves en el orden de inserción)</target>
        </trans-unit>
        <trans-unit id="ed7cecaff2b2b865d7552ddaf655c499e0ab0a33" translate="yes" xml:space="preserve">
          <source>The lack of specificity in ECMA-262 does not reflect reality. In discussion going back years, implementors have observed that there are some constraints on the behavior of for-in which anyone who wants to run code on the web needs to follow.</source>
          <target state="translated">La falta de especificidad del ECMA-262 no refleja la realidad.En discusiones que se remontan a años atrás,los implementadores han observado que hay algunas restricciones en el comportamiento de for-in que cualquiera que quiera ejecutar código en la web necesita seguir.</target>
        </trans-unit>
        <trans-unit id="99cdafe7bfb6d937df7209d8848443a7e20e02fd" translate="yes" xml:space="preserve">
          <source>The mechanics and order of enumerating the properties ... is not specified.</source>
          <target state="translated">La mecánica y el orden de enumeración de las propiedades...no está especificada.</target>
        </trans-unit>
        <trans-unit id="111c3077a9bab7d0eb66f628b1f52704d6558d5c" translate="yes" xml:space="preserve">
          <source>The order is defined in the spec, under the abstract operation &lt;a href=&quot;https://www.ecma-international.org/ecma-262/9.0/index.html#sec-ordinaryownpropertykeys&quot;&gt;OrdinaryOwnPropertyKeys&lt;/a&gt;, which underpins all methods of iterating over an object's own keys. Paraphrased, the order is as follows:</source>
          <target state="translated">El orden se define en la especificaci&amp;oacute;n, bajo la operaci&amp;oacute;n abstracta &lt;a href=&quot;https://www.ecma-international.org/ecma-262/9.0/index.html#sec-ordinaryownpropertykeys&quot;&gt;OrdinaryOwnPropertyKeys&lt;/a&gt; , que sustenta todos los m&amp;eacute;todos de iteraci&amp;oacute;n sobre las propias claves de un objeto. Parafraseado, el orden es el siguiente:</target>
        </trans-unit>
        <trans-unit id="10e68ba3d24da3f1a6c55e57fc43a01f2310bb93" translate="yes" xml:space="preserve">
          <source>The order is essentially: integer-like &lt;code&gt;Strings&lt;/code&gt; in ascending order, non-integer-like &lt;code&gt;Strings&lt;/code&gt; in creation order, Symbols in creation order. Depending which function invokes this, some of these types may not be included.</source>
          <target state="translated">El orden es esencialmente: &lt;code&gt;Strings&lt;/code&gt; enteras en orden ascendente, cadenas no enteras en orden de creaci&amp;oacute;n, s&amp;iacute;mbolos en orden de creaci&amp;oacute;n. Dependiendo de qu&amp;eacute; funci&amp;oacute;n invoque esto, algunos de estos tipos pueden no estar incluidos.</target>
        </trans-unit>
        <trans-unit id="b3287cf2d6f8c1f23bb792abaeefb0a8c1cbeba7" translate="yes" xml:space="preserve">
          <source>The order of keys in an object wasn't guaranteed until ES2015. It was implementation-defined.</source>
          <target state="translated">El orden de las llaves de un objeto no estaba garantizado hasta ES2015.Fue definido por la implementación.</target>
        </trans-unit>
        <trans-unit id="cc78fa8b6dadd0f1f48d48f9402a99419d560fbd" translate="yes" xml:space="preserve">
          <source>The question is, for what methods this order is guaranteed in the ES2015 spec?</source>
          <target state="translated">La pregunta es,¿para qué métodos se garantiza este orden en la especificación ES2015?</target>
        </trans-unit>
        <trans-unit id="a5b1e52a5ac36573960704b3789b1a8d268ccf5a" translate="yes" xml:space="preserve">
          <source>The specific language is that keys are returned in the following order:</source>
          <target state="translated">El lenguaje específico es que las llaves se devuelven en el siguiente orden:</target>
        </trans-unit>
        <trans-unit id="0dce972e73d0a4fac0a155ed2f727b3110d2cad9" translate="yes" xml:space="preserve">
          <source>There are a few weird cases which implementations currently do &lt;em&gt;not&lt;/em&gt; agree on, and in such cases, the resulting order will continue be unspecified. For property order &lt;a href=&quot;https://github.com/tc39/proposal-for-in-order#a-conservative-underapproximation-of-interop-semantics&quot;&gt;to be guaranteed&lt;/a&gt;:</source>
          <target state="translated">Hay algunos casos extra&amp;ntilde;os en los que las implementaciones actualmente &lt;em&gt;no&lt;/em&gt; est&amp;aacute;n de acuerdo, y en tales casos, el orden resultante continuar&amp;aacute; sin especificarse. Para &lt;a href=&quot;https://github.com/tc39/proposal-for-in-order#a-conservative-underapproximation-of-interop-semantics&quot;&gt;garantizar el&lt;/a&gt; orden de la propiedad:</target>
        </trans-unit>
        <trans-unit id="55b19b14da72f8c7f30f65d3c0821fb28bb19664" translate="yes" xml:space="preserve">
          <source>This is what pretty much every implementation does already, but the new proposal will make it official.</source>
          <target state="translated">Esto es lo que casi todas las implementaciones ya hacen,pero la nueva propuesta lo hará oficial.</target>
        </trans-unit>
        <trans-unit id="49f03181403db0a6631b9c892e5eb9016ddb9775" translate="yes" xml:space="preserve">
          <source>This results in the following order (in certain cases):</source>
          <target state="translated">Esto da como resultado el siguiente orden (en ciertos casos):</target>
        </trans-unit>
        <trans-unit id="2a2d2ebbf23e9e14a50e49a2ebb2718a4d31e0ae" translate="yes" xml:space="preserve">
          <source>This way you can use a regular for loop and have the insert order. You could then use the Array sort method to sort this into a new array if needed.</source>
          <target state="translated">De esta manera puedes usar un regular para el bucle y tener el orden de inserción.Podrías usar el método de ordenación de arreglos para ordenar esto en un nuevo arreglo si es necesario.</target>
        </trans-unit>
        <trans-unit id="db70c450e37560ad700c843433664c3f72d27c97" translate="yes" xml:space="preserve">
          <source>This whole answer is in the context of spec compliance, not what any engine does at a particular moment or historically.</source>
          <target state="translated">Toda esta respuesta está en el contexto de la conformidad con las especificaciones,no lo que hace cualquier motor en un momento determinado o históricamente.</target>
        </trans-unit>
        <trans-unit id="36e7408731ad7eda18219f4f3ecf847b4d50bd86" translate="yes" xml:space="preserve">
          <source>Thus, in order to take &lt;code&gt;Object.keys(valueFromStore)&lt;/code&gt; I used &lt;code&gt;Object.keys(valueFromStore).sort()&lt;/code&gt;, so that I at least now have an alphabetical order for the keys.</source>
          <target state="translated">Por lo tanto, para tomar &lt;code&gt;Object.keys(valueFromStore)&lt;/code&gt; utilic&amp;eacute; &lt;code&gt;Object.keys(valueFromStore).sort()&lt;/code&gt; , de modo que al menos ahora tengo un orden alfab&amp;eacute;tico para las teclas.</target>
        </trans-unit>
        <trans-unit id="6c15ca0416904aeea36408d198c5a736ea187af3" translate="yes" xml:space="preserve">
          <source>Thus, there are three segments, which may alter the insertion order (as happened in the example). And integer-like keys don't stick to the insertion order at all.</source>
          <target state="translated">Así pues,hay tres segmentos,que pueden alterar el orden de inserción (como ocurrió en el ejemplo).Y las teclas de tipo entero no se ciñen en absoluto al orden de inserción.</target>
        </trans-unit>
        <trans-unit id="42f21f6edccf6b7e965aa6753e10344cefc870e1" translate="yes" xml:space="preserve">
          <source>Using React with Redux, the state container of which's keys I want to traverse in order to generate children is refreshed everytime the store is changed (as per Redux's immutability concepts).</source>
          <target state="translated">Usando Reaccionar con Redux,el contenedor de estado cuyas llaves quiero atravesar para generar niños se refresca cada vez que se cambia de tienda (según los conceptos de inmutabilidad de Redux).</target>
        </trans-unit>
        <trans-unit id="158b0728eeda2f2e43e242eab00a657882339035" translate="yes" xml:space="preserve">
          <source>Using an array or a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;&lt;code&gt;Map&lt;/code&gt; object&lt;/a&gt; can be a better way to achieve this. &lt;code&gt;Map&lt;/code&gt; shares some similarities with &lt;code&gt;Object&lt;/code&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_and_maps_compared&quot;&gt;guarantees the keys to be iterated in order of insertion&lt;/a&gt;, without exception:</source>
          <target state="translated">Usar una matriz o un &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;objeto &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; puede ser una mejor manera de lograrlo. &lt;code&gt;Map&lt;/code&gt; comparte algunas similitudes con &lt;code&gt;Object&lt;/code&gt; y &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_and_maps_compared&quot;&gt;garantiza que las claves se repitan en orden de inserci&amp;oacute;n&lt;/a&gt; , sin excepci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="717e9d7bd21b2bf25179048c23b8139ebca1d0df" translate="yes" xml:space="preserve">
          <source>While in ES5 explicitly no order has been specified, ES2015 has an order in certain cases. Given is the following object:</source>
          <target state="translated">Mientras que en ES5 explícitamente no se ha especificado ningún orden,ES2015 tiene un orden en ciertos casos.Se da el siguiente objeto:</target>
        </trans-unit>
        <trans-unit id="2c4f5a24bafe473e423771440ba63f17544d239e" translate="yes" xml:space="preserve">
          <source>Will the resulting object &lt;em&gt;always&lt;/em&gt; look like this?</source>
          <target state="translated">&amp;iquest;El objeto resultante &lt;em&gt;siempre se&lt;/em&gt; ver&amp;aacute; as&amp;iacute;?</target>
        </trans-unit>
        <trans-unit id="64e3dd86e22797f5de12c4dcc57dae70834e7300" translate="yes" xml:space="preserve">
          <source>for..in</source>
          <target state="translated">for..in</target>
        </trans-unit>
        <trans-unit id="139528a85e8b998035ad6a5c85b4e51ace8b55c2" translate="yes" xml:space="preserve">
          <source>integer-like keys in ascending order</source>
          <target state="translated">claves de tipo entero en orden ascendente</target>
        </trans-unit>
        <trans-unit id="4412ac0ae820171fd5f4fb0263ad6679aaf6cf9c" translate="yes" xml:space="preserve">
          <source>normal keys in insertion order</source>
          <target state="translated">teclas normales en orden de inserción</target>
        </trans-unit>
        <trans-unit id="41d84f4f169439986c15f630c7f2198df104449c" translate="yes" xml:space="preserve">
          <source>will the properties be in the same order that I added them</source>
          <target state="translated">¿estarán las propiedades en el mismo orden en que las añadí</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
