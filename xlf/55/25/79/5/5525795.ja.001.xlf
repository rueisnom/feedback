<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/5525795">
    <body>
      <group id="5525795">
        <trans-unit id="da3687cfe7631d821ba35f4e012caced3b66cd22" translate="yes" xml:space="preserve">
          <source>(emphasis mine).</source>
          <target state="translated">(私は強調しています)。</target>
        </trans-unit>
        <trans-unit id="506a92cc597c8229d7c4a2bed4f4e9b88c6d9d1b" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; [the object being iterated] that is an integer index, in ascending numeric index order</source>
          <target state="translated">...番号インデックスの昇順の整数インデックスである &lt;code&gt;O&lt;/code&gt; [反復されるオブジェクト]の各独自のプロパティキー &lt;code&gt;P&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1431eb62a77c3957a1a90ad8c2ee19b35d73184" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; that is a String but is not an integer index, in property creation order</source>
          <target state="translated">...プロパティの作成順に、文字列であるが整数インデックスではない &lt;code&gt;O&lt;/code&gt; の各プロパティキー &lt;code&gt;P&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41f72be3edc7209f752acd3f28c3b1078665a04e" translate="yes" xml:space="preserve">
          <source>... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; that is a Symbol, in property creation order</source>
          <target state="translated">...プロパティの作成順に、シンボルである &lt;code&gt;O&lt;/code&gt; の各独自のプロパティキー &lt;code&gt;P&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="617676d9406eee86e16ed250ff2bd786d055b06f" translate="yes" xml:space="preserve">
          <source>4.3.3 Object</source>
          <target state="translated">4.3.3 オブジェクト</target>
        </trans-unit>
        <trans-unit id="629e86072909febc69cff039b31e251bfb5bcef7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;, &lt;code&gt;Reflect.ownKeys()&lt;/code&gt;, &lt;code&gt;Object.getOwnPropertySymbols(O)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt; 、 &lt;code&gt;Reflect.ownKeys()&lt;/code&gt; 、 &lt;code&gt;Object.getOwnPropertySymbols(O)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="906437decdad0d2084e279baa2e2d923b430539c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.keys&lt;/code&gt;, &lt;code&gt;Object.values&lt;/code&gt;, &lt;code&gt;Object.entries&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.keys&lt;/code&gt; 、 &lt;code&gt;Object.values&lt;/code&gt; 、 &lt;code&gt;Object.entries&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac72976f1fd79543ad7172b5c48fa8ec5cc520a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..in&lt;/code&gt; loops</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; ループ</target>
        </trans-unit>
        <trans-unit id="3f7356ed9c8dad2efb0205e5f9f24151517669d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In what context?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;どのような状況で？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d30fe30d4258ac32279a10fad11a23661e24d1fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But, soon (probably in ES2020), property order for these previously untrustworthy methods &lt;em&gt;will&lt;/em&gt; be guaranteed by the specification&lt;/strong&gt; to be iterated over in the same deterministic manner as the others, due to to the &lt;a href=&quot;https://github.com/tc39/proposals/blob/master/finished-proposals.md&quot;&gt;stage 4&lt;/a&gt; proposal: &lt;a href=&quot;http://tc39.es/proposal-for-in-order/&quot;&gt;For-in enumeration order&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;ただし、間もなく（おそらくES2020では）、これらの以前は信頼できなかったメソッドのプロパティの順序は&lt;/strong&gt; 、 &lt;a href=&quot;https://github.com/tc39/proposals/blob/master/finished-proposals.md&quot;&gt;ステージ4の&lt;/a&gt;提案： &lt;a href=&quot;http://tc39.es/proposal-for-in-order/&quot;&gt;For-in enumeration order&lt;/a&gt; &lt;strong&gt;により、仕様によって&lt;/strong&gt;他と同じ決定論的な方法で反復&lt;strong&gt;される&lt;em&gt;こと&lt;/em&gt;が保証さ&lt;/strong&gt; れます 。</target>
        </trans-unit>
        <trans-unit id="43cf735af1addba43cf6135a9e6cd5fd77f69b83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusion: Even in ES2015 you shouldn't rely on the property order of normal objects in Javascript. It is prone to errors. Use &lt;code&gt;Map&lt;/code&gt; instead.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;結論：ES2015でも、JavaScriptの通常のオブジェクトのプロパティの順序に依存するべきではありません。&lt;/strong&gt; &lt;strong&gt;エラーが発生しやすい。&lt;/strong&gt; &lt;strong&gt;代わりに &lt;code&gt;Map&lt;/code&gt; を使用してください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be9ffe71c53127990a370c8d47eb77ce87f4c69b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Current Language Spec (since ES2015)&lt;/strong&gt; insertion order is preserved, except in the case of keys that parse as integers (eg &quot;7&quot; or &quot;99&quot;), where behavior varies between browsers. For example, Chrome/V8 does not respect insertion order when the keys are parse as numeric.</source>
          <target state="translated">&lt;strong&gt;現在の言語仕様（ES2015以降）の&lt;/strong&gt;挿入順序は保持されます。ただし、整数として解析されるキー（「7」や「99」など）の場合を除き、ブラウザ間で動作が異なります。 たとえば、キーが数値として解析される場合、Chrome / V8は挿入順序を考慮しません。</target>
        </trans-unit>
        <trans-unit id="8c848754eb60df7eadf93fb71befdc94139eef6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Old Language Spec (before ES2015)&lt;/strong&gt;: Iteration order was technically undefined, but all major browsers complied with the ES2015 behavior.</source>
          <target state="translated">&lt;strong&gt;古い言語仕様（ES2015より前）&lt;/strong&gt; ：反復順序は技術的に未定義ですが、すべての主要なブラウザーはES2015の動作に準拠していました。</target>
        </trans-unit>
        <trans-unit id="a5cabd9db5130fe850fc14a9f035d862d77edcae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;YES (for non-integer keys).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;YES（非整数キーの場合）。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ddc2dc2dbcd4516457a87d0f7f30c97209aab02" translate="yes" xml:space="preserve">
          <source>A Map object can iterate its elements in insertion order...</source>
          <target state="translated">マップ オブジェクトは、その要素を挿入順に反復処理することができます。</target>
        </trans-unit>
        <trans-unit id="8272a49555285dae357452d8b3518864897ab434" translate="yes" xml:space="preserve">
          <source>All &lt;em&gt;integer index&lt;/em&gt; keys (stuff like &lt;code&gt;&quot;1123&quot;&lt;/code&gt;, &lt;code&gt;&quot;55&quot;&lt;/code&gt;, etc) in ascending numeric order.</source>
          <target state="translated">数値の昇順のすべての&lt;em&gt;整数インデックス&lt;/em&gt;キー（ &lt;code&gt;&quot;1123&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;55&quot;&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="6d0d086e05c3f95500e0ef71cccca3dcbbf3ee81" translate="yes" xml:space="preserve">
          <source>All other non-Symbol keys, in insertion order</source>
          <target state="translated">他のすべての非記号キー(挿入順</target>
        </trans-unit>
        <trans-unit id="6931239bebc33c69fddecf7cf1a400bef63e3d2e" translate="yes" xml:space="preserve">
          <source>All string keys which are not integer indices, in order of creation (oldest-first).</source>
          <target state="translated">整数インデックスではないすべての文字列キーを、作成順(古い順)に並べて表示します。</target>
        </trans-unit>
        <trans-unit id="9cc7882625e1fa1848c2d4d2d56f6e182d7ff836" translate="yes" xml:space="preserve">
          <source>All symbol keys, in order of creation (oldest-first).</source>
          <target state="translated">すべてのシンボルキー、作成順(古い順)。</target>
        </trans-unit>
        <trans-unit id="d99ee358a61be9c08f8e3663248de7c6ea7386a1" translate="yes" xml:space="preserve">
          <source>Although the current specification leaves for..in iteration order &quot;&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-enumerate-object-properties&quot;&gt;almost totally unspecified&lt;/a&gt;, real engines tend to be more consistent:&quot;</source>
          <target state="translated">現在の仕様では、「 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-enumerate-object-properties&quot;&gt;ほとんど完全に指定されていないが&lt;/a&gt; 、反復順序は残っていますが、実際のエンジンはより一貫している傾向があります。</target>
        </trans-unit>
        <trans-unit id="9f541eac51b245397dfc1dd505657af7d28c26b2" translate="yes" xml:space="preserve">
          <source>An object is a member of the
  type Object. &lt;strong&gt;It is an unordered collection of properties&lt;/strong&gt; each of which
  contains a primitive value, object, or
  function. A function stored in a
  property of an object is called a
  method.</source>
          <target state="translated">オブジェクトはタイプObjectのメンバーです。 &lt;strong&gt;これは、&lt;/strong&gt;それぞれがプリミティブ値、オブジェクト、または関数を含む&lt;strong&gt;、順序付けされていないプロパティのコレクションです&lt;/strong&gt; 。 オブジェクトのプロパティに格納されている関数をメソッドと呼びます。</target>
        </trans-unit>
        <trans-unit id="3f1e99d603dc8c534f17c37e7680125db1255ec4" translate="yes" xml:space="preserve">
          <source>An object is an &lt;strong&gt;unordered&lt;/strong&gt; collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array.</source>
          <target state="translated">オブジェクトは、0個以上の名前と値のペアの&lt;strong&gt;順序付けられていない&lt;/strong&gt;コレクションです。名前は文字列であり、値は文字列、数値、ブール値、null、オブジェクト、または配列です。</target>
        </trans-unit>
        <trans-unit id="0ce441a742a81f4f9ec981fd12c2ec069bde986b" translate="yes" xml:space="preserve">
          <source>As a note, properties order in objects weren&amp;rsquo;t guaranteed at all before ES2015. Definition of an Object from &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf&quot;&gt;ECMAScript Third Edition (pdf)&lt;/a&gt;:</source>
          <target state="translated">注記として、オブジェクトのプロパティの順序は、ES2015以前はまったく保証されていませんでした。 &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf&quot;&gt;ECMAScript Third Edition（pdf）の&lt;/a&gt;オブジェクトの定義：</target>
        </trans-unit>
        <trans-unit id="89359f1939ff8169993255536817a0eeb023f70f" translate="yes" xml:space="preserve">
          <source>As of ES2015, property order is guaranteed for certain methods that iterate over properties. &lt;a href=&quot;https://stackoverflow.com/a/30919039/&quot;&gt;but not others&lt;/a&gt;. Unfortunately, the methods which are not guaranteed to have an order are generally the most often used:</source>
          <target state="translated">ES2015以降、プロパティを反復する特定のメソッドでプロパティの順序が保証されています。 &lt;a href=&quot;https://stackoverflow.com/a/30919039/&quot;&gt;しかし、他のものではありません&lt;/a&gt; 。 残念ながら、順序を持つことが保証されていないメソッドは、一般的に最も頻繁に使用されます。</target>
        </trans-unit>
        <trans-unit id="f0701b9ee5dc8738764e68bb472acd3938023043" translate="yes" xml:space="preserve">
          <source>As others have stated, you have no guarantee as to the order when you iterate over the properties of an object. If you need an ordered list of multiple fields I suggested creating an array of objects.</source>
          <target state="translated">他の人が述べているように、オブジェクトのプロパティを反復処理するときの順序は保証されていません。複数のフィールドの順序付きリストが必要な場合、私はオブジェクトの配列を作成することを提案しました。</target>
        </trans-unit>
        <trans-unit id="4444585e7d19b4c0af133a98d6096e8c852f3f8b" translate="yes" xml:space="preserve">
          <source>At the time of writing, most browsers did return properties in the same order as they were inserted, but it was explicitly not guaranteed behaviour so shouldn't have been relied upon.</source>
          <target state="translated">執筆時点では、ほとんどのブラウザはプロパティを挿入された順に返していましたが、明示的に動作が保証されていなかったので、これに頼るべきではありませんでした。</target>
        </trans-unit>
        <trans-unit id="98f97678eae35879cc93487177bce8991d7bde31" translate="yes" xml:space="preserve">
          <source>Because every implementation already iterates over properties predictably, it can be put into the specification without breaking backwards compatibility.</source>
          <target state="translated">すべての実装はすでに予測可能なプロパティの反復処理を行っているため、下位互換性を壊すことなく仕様に入れることができます。</target>
        </trans-unit>
        <trans-unit id="1ac1c2bd0aec0e13d9c387f83cc8b463ba74df8f" translate="yes" xml:space="preserve">
          <source>Developer mozilla &amp;gt; Map</source>
          <target state="translated">開発者mozilla&amp;gt;マップ</target>
        </trans-unit>
        <trans-unit id="099a01ed9dd31f9684e8375f7034b12c3bb1a630" translate="yes" xml:space="preserve">
          <source>Does JavaScript Guarantee Object Property Order</source>
          <target state="translated">JavaScriptはオブジェクトのプロパティの順序を保証するか</target>
        </trans-unit>
        <trans-unit id="cc80c2d78cd6d75a58d4466354ff030d12c0c74d" translate="yes" xml:space="preserve">
          <source>ES2015 compliant engine</source>
          <target state="translated">ES2015対応エンジン</target>
        </trans-unit>
        <trans-unit id="0acc2d215fca04ea6cc5ff432bfc48e007f86d3f" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot;&gt;JSON standard&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot;&gt;JSON標準&lt;/a&gt;から：</target>
        </trans-unit>
        <trans-unit id="2a4e536fd55e0da3c613262b2b50225cf7c78b01" translate="yes" xml:space="preserve">
          <source>Generally, no</source>
          <target state="translated">一般的には</target>
        </trans-unit>
        <trans-unit id="4226982480d45f93dd459e9b1117c39c199447db" translate="yes" xml:space="preserve">
          <source>Here is where you can count on property key order for plain &lt;code&gt;Objects&lt;/code&gt;:</source>
          <target state="translated">ここでは、プレーン &lt;code&gt;Objects&lt;/code&gt; プロパティキーの順序を当てにできます。</target>
        </trans-unit>
        <trans-unit id="52147a0993d04e70a8e544d610fb45da923bbc68" translate="yes" xml:space="preserve">
          <source>However in ES2015 and later non-integer keys will be returned in insertion order.</source>
          <target state="translated">ただし、ES2015以降では、非整数のキーは挿入順に返されます。</target>
        </trans-unit>
        <trans-unit id="4961c2d8675f28a3fc5ef4a18b41c9201056b692" translate="yes" xml:space="preserve">
          <source>However, in ES2015 in &lt;em&gt;was&lt;/em&gt; specified. Like many things in JavaScript, this was done for compatibility purposes and generally reflected an existing unofficial standard among most JS engines (with you-know-who being an exception).</source>
          <target state="translated">ただし、ES2015では&lt;em&gt;が&lt;/em&gt;指定されました。 JavaScriptの多くのことと同様に、これは互換性の目的で行われ、一般にほとんどのJSエンジンの間の既存の非公式の標準を反映しています（例外として、あなたが知っている人は知っています）。</target>
        </trans-unit>
        <trans-unit id="b0828e60d703c26f73af1747c4d90e291c0a0d65" translate="yes" xml:space="preserve">
          <source>If I create an object like this:</source>
          <target state="translated">こんな感じのオブジェクトを作ると</target>
        </trans-unit>
        <trans-unit id="faabc3e0f5d76ebc58393833b7e692b3510ba07c" translate="yes" xml:space="preserve">
          <source>If you're interested in ordered maps you should consider using the &lt;code&gt;Map&lt;/code&gt; type introduced in ES2015 instead of plain &lt;code&gt;Objects&lt;/code&gt;.</source>
          <target state="translated">順序付けられたマップに興味がある場合は、プレーン &lt;code&gt;Objects&lt;/code&gt; 代わりに、ES2015で導入された &lt;code&gt;Map&lt;/code&gt; タイプの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="b627572cf43af1c9edcc2a011b2dbb4addc1a4f5" translate="yes" xml:space="preserve">
          <source>In ES2015, it does, but not to what you might think</source>
          <target state="translated">ES2015では、それはそうですが、あなたが考えるようなものではありません。</target>
        </trans-unit>
        <trans-unit id="c53c091a8a1dc6a4941c3d127b1c3f5926252001" translate="yes" xml:space="preserve">
          <source>In all cases these methods include non-enumerable property keys and order keys as specified by &lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt; (see below). They differ in the type of key values they include (&lt;code&gt;String&lt;/code&gt; and / or &lt;code&gt;Symbol&lt;/code&gt;). In this context &lt;code&gt;String&lt;/code&gt; includes integer values.</source>
          <target state="translated">すべての場合において、これらのメソッドには、 &lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt; で指定されている列挙不可能なプロパティキーと順序キーが含まれます（以下を参照）。 それらには、含まれるキー値のタイプ（ &lt;code&gt;String&lt;/code&gt; および/または &lt;code&gt;Symbol&lt;/code&gt; ）が異なります。 このコンテキストでは、 &lt;code&gt;String&lt;/code&gt; は整数値が含まれます。</target>
        </trans-unit>
        <trans-unit id="a66377df8463c41ca80dbcbc5b839a498d9c49dd" translate="yes" xml:space="preserve">
          <source>In modern browsers you can use the &lt;code&gt;Map&lt;/code&gt; data structure instead of a object.</source>
          <target state="translated">最新のブラウザーでは、オブジェクトの代わりに &lt;code&gt;Map&lt;/code&gt; データ構造を使用できます。</target>
        </trans-unit>
        <trans-unit id="149f5ce9ce098e7b86f9afc0516dad29d57de442" translate="yes" xml:space="preserve">
          <source>Integer keys in ascending order (and strings like &quot;1&quot; that parse as ints)</source>
          <target state="translated">昇順の整数キー (および &quot;1&quot; のような文字列は int としてパースされます)</target>
        </trans-unit>
        <trans-unit id="ee46467fe2fdf494dcc7270423065b1d077f30f2" translate="yes" xml:space="preserve">
          <source>It's silly to say that the order is unreliable - it is reliable, it's just probably not what you want, and modern browsers implement this order correctly.</source>
          <target state="translated">順番が信頼できないと言うのは愚かなことです-信頼できます。</target>
        </trans-unit>
        <trans-unit id="64b5375f0360e9044ba38df47f55f6d563d59252" translate="yes" xml:space="preserve">
          <source>JSON.parse</source>
          <target state="translated">JSON.parse</target>
        </trans-unit>
        <trans-unit id="3898286ce044bc87123989a97e0cdf2ef51669ae" translate="yes" xml:space="preserve">
          <source>JSON.stringify</source>
          <target state="translated">JSON.stringify</target>
        </trans-unit>
        <trans-unit id="b266d7c42c66244150bfc03d76098bb073e86d28" translate="yes" xml:space="preserve">
          <source>Just found this out the hard way.</source>
          <target state="translated">苦労して見つけたんだ</target>
        </trans-unit>
        <trans-unit id="8e16c53d1bbc95155c6ceb4bb722f567d58cc184" translate="yes" xml:space="preserve">
          <source>Just like with the methods which have a guaranteed iteration order (like &lt;code&gt;Reflect.ownKeys&lt;/code&gt; and &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;), the previously-unspecified methods will also iterate in the following order:</source>
          <target state="translated">反復順序が保証されているメソッド（ &lt;code&gt;Reflect.ownKeys&lt;/code&gt; や &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt; など ）と同様に、以前に指定されていないメソッドも次の順序で反復します。</target>
        </trans-unit>
        <trans-unit id="4dda5a1c505242ff9f21a80d9c0ec24fcd977189" translate="yes" xml:space="preserve">
          <source>Most Browsers iterate object properties as:</source>
          <target state="translated">ほとんどのブラウザは、オブジェクトのプロパティをイテレートします。</target>
        </trans-unit>
        <trans-unit id="eca0d6e5ddb7e8e19c66b315455277ac55d52648" translate="yes" xml:space="preserve">
          <source>Neither the object being iterated nor anything in its prototype chain is a proxy, typed array, module namespace object, or host exotic object.</source>
          <target state="translated">反復されるオブジェクトも、そのプロトタイプチェーン内のものも、プロキシ、型付き配列、モジュール名前空間オブジェクト、ホストのエキゾチックなオブジェクトではありません。</target>
        </trans-unit>
        <trans-unit id="1d4ab0a6df04c34dd48b584b2a415ab43129c02b" translate="yes" xml:space="preserve">
          <source>Neither the object nor anything in its prototype chain has a property deleted during iteration.</source>
          <target state="translated">オブジェクトもそのプロトタイプチェーン内のものも、反復中に削除されたプロパティを持っていません。</target>
        </trans-unit>
        <trans-unit id="4dc6577720fdc085f0e42c0d8290ba58b994327e" translate="yes" xml:space="preserve">
          <source>Neither the object nor anything in its prototype chain has its prototype change during iteration.</source>
          <target state="translated">オブジェクトもそのプロトタイプチェーン内のものも、反復中にプロトタイプが変更されることはありません。</target>
        </trans-unit>
        <trans-unit id="0e995b5f9a057b2527e1b6be18d9f747fa5a5ffe" translate="yes" xml:space="preserve">
          <source>No non-enumerable property shadows an enumerable one.</source>
          <target state="translated">列挙可能でないプロパティが列挙可能なプロパティの影になることはありません。</target>
        </trans-unit>
        <trans-unit id="d658441f85cb60696e476538b61044fc4858c1a6" translate="yes" xml:space="preserve">
          <source>No property of the object or anything in its prototype chain has its enumerability change during iteration.</source>
          <target state="translated">オブジェクトやそのプロトタイプチェーン内のいかなるプロパティも、反復中にその列挙可能性が変更されることはありません。</target>
        </trans-unit>
        <trans-unit id="89c320a56b18231c4a841ab136d9db9f9cc15237" translate="yes" xml:space="preserve">
          <source>Note that the ES2015 behavior was a good example of the language spec being driven by existing behavior, and not the other way round. To get a deeper sense of that backwards-compatibility mindset, see &lt;a href=&quot;http://code.google.com/p/v8/issues/detail?id=164&quot;&gt;http://code.google.com/p/v8/issues/detail?id=164&lt;/a&gt;, a Chrome bug that covers in detail the design decisions behind Chrome's iteration order behavior.
Per one of the (rather opinionated) comments on that bug report:</source>
          <target state="translated">ES2015の動作は、言語仕様が既存の動作によって駆動される良い例であり、その逆ではないことに注意してください。 下位互換性の考え方の詳細については、 &lt;a href=&quot;http://code.google.com/p/v8/issues/detail?id=164&quot;&gt;http:&lt;/a&gt; //code.google.com/p/v8/issues/detail?id=164を参照してください。これは、Chromeの反復順序動作の背後にある設計上の決定を詳細にカバーするChromeのバグです。 。 そのバグレポートに関する（むしろ意見が分かれた）コメントの1つによると、</target>
        </trans-unit>
        <trans-unit id="a4d61c2f54a1ad70200ca0ee70c2977c4eb1f610" translate="yes" xml:space="preserve">
          <source>Nothing in the object's prototype chain has a property added during iteration.</source>
          <target state="translated">オブジェクトのプロトタイプチェーンには、反復中にプロパティが追加されているものはありません。</target>
        </trans-unit>
        <trans-unit id="0194eee4f03b556be8832cea08ed12de31c2d9b2" translate="yes" xml:space="preserve">
          <source>Numeric array keys, in ascending numeric order</source>
          <target state="translated">数値配列キー、数値の昇順</target>
        </trans-unit>
        <trans-unit id="1d51672345557c0f022fd737f9b7489d16b30459" translate="yes" xml:space="preserve">
          <source>Object.assign</source>
          <target state="translated">Object.assign</target>
        </trans-unit>
        <trans-unit id="792a27c424ad52e5a9356f3722643e927041e20f" translate="yes" xml:space="preserve">
          <source>Object.defineProperties</source>
          <target state="translated">Object.defineProperties</target>
        </trans-unit>
        <trans-unit id="a37c98a6f5f7ca5863f83538b43a1b90ce0f8d42" translate="yes" xml:space="preserve">
          <source>Object.getOwnPropertyNames</source>
          <target state="translated">Object.getOwnPropertyNames</target>
        </trans-unit>
        <trans-unit id="1061044277b2b1b91a3ad9fd72b96a926df8e0ad" translate="yes" xml:space="preserve">
          <source>Object.getOwnPropertySymbols</source>
          <target state="translated">Object.getOwnPropertySymbols</target>
        </trans-unit>
        <trans-unit id="c5a933e00dc39b7be5f3039f9caf7a7ff8b476c8" translate="yes" xml:space="preserve">
          <source>Object.keys</source>
          <target state="translated">Object.keys</target>
        </trans-unit>
        <trans-unit id="9766dcc2678dca29aca27b7034272c421f110e70" translate="yes" xml:space="preserve">
          <source>Own properties</source>
          <target state="translated">所有物件</target>
        </trans-unit>
        <trans-unit id="2ea9d512846684027cf3f09daee60e1b4fb1823d" translate="yes" xml:space="preserve">
          <source>Property order in normal Objects is a complex subject in Javascript.</source>
          <target state="translated">通常のオブジェクトのプロパティの順序は、Javascriptでは複雑なテーマです。</target>
        </trans-unit>
        <trans-unit id="0efb52a164d2557eb51e9d57bef3b03f3cfa6ce2" translate="yes" xml:space="preserve">
          <source>Reflect.ownKeys</source>
          <target state="translated">Reflect.ownKeys</target>
        </trans-unit>
        <trans-unit id="8c7c6e0edbbe7036c351801472457895f35b7ca5" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;String&lt;/code&gt;- and &lt;code&gt;Symbol&lt;/code&gt;-keyed properties.</source>
          <target state="translated">&lt;code&gt;O&lt;/code&gt; 自身の &lt;code&gt;String&lt;/code&gt; および &lt;code&gt;Symbol&lt;/code&gt; キーのプロパティを返します。</target>
        </trans-unit>
        <trans-unit id="073ddc07bb314332dd4af4685c8be8359a5e671a" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;String&lt;/code&gt;-keyed properties (&lt;em&gt;property names&lt;/em&gt;).</source>
          <target state="translated">&lt;code&gt;O&lt;/code&gt; 自身の &lt;code&gt;String&lt;/code&gt; キープロパティ（ &lt;em&gt;プロパティ名&lt;/em&gt; ）を返します。</target>
        </trans-unit>
        <trans-unit id="cec74648d029ac27ae652baf8d58c1a15e7cb459" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;O&lt;/code&gt;'s own &lt;code&gt;Symbol&lt;/code&gt;-keyed properties.</source>
          <target state="translated">&lt;code&gt;O&lt;/code&gt; 自身の &lt;code&gt;Symbol&lt;/code&gt; キー付きプロパティを返します。</target>
        </trans-unit>
        <trans-unit id="77f8e27f1eed61991843e7511c8740205287dc40" translate="yes" xml:space="preserve">
          <source>So, no you can't guarantee the order.</source>
          <target state="translated">だから、あなたが注文を保証することはできません。</target>
        </trans-unit>
        <trans-unit id="9127c30b90d11e6061555ee1cae2d848f30da10c" translate="yes" xml:space="preserve">
          <source>Some exceptions include methods of enumerating inherited keys, such as the &lt;code&gt;for .. in&lt;/code&gt; loop. The &lt;code&gt;for .. in&lt;/code&gt; loop doesn't guarantee order according to the specification.</source>
          <target state="translated">一部の例外には、 &lt;code&gt;for .. in&lt;/code&gt; ループなど、継承されたキーを列挙するメソッドが含まれます。 &lt;code&gt;for .. in&lt;/code&gt; ループは、仕様に従って順序を保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="aeb78bd417a7768c123cd38651d774129e3176fc" translate="yes" xml:space="preserve">
          <source>Some older browsers combine categories #1 and #2, iterating all keys in insertion order. If your keys might parse as integers, it's best not to rely on any specific iteration order.</source>
          <target state="translated">古いブラウザの中には、カテゴリ#1と#2を組み合わせて、すべてのキーを挿入順に繰り返し処理するものもあります。キーが整数としてパースされる可能性がある場合は、特定の反復順序に頼らない方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="bedb8cd8e036c17b94b5d6c22f537e6cd438946f" translate="yes" xml:space="preserve">
          <source>Sometimes, yes</source>
          <target state="translated">時々、はい</target>
        </trans-unit>
        <trans-unit id="03696b013ec729f79ff55615110524b6d377d9c3" translate="yes" xml:space="preserve">
          <source>Standards always follow implementations, that's where XHR came from, and Google does the same thing by implementing Gears and then embracing equivalent HTML5 functionality.  The right fix is to have ECMA formally incorporate the de-facto standard behavior into the next rev of the spec.</source>
          <target state="translated">標準は常に実装に従うもので、XHR はそこから来ています。Google は Gears を実装した後、同等の HTML5 機能を採用することで同じことをしています。正しい修正は、ECMA がデファクトスタンダードの動作を正式に次の改訂版の仕様に組み込むことです。</target>
        </trans-unit>
        <trans-unit id="df387116de084996fa33cc5b4ccad3778e284d52" translate="yes" xml:space="preserve">
          <source>String keys, in insertion order (ES2015 guarantees this and all browsers comply)</source>
          <target state="translated">文字列キー、挿入順(ES2015がこれを保証しており、すべてのブラウザがこれに準拠しています。</target>
        </trans-unit>
        <trans-unit id="369d7c7a7aad2cd01d5e02f587face2623161f7f" translate="yes" xml:space="preserve">
          <source>Symbol keys, in insertion order</source>
          <target state="translated">シンボルキー、挿入順</target>
        </trans-unit>
        <trans-unit id="8454bd456035f63689f1f7538dbb3e71c5e28c85" translate="yes" xml:space="preserve">
          <source>Symbol names, in insertion order (ES2015 guarantees this and all browsers comply)</source>
          <target state="translated">シンボル名、挿入順(ES2015がこれを保証し、すべてのブラウザがこれに準拠しています。</target>
        </trans-unit>
        <trans-unit id="a9ff19a745e63e404d88d621888c4ff8971c082e" translate="yes" xml:space="preserve">
          <source>Symbols in insertion order</source>
          <target state="translated">記号の挿入順</target>
        </trans-unit>
        <trans-unit id="3b2092c1a98be999603f3c961d4be7889be676c3" translate="yes" xml:space="preserve">
          <source>That is, will the properties be in the same order that I added them?</source>
          <target state="translated">つまり、プロパティは追加した順番通りになるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="4d2de9daf855204938fd9e3b04c0ed0d327682b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMAScript specification&lt;/a&gt; used to say:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMAScript仕様&lt;/a&gt;は次のように言っていました。</target>
        </trans-unit>
        <trans-unit id="29fa3e4243bed714bd28cdcc5a439b305d27dff3" translate="yes" xml:space="preserve">
          <source>The actual question is very vague.</source>
          <target state="translated">実際の質問は非常に曖昧です。</target>
        </trans-unit>
        <trans-unit id="d9bb6366ecce97d1a3154d5144e1244355d132c5" translate="yes" xml:space="preserve">
          <source>The answer is: it depends on a number of factors. In general, &lt;em&gt;no&lt;/em&gt;.</source>
          <target state="translated">答えは次のとおりです。それはいくつかの要因に依存します。 一般に、 &lt;em&gt;いいえ&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb3112a8a32dbd36dfe4b46a1d1df283f2bffaf5" translate="yes" xml:space="preserve">
          <source>The following methods guarantee the order shown:</source>
          <target state="translated">以下の方法で、表示された順序を保証します。</target>
        </trans-unit>
        <trans-unit id="b8bb19c6e5330bcaa59b97be556c1675a287f34b" translate="yes" xml:space="preserve">
          <source>The following methods/loops guarantee no order at all:</source>
          <target state="translated">以下のメソッドループは、全く順序がないことを保証します。</target>
        </trans-unit>
        <trans-unit id="dbdc2d4c67254f98b99f13c6b0dc25f2e511fb83" translate="yes" xml:space="preserve">
          <source>The iteration order for objects follows &lt;a href=&quot;https://stackoverflow.com/a/38218582/292500&quot;&gt;a certain set of rules&lt;/a&gt; since ES2015, but &lt;strong&gt;it does not (always) follow the insertion order&lt;/strong&gt;. Simply put, the iteration order is a combination of the insertion order for strings keys, and ascending order for number-like keys:</source>
          <target state="translated">オブジェクトの反復順序は、ES2015以降&lt;a href=&quot;https://stackoverflow.com/a/38218582/292500&quot;&gt;、特定のルールセットに&lt;/a&gt; &lt;strong&gt;従いますが、（常に）挿入順序に従いません&lt;/strong&gt; 。 簡単に言うと、反復順序は文字列キーの挿入順序と数字のようなキーの昇順の組み合わせです。</target>
        </trans-unit>
        <trans-unit id="b4a4e6f068dfc6cd8381634fb9999b8edbd5d5cc" translate="yes" xml:space="preserve">
          <source>The keys in Map are ordered while keys added to object are not. Thus, when iterating over it, a Map object returns keys in order of insertion. (Note that in the ECMAScript 2015 spec objects do preserve creation order for string and Symbol keys, so traversal of an object with ie only string keys would yield keys in order of insertion)</source>
          <target state="translated">Map のキーは順序付けられていますが、オブジェクトに追加されたキーは順序付けられていません。したがって、Map オブジェクトを反復処理すると、Map オブジェクトは挿入順にキーを返します。(ECMAScript 2015 仕様では、オブジェクトは文字列キーとシンボルキーの作成順を保持しているため、文字列キーのみを持つオブジェクトをトラバーサルすると、挿入順にキーが返されることに注意してください)</target>
        </trans-unit>
        <trans-unit id="ed7cecaff2b2b865d7552ddaf655c499e0ab0a33" translate="yes" xml:space="preserve">
          <source>The lack of specificity in ECMA-262 does not reflect reality. In discussion going back years, implementors have observed that there are some constraints on the behavior of for-in which anyone who wants to run code on the web needs to follow.</source>
          <target state="translated">ECMA-262における特定性の欠如は、現実を反映していません。何年も前からの議論の中で、実装者は for-in の動作にいくつかの制約があることを観察してきましたが、これはウェブ上でコードを実行したい人なら誰もが従う必要があります。</target>
        </trans-unit>
        <trans-unit id="99cdafe7bfb6d937df7209d8848443a7e20e02fd" translate="yes" xml:space="preserve">
          <source>The mechanics and order of enumerating the properties ... is not specified.</source>
          <target state="translated">プロパティを列挙する仕組みや順序は...指定されていません。</target>
        </trans-unit>
        <trans-unit id="111c3077a9bab7d0eb66f628b1f52704d6558d5c" translate="yes" xml:space="preserve">
          <source>The order is defined in the spec, under the abstract operation &lt;a href=&quot;https://www.ecma-international.org/ecma-262/9.0/index.html#sec-ordinaryownpropertykeys&quot;&gt;OrdinaryOwnPropertyKeys&lt;/a&gt;, which underpins all methods of iterating over an object's own keys. Paraphrased, the order is as follows:</source>
          <target state="translated">順序は仕様で、抽象オペレーション&lt;a href=&quot;https://www.ecma-international.org/ecma-262/9.0/index.html#sec-ordinaryownpropertykeys&quot;&gt;OrdinaryOwnPropertyKeysの&lt;/a&gt;下で定義されています。これは、オブジェクト自体のキーを反復するすべてのメソッドを支えています。 言い換えると、順序は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="10e68ba3d24da3f1a6c55e57fc43a01f2310bb93" translate="yes" xml:space="preserve">
          <source>The order is essentially: integer-like &lt;code&gt;Strings&lt;/code&gt; in ascending order, non-integer-like &lt;code&gt;Strings&lt;/code&gt; in creation order, Symbols in creation order. Depending which function invokes this, some of these types may not be included.</source>
          <target state="translated">順序は基本的に、昇順の整数のような &lt;code&gt;Strings&lt;/code&gt; 、作成順の非整数のような文字列 、作成順のシンボルです。 これを呼び出す関数によっては、これらのタイプの一部が含まれていない場合があります。</target>
        </trans-unit>
        <trans-unit id="b3287cf2d6f8c1f23bb792abaeefb0a8c1cbeba7" translate="yes" xml:space="preserve">
          <source>The order of keys in an object wasn't guaranteed until ES2015. It was implementation-defined.</source>
          <target state="translated">オブジェクト内のキーの順番はES2015まで保証されていませんでした。実装で定義されていました。</target>
        </trans-unit>
        <trans-unit id="cc78fa8b6dadd0f1f48d48f9402a99419d560fbd" translate="yes" xml:space="preserve">
          <source>The question is, for what methods this order is guaranteed in the ES2015 spec?</source>
          <target state="translated">問題は、ES2015の仕様では、どのような方法でこの順序が保証されているのかということです。</target>
        </trans-unit>
        <trans-unit id="a5b1e52a5ac36573960704b3789b1a8d268ccf5a" translate="yes" xml:space="preserve">
          <source>The specific language is that keys are returned in the following order:</source>
          <target state="translated">具体的な言語は、以下の順番でキーが返されるというものです。</target>
        </trans-unit>
        <trans-unit id="0dce972e73d0a4fac0a155ed2f727b3110d2cad9" translate="yes" xml:space="preserve">
          <source>There are a few weird cases which implementations currently do &lt;em&gt;not&lt;/em&gt; agree on, and in such cases, the resulting order will continue be unspecified. For property order &lt;a href=&quot;https://github.com/tc39/proposal-for-in-order#a-conservative-underapproximation-of-interop-semantics&quot;&gt;to be guaranteed&lt;/a&gt;:</source>
          <target state="translated">現在実装が合意してい&lt;em&gt;ない&lt;/em&gt;いくつかの奇妙なケースがあり、そのような場合、結果の順序は不特定のままになります。 プロパティの順序&lt;a href=&quot;https://github.com/tc39/proposal-for-in-order#a-conservative-underapproximation-of-interop-semantics&quot;&gt;を保証するには&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="55b19b14da72f8c7f30f65d3c0821fb28bb19664" translate="yes" xml:space="preserve">
          <source>This is what pretty much every implementation does already, but the new proposal will make it official.</source>
          <target state="translated">これはかなりすべての実装ですでに行われていることですが、新しい提案では正式なものになります。</target>
        </trans-unit>
        <trans-unit id="49f03181403db0a6631b9c892e5eb9016ddb9775" translate="yes" xml:space="preserve">
          <source>This results in the following order (in certain cases):</source>
          <target state="translated">その結果、以下のような順番になります(場合によっては)。</target>
        </trans-unit>
        <trans-unit id="2a2d2ebbf23e9e14a50e49a2ebb2718a4d31e0ae" translate="yes" xml:space="preserve">
          <source>This way you can use a regular for loop and have the insert order. You could then use the Array sort method to sort this into a new array if needed.</source>
          <target state="translated">この方法では、通常の for ループを使用して挿入順を指定することができます。そして、必要に応じて配列のソートメソッドを使用して、これを新しい配列に並べ替えることができます。</target>
        </trans-unit>
        <trans-unit id="db70c450e37560ad700c843433664c3f72d27c97" translate="yes" xml:space="preserve">
          <source>This whole answer is in the context of spec compliance, not what any engine does at a particular moment or historically.</source>
          <target state="translated">この答えは、仕様準拠の文脈であって、どのエンジンでも特定の瞬間に何をするか、歴史的に何をするかということではありません。</target>
        </trans-unit>
        <trans-unit id="36e7408731ad7eda18219f4f3ecf847b4d50bd86" translate="yes" xml:space="preserve">
          <source>Thus, in order to take &lt;code&gt;Object.keys(valueFromStore)&lt;/code&gt; I used &lt;code&gt;Object.keys(valueFromStore).sort()&lt;/code&gt;, so that I at least now have an alphabetical order for the keys.</source>
          <target state="translated">したがって、 &lt;code&gt;Object.keys(valueFromStore)&lt;/code&gt; を取得するために、私は &lt;code&gt;Object.keys(valueFromStore).sort()&lt;/code&gt; を使用して、少なくともキーのアルファベット順を取得できるようにしました。</target>
        </trans-unit>
        <trans-unit id="6c15ca0416904aeea36408d198c5a736ea187af3" translate="yes" xml:space="preserve">
          <source>Thus, there are three segments, which may alter the insertion order (as happened in the example). And integer-like keys don't stick to the insertion order at all.</source>
          <target state="translated">このように、3つのセグメントがあり、それによって挿入順が変わる可能性があります(例で起こったように)。そして、整数のようなキーは挿入順に全く固執しません。</target>
        </trans-unit>
        <trans-unit id="42f21f6edccf6b7e965aa6753e10344cefc870e1" translate="yes" xml:space="preserve">
          <source>Using React with Redux, the state container of which's keys I want to traverse in order to generate children is refreshed everytime the store is changed (as per Redux's immutability concepts).</source>
          <target state="translated">React with Reduxを使用すると、子を生成するためにトラバースしたいキーのステートコンテナは、ストアが変更されるたびにリフレッシュされます(Reduxの不変性の概念に従っています)。</target>
        </trans-unit>
        <trans-unit id="158b0728eeda2f2e43e242eab00a657882339035" translate="yes" xml:space="preserve">
          <source>Using an array or a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;&lt;code&gt;Map&lt;/code&gt; object&lt;/a&gt; can be a better way to achieve this. &lt;code&gt;Map&lt;/code&gt; shares some similarities with &lt;code&gt;Object&lt;/code&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_and_maps_compared&quot;&gt;guarantees the keys to be iterated in order of insertion&lt;/a&gt;, without exception:</source>
          <target state="translated">これを実現するには、配列または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; オブジェクト&lt;/a&gt;を使用する方が良い方法です。 &lt;code&gt;Map&lt;/code&gt; は &lt;code&gt;Object&lt;/code&gt; といくつかの類似点を共有し、例外なく&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_and_maps_compared&quot;&gt;、挿入順にキーが反復されること&lt;/a&gt;を保証します 。</target>
        </trans-unit>
        <trans-unit id="717e9d7bd21b2bf25179048c23b8139ebca1d0df" translate="yes" xml:space="preserve">
          <source>While in ES5 explicitly no order has been specified, ES2015 has an order in certain cases. Given is the following object:</source>
          <target state="translated">ES5では明示的に順序が指定されていませんでしたが、ES2015では特定のケースで順序が指定されています。与えられたオブジェクトは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="2c4f5a24bafe473e423771440ba63f17544d239e" translate="yes" xml:space="preserve">
          <source>Will the resulting object &lt;em&gt;always&lt;/em&gt; look like this?</source>
          <target state="translated">結果のオブジェクトは&lt;em&gt;常に&lt;/em&gt;このようになりますか？</target>
        </trans-unit>
        <trans-unit id="64e3dd86e22797f5de12c4dcc57dae70834e7300" translate="yes" xml:space="preserve">
          <source>for..in</source>
          <target state="translated">for..in</target>
        </trans-unit>
        <trans-unit id="139528a85e8b998035ad6a5c85b4e51ace8b55c2" translate="yes" xml:space="preserve">
          <source>integer-like keys in ascending order</source>
          <target state="translated">昇順整数型キー</target>
        </trans-unit>
        <trans-unit id="4412ac0ae820171fd5f4fb0263ad6679aaf6cf9c" translate="yes" xml:space="preserve">
          <source>normal keys in insertion order</source>
          <target state="translated">挿入順正規キー</target>
        </trans-unit>
        <trans-unit id="41d84f4f169439986c15f630c7f2198df104449c" translate="yes" xml:space="preserve">
          <source>will the properties be in the same order that I added them</source>
          <target state="translated">のプロパティは、追加した順番と同じになりますか?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
