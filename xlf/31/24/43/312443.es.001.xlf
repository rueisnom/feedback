<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/312443">
    <body>
      <group id="312443">
        <trans-unit id="afc62f24d04a757a3fed298ee0502acbf641cc78" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.defaultdict&quot;&gt;&lt;code&gt;collections.defaultdict&lt;/code&gt;&lt;/a&gt;  (ordered results requires Python 3.6+)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.defaultdict&quot;&gt; &lt;code&gt;collections.defaultdict&lt;/code&gt; &lt;/a&gt; (los resultados ordenados requieren Python 3.6+)</target>
        </trans-unit>
        <trans-unit id="58e6d793c579e3e4ec49e97cc8c906104c1d4c0d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.zip_longest&quot;&gt;&lt;code&gt;zip_longest&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/3125186#3125186&quot;&gt;related post&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/29009933#29009933&quot;&gt;related post&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.zip_longest&quot;&gt; &lt;code&gt;zip_longest&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/3125186#3125186&quot;&gt;publicaci&amp;oacute;n&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/29009933#29009933&quot;&gt;relacionada&lt;/a&gt; , publicaci&amp;oacute;n relacionada )</target>
        </trans-unit>
        <trans-unit id="11757f2a8c1187933509721f8f085fdedce709a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.setdefault&quot;&gt;&lt;code&gt;setdefault&lt;/code&gt;&lt;/a&gt; (ordered results requires Python 3.6+)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.setdefault&quot;&gt; &lt;code&gt;setdefault&lt;/code&gt; &lt;/a&gt; (los resultados ordenados requieren Python 3.6+)</target>
        </trans-unit>
        <trans-unit id="e0cfc75ee17c3572b6f56675f60c272896e59887" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;em&gt;&lt;code&gt;more_itertools&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;sup&gt;+&lt;/sup&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;em&gt;&lt;code&gt;more_itertools&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;sup&gt;+&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="709b4f054179d1afa28588c2eb207c1d90f9629b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.chunked&quot;&gt;&lt;code&gt;more_itertools.chunked&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/16315158#16315158&quot;&gt;related posted&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.chunked&quot;&gt; &lt;code&gt;more_itertools.chunked&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/16315158#16315158&quot;&gt;relacionado publicado&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1a2f32177b51d0d1415b5b4e4c7e1b2f156dab73" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.grouper&quot;&gt;&lt;code&gt;more_itertools.grouper&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/312644#312644&quot;&gt;related post&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.grouper&quot;&gt; &lt;code&gt;more_itertools.grouper&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/312644#312644&quot;&gt;publicaci&amp;oacute;n relacionada&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="2a6ae8e428ee8fb0f3bf5335e99eadd09d507001" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.windowed&quot;&gt;&lt;code&gt;more_itertools.windowed&lt;/code&gt;&lt;/a&gt; (see also &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.stagger&quot;&gt;&lt;code&gt;stagger&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.zip_offset&quot;&gt;&lt;code&gt;zip_offset&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.windowed&quot;&gt; &lt;code&gt;more_itertools.windowed&lt;/code&gt; &lt;/a&gt; (ver tambi&amp;eacute;n &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.stagger&quot;&gt; &lt;code&gt;stagger&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.zip_offset&quot;&gt; &lt;code&gt;zip_offset&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="4143c70f77b270636a13fe869cc8ef3a270deec2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Disclaimer: I am the creator of &lt;a href=&quot;https://github.com/moin18/utilspie&quot;&gt;utilspie&lt;/a&gt; library&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Descargo de responsabilidad: soy el creador de la biblioteca &lt;a href=&quot;https://github.com/moin18/utilspie&quot;&gt;utilspie&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="610a42d66a5c2ccc81158b17f6ef8cfa7fb436c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The Standard Library&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;La biblioteca est&amp;aacute;ndar&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6607830e66ad80aa66ee0fb7977558ee0e94c1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Given&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Given&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="762b0b987efcf101541560526e8d90e402907514" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;References&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;References&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46d89300e0df73036ac46de568703f812bd19662" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Results:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Results:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c015b0c9104bd29356550baed6c391c2367ace1" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;sup&gt;+&lt;/sup&gt; A third-party library that implements &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;itertools recipes&lt;/a&gt; and more. &lt;code&gt;&amp;gt; pip install more_itertools&lt;/code&gt; &lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;sup&gt;+&lt;/sup&gt; Una biblioteca de terceros que implementa &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;recetas de herramientas iterto&lt;/a&gt; y m&amp;aacute;s.&lt;/sub&gt; &lt;sub&gt; &lt;code&gt;&amp;gt; pip install more_itertools&lt;/code&gt; &lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="0c113960317b7fd4d0b8bd387f0902aaeec55697" translate="yes" xml:space="preserve">
          <source>Also you can simply use list comprehension instead of writing a function, though it's a good idea to encapsulate operations like this in named functions so that your code is easier to understand. Python 3:</source>
          <target state="translated">También puedes usar simplemente la comprensión de la lista en lugar de escribir una función,aunque es una buena idea encapsular las operaciones como esta en funciones con nombre para que tu código sea más fácil de entender.Python 3:</target>
        </trans-unit>
        <trans-unit id="e19011a8b23a7c95dfea6a63f6395685a7497d26" translate="yes" xml:space="preserve">
          <source>Also, in case of massive Alien invasion, a &lt;strong&gt;decorated recursive generator&lt;/strong&gt; might become handy:</source>
          <target state="translated">Adem&amp;aacute;s, en caso de invasi&amp;oacute;n alien&amp;iacute;gena masiva, un &lt;strong&gt;generador recursivo decorado&lt;/strong&gt; podr&amp;iacute;a ser &amp;uacute;til:</target>
        </trans-unit>
        <trans-unit id="466f5c5627dd26bb81e764ceba90451103f9d8cc" translate="yes" xml:space="preserve">
          <source>And I created a generator that does the same if you put it into a list:</source>
          <target state="translated">Y he creado un generador que hace lo mismo si lo pones en una lista:</target>
        </trans-unit>
        <trans-unit id="a16a583c7b9df127020c4200726cd6173125abe2" translate="yes" xml:space="preserve">
          <source>And finally, since I see that all of the above functions return elements in a contiguous order (as they were given):</source>
          <target state="translated">Y finalmente,ya que veo que todas las funciones anteriores devuelven los elementos en un orden contiguo (como fueron dados):</target>
        </trans-unit>
        <trans-unit id="94291434f78dba4982f11e538ec1bc90b5361cfc" translate="yes" xml:space="preserve">
          <source>And this is for iterables:</source>
          <target state="translated">Y esto es para los iterables:</target>
        </trans-unit>
        <trans-unit id="b159a861f8ac09fa08f7c361d73a5a0451b7dd73" translate="yes" xml:space="preserve">
          <source>Another more explicit version.</source>
          <target state="translated">Otra versión más explícita.</target>
        </trans-unit>
        <trans-unit id="ba794e09d99fdf8a8de1d67d43d30f291b3a0e46" translate="yes" xml:space="preserve">
          <source>As Tomasz Gandor &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/22045226?noredirect=1#comment93566337_22045226&quot;&gt;observed&lt;/a&gt;, the two padding chunkers will stop unexpectedly if they encounter a long sequence of pad values. Here's a final variation that works around that problem in a reasonable way:</source>
          <target state="translated">Como &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/22045226?noredirect=1#comment93566337_22045226&quot;&gt;observ&amp;oacute;&lt;/a&gt; Tomasz Gandor, los dos fragmentos de relleno se detendr&amp;aacute;n inesperadamente si encuentran una larga secuencia de valores de relleno. Aqu&amp;iacute; hay una variaci&amp;oacute;n final que resuelve ese problema de manera razonable:</target>
        </trans-unit>
        <trans-unit id="684924ad57df650cdd2c98486dd54f22750bac17" translate="yes" xml:space="preserve">
          <source>At this point, I think we need a &lt;strong&gt;recursive generator&lt;/strong&gt;, just in case...</source>
          <target state="translated">En este punto, creo que necesitamos un &lt;strong&gt;generador recursivo&lt;/strong&gt; , por si acaso ...</target>
        </trans-unit>
        <trans-unit id="b708848595848810ad1ac40c9fc5a0ee26de016c" translate="yes" xml:space="preserve">
          <source>But if you don't want to be mercy on memory, you can use old-way and store the full &lt;code&gt;list&lt;/code&gt; in the first place with &lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked&quot;&gt;&lt;code&gt;iterutils.chunked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Pero si no desea ser misericordioso con la memoria, puede usar el m&amp;eacute;todo antiguo y almacenar la &lt;code&gt;list&lt;/code&gt; a completa en primer lugar con &lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked&quot;&gt; &lt;code&gt;iterutils.chunked&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0217590d01991aeb18e3cba8bb8c5866ca27dc94" translate="yes" xml:space="preserve">
          <source>Consider using &lt;a href=&quot;http://matplotlib.sourceforge.net/&quot;&gt;matplotlib.cbook&lt;/a&gt; pieces</source>
          <target state="translated">Considere usar piezas &lt;a href=&quot;http://matplotlib.sourceforge.net/&quot;&gt;matplotlib.cbook&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a9d2b49e8f4df50e8b1ac623f6bb7a7b4bd6a4e" translate="yes" xml:space="preserve">
          <source>Critique of other answers here:</source>
          <target state="translated">Crítica de otras respuestas aquí:</target>
        </trans-unit>
        <trans-unit id="83d36288b5c8873730d74ec2bee7f0a6e4883b2f" translate="yes" xml:space="preserve">
          <source>Demo:</source>
          <target state="translated">Demo:</target>
        </trans-unit>
        <trans-unit id="f6bc2643cbb300ad6f87ceb89b786afa73254a5b" translate="yes" xml:space="preserve">
          <source>Directly from the (old) Python documentation (recipes for itertools):</source>
          <target state="translated">Directamente de la (antigua)documentación de Python (recetas de herramientas):</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="abeb6a534299e04695514a9d009939b0be5ee7f8" translate="yes" xml:space="preserve">
          <source>For example, the current top answer ends with:</source>
          <target state="translated">Por ejemplo,la actual respuesta superior termina con:</target>
        </trans-unit>
        <trans-unit id="42fe4dc988463309c34e2c538e2fc0593a3da661" translate="yes" xml:space="preserve">
          <source>Here is a generator that work on arbitrary iterables:</source>
          <target state="translated">Aquí hay un generador que funciona con iterables arbitrarios:</target>
        </trans-unit>
        <trans-unit id="6118f1efb5132ea152c00e94763f8cc7da5935f7" translate="yes" xml:space="preserve">
          <source>Here is a list of additional approaches:</source>
          <target state="translated">He aquí una lista de enfoques adicionales:</target>
        </trans-unit>
        <trans-unit id="bc7408adabbd85102b98cc213e0b34ec73d9656a" translate="yes" xml:space="preserve">
          <source>Here's a balanced solution, adapted from a function I've used in production (Note in Python 3 to replace &lt;code&gt;xrange&lt;/code&gt; with &lt;code&gt;range&lt;/code&gt;):</source>
          <target state="translated">Aqu&amp;iacute; hay una soluci&amp;oacute;n equilibrada, adaptada de una funci&amp;oacute;n que he usado en producci&amp;oacute;n (Nota en Python 3 para reemplazar &lt;code&gt;xrange&lt;/code&gt; con &lt;code&gt;range&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="475e0ad532c2a9677552254e743eb1f3f0cfeb3e" translate="yes" xml:space="preserve">
          <source>Here's a generator that yields the chunks you want:</source>
          <target state="translated">Aquí hay un generador que produce los trozos que quieres:</target>
        </trans-unit>
        <trans-unit id="1b8977bd5e42e4e93b5e4e519f5b2ddce0307dc6" translate="yes" xml:space="preserve">
          <source>How do you split a list into evenly sized chunks</source>
          <target state="translated">¿Cómo se divide una lista en trozos de tamaño uniforme</target>
        </trans-unit>
        <trans-unit id="259b93bbd5391d6658f5c36fa7eb12deb846d34f" translate="yes" xml:space="preserve">
          <source>I believe this is the shortest chunker proposed that offers optional padding.</source>
          <target state="translated">Creo que es la propuesta más corta que ofrece un relleno opcional.</target>
        </trans-unit>
        <trans-unit id="dd756cc216563d48dfc2970de60f4103eea9c827" translate="yes" xml:space="preserve">
          <source>I guess Guido's time machine works&amp;mdash;worked&amp;mdash;will work&amp;mdash;will have worked&amp;mdash;was working again.</source>
          <target state="translated">Supongo que la m&amp;aacute;quina del tiempo de Guido funciona, funcion&amp;oacute;, funcionar&amp;aacute;, habr&amp;aacute; funcionado, estaba funcionando de nuevo.</target>
        </trans-unit>
        <trans-unit id="b0e9da2531173131f600ba521b0148ce5d316a49" translate="yes" xml:space="preserve">
          <source>I have a list of arbitrary length, and I need to split it up into equal size chunks and operate on it. There are some obvious ways to do this, like keeping a counter and two lists, and when the second list fills up, add it to the first list and empty the second list for the next round of data, but this is potentially extremely expensive.</source>
          <target state="translated">Tengo una lista de longitudes arbitrarias,y necesito dividirla en trozos de igual tamaño y operarla.Hay algunas maneras obvias de hacer esto,como mantener un contador y dos listas,y cuando la segunda lista se llena,añadirla a la primera lista y vaciar la segunda lista para la siguiente ronda de datos,pero esto es potencialmente muy caro.</target>
        </trans-unit>
        <trans-unit id="4e7311dd17ddc4d2548d04628d3db9f3eb615d09" translate="yes" xml:space="preserve">
          <source>I just hate that runt at the end!</source>
          <target state="translated">¡Odio a ese enano del final!</target>
        </trans-unit>
        <trans-unit id="6991457426a330552fa2b53cc1cd9baf2eda5d4d" translate="yes" xml:space="preserve">
          <source>I know this is kind of old but nobody yet mentioned &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_split.html&quot;&gt;&lt;code&gt;numpy.array_split&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">S&amp;eacute; que esto es un poco viejo, pero nadie ha mencionado &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_split.html&quot;&gt; &lt;code&gt;numpy.array_split&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="917f3cb33b9d8fc32db26c4c1d42ba79be308ac2" translate="yes" xml:space="preserve">
          <source>I like the Python doc's version proposed by tzot and J.F.Sebastian a lot,
 but it has two shortcomings:</source>
          <target state="translated">Me gusta mucho la versión del doctor Python propuesta por Tzot y J.F.Sebastian,pero tiene dos defectos:</target>
        </trans-unit>
        <trans-unit id="5e3a64e79ca9f8b6363ea8116d1b83a71d6de8b2" translate="yes" xml:space="preserve">
          <source>I saw the most awesome Python-ish answer in a &lt;a href=&quot;https://stackoverflow.com/questions/23286254/convert-list-to-a-list-of-tuples-python&quot;&gt;duplicate&lt;/a&gt; of this question:</source>
          <target state="translated">Vi la respuesta m&amp;aacute;s incre&amp;iacute;ble de Python-ish en un &lt;a href=&quot;https://stackoverflow.com/questions/23286254/convert-list-to-a-list-of-tuples-python&quot;&gt;duplicado&lt;/a&gt; de esta pregunta:</target>
        </trans-unit>
        <trans-unit id="90a677670a1371ced290b5e2e08bddb3c581b545" translate="yes" xml:space="preserve">
          <source>I usually don't want a fill value in the last chunk</source>
          <target state="translated">Normalmente no quiero un valor de relleno en el último trozo</target>
        </trans-unit>
        <trans-unit id="f1a4cd279695e4cab40018189926107de127ebd9" translate="yes" xml:space="preserve">
          <source>I was curious about the performance of different approaches and here it is:</source>
          <target state="translated">Tenía curiosidad por el rendimiento de los diferentes enfoques y aquí está:</target>
        </trans-unit>
        <trans-unit id="29613d33898c9e3aec1192dd3959128eeeaed9fe" translate="yes" xml:space="preserve">
          <source>I was looking for something useful in &lt;code&gt;itertools&lt;/code&gt; but I couldn't find anything obviously useful. Might've missed it, though.</source>
          <target state="translated">Estaba buscando algo &amp;uacute;til en &lt;code&gt;itertools&lt;/code&gt; pero no pude encontrar nada obviamente &amp;uacute;til. Sin embargo, podr&amp;iacute;a haberlo perdido.</target>
        </trans-unit>
        <trans-unit id="bac2dd4a60fa37bbf263a540d9fa81fa040d5743" translate="yes" xml:space="preserve">
          <source>I was wondering if anyone had a good solution to this for lists of any length, e.g. using generators.</source>
          <target state="translated">Me preguntaba si alguien tenía una buena solución para esto para listas de cualquier longitud,por ejemplo,usando generadores.</target>
        </trans-unit>
        <trans-unit id="327e2511d640cd43b47f579330504ab03a8329e1" translate="yes" xml:space="preserve">
          <source>I would use this when my chunk size is fixed number I can type, e.g. '3', and would never change.</source>
          <target state="translated">Usaría esto cuando el tamaño de mi trozo es un número fijo que puedo teclear,por ejemplo '3',y nunca cambiaría.</target>
        </trans-unit>
        <trans-unit id="9d08e2202ebb0e7dc670d4c4a6a76969c5c407b9" translate="yes" xml:space="preserve">
          <source>I'm surprised nobody has thought of using &lt;code&gt;iter&lt;/code&gt;'s &lt;a href=&quot;http://docs.python.org/2/library/functions.html#iter&quot;&gt;two-argument form&lt;/a&gt;:</source>
          <target state="translated">Me sorprende que nadie haya pensado en usar la forma de &lt;a href=&quot;http://docs.python.org/2/library/functions.html#iter&quot;&gt;dos argumentos de&lt;/a&gt; &lt;code&gt;iter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e58be21445a654631cbca714b7d8b95f296a6e61" translate="yes" xml:space="preserve">
          <source>I'm using this one a lot in my code:</source>
          <target state="translated">Estoy usando mucho este en mi código:</target>
        </trans-unit>
        <trans-unit id="83268aaf64878571e40a4b3ddea382e550652a4b" translate="yes" xml:space="preserve">
          <source>If the list is divided evenly, then you can replace &lt;code&gt;zip_longest&lt;/code&gt; with &lt;code&gt;zip&lt;/code&gt;, otherwise the triplet &lt;code&gt;(13, 14, None)&lt;/code&gt; would be lost. Python 3 is used above. For Python 2, use &lt;code&gt;izip_longest&lt;/code&gt;.</source>
          <target state="translated">Si la lista se divide en partes iguales, entonces puede reemplazar &lt;code&gt;zip_longest&lt;/code&gt; con &lt;code&gt;zip&lt;/code&gt; , de lo contrario se perder&amp;iacute;a el triplete &lt;code&gt;(13, 14, None)&lt;/code&gt; . Python 3 se usa arriba. Para Python 2, use &lt;code&gt;izip_longest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec5170c60b383c50bed6d0ed79270c3d4ebe5132" translate="yes" xml:space="preserve">
          <source>If you don't (an iterator):</source>
          <target state="translated">Si no lo haces (un iterador):</target>
        </trans-unit>
        <trans-unit id="eddfb5e7767850909b409b1a2b176629677801ee" translate="yes" xml:space="preserve">
          <source>If you had a chunk size of 3 for example, you could do:</source>
          <target state="translated">Si tuvieras un trozo de 3 por ejemplo,podrías hacerlo:</target>
        </trans-unit>
        <trans-unit id="27eb8d0c6e9a173ad4d54f2902a79e97d196089b" translate="yes" xml:space="preserve">
          <source>If you know list size:</source>
          <target state="translated">Si sabes el tamaño de la lista:</target>
        </trans-unit>
        <trans-unit id="ff962a30cc841787ba98f0e5697fc8787d38cdab" translate="yes" xml:space="preserve">
          <source>If you want something super simple:</source>
          <target state="translated">Si quieres algo súper simple:</target>
        </trans-unit>
        <trans-unit id="a92329ae6bbc2a5040204df33f2716aecd3924d3" translate="yes" xml:space="preserve">
          <source>If you're using Python 2, you should use &lt;code&gt;xrange()&lt;/code&gt; instead of &lt;code&gt;range()&lt;/code&gt;:</source>
          <target state="translated">Si usa Python 2, debe usar &lt;code&gt;xrange()&lt;/code&gt; lugar de &lt;code&gt;range()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="50140409745590859a22a654b9d2d2bf667150ea" translate="yes" xml:space="preserve">
          <source>In python 2:</source>
          <target state="translated">En pitón 2:</target>
        </trans-unit>
        <trans-unit id="ed6aded6af5e50183bd509e4af49bc6f8f430810" translate="yes" xml:space="preserve">
          <source>In python 3:</source>
          <target state="translated">En pitón 3:</target>
        </trans-unit>
        <trans-unit id="6ac245ac8f98f44abef3718b96f8f30922b4f9fe" translate="yes" xml:space="preserve">
          <source>In the latter case, it can be rephrased in a more beautiful way if you can be sure that the sequence always contains a whole number of chunks of given size (i.e. there is no incomplete last chunk).</source>
          <target state="translated">En este último caso,puede reformularse de una manera más hermosa si se puede estar seguro de que la secuencia siempre contiene un número entero de trozos de un tamaño determinado (es decir,no hay un último trozo incompleto).</target>
        </trans-unit>
        <trans-unit id="b508194a7c943e4f0e63ec041cd324e913fa524d" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;izip_longest&lt;/code&gt;-based solutions, the above &lt;em&gt;always&lt;/em&gt; pads. As far as I know, there's no one- or two-line itertools recipe for a function that &lt;em&gt;optionally&lt;/em&gt; pads. By combining the above two approaches, this one comes pretty close:</source>
          <target state="translated">Al igual que las &lt;code&gt;izip_longest&lt;/code&gt; basadas en izip_longest , lo anterior &lt;em&gt;siempre se&lt;/em&gt; rellena. Hasta donde s&amp;eacute;, no hay una receta de itertools de una o dos l&amp;iacute;neas para una funci&amp;oacute;n que &lt;em&gt;opcionalmente&lt;/em&gt; rellena. Al combinar los dos enfoques anteriores, este se acerca bastante:</target>
        </trans-unit>
        <trans-unit id="d8e673b11cbca16e0478d7e50c1a8ee8964a0366" translate="yes" xml:space="preserve">
          <source>My Solution(s)</source>
          <target state="translated">Mi(s)solución(es)</target>
        </trans-unit>
        <trans-unit id="d16d82e7085b348c197150b20ab37cad4152300a" translate="yes" xml:space="preserve">
          <source>None of these answers are evenly sized chunks, they all leave a runt chunk at the end, so they're not completely balanced. If you were using these functions to distribute work, you've built-in the prospect of one likely finishing well before the others, so it would sit around doing nothing while the others continued working hard.</source>
          <target state="translated">Ninguna de estas respuestas son trozos de tamaño uniforme,todas dejan un trozo pequeño al final,por lo que no están completamente equilibradas.Si utilizas estas funciones para distribuir el trabajo,has incorporado la posibilidad de que uno termine mucho antes que los otros,así que se quedaría sentado sin hacer nada mientras los otros siguen trabajando duro.</target>
        </trans-unit>
        <trans-unit id="4fb5cd16340841226cb584a92c0d56a59cc45ff9" translate="yes" xml:space="preserve">
          <source>Notice that the contiguous generator provide chunks in the same length patterns as the other two, but the items are all in order, and they are as evenly divided as one may divide a list of discrete elements.</source>
          <target state="translated">Obsérvese que el generador contiguo proporciona trozos de la misma longitud que los otros dos,pero los elementos están todos en orden,y están tan uniformemente divididos como se puede dividir una lista de elementos discretos.</target>
        </trans-unit>
        <trans-unit id="6f253cbf35cc30170ea6d83c8b71ed090a9a84a9" translate="yes" xml:space="preserve">
          <source>OR:</source>
          <target state="translated">OR:</target>
        </trans-unit>
        <trans-unit id="17a9b13128644f1d8b18cb515e3e01c79a026853" translate="yes" xml:space="preserve">
          <source>One more solution</source>
          <target state="translated">Una solución más</target>
        </trans-unit>
        <trans-unit id="f9199d6541466df87c407771ffe310862754415b" translate="yes" xml:space="preserve">
          <source>Others, like &lt;code&gt;list(grouper(3, xrange(7)))&lt;/code&gt;, and &lt;code&gt;chunk(xrange(7), 3)&lt;/code&gt; both return: &lt;code&gt;[(0, 1, 2), (3, 4, 5), (6, None, None)]&lt;/code&gt;. The &lt;code&gt;None&lt;/code&gt;'s are just padding, and rather inelegant in my opinion. They are NOT evenly chunking the iterables.</source>
          <target state="translated">Otros, como &lt;code&gt;list(grouper(3, xrange(7)))&lt;/code&gt; y &lt;code&gt;chunk(xrange(7), 3)&lt;/code&gt; ambos devuelven: &lt;code&gt;[(0, 1, 2), (3, 4, 5), (6, None, None)]&lt;/code&gt; . Los &lt;code&gt;None&lt;/code&gt; son solo acolchados y, en mi opini&amp;oacute;n, bastante poco elegantes. NO est&amp;aacute;n fragmentando uniformemente los iterables.</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="c0bf8c95093739ba9b7bafbe08dbe897abd95683" translate="yes" xml:space="preserve">
          <source>Python 2 version:</source>
          <target state="translated">Versión Python 2:</target>
        </trans-unit>
        <trans-unit id="260cdb02eef94c3ec0c5d6feeb1243b43c8d1491" translate="yes" xml:space="preserve">
          <source>Python3</source>
          <target state="translated">Python3</target>
        </trans-unit>
        <trans-unit id="71849193d7d4d55164b78c9896f7a9dc772ed9fe" translate="yes" xml:space="preserve">
          <source>Related question: &lt;a href=&quot;https://stackoverflow.com/questions/434287/what-is-the-most-pythonic-way-to-iterate-over-a-list-in-chunks&quot;&gt;What is the most &amp;ldquo;pythonic&amp;rdquo; way to iterate over a list in chunks?&lt;/a&gt;</source>
          <target state="translated">Pregunta relacionada: &lt;a href=&quot;https://stackoverflow.com/questions/434287/what-is-the-most-pythonic-way-to-iterate-over-a-list-in-chunks&quot;&gt;&amp;iquest;Cu&amp;aacute;l es la forma m&amp;aacute;s &quot;pit&amp;oacute;nica&quot; de iterar sobre una lista en fragmentos?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="981fcb2aa39ba3a18ef848f7e642cdf5f8ecd7fc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://docs.python.org/3.3/library/functions.html?highlight=zip#zip&quot;&gt;this reference&lt;/a&gt;</source>
          <target state="translated">Ver &lt;a href=&quot;http://docs.python.org/3.3/library/functions.html?highlight=zip#zip&quot;&gt;esta referencia&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c89e1bf8261d7f316330a5faf8a9a46b0e582595" translate="yes" xml:space="preserve">
          <source>Simple yet elegant</source>
          <target state="translated">Simple pero elegante</target>
        </trans-unit>
        <trans-unit id="2ff35546249ad5b66d0fb9d1fe43700554f6319c" translate="yes" xml:space="preserve">
          <source>Since everybody here talking about iterators. &lt;a href=&quot;https://boltons.readthedocs.io/&quot;&gt;&lt;code&gt;boltons&lt;/code&gt;&lt;/a&gt; has perfect method for that, called &lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked_iter&quot;&gt;&lt;code&gt;iterutils.chunked_iter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ya que todos aqu&amp;iacute; est&amp;aacute;n hablando de iteradores. &lt;a href=&quot;https://boltons.readthedocs.io/&quot;&gt; &lt;code&gt;boltons&lt;/code&gt; &lt;/a&gt; tiene un m&amp;eacute;todo perfecto para eso, llamado &lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked_iter&quot;&gt; &lt;code&gt;iterutils.chunked_iter&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74deacfe8465d3eece5467e74021e02845fce531" translate="yes" xml:space="preserve">
          <source>Tested on Python 3.5.1</source>
          <target state="translated">Probado en Python 3.5.1</target>
        </trans-unit>
        <trans-unit id="a070904a56ca5749113b247909c8f4172a684de4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/pytoolz/toolz&quot;&gt;toolz&lt;/a&gt; library has the &lt;code&gt;partition&lt;/code&gt; function for this:</source>
          <target state="translated">La biblioteca &lt;a href=&quot;https://github.com/pytoolz/toolz&quot;&gt;toolz&lt;/a&gt; tiene la funci&amp;oacute;n de &lt;code&gt;partition&lt;/code&gt; para esto:</target>
        </trans-unit>
        <trans-unit id="0e222ece4f0d63b0c3a30d4b1cff53a12ec0b0d7" translate="yes" xml:space="preserve">
          <source>The current version, as suggested by J.F.Sebastian:</source>
          <target state="translated">La versión actual,sugerida por J.F.Sebastian:</target>
        </trans-unit>
        <trans-unit id="303084aa1cd175ed003cf0c538e9a51c8ce3ee48" translate="yes" xml:space="preserve">
          <source>The functional flavour of the above:</source>
          <target state="translated">El sabor funcional de lo anterior:</target>
        </trans-unit>
        <trans-unit id="2d31acba4646b7046246eb5ec8c89ea9ba1453d6" translate="yes" xml:space="preserve">
          <source>These solutions work because &lt;code&gt;[iter(iterable)]*n&lt;/code&gt; (or the equivalent in the earlier version) creates &lt;em&gt;one&lt;/em&gt; iterator, repeated &lt;code&gt;n&lt;/code&gt; times in the list. &lt;code&gt;izip_longest&lt;/code&gt; then effectively performs a round-robin of &quot;each&quot; iterator; because this is the same iterator, it is advanced by each such call, resulting in each such zip-roundrobin generating one tuple of &lt;code&gt;n&lt;/code&gt; items.</source>
          <target state="translated">Estas soluciones funcionan porque &lt;code&gt;[iter(iterable)]*n&lt;/code&gt; (o el equivalente en la versi&amp;oacute;n anterior) crea &lt;em&gt;un&lt;/em&gt; iterador, repetido &lt;code&gt;n&lt;/code&gt; veces en la lista. &lt;code&gt;izip_longest&lt;/code&gt; luego realiza efectivamente un round-robin de &quot;cada&quot; iterador; Debido a que este es el mismo iterador, cada llamada de este tipo avanza, lo que da como resultado que cada zip-roundrobin genere una tupla de &lt;code&gt;n&lt;/code&gt; elementos.</target>
        </trans-unit>
        <trans-unit id="3351ae97164ad34d25cfa1a87ba90d402b29e7dc" translate="yes" xml:space="preserve">
          <source>This works on an arbitrary iterable, not just a list.</source>
          <target state="translated">Esto funciona en un iterable arbitrario,no sólo en una lista.</target>
        </trans-unit>
        <trans-unit id="f72c8b9833ef44f668e605f6c6b47726e8e3f946" translate="yes" xml:space="preserve">
          <source>This works with any iterable and produces output lazily. It returns tuples rather than iterators, but I think it has a certain elegance nonetheless. It also doesn't pad; if you want padding, a simple variation on the above will suffice:</source>
          <target state="translated">Esto funciona con cualquier iterable y produce una salida perezosa.Devuelve tuplas en lugar de iteradores,pero creo que tiene cierta elegancia.Tampoco es acolchado;si quieres acolchado,una simple variación de lo anterior será suficiente:</target>
        </trans-unit>
        <trans-unit id="c8c4d7f83e6f3c9aad0f35fb413eb0e5fbdd3d02" translate="yes" xml:space="preserve">
          <source>To test them out:</source>
          <target state="translated">Para probarlos:</target>
        </trans-unit>
        <trans-unit id="7e2bf240c51921bc85786da57f64d4d7ffb9b537" translate="yes" xml:space="preserve">
          <source>UPDATE: A lazy chunks version:</source>
          <target state="translated">ACTUALIZACIÓN:Una versión de trozos perezosos:</target>
        </trans-unit>
        <trans-unit id="379fa67eaaf9d4bf3b4cb8fe4251da2145554ba4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;xrange()&lt;/code&gt; instead of &lt;code&gt;range()&lt;/code&gt; in the case of Python 2.x</source>
          <target state="translated">Use &lt;code&gt;xrange()&lt;/code&gt; lugar de &lt;code&gt;range()&lt;/code&gt; en el caso de Python 2.x</target>
        </trans-unit>
        <trans-unit id="f610215c01d3050c4bc4007ebaf25e124322c260" translate="yes" xml:space="preserve">
          <source>Where AA is array, SS is chunk size. For example:</source>
          <target state="translated">Donde AA es la matriz,SS es el tamaño de un trozo.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="37716ed00d633b81920f80390744e2f570994984" translate="yes" xml:space="preserve">
          <source>Which prints out:</source>
          <target state="translated">Que se imprime:</target>
        </trans-unit>
        <trans-unit id="de34eeea45ec51d962a89827c68f30b24f15f868" translate="yes" xml:space="preserve">
          <source>Why can't we divide these better?</source>
          <target state="translated">¿Por qué no podemos dividirlos mejor?</target>
        </trans-unit>
        <trans-unit id="d1a8e487c7ddd714dc6aa815c7a65005ebeb7b81" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://www.python.org/dev/peps/pep-0572/&quot;&gt;Assignment Expressions&lt;/a&gt; in Python 3.8 it becomes quite nice:</source>
          <target state="translated">Con las &lt;a href=&quot;https://www.python.org/dev/peps/pep-0572/&quot;&gt;expresiones de asignaci&amp;oacute;n&lt;/a&gt; en Python 3.8 se vuelve bastante agradable:</target>
        </trans-unit>
        <trans-unit id="e81ab559adc970d663d23724576742b3e62a7248" translate="yes" xml:space="preserve">
          <source>Without calling len() which is good for large lists:</source>
          <target state="translated">Sin llamar a len()que es bueno para las listas grandes:</target>
        </trans-unit>
        <trans-unit id="e4eaae3f6d5fe8325131510e654ca9103ed32e13" translate="yes" xml:space="preserve">
          <source>You can create n-tuple for any n. If &lt;code&gt;a = range(1, 15)&lt;/code&gt;, then the result will be:</source>
          <target state="translated">Puede crear n-tuplas para cualquier n. Si &lt;code&gt;a = range(1, 15)&lt;/code&gt; , el resultado ser&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="58e01c1308a4e76507dfd9bfbc03b3c0bd4ab7ea" translate="yes" xml:space="preserve">
          <source>You can install &lt;a href=&quot;https://pypi.python.org/pypi/utilspie&quot;&gt;&lt;code&gt;utilspie&lt;/code&gt;&lt;/a&gt; via pip:</source>
          <target state="translated">Puede instalar &lt;a href=&quot;https://pypi.python.org/pypi/utilspie&quot;&gt; &lt;code&gt;utilspie&lt;/code&gt; a&lt;/a&gt; trav&amp;eacute;s de pip:</target>
        </trans-unit>
        <trans-unit id="c63f793d1aadeef671378f417f94a070ffde5e01" translate="yes" xml:space="preserve">
          <source>You may also use &lt;a href=&quot;http://utilspie.readthedocs.io/en/latest/#get-chunks&quot;&gt;&lt;code&gt;get_chunks&lt;/code&gt;&lt;/a&gt; function of &lt;a href=&quot;http://utilspie.readthedocs.io&quot;&gt;&lt;code&gt;utilspie&lt;/code&gt;&lt;/a&gt; library as:</source>
          <target state="translated">Tambi&amp;eacute;n puede usar la funci&amp;oacute;n &lt;a href=&quot;http://utilspie.readthedocs.io&quot;&gt; &lt;code&gt;utilspie&lt;/code&gt; &lt;/a&gt; biblioteca utilspie como:</target>
        </trans-unit>
        <trans-unit id="4fc19dd49d67bc4ce99ea768a6c767c51047c281" translate="yes" xml:space="preserve">
          <source>code:</source>
          <target state="translated">code:</target>
        </trans-unit>
        <trans-unit id="07d20acd3d6d3a65dab86aac1963f8fc7266dde3" translate="yes" xml:space="preserve">
          <source>for example:</source>
          <target state="translated">por ejemplo:</target>
        </trans-unit>
        <trans-unit id="868a36da4eb71c0342f273350a197b11e69d1c66" translate="yes" xml:space="preserve">
          <source>heh, one line version</source>
          <target state="translated">heh,versión de una línea</target>
        </trans-unit>
        <trans-unit id="39a25778f91a825c38533cb5a85e43cc0130f38a" translate="yes" xml:space="preserve">
          <source>it is not very explicit</source>
          <target state="translated">no es muy explícito</target>
        </trans-unit>
        <trans-unit id="23d29a1e5ae63b782e6282a05f8eba18a5eebc52" translate="yes" xml:space="preserve">
          <source>or if you prefer:</source>
          <target state="translated">o si lo prefieres:</target>
        </trans-unit>
        <trans-unit id="d575e92f6e78dfc9ee7b6d9f6680fd8e354625d8" translate="yes" xml:space="preserve">
          <source>result:</source>
          <target state="translated">result:</target>
        </trans-unit>
        <trans-unit id="7fb777990060cd6a13fa8c404b0c52ae3c520ed2" translate="yes" xml:space="preserve">
          <source>source:
&lt;a href=&quot;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&quot;&gt;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&lt;/a&gt;</source>
          <target state="translated">source:
&lt;a href=&quot;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&quot;&gt;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d99f66b852fef055214f1f6c4e0864afe932b13e" translate="yes" xml:space="preserve">
          <source>usage:</source>
          <target state="translated">usage:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
