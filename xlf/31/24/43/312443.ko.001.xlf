<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/312443">
    <body>
      <group id="312443">
        <trans-unit id="afc62f24d04a757a3fed298ee0502acbf641cc78" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.defaultdict&quot;&gt;&lt;code&gt;collections.defaultdict&lt;/code&gt;&lt;/a&gt;  (ordered results requires Python 3.6+)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.defaultdict&quot;&gt; &lt;code&gt;collections.defaultdict&lt;/code&gt; &lt;/a&gt; (순서 결과에는 Python 3.6 이상이 필요합니다)</target>
        </trans-unit>
        <trans-unit id="58e6d793c579e3e4ec49e97cc8c906104c1d4c0d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.zip_longest&quot;&gt;&lt;code&gt;zip_longest&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/3125186#3125186&quot;&gt;related post&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/29009933#29009933&quot;&gt;related post&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.zip_longest&quot;&gt; &lt;code&gt;zip_longest&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/3125186#3125186&quot;&gt;관련 게시물&lt;/a&gt; , &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/29009933#29009933&quot;&gt;관련 게시물&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="11757f2a8c1187933509721f8f085fdedce709a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.setdefault&quot;&gt;&lt;code&gt;setdefault&lt;/code&gt;&lt;/a&gt; (ordered results requires Python 3.6+)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.setdefault&quot;&gt; &lt;code&gt;setdefault&lt;/code&gt; &lt;/a&gt; (순서가 지정된 결과에는 Python 3.6 이상이 필요함)</target>
        </trans-unit>
        <trans-unit id="e0cfc75ee17c3572b6f56675f60c272896e59887" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;em&gt;&lt;code&gt;more_itertools&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;sup&gt;+&lt;/sup&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;em&gt;&lt;code&gt;more_itertools&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;sup&gt;+&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="709b4f054179d1afa28588c2eb207c1d90f9629b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.chunked&quot;&gt;&lt;code&gt;more_itertools.chunked&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/16315158#16315158&quot;&gt;related posted&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.chunked&quot;&gt; &lt;code&gt;more_itertools.chunked&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/16315158#16315158&quot;&gt;관련 게시&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1a2f32177b51d0d1415b5b4e4c7e1b2f156dab73" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.grouper&quot;&gt;&lt;code&gt;more_itertools.grouper&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/312644#312644&quot;&gt;related post&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.grouper&quot;&gt; &lt;code&gt;more_itertools.grouper&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/312644#312644&quot;&gt;관련 게시물&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="2a6ae8e428ee8fb0f3bf5335e99eadd09d507001" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.windowed&quot;&gt;&lt;code&gt;more_itertools.windowed&lt;/code&gt;&lt;/a&gt; (see also &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.stagger&quot;&gt;&lt;code&gt;stagger&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.zip_offset&quot;&gt;&lt;code&gt;zip_offset&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.windowed&quot;&gt; &lt;code&gt;more_itertools.windowed&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.stagger&quot;&gt; &lt;code&gt;stagger&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.zip_offset&quot;&gt; &lt;code&gt;zip_offset&lt;/code&gt; &lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="4143c70f77b270636a13fe869cc8ef3a270deec2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Disclaimer: I am the creator of &lt;a href=&quot;https://github.com/moin18/utilspie&quot;&gt;utilspie&lt;/a&gt; library&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;면책 조항 : 나는 &lt;a href=&quot;https://github.com/moin18/utilspie&quot;&gt;utilspie&lt;/a&gt; library의 제작자입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="610a42d66a5c2ccc81158b17f6ef8cfa7fb436c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The Standard Library&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;표준 라이브러리&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6607830e66ad80aa66ee0fb7977558ee0e94c1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Given&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Given&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="762b0b987efcf101541560526e8d90e402907514" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;References&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;References&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46d89300e0df73036ac46de568703f812bd19662" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Results:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Results:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c015b0c9104bd29356550baed6c391c2367ace1" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;sup&gt;+&lt;/sup&gt; A third-party library that implements &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;itertools recipes&lt;/a&gt; and more. &lt;code&gt;&amp;gt; pip install more_itertools&lt;/code&gt; &lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;sup&gt;+&lt;/sup&gt; &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;itertools 레시피&lt;/a&gt; 등을 구현하는 타사 라이브러리.&lt;/sub&gt; &lt;sub&gt; &lt;code&gt;&amp;gt; pip install more_itertools&lt;/code&gt; &lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="0c113960317b7fd4d0b8bd387f0902aaeec55697" translate="yes" xml:space="preserve">
          <source>Also you can simply use list comprehension instead of writing a function, though it's a good idea to encapsulate operations like this in named functions so that your code is easier to understand. Python 3:</source>
          <target state="translated">또한 함수를 작성하는 대신 간단히 목록 이해를 사용할 수 있지만 코드를 이해하기 쉽도록 이와 같은 연산을 명명 된 함수로 캡슐화하는 것이 좋습니다. 파이썬 3 :</target>
        </trans-unit>
        <trans-unit id="e19011a8b23a7c95dfea6a63f6395685a7497d26" translate="yes" xml:space="preserve">
          <source>Also, in case of massive Alien invasion, a &lt;strong&gt;decorated recursive generator&lt;/strong&gt; might become handy:</source>
          <target state="translated">또한 대규모 외계인 침공의 경우 &lt;strong&gt;장식 된 재귀 생성기&lt;/strong&gt; 가 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="466f5c5627dd26bb81e764ceba90451103f9d8cc" translate="yes" xml:space="preserve">
          <source>And I created a generator that does the same if you put it into a list:</source>
          <target state="translated">그리고 목록에 넣으면 똑같은 발전기를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="a16a583c7b9df127020c4200726cd6173125abe2" translate="yes" xml:space="preserve">
          <source>And finally, since I see that all of the above functions return elements in a contiguous order (as they were given):</source>
          <target state="translated">마지막으로 위의 모든 함수가 주어진 순서대로 요소를 연속적인 순서로 반환한다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="94291434f78dba4982f11e538ec1bc90b5361cfc" translate="yes" xml:space="preserve">
          <source>And this is for iterables:</source>
          <target state="translated">그리고 이것은 iterables를위한 것입니다 :</target>
        </trans-unit>
        <trans-unit id="b159a861f8ac09fa08f7c361d73a5a0451b7dd73" translate="yes" xml:space="preserve">
          <source>Another more explicit version.</source>
          <target state="translated">더 명백한 다른 버전.</target>
        </trans-unit>
        <trans-unit id="ba794e09d99fdf8a8de1d67d43d30f291b3a0e46" translate="yes" xml:space="preserve">
          <source>As Tomasz Gandor &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/22045226?noredirect=1#comment93566337_22045226&quot;&gt;observed&lt;/a&gt;, the two padding chunkers will stop unexpectedly if they encounter a long sequence of pad values. Here's a final variation that works around that problem in a reasonable way:</source>
          <target state="translated">Tomasz Gandor가 &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/22045226?noredirect=1#comment93566337_22045226&quot;&gt;관찰 한&lt;/a&gt; 바와 같이, 2 개의 패딩 청커는 긴 일련의 패드 값을 만나면 예기치 않게 멈출 것입니다. 다음은 합리적으로 해당 문제를 해결하는 최종 변형입니다.</target>
        </trans-unit>
        <trans-unit id="684924ad57df650cdd2c98486dd54f22750bac17" translate="yes" xml:space="preserve">
          <source>At this point, I think we need a &lt;strong&gt;recursive generator&lt;/strong&gt;, just in case...</source>
          <target state="translated">이 시점에서 우리는 &lt;strong&gt;재귀 발생기&lt;/strong&gt; 가 필요하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="b708848595848810ad1ac40c9fc5a0ee26de016c" translate="yes" xml:space="preserve">
          <source>But if you don't want to be mercy on memory, you can use old-way and store the full &lt;code&gt;list&lt;/code&gt; in the first place with &lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked&quot;&gt;&lt;code&gt;iterutils.chunked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그러나 메모리에 자비를 원하지 않으면 구식을 사용하고 &lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked&quot;&gt; &lt;code&gt;iterutils.chunked&lt;/code&gt; &lt;/a&gt; 를 사용하여 처음부터 전체 &lt;code&gt;list&lt;/code&gt; 을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0217590d01991aeb18e3cba8bb8c5866ca27dc94" translate="yes" xml:space="preserve">
          <source>Consider using &lt;a href=&quot;http://matplotlib.sourceforge.net/&quot;&gt;matplotlib.cbook&lt;/a&gt; pieces</source>
          <target state="translated">&lt;a href=&quot;http://matplotlib.sourceforge.net/&quot;&gt;matplotlib.cbook&lt;/a&gt; 조각 사용을 고려하십시오</target>
        </trans-unit>
        <trans-unit id="4a9d2b49e8f4df50e8b1ac623f6bb7a7b4bd6a4e" translate="yes" xml:space="preserve">
          <source>Critique of other answers here:</source>
          <target state="translated">다른 답변에 대한 비판 :</target>
        </trans-unit>
        <trans-unit id="83d36288b5c8873730d74ec2bee7f0a6e4883b2f" translate="yes" xml:space="preserve">
          <source>Demo:</source>
          <target state="translated">Demo:</target>
        </trans-unit>
        <trans-unit id="f6bc2643cbb300ad6f87ceb89b786afa73254a5b" translate="yes" xml:space="preserve">
          <source>Directly from the (old) Python documentation (recipes for itertools):</source>
          <target state="translated">(구) 파이썬 문서 (itertools에 대한 레시피)에서 직접 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="abeb6a534299e04695514a9d009939b0be5ee7f8" translate="yes" xml:space="preserve">
          <source>For example, the current top answer ends with:</source>
          <target state="translated">예를 들어 현재의 최상위 답변은 다음과 같이 끝납니다.</target>
        </trans-unit>
        <trans-unit id="42fe4dc988463309c34e2c538e2fc0593a3da661" translate="yes" xml:space="preserve">
          <source>Here is a generator that work on arbitrary iterables:</source>
          <target state="translated">다음은 임의의 이터 러블에서 작동하는 생성기입니다.</target>
        </trans-unit>
        <trans-unit id="6118f1efb5132ea152c00e94763f8cc7da5935f7" translate="yes" xml:space="preserve">
          <source>Here is a list of additional approaches:</source>
          <target state="translated">추가 접근 방식의 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc7408adabbd85102b98cc213e0b34ec73d9656a" translate="yes" xml:space="preserve">
          <source>Here's a balanced solution, adapted from a function I've used in production (Note in Python 3 to replace &lt;code&gt;xrange&lt;/code&gt; with &lt;code&gt;range&lt;/code&gt;):</source>
          <target state="translated">다음은 프로덕션에서 사용한 함수 ( &lt;code&gt;xrange&lt;/code&gt; 를 &lt;code&gt;range&lt;/code&gt; 로 대체하는 Python 3 참고)에서 조정 된 균형 잡힌 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="475e0ad532c2a9677552254e743eb1f3f0cfeb3e" translate="yes" xml:space="preserve">
          <source>Here's a generator that yields the chunks you want:</source>
          <target state="translated">다음은 원하는 청크를 생성하는 생성기입니다.</target>
        </trans-unit>
        <trans-unit id="1b8977bd5e42e4e93b5e4e519f5b2ddce0307dc6" translate="yes" xml:space="preserve">
          <source>How do you split a list into evenly sized chunks</source>
          <target state="translated">목록을 고른 크기의 덩어리로 나누는 방법</target>
        </trans-unit>
        <trans-unit id="259b93bbd5391d6658f5c36fa7eb12deb846d34f" translate="yes" xml:space="preserve">
          <source>I believe this is the shortest chunker proposed that offers optional padding.</source>
          <target state="translated">나는 이것이 선택적 패딩을 제공하는 가장 짧은 청커 제안이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="dd756cc216563d48dfc2970de60f4103eea9c827" translate="yes" xml:space="preserve">
          <source>I guess Guido's time machine works&amp;mdash;worked&amp;mdash;will work&amp;mdash;will have worked&amp;mdash;was working again.</source>
          <target state="translated">귀도의 타임머신 작업 (작동했거나 작동했을 것임)이 다시 작동 한 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0e9da2531173131f600ba521b0148ce5d316a49" translate="yes" xml:space="preserve">
          <source>I have a list of arbitrary length, and I need to split it up into equal size chunks and operate on it. There are some obvious ways to do this, like keeping a counter and two lists, and when the second list fills up, add it to the first list and empty the second list for the next round of data, but this is potentially extremely expensive.</source>
          <target state="translated">나는 임의의 길이 목록을 가지고 있으며, 그것을 동일한 크기의 덩어리로 나누고 작동해야합니다. 카운터와 두 개의 목록을 유지하는 것과 같은 명백한 방법이 있으며 두 번째 목록이 채워지면 첫 번째 목록에 추가하고 다음 데이터 라운드를 위해 두 번째 목록을 비우십시오. 그러나 이것은 잠재적으로 매우 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="4e7311dd17ddc4d2548d04628d3db9f3eb615d09" translate="yes" xml:space="preserve">
          <source>I just hate that runt at the end!</source>
          <target state="translated">나는 결국 그 런트를 싫어합니다!</target>
        </trans-unit>
        <trans-unit id="6991457426a330552fa2b53cc1cd9baf2eda5d4d" translate="yes" xml:space="preserve">
          <source>I know this is kind of old but nobody yet mentioned &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_split.html&quot;&gt;&lt;code&gt;numpy.array_split&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">나는 이것이 오래된 종류라는 것을 알고 있지만 아무도 &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_split.html&quot;&gt; &lt;code&gt;numpy.array_split&lt;/code&gt; 을&lt;/a&gt; 언급하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="917f3cb33b9d8fc32db26c4c1d42ba79be308ac2" translate="yes" xml:space="preserve">
          <source>I like the Python doc's version proposed by tzot and J.F.Sebastian a lot,
 but it has two shortcomings:</source>
          <target state="translated">나는 tzot과 JFSebastian이 제안한 Python doc 버전을 좋아하지만 두 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e3a64e79ca9f8b6363ea8116d1b83a71d6de8b2" translate="yes" xml:space="preserve">
          <source>I saw the most awesome Python-ish answer in a &lt;a href=&quot;https://stackoverflow.com/questions/23286254/convert-list-to-a-list-of-tuples-python&quot;&gt;duplicate&lt;/a&gt; of this question:</source>
          <target state="translated">이 질문의 &lt;a href=&quot;https://stackoverflow.com/questions/23286254/convert-list-to-a-list-of-tuples-python&quot;&gt;복제본&lt;/a&gt; 에서 가장 멋진 Python-ish 답변을 보았습니다.</target>
        </trans-unit>
        <trans-unit id="90a677670a1371ced290b5e2e08bddb3c581b545" translate="yes" xml:space="preserve">
          <source>I usually don't want a fill value in the last chunk</source>
          <target state="translated">나는 보통 마지막 덩어리에 채우기 값을 원하지 않는다</target>
        </trans-unit>
        <trans-unit id="f1a4cd279695e4cab40018189926107de127ebd9" translate="yes" xml:space="preserve">
          <source>I was curious about the performance of different approaches and here it is:</source>
          <target state="translated">다른 접근 방식의 성능에 대해 궁금했고 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="29613d33898c9e3aec1192dd3959128eeeaed9fe" translate="yes" xml:space="preserve">
          <source>I was looking for something useful in &lt;code&gt;itertools&lt;/code&gt; but I couldn't find anything obviously useful. Might've missed it, though.</source>
          <target state="translated">&lt;code&gt;itertools&lt;/code&gt; 에서 유용한 것을 찾고 있었지만 분명히 유용한 것을 찾을 수 없었습니다. 그래도 놓쳤을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bac2dd4a60fa37bbf263a540d9fa81fa040d5743" translate="yes" xml:space="preserve">
          <source>I was wondering if anyone had a good solution to this for lists of any length, e.g. using generators.</source>
          <target state="translated">나는 길이가 긴 목록 (예 : 발전기 사용)에 대해 누군가가 이것에 대한 좋은 해결책을 가지고 있는지 궁금합니다.</target>
        </trans-unit>
        <trans-unit id="327e2511d640cd43b47f579330504ab03a8329e1" translate="yes" xml:space="preserve">
          <source>I would use this when my chunk size is fixed number I can type, e.g. '3', and would never change.</source>
          <target state="translated">내 청크 크기가 고정 숫자 일 때 사용할 수 있습니다 (예 : '3'). 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d08e2202ebb0e7dc670d4c4a6a76969c5c407b9" translate="yes" xml:space="preserve">
          <source>I'm surprised nobody has thought of using &lt;code&gt;iter&lt;/code&gt;'s &lt;a href=&quot;http://docs.python.org/2/library/functions.html#iter&quot;&gt;two-argument form&lt;/a&gt;:</source>
          <target state="translated">아무도 &lt;code&gt;iter&lt;/code&gt; 의 &lt;a href=&quot;http://docs.python.org/2/library/functions.html#iter&quot;&gt;두 가지 인수 형식&lt;/a&gt; 을 사용하려고 생각하지 않은 것에 놀랐습니다.</target>
        </trans-unit>
        <trans-unit id="e58be21445a654631cbca714b7d8b95f296a6e61" translate="yes" xml:space="preserve">
          <source>I'm using this one a lot in my code:</source>
          <target state="translated">내 코드에서 이것을 많이 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="83268aaf64878571e40a4b3ddea382e550652a4b" translate="yes" xml:space="preserve">
          <source>If the list is divided evenly, then you can replace &lt;code&gt;zip_longest&lt;/code&gt; with &lt;code&gt;zip&lt;/code&gt;, otherwise the triplet &lt;code&gt;(13, 14, None)&lt;/code&gt; would be lost. Python 3 is used above. For Python 2, use &lt;code&gt;izip_longest&lt;/code&gt;.</source>
          <target state="translated">목록이 균등하게 분할되면 &lt;code&gt;zip_longest&lt;/code&gt; 를 &lt;code&gt;zip&lt;/code&gt; 으로 바꿀 수 있습니다. 그렇지 않으면 삼중 항 &lt;code&gt;(13, 14, None)&lt;/code&gt; 이 손실됩니다. 파이썬 3이 위에서 사용되었습니다. Python 2의 경우 &lt;code&gt;izip_longest&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec5170c60b383c50bed6d0ed79270c3d4ebe5132" translate="yes" xml:space="preserve">
          <source>If you don't (an iterator):</source>
          <target state="translated">그렇지 않으면 (반복자) :</target>
        </trans-unit>
        <trans-unit id="eddfb5e7767850909b409b1a2b176629677801ee" translate="yes" xml:space="preserve">
          <source>If you had a chunk size of 3 for example, you could do:</source>
          <target state="translated">예를 들어 청크 크기가 3 인 경우 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27eb8d0c6e9a173ad4d54f2902a79e97d196089b" translate="yes" xml:space="preserve">
          <source>If you know list size:</source>
          <target state="translated">목록 크기를 알고있는 경우 :</target>
        </trans-unit>
        <trans-unit id="ff962a30cc841787ba98f0e5697fc8787d38cdab" translate="yes" xml:space="preserve">
          <source>If you want something super simple:</source>
          <target state="translated">아주 간단한 것을 원한다면 :</target>
        </trans-unit>
        <trans-unit id="a92329ae6bbc2a5040204df33f2716aecd3924d3" translate="yes" xml:space="preserve">
          <source>If you're using Python 2, you should use &lt;code&gt;xrange()&lt;/code&gt; instead of &lt;code&gt;range()&lt;/code&gt;:</source>
          <target state="translated">Python 2를 사용하는 경우 &lt;code&gt;xrange()&lt;/code&gt; 대신 xrange () 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="50140409745590859a22a654b9d2d2bf667150ea" translate="yes" xml:space="preserve">
          <source>In python 2:</source>
          <target state="translated">파이썬 2에서 :</target>
        </trans-unit>
        <trans-unit id="ed6aded6af5e50183bd509e4af49bc6f8f430810" translate="yes" xml:space="preserve">
          <source>In python 3:</source>
          <target state="translated">파이썬 3에서 :</target>
        </trans-unit>
        <trans-unit id="6ac245ac8f98f44abef3718b96f8f30922b4f9fe" translate="yes" xml:space="preserve">
          <source>In the latter case, it can be rephrased in a more beautiful way if you can be sure that the sequence always contains a whole number of chunks of given size (i.e. there is no incomplete last chunk).</source>
          <target state="translated">후자의 경우, 시퀀스에 항상 주어진 크기의 전체 청크 수가 포함되어 있는지 (즉, 불완전한 마지막 청크가 없음) 확신 할 수 있으면 더 아름다운 방식으로 다시 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b508194a7c943e4f0e63ec041cd324e913fa524d" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;izip_longest&lt;/code&gt;-based solutions, the above &lt;em&gt;always&lt;/em&gt; pads. As far as I know, there's no one- or two-line itertools recipe for a function that &lt;em&gt;optionally&lt;/em&gt; pads. By combining the above two approaches, this one comes pretty close:</source>
          <target state="translated">&lt;code&gt;izip_longest&lt;/code&gt; 기반 솔루션과 마찬가지로 위도 &lt;em&gt;항상&lt;/em&gt; 패딩됩니다. 내가 아는 한, &lt;em&gt;선택적으로&lt;/em&gt; 패딩하는 함수에 대한 한 줄 또는 두 줄의 itertools 레시피가 없습니다. 위의 두 가지 접근 방식을 결합하면이 접근 방식이 매우 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="d8e673b11cbca16e0478d7e50c1a8ee8964a0366" translate="yes" xml:space="preserve">
          <source>My Solution(s)</source>
          <target state="translated">내 솔루션</target>
        </trans-unit>
        <trans-unit id="d16d82e7085b348c197150b20ab37cad4152300a" translate="yes" xml:space="preserve">
          <source>None of these answers are evenly sized chunks, they all leave a runt chunk at the end, so they're not completely balanced. If you were using these functions to distribute work, you've built-in the prospect of one likely finishing well before the others, so it would sit around doing nothing while the others continued working hard.</source>
          <target state="translated">이 답변 중 어느 것도 고른 크기의 청크가 아니며 끝 부분에 런트 청크가 남으므로 완전히 균형이 맞지 않습니다. 이러한 기능을 사용하여 작업을 배포하는 경우 다른 작업보다 먼저 마무리 작업이 완료 될 수 있으므로 다른 작업을 계속하는 동안 아무 작업도 수행하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="4fb5cd16340841226cb584a92c0d56a59cc45ff9" translate="yes" xml:space="preserve">
          <source>Notice that the contiguous generator provide chunks in the same length patterns as the other two, but the items are all in order, and they are as evenly divided as one may divide a list of discrete elements.</source>
          <target state="translated">연속 생성기는 다른 두 패턴과 동일한 길이 패턴으로 청크를 제공하지만 항목은 모두 순서대로 나열되며 개별 요소 목록을 분할 할 수있는만큼 균일하게 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="6f253cbf35cc30170ea6d83c8b71ed090a9a84a9" translate="yes" xml:space="preserve">
          <source>OR:</source>
          <target state="translated">OR:</target>
        </trans-unit>
        <trans-unit id="17a9b13128644f1d8b18cb515e3e01c79a026853" translate="yes" xml:space="preserve">
          <source>One more solution</source>
          <target state="translated">하나 더 솔루션</target>
        </trans-unit>
        <trans-unit id="f9199d6541466df87c407771ffe310862754415b" translate="yes" xml:space="preserve">
          <source>Others, like &lt;code&gt;list(grouper(3, xrange(7)))&lt;/code&gt;, and &lt;code&gt;chunk(xrange(7), 3)&lt;/code&gt; both return: &lt;code&gt;[(0, 1, 2), (3, 4, 5), (6, None, None)]&lt;/code&gt;. The &lt;code&gt;None&lt;/code&gt;'s are just padding, and rather inelegant in my opinion. They are NOT evenly chunking the iterables.</source>
          <target state="translated">&lt;code&gt;list(grouper(3, xrange(7)))&lt;/code&gt; 및 &lt;code&gt;chunk(xrange(7), 3)&lt;/code&gt; 와 같은 다른 것들은 모두 다음을 반환합니다 : &lt;code&gt;[(0, 1, 2), (3, 4, 5), (6, None, None)]&lt;/code&gt; . &lt;code&gt;None&lt;/code&gt; 은 단지 패딩이며 내 의견으로는 우아하지 않습니다. 그들은 iterables를 고르게 청크하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="c0bf8c95093739ba9b7bafbe08dbe897abd95683" translate="yes" xml:space="preserve">
          <source>Python 2 version:</source>
          <target state="translated">파이썬 2 버전 :</target>
        </trans-unit>
        <trans-unit id="260cdb02eef94c3ec0c5d6feeb1243b43c8d1491" translate="yes" xml:space="preserve">
          <source>Python3</source>
          <target state="translated">Python3</target>
        </trans-unit>
        <trans-unit id="71849193d7d4d55164b78c9896f7a9dc772ed9fe" translate="yes" xml:space="preserve">
          <source>Related question: &lt;a href=&quot;https://stackoverflow.com/questions/434287/what-is-the-most-pythonic-way-to-iterate-over-a-list-in-chunks&quot;&gt;What is the most &amp;ldquo;pythonic&amp;rdquo; way to iterate over a list in chunks?&lt;/a&gt;</source>
          <target state="translated">관련 질문 : &lt;a href=&quot;https://stackoverflow.com/questions/434287/what-is-the-most-pythonic-way-to-iterate-over-a-list-in-chunks&quot;&gt;청크 목록을 반복하는 가장 &quot;파이썬&quot;방법은 무엇입니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="981fcb2aa39ba3a18ef848f7e642cdf5f8ecd7fc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://docs.python.org/3.3/library/functions.html?highlight=zip#zip&quot;&gt;this reference&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/3.3/library/functions.html?highlight=zip#zip&quot;&gt;이 참조를보십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c89e1bf8261d7f316330a5faf8a9a46b0e582595" translate="yes" xml:space="preserve">
          <source>Simple yet elegant</source>
          <target state="translated">단순하면서도 우아함</target>
        </trans-unit>
        <trans-unit id="2ff35546249ad5b66d0fb9d1fe43700554f6319c" translate="yes" xml:space="preserve">
          <source>Since everybody here talking about iterators. &lt;a href=&quot;https://boltons.readthedocs.io/&quot;&gt;&lt;code&gt;boltons&lt;/code&gt;&lt;/a&gt; has perfect method for that, called &lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked_iter&quot;&gt;&lt;code&gt;iterutils.chunked_iter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여기 모두가 반복자에 대해 이야기하기 때문에. &lt;a href=&quot;https://boltons.readthedocs.io/&quot;&gt; &lt;code&gt;boltons&lt;/code&gt; &lt;/a&gt; 에는 iterutils.chunked_iter 라는 완벽한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="74deacfe8465d3eece5467e74021e02845fce531" translate="yes" xml:space="preserve">
          <source>Tested on Python 3.5.1</source>
          <target state="translated">Python 3.5.1에서 테스트</target>
        </trans-unit>
        <trans-unit id="a070904a56ca5749113b247909c8f4172a684de4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/pytoolz/toolz&quot;&gt;toolz&lt;/a&gt; library has the &lt;code&gt;partition&lt;/code&gt; function for this:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/pytoolz/toolz&quot;&gt;toolz&lt;/a&gt; 라이브러리에는이를위한 &lt;code&gt;partition&lt;/code&gt; 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e222ece4f0d63b0c3a30d4b1cff53a12ec0b0d7" translate="yes" xml:space="preserve">
          <source>The current version, as suggested by J.F.Sebastian:</source>
          <target state="translated">JFSebastian이 제안한 현재 버전 :</target>
        </trans-unit>
        <trans-unit id="303084aa1cd175ed003cf0c538e9a51c8ce3ee48" translate="yes" xml:space="preserve">
          <source>The functional flavour of the above:</source>
          <target state="translated">위의 기능적 풍미 :</target>
        </trans-unit>
        <trans-unit id="2d31acba4646b7046246eb5ec8c89ea9ba1453d6" translate="yes" xml:space="preserve">
          <source>These solutions work because &lt;code&gt;[iter(iterable)]*n&lt;/code&gt; (or the equivalent in the earlier version) creates &lt;em&gt;one&lt;/em&gt; iterator, repeated &lt;code&gt;n&lt;/code&gt; times in the list. &lt;code&gt;izip_longest&lt;/code&gt; then effectively performs a round-robin of &quot;each&quot; iterator; because this is the same iterator, it is advanced by each such call, resulting in each such zip-roundrobin generating one tuple of &lt;code&gt;n&lt;/code&gt; items.</source>
          <target state="translated">이 솔루션은 &lt;code&gt;[iter(iterable)]*n&lt;/code&gt; (또는 이전 버전과 동일)이 목록에서 &lt;code&gt;n&lt;/code&gt; 번 반복되는 &lt;em&gt;하나의&lt;/em&gt; 반복자를 작성하기 때문에 작동합니다. &lt;code&gt;izip_longest&lt;/code&gt; 다음 izip_longest 는 &quot;각&quot;반복자의 라운드 로빈을 효과적으로 수행합니다. 이것은 동일한 반복자이므로 각 호출에 의해 진행되어 이러한 zip-roundrobin이 &lt;code&gt;n&lt;/code&gt; 개의 튜플 하나를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3351ae97164ad34d25cfa1a87ba90d402b29e7dc" translate="yes" xml:space="preserve">
          <source>This works on an arbitrary iterable, not just a list.</source>
          <target state="translated">이것은 목록뿐만 아니라 임의의 반복 가능에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f72c8b9833ef44f668e605f6c6b47726e8e3f946" translate="yes" xml:space="preserve">
          <source>This works with any iterable and produces output lazily. It returns tuples rather than iterators, but I think it has a certain elegance nonetheless. It also doesn't pad; if you want padding, a simple variation on the above will suffice:</source>
          <target state="translated">이것은 모든 iterable과 작동하며 느리게 출력됩니다. 반복자보다는 튜플을 반환하지만 그럼에도 불구하고 특정 우아함이 있다고 생각합니다. 또한 패드가 없습니다. 패딩을 원하면 위의 간단한 변형으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="c8c4d7f83e6f3c9aad0f35fb413eb0e5fbdd3d02" translate="yes" xml:space="preserve">
          <source>To test them out:</source>
          <target state="translated">테스트하려면 :</target>
        </trans-unit>
        <trans-unit id="7e2bf240c51921bc85786da57f64d4d7ffb9b537" translate="yes" xml:space="preserve">
          <source>UPDATE: A lazy chunks version:</source>
          <target state="translated">업데이트 : 게으른 청크 버전 :</target>
        </trans-unit>
        <trans-unit id="379fa67eaaf9d4bf3b4cb8fe4251da2145554ba4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;xrange()&lt;/code&gt; instead of &lt;code&gt;range()&lt;/code&gt; in the case of Python 2.x</source>
          <target state="translated">Python 2.x의 경우 &lt;code&gt;range()&lt;/code&gt; &lt;code&gt;xrange()&lt;/code&gt; 대신 xrange () 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f610215c01d3050c4bc4007ebaf25e124322c260" translate="yes" xml:space="preserve">
          <source>Where AA is array, SS is chunk size. For example:</source>
          <target state="translated">AA가 배열 인 경우 SS는 청크 크기입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37716ed00d633b81920f80390744e2f570994984" translate="yes" xml:space="preserve">
          <source>Which prints out:</source>
          <target state="translated">출력되는 내용 :</target>
        </trans-unit>
        <trans-unit id="de34eeea45ec51d962a89827c68f30b24f15f868" translate="yes" xml:space="preserve">
          <source>Why can't we divide these better?</source>
          <target state="translated">왜 우리는 이것을 더 잘 나눌 수 없습니까?</target>
        </trans-unit>
        <trans-unit id="d1a8e487c7ddd714dc6aa815c7a65005ebeb7b81" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://www.python.org/dev/peps/pep-0572/&quot;&gt;Assignment Expressions&lt;/a&gt; in Python 3.8 it becomes quite nice:</source>
          <target state="translated">Python 3.8의 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0572/&quot;&gt;Assignment Expressions&lt;/a&gt; 를 사용하면 꽤 좋아집니다.</target>
        </trans-unit>
        <trans-unit id="e81ab559adc970d663d23724576742b3e62a7248" translate="yes" xml:space="preserve">
          <source>Without calling len() which is good for large lists:</source>
          <target state="translated">큰 목록에 좋은 len ()을 호출하지 않으면 :</target>
        </trans-unit>
        <trans-unit id="e4eaae3f6d5fe8325131510e654ca9103ed32e13" translate="yes" xml:space="preserve">
          <source>You can create n-tuple for any n. If &lt;code&gt;a = range(1, 15)&lt;/code&gt;, then the result will be:</source>
          <target state="translated">모든 n에 대해 n- 튜플을 만들 수 있습니다. &lt;code&gt;a = range(1, 15)&lt;/code&gt; 인 경우 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58e01c1308a4e76507dfd9bfbc03b3c0bd4ab7ea" translate="yes" xml:space="preserve">
          <source>You can install &lt;a href=&quot;https://pypi.python.org/pypi/utilspie&quot;&gt;&lt;code&gt;utilspie&lt;/code&gt;&lt;/a&gt; via pip:</source>
          <target state="translated">pip를 통해 &lt;a href=&quot;https://pypi.python.org/pypi/utilspie&quot;&gt; &lt;code&gt;utilspie&lt;/code&gt; &lt;/a&gt; 를 설치할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c63f793d1aadeef671378f417f94a070ffde5e01" translate="yes" xml:space="preserve">
          <source>You may also use &lt;a href=&quot;http://utilspie.readthedocs.io/en/latest/#get-chunks&quot;&gt;&lt;code&gt;get_chunks&lt;/code&gt;&lt;/a&gt; function of &lt;a href=&quot;http://utilspie.readthedocs.io&quot;&gt;&lt;code&gt;utilspie&lt;/code&gt;&lt;/a&gt; library as:</source>
          <target state="translated">&lt;a href=&quot;http://utilspie.readthedocs.io&quot;&gt; &lt;code&gt;utilspie&lt;/code&gt; &lt;/a&gt; 라이브러리의 get_chunks 함수를 다음 과 같이 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc19dd49d67bc4ce99ea768a6c767c51047c281" translate="yes" xml:space="preserve">
          <source>code:</source>
          <target state="translated">code:</target>
        </trans-unit>
        <trans-unit id="07d20acd3d6d3a65dab86aac1963f8fc7266dde3" translate="yes" xml:space="preserve">
          <source>for example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="868a36da4eb71c0342f273350a197b11e69d1c66" translate="yes" xml:space="preserve">
          <source>heh, one line version</source>
          <target state="translated">허, 한 줄 버전</target>
        </trans-unit>
        <trans-unit id="39a25778f91a825c38533cb5a85e43cc0130f38a" translate="yes" xml:space="preserve">
          <source>it is not very explicit</source>
          <target state="translated">그것은 명백하지 않다</target>
        </trans-unit>
        <trans-unit id="23d29a1e5ae63b782e6282a05f8eba18a5eebc52" translate="yes" xml:space="preserve">
          <source>or if you prefer:</source>
          <target state="translated">또는 원하는 경우 :</target>
        </trans-unit>
        <trans-unit id="d575e92f6e78dfc9ee7b6d9f6680fd8e354625d8" translate="yes" xml:space="preserve">
          <source>result:</source>
          <target state="translated">result:</target>
        </trans-unit>
        <trans-unit id="7fb777990060cd6a13fa8c404b0c52ae3c520ed2" translate="yes" xml:space="preserve">
          <source>source:
&lt;a href=&quot;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&quot;&gt;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&lt;/a&gt;</source>
          <target state="translated">source:
&lt;a href=&quot;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&quot;&gt;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d99f66b852fef055214f1f6c4e0864afe932b13e" translate="yes" xml:space="preserve">
          <source>usage:</source>
          <target state="translated">usage:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
