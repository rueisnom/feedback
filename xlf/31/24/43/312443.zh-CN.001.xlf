<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/312443">
    <body>
      <group id="312443">
        <trans-unit id="afc62f24d04a757a3fed298ee0502acbf641cc78" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.defaultdict&quot;&gt;&lt;code&gt;collections.defaultdict&lt;/code&gt;&lt;/a&gt;  (ordered results requires Python 3.6+)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.defaultdict&quot;&gt; &lt;code&gt;collections.defaultdict&lt;/code&gt; &lt;/a&gt; （排序结果需要Python 3.6+）</target>
        </trans-unit>
        <trans-unit id="58e6d793c579e3e4ec49e97cc8c906104c1d4c0d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.zip_longest&quot;&gt;&lt;code&gt;zip_longest&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/3125186#3125186&quot;&gt;related post&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/29009933#29009933&quot;&gt;related post&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.zip_longest&quot;&gt; &lt;code&gt;zip_longest&lt;/code&gt; &lt;/a&gt; （ &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/3125186#3125186&quot;&gt;相关文章&lt;/a&gt; ， &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/29009933#29009933&quot;&gt;相关文章&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="11757f2a8c1187933509721f8f085fdedce709a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.setdefault&quot;&gt;&lt;code&gt;setdefault&lt;/code&gt;&lt;/a&gt; (ordered results requires Python 3.6+)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.setdefault&quot;&gt; &lt;code&gt;setdefault&lt;/code&gt; &lt;/a&gt; （排序结果需要Python 3.6+）</target>
        </trans-unit>
        <trans-unit id="e0cfc75ee17c3572b6f56675f60c272896e59887" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;em&gt;&lt;code&gt;more_itertools&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;sup&gt;+&lt;/sup&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;em&gt;&lt;code&gt;more_itertools&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;sup&gt;+&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="709b4f054179d1afa28588c2eb207c1d90f9629b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.chunked&quot;&gt;&lt;code&gt;more_itertools.chunked&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/16315158#16315158&quot;&gt;related posted&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.chunked&quot;&gt; &lt;code&gt;more_itertools.chunked&lt;/code&gt; &lt;/a&gt; （ &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/16315158#16315158&quot;&gt;相关发布&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="1a2f32177b51d0d1415b5b4e4c7e1b2f156dab73" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.grouper&quot;&gt;&lt;code&gt;more_itertools.grouper&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/312644#312644&quot;&gt;related post&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.grouper&quot;&gt; &lt;code&gt;more_itertools.grouper&lt;/code&gt; &lt;/a&gt; （ &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/312644#312644&quot;&gt;相关文章&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="2a6ae8e428ee8fb0f3bf5335e99eadd09d507001" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.windowed&quot;&gt;&lt;code&gt;more_itertools.windowed&lt;/code&gt;&lt;/a&gt; (see also &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.stagger&quot;&gt;&lt;code&gt;stagger&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.zip_offset&quot;&gt;&lt;code&gt;zip_offset&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.windowed&quot;&gt; &lt;code&gt;more_itertools.windowed&lt;/code&gt; &lt;/a&gt; （另请参见&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.stagger&quot;&gt; &lt;code&gt;stagger&lt;/code&gt; &lt;/a&gt; ， &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.zip_offset&quot;&gt; &lt;code&gt;zip_offset&lt;/code&gt; &lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="4143c70f77b270636a13fe869cc8ef3a270deec2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Disclaimer: I am the creator of &lt;a href=&quot;https://github.com/moin18/utilspie&quot;&gt;utilspie&lt;/a&gt; library&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;免责声明：我是&lt;a href=&quot;https://github.com/moin18/utilspie&quot;&gt;utilspie&lt;/a&gt;库的创建者&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="610a42d66a5c2ccc81158b17f6ef8cfa7fb436c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The Standard Library&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;标准图书馆&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6607830e66ad80aa66ee0fb7977558ee0e94c1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Given&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Given&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="762b0b987efcf101541560526e8d90e402907514" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;References&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;References&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46d89300e0df73036ac46de568703f812bd19662" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Results:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Results:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c015b0c9104bd29356550baed6c391c2367ace1" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;sup&gt;+&lt;/sup&gt; A third-party library that implements &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;itertools recipes&lt;/a&gt; and more. &lt;code&gt;&amp;gt; pip install more_itertools&lt;/code&gt; &lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;sup&gt;+&lt;/sup&gt;一个实现&lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;itertools配方&lt;/a&gt;等的第三方库。&lt;/sub&gt; &lt;sub&gt; &lt;code&gt;&amp;gt; pip install more_itertools&lt;/code&gt; &lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="0c113960317b7fd4d0b8bd387f0902aaeec55697" translate="yes" xml:space="preserve">
          <source>Also you can simply use list comprehension instead of writing a function, though it's a good idea to encapsulate operations like this in named functions so that your code is easier to understand. Python 3:</source>
          <target state="translated">另外,你可以简单地使用列表理解而不是写一个函数,当然,把这样的操作封装在命名的函数中是个好主意,这样你的代码更容易理解。Python 3:</target>
        </trans-unit>
        <trans-unit id="e19011a8b23a7c95dfea6a63f6395685a7497d26" translate="yes" xml:space="preserve">
          <source>Also, in case of massive Alien invasion, a &lt;strong&gt;decorated recursive generator&lt;/strong&gt; might become handy:</source>
          <target state="translated">同样，在外星人大规模入侵的情况下，经过&lt;strong&gt;修饰的递归生成器&lt;/strong&gt;可能会变得很方便：</target>
        </trans-unit>
        <trans-unit id="466f5c5627dd26bb81e764ceba90451103f9d8cc" translate="yes" xml:space="preserve">
          <source>And I created a generator that does the same if you put it into a list:</source>
          <target state="translated">而我创造了一个生成器,如果你把它放到列表里,也是一样的。</target>
        </trans-unit>
        <trans-unit id="a16a583c7b9df127020c4200726cd6173125abe2" translate="yes" xml:space="preserve">
          <source>And finally, since I see that all of the above functions return elements in a contiguous order (as they were given):</source>
          <target state="translated">最后,由于我看到上述所有的函数都是以连续的顺序返回元素(因为它们被赋予了)。</target>
        </trans-unit>
        <trans-unit id="94291434f78dba4982f11e538ec1bc90b5361cfc" translate="yes" xml:space="preserve">
          <source>And this is for iterables:</source>
          <target state="translated">而这是针对Iterables的。</target>
        </trans-unit>
        <trans-unit id="b159a861f8ac09fa08f7c361d73a5a0451b7dd73" translate="yes" xml:space="preserve">
          <source>Another more explicit version.</source>
          <target state="translated">另一个更明确的版本。</target>
        </trans-unit>
        <trans-unit id="ba794e09d99fdf8a8de1d67d43d30f291b3a0e46" translate="yes" xml:space="preserve">
          <source>As Tomasz Gandor &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/22045226?noredirect=1#comment93566337_22045226&quot;&gt;observed&lt;/a&gt;, the two padding chunkers will stop unexpectedly if they encounter a long sequence of pad values. Here's a final variation that works around that problem in a reasonable way:</source>
          <target state="translated">正如Tomasz Gandor &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/22045226?noredirect=1#comment93566337_22045226&quot;&gt;观察到的&lt;/a&gt; ，如果两个填充分块器遇到很长的填充值序列，它们将意外停止。 这是一个可以合理解决该问题的最终变体：</target>
        </trans-unit>
        <trans-unit id="684924ad57df650cdd2c98486dd54f22750bac17" translate="yes" xml:space="preserve">
          <source>At this point, I think we need a &lt;strong&gt;recursive generator&lt;/strong&gt;, just in case...</source>
          <target state="translated">在这一点上，我认为我们需要一个&lt;strong&gt;递归生成器&lt;/strong&gt; ，以防万一...</target>
        </trans-unit>
        <trans-unit id="b708848595848810ad1ac40c9fc5a0ee26de016c" translate="yes" xml:space="preserve">
          <source>But if you don't want to be mercy on memory, you can use old-way and store the full &lt;code&gt;list&lt;/code&gt; in the first place with &lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked&quot;&gt;&lt;code&gt;iterutils.chunked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">但是，如果您不想在内存上宽容，可以使用old-way并通过&lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked&quot;&gt; &lt;code&gt;iterutils.chunked&lt;/code&gt; &lt;/a&gt;将完整 &lt;code&gt;list&lt;/code&gt; 存储在第一位。</target>
        </trans-unit>
        <trans-unit id="0217590d01991aeb18e3cba8bb8c5866ca27dc94" translate="yes" xml:space="preserve">
          <source>Consider using &lt;a href=&quot;http://matplotlib.sourceforge.net/&quot;&gt;matplotlib.cbook&lt;/a&gt; pieces</source>
          <target state="translated">考虑使用&lt;a href=&quot;http://matplotlib.sourceforge.net/&quot;&gt;matplotlib.cbook&lt;/a&gt;片段</target>
        </trans-unit>
        <trans-unit id="4a9d2b49e8f4df50e8b1ac623f6bb7a7b4bd6a4e" translate="yes" xml:space="preserve">
          <source>Critique of other answers here:</source>
          <target state="translated">点评这里的其他答案。</target>
        </trans-unit>
        <trans-unit id="83d36288b5c8873730d74ec2bee7f0a6e4883b2f" translate="yes" xml:space="preserve">
          <source>Demo:</source>
          <target state="translated">Demo:</target>
        </trans-unit>
        <trans-unit id="f6bc2643cbb300ad6f87ceb89b786afa73254a5b" translate="yes" xml:space="preserve">
          <source>Directly from the (old) Python documentation (recipes for itertools):</source>
          <target state="translated">直接来自(旧的)Python文档(迭代工具的食谱)。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="abeb6a534299e04695514a9d009939b0be5ee7f8" translate="yes" xml:space="preserve">
          <source>For example, the current top answer ends with:</source>
          <target state="translated">比如说,目前最上面的答案是以。</target>
        </trans-unit>
        <trans-unit id="42fe4dc988463309c34e2c538e2fc0593a3da661" translate="yes" xml:space="preserve">
          <source>Here is a generator that work on arbitrary iterables:</source>
          <target state="translated">这里有一个可以在任意迭代的生成器。</target>
        </trans-unit>
        <trans-unit id="6118f1efb5132ea152c00e94763f8cc7da5935f7" translate="yes" xml:space="preserve">
          <source>Here is a list of additional approaches:</source>
          <target state="translated">以下是一些补充方法。</target>
        </trans-unit>
        <trans-unit id="bc7408adabbd85102b98cc213e0b34ec73d9656a" translate="yes" xml:space="preserve">
          <source>Here's a balanced solution, adapted from a function I've used in production (Note in Python 3 to replace &lt;code&gt;xrange&lt;/code&gt; with &lt;code&gt;range&lt;/code&gt;):</source>
          <target state="translated">这是一个平衡的解决方案，它是根据我在生产环境中使用的功能改编而成的（Python 3中的注释将 &lt;code&gt;xrange&lt;/code&gt; 替换为 &lt;code&gt;range&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="475e0ad532c2a9677552254e743eb1f3f0cfeb3e" translate="yes" xml:space="preserve">
          <source>Here's a generator that yields the chunks you want:</source>
          <target state="translated">这里有一个发电机,可以产生你想要的大块。</target>
        </trans-unit>
        <trans-unit id="1b8977bd5e42e4e93b5e4e519f5b2ddce0307dc6" translate="yes" xml:space="preserve">
          <source>How do you split a list into evenly sized chunks</source>
          <target state="translated">如何将列表分成均匀大小的块状物</target>
        </trans-unit>
        <trans-unit id="259b93bbd5391d6658f5c36fa7eb12deb846d34f" translate="yes" xml:space="preserve">
          <source>I believe this is the shortest chunker proposed that offers optional padding.</source>
          <target state="translated">我相信这是建议的最短的、可选择填充物的夹层。</target>
        </trans-unit>
        <trans-unit id="dd756cc216563d48dfc2970de60f4103eea9c827" translate="yes" xml:space="preserve">
          <source>I guess Guido's time machine works&amp;mdash;worked&amp;mdash;will work&amp;mdash;will have worked&amp;mdash;was working again.</source>
          <target state="translated">我猜Guido的时间机器正常工作了，可以工作了，可以正常工作了。</target>
        </trans-unit>
        <trans-unit id="b0e9da2531173131f600ba521b0148ce5d316a49" translate="yes" xml:space="preserve">
          <source>I have a list of arbitrary length, and I need to split it up into equal size chunks and operate on it. There are some obvious ways to do this, like keeping a counter and two lists, and when the second list fills up, add it to the first list and empty the second list for the next round of data, but this is potentially extremely expensive.</source>
          <target state="translated">我有一个任意长度的列表,我需要把它分成大小相等的大块,并对其进行操作。有一些明显的方法可以做到这一点,比如保留一个计数器和两个列表,当第二个列表满了,就把它添加到第一个列表中,然后清空第二个列表,进行下一轮的数据操作,但这样做可能会非常昂贵。</target>
        </trans-unit>
        <trans-unit id="4e7311dd17ddc4d2548d04628d3db9f3eb615d09" translate="yes" xml:space="preserve">
          <source>I just hate that runt at the end!</source>
          <target state="translated">我只是讨厌结尾的那个小毛头!</target>
        </trans-unit>
        <trans-unit id="6991457426a330552fa2b53cc1cd9baf2eda5d4d" translate="yes" xml:space="preserve">
          <source>I know this is kind of old but nobody yet mentioned &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_split.html&quot;&gt;&lt;code&gt;numpy.array_split&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">我知道这有点陈旧，但是没有人提到&lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_split.html&quot;&gt; &lt;code&gt;numpy.array_split&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="917f3cb33b9d8fc32db26c4c1d42ba79be308ac2" translate="yes" xml:space="preserve">
          <source>I like the Python doc's version proposed by tzot and J.F.Sebastian a lot,
 but it has two shortcomings:</source>
          <target state="translated">我很喜欢tzot和J.F.Sebastian提出的Python doc的版本,但它有两个缺点。</target>
        </trans-unit>
        <trans-unit id="5e3a64e79ca9f8b6363ea8116d1b83a71d6de8b2" translate="yes" xml:space="preserve">
          <source>I saw the most awesome Python-ish answer in a &lt;a href=&quot;https://stackoverflow.com/questions/23286254/convert-list-to-a-list-of-tuples-python&quot;&gt;duplicate&lt;/a&gt; of this question:</source>
          <target state="translated">我在这个问题的&lt;a href=&quot;https://stackoverflow.com/questions/23286254/convert-list-to-a-list-of-tuples-python&quot;&gt;副本&lt;/a&gt;中看到了最棒的Python式答案：</target>
        </trans-unit>
        <trans-unit id="90a677670a1371ced290b5e2e08bddb3c581b545" translate="yes" xml:space="preserve">
          <source>I usually don't want a fill value in the last chunk</source>
          <target state="translated">我通常不希望在最后一个大块中出现填充值</target>
        </trans-unit>
        <trans-unit id="f1a4cd279695e4cab40018189926107de127ebd9" translate="yes" xml:space="preserve">
          <source>I was curious about the performance of different approaches and here it is:</source>
          <target state="translated">我很好奇不同方法的表现,这里就有了。</target>
        </trans-unit>
        <trans-unit id="29613d33898c9e3aec1192dd3959128eeeaed9fe" translate="yes" xml:space="preserve">
          <source>I was looking for something useful in &lt;code&gt;itertools&lt;/code&gt; but I couldn't find anything obviously useful. Might've missed it, though.</source>
          <target state="translated">我一直在寻找 &lt;code&gt;itertools&lt;/code&gt; 中有用的东西，但找不到任何明显有用的东西。 可能已经错过了。</target>
        </trans-unit>
        <trans-unit id="bac2dd4a60fa37bbf263a540d9fa81fa040d5743" translate="yes" xml:space="preserve">
          <source>I was wondering if anyone had a good solution to this for lists of any length, e.g. using generators.</source>
          <target state="translated">我想知道,对于任何长度的列表,如使用生成器,是否有人有好的解决方案。</target>
        </trans-unit>
        <trans-unit id="327e2511d640cd43b47f579330504ab03a8329e1" translate="yes" xml:space="preserve">
          <source>I would use this when my chunk size is fixed number I can type, e.g. '3', and would never change.</source>
          <target state="translated">当我的数据块大小是固定的数字时,我就会使用这个,比如说'3',我可以输入固定的数字,而且永远不会改变。</target>
        </trans-unit>
        <trans-unit id="9d08e2202ebb0e7dc670d4c4a6a76969c5c407b9" translate="yes" xml:space="preserve">
          <source>I'm surprised nobody has thought of using &lt;code&gt;iter&lt;/code&gt;'s &lt;a href=&quot;http://docs.python.org/2/library/functions.html#iter&quot;&gt;two-argument form&lt;/a&gt;:</source>
          <target state="translated">我很惊讶没有人想到使用 &lt;code&gt;iter&lt;/code&gt; 的&lt;a href=&quot;http://docs.python.org/2/library/functions.html#iter&quot;&gt;两个参数形式&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="e58be21445a654631cbca714b7d8b95f296a6e61" translate="yes" xml:space="preserve">
          <source>I'm using this one a lot in my code:</source>
          <target state="translated">我在我的代码中经常使用这一个。</target>
        </trans-unit>
        <trans-unit id="83268aaf64878571e40a4b3ddea382e550652a4b" translate="yes" xml:space="preserve">
          <source>If the list is divided evenly, then you can replace &lt;code&gt;zip_longest&lt;/code&gt; with &lt;code&gt;zip&lt;/code&gt;, otherwise the triplet &lt;code&gt;(13, 14, None)&lt;/code&gt; would be lost. Python 3 is used above. For Python 2, use &lt;code&gt;izip_longest&lt;/code&gt;.</source>
          <target state="translated">如果列表平均分配，则可以用 &lt;code&gt;zip&lt;/code&gt; 替换 &lt;code&gt;zip_longest&lt;/code&gt; ，否则三元组 &lt;code&gt;(13, 14, None)&lt;/code&gt; 将丢失。 上面使用了Python 3。 对于Python 2，请使用 &lt;code&gt;izip_longest&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec5170c60b383c50bed6d0ed79270c3d4ebe5132" translate="yes" xml:space="preserve">
          <source>If you don't (an iterator):</source>
          <target state="translated">如果你不(迭代器)。</target>
        </trans-unit>
        <trans-unit id="eddfb5e7767850909b409b1a2b176629677801ee" translate="yes" xml:space="preserve">
          <source>If you had a chunk size of 3 for example, you could do:</source>
          <target state="translated">如果你有3个大块,比如说,你可以做。</target>
        </trans-unit>
        <trans-unit id="27eb8d0c6e9a173ad4d54f2902a79e97d196089b" translate="yes" xml:space="preserve">
          <source>If you know list size:</source>
          <target state="translated">如果你知道列表的大小。</target>
        </trans-unit>
        <trans-unit id="ff962a30cc841787ba98f0e5697fc8787d38cdab" translate="yes" xml:space="preserve">
          <source>If you want something super simple:</source>
          <target state="translated">如果你想要超级简单的东西。</target>
        </trans-unit>
        <trans-unit id="a92329ae6bbc2a5040204df33f2716aecd3924d3" translate="yes" xml:space="preserve">
          <source>If you're using Python 2, you should use &lt;code&gt;xrange()&lt;/code&gt; instead of &lt;code&gt;range()&lt;/code&gt;:</source>
          <target state="translated">如果您使用的是Python 2，则应使用 &lt;code&gt;xrange()&lt;/code&gt; 而不是 &lt;code&gt;range()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="50140409745590859a22a654b9d2d2bf667150ea" translate="yes" xml:space="preserve">
          <source>In python 2:</source>
          <target state="translated">在python中2:</target>
        </trans-unit>
        <trans-unit id="ed6aded6af5e50183bd509e4af49bc6f8f430810" translate="yes" xml:space="preserve">
          <source>In python 3:</source>
          <target state="translated">在Python 3中。</target>
        </trans-unit>
        <trans-unit id="6ac245ac8f98f44abef3718b96f8f30922b4f9fe" translate="yes" xml:space="preserve">
          <source>In the latter case, it can be rephrased in a more beautiful way if you can be sure that the sequence always contains a whole number of chunks of given size (i.e. there is no incomplete last chunk).</source>
          <target state="translated">在后一种情况下,如果能确定序列总是包含给定大小的整数块(即不存在不完整的最后一个块),则可以用更漂亮的方式重新表述。</target>
        </trans-unit>
        <trans-unit id="b508194a7c943e4f0e63ec041cd324e913fa524d" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;izip_longest&lt;/code&gt;-based solutions, the above &lt;em&gt;always&lt;/em&gt; pads. As far as I know, there's no one- or two-line itertools recipe for a function that &lt;em&gt;optionally&lt;/em&gt; pads. By combining the above two approaches, this one comes pretty close:</source>
          <target state="translated">像基于 &lt;code&gt;izip_longest&lt;/code&gt; 的解决方案一样，以上内容&lt;em&gt;始终&lt;/em&gt; 可以满足要求 。 据我所知，没有&lt;em&gt;可选的&lt;/em&gt;填充函数的单行或两行itertools配方。 通过结合以上两种方法，这一方法非常接近：</target>
        </trans-unit>
        <trans-unit id="d8e673b11cbca16e0478d7e50c1a8ee8964a0366" translate="yes" xml:space="preserve">
          <source>My Solution(s)</source>
          <target state="translated">我的解决方案</target>
        </trans-unit>
        <trans-unit id="d16d82e7085b348c197150b20ab37cad4152300a" translate="yes" xml:space="preserve">
          <source>None of these answers are evenly sized chunks, they all leave a runt chunk at the end, so they're not completely balanced. If you were using these functions to distribute work, you've built-in the prospect of one likely finishing well before the others, so it would sit around doing nothing while the others continued working hard.</source>
          <target state="translated">这些答案都不是均匀的大块,它们都会在最后留下一个runt大块,所以它们并不完全平衡。如果你用这些函数来分配工作,你已经内置了一个可能比其他的人早完成的前景,所以它就会在其他的人继续努力工作的时候,坐在一旁无所事事事。</target>
        </trans-unit>
        <trans-unit id="4fb5cd16340841226cb584a92c0d56a59cc45ff9" translate="yes" xml:space="preserve">
          <source>Notice that the contiguous generator provide chunks in the same length patterns as the other two, but the items are all in order, and they are as evenly divided as one may divide a list of discrete elements.</source>
          <target state="translated">请注意,毗连生成器提供的块的长度模式与其他两个相同,但这些项目都是按顺序排列的,而且它们被均匀地划分,就像划分一个离散元素列表一样。</target>
        </trans-unit>
        <trans-unit id="6f253cbf35cc30170ea6d83c8b71ed090a9a84a9" translate="yes" xml:space="preserve">
          <source>OR:</source>
          <target state="translated">OR:</target>
        </trans-unit>
        <trans-unit id="17a9b13128644f1d8b18cb515e3e01c79a026853" translate="yes" xml:space="preserve">
          <source>One more solution</source>
          <target state="translated">还有一个解决方案</target>
        </trans-unit>
        <trans-unit id="f9199d6541466df87c407771ffe310862754415b" translate="yes" xml:space="preserve">
          <source>Others, like &lt;code&gt;list(grouper(3, xrange(7)))&lt;/code&gt;, and &lt;code&gt;chunk(xrange(7), 3)&lt;/code&gt; both return: &lt;code&gt;[(0, 1, 2), (3, 4, 5), (6, None, None)]&lt;/code&gt;. The &lt;code&gt;None&lt;/code&gt;'s are just padding, and rather inelegant in my opinion. They are NOT evenly chunking the iterables.</source>
          <target state="translated">其他 &lt;code&gt;list(grouper(3, xrange(7)))&lt;/code&gt; ，例如list（grouper（3，xrange（7）））和 &lt;code&gt;chunk(xrange(7), 3)&lt;/code&gt; 都返回： &lt;code&gt;[(0, 1, 2), (3, 4, 5), (6, None, None)]&lt;/code&gt; 。 在我看来， &lt;code&gt;None&lt;/code&gt; 只是填充，并且不太雅致。 他们没有将可迭代对象均匀地分块。</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="c0bf8c95093739ba9b7bafbe08dbe897abd95683" translate="yes" xml:space="preserve">
          <source>Python 2 version:</source>
          <target state="translated">Python 2版本。</target>
        </trans-unit>
        <trans-unit id="260cdb02eef94c3ec0c5d6feeb1243b43c8d1491" translate="yes" xml:space="preserve">
          <source>Python3</source>
          <target state="translated">Python3</target>
        </trans-unit>
        <trans-unit id="71849193d7d4d55164b78c9896f7a9dc772ed9fe" translate="yes" xml:space="preserve">
          <source>Related question: &lt;a href=&quot;https://stackoverflow.com/questions/434287/what-is-the-most-pythonic-way-to-iterate-over-a-list-in-chunks&quot;&gt;What is the most &amp;ldquo;pythonic&amp;rdquo; way to iterate over a list in chunks?&lt;/a&gt;</source>
          <target state="translated">相关问题： &lt;a href=&quot;https://stackoverflow.com/questions/434287/what-is-the-most-pythonic-way-to-iterate-over-a-list-in-chunks&quot;&gt;遍历大块列表的最&amp;ldquo; pythonic&amp;rdquo;方法是什么？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="981fcb2aa39ba3a18ef848f7e642cdf5f8ecd7fc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://docs.python.org/3.3/library/functions.html?highlight=zip#zip&quot;&gt;this reference&lt;/a&gt;</source>
          <target state="translated">看到&lt;a href=&quot;http://docs.python.org/3.3/library/functions.html?highlight=zip#zip&quot;&gt;这个参考&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c89e1bf8261d7f316330a5faf8a9a46b0e582595" translate="yes" xml:space="preserve">
          <source>Simple yet elegant</source>
          <target state="translated">简单而优雅</target>
        </trans-unit>
        <trans-unit id="2ff35546249ad5b66d0fb9d1fe43700554f6319c" translate="yes" xml:space="preserve">
          <source>Since everybody here talking about iterators. &lt;a href=&quot;https://boltons.readthedocs.io/&quot;&gt;&lt;code&gt;boltons&lt;/code&gt;&lt;/a&gt; has perfect method for that, called &lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked_iter&quot;&gt;&lt;code&gt;iterutils.chunked_iter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由于这里的每个人都在谈论迭代器。 &lt;a href=&quot;https://boltons.readthedocs.io/&quot;&gt; &lt;code&gt;boltons&lt;/code&gt; 为此&lt;/a&gt;具有完美的方法，称为&lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked_iter&quot;&gt; &lt;code&gt;iterutils.chunked_iter&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="74deacfe8465d3eece5467e74021e02845fce531" translate="yes" xml:space="preserve">
          <source>Tested on Python 3.5.1</source>
          <target state="translated">在Python 3.5.1上测试</target>
        </trans-unit>
        <trans-unit id="a070904a56ca5749113b247909c8f4172a684de4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/pytoolz/toolz&quot;&gt;toolz&lt;/a&gt; library has the &lt;code&gt;partition&lt;/code&gt; function for this:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/pytoolz/toolz&quot;&gt;为此，toolz&lt;/a&gt;库具有 &lt;code&gt;partition&lt;/code&gt; 功能：</target>
        </trans-unit>
        <trans-unit id="0e222ece4f0d63b0c3a30d4b1cff53a12ec0b0d7" translate="yes" xml:space="preserve">
          <source>The current version, as suggested by J.F.Sebastian:</source>
          <target state="translated">目前的版本,由J.F.Sebastian建议。</target>
        </trans-unit>
        <trans-unit id="303084aa1cd175ed003cf0c538e9a51c8ce3ee48" translate="yes" xml:space="preserve">
          <source>The functional flavour of the above:</source>
          <target state="translated">以上的功能风味。</target>
        </trans-unit>
        <trans-unit id="2d31acba4646b7046246eb5ec8c89ea9ba1453d6" translate="yes" xml:space="preserve">
          <source>These solutions work because &lt;code&gt;[iter(iterable)]*n&lt;/code&gt; (or the equivalent in the earlier version) creates &lt;em&gt;one&lt;/em&gt; iterator, repeated &lt;code&gt;n&lt;/code&gt; times in the list. &lt;code&gt;izip_longest&lt;/code&gt; then effectively performs a round-robin of &quot;each&quot; iterator; because this is the same iterator, it is advanced by each such call, resulting in each such zip-roundrobin generating one tuple of &lt;code&gt;n&lt;/code&gt; items.</source>
          <target state="translated">这些解决方案之所以有效，是因为 &lt;code&gt;[iter(iterable)]*n&lt;/code&gt; （或早期版本中的等效项）创建了&lt;em&gt;一个&lt;/em&gt;迭代器， &lt;em&gt;该&lt;/em&gt;迭代器在列表中重复了 &lt;code&gt;n&lt;/code&gt; 次。 然后， &lt;code&gt;izip_longest&lt;/code&gt; 有效地执行&amp;ldquo;每个&amp;rdquo;迭代器的循环； 因为这是相同的迭代器，所以每次此类调用都会对其进行高级处理，从而使每个此类zip-roundrobin生成一个 &lt;code&gt;n&lt;/code&gt; 个元组。</target>
        </trans-unit>
        <trans-unit id="3351ae97164ad34d25cfa1a87ba90d402b29e7dc" translate="yes" xml:space="preserve">
          <source>This works on an arbitrary iterable, not just a list.</source>
          <target state="translated">这在一个任意的迭代器上有效,而不仅仅是一个列表。</target>
        </trans-unit>
        <trans-unit id="f72c8b9833ef44f668e605f6c6b47726e8e3f946" translate="yes" xml:space="preserve">
          <source>This works with any iterable and produces output lazily. It returns tuples rather than iterators, but I think it has a certain elegance nonetheless. It also doesn't pad; if you want padding, a simple variation on the above will suffice:</source>
          <target state="translated">这可以与任何迭代器一起工作,并且可以懒散地产生输出。它返回的是tuple而不是迭代器,但我认为它还是有一定的优雅之处。它也不加padding;如果你想要padding,在上面的基础上做一个简单的变化就足够了。</target>
        </trans-unit>
        <trans-unit id="c8c4d7f83e6f3c9aad0f35fb413eb0e5fbdd3d02" translate="yes" xml:space="preserve">
          <source>To test them out:</source>
          <target state="translated">为了试探他们。</target>
        </trans-unit>
        <trans-unit id="7e2bf240c51921bc85786da57f64d4d7ffb9b537" translate="yes" xml:space="preserve">
          <source>UPDATE: A lazy chunks version:</source>
          <target state="translated">UPDATE:一个懒惰的大块头版本。</target>
        </trans-unit>
        <trans-unit id="379fa67eaaf9d4bf3b4cb8fe4251da2145554ba4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;xrange()&lt;/code&gt; instead of &lt;code&gt;range()&lt;/code&gt; in the case of Python 2.x</source>
          <target state="translated">在Python 2.x中使用 &lt;code&gt;xrange()&lt;/code&gt; 而不是 &lt;code&gt;range()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f610215c01d3050c4bc4007ebaf25e124322c260" translate="yes" xml:space="preserve">
          <source>Where AA is array, SS is chunk size. For example:</source>
          <target state="translated">其中AA是数组,SS是块大小。例如:</target>
        </trans-unit>
        <trans-unit id="37716ed00d633b81920f80390744e2f570994984" translate="yes" xml:space="preserve">
          <source>Which prints out:</source>
          <target state="translated">其中打印出来的。</target>
        </trans-unit>
        <trans-unit id="de34eeea45ec51d962a89827c68f30b24f15f868" translate="yes" xml:space="preserve">
          <source>Why can't we divide these better?</source>
          <target state="translated">为什么我们不能把这些分得更好?</target>
        </trans-unit>
        <trans-unit id="d1a8e487c7ddd714dc6aa815c7a65005ebeb7b81" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://www.python.org/dev/peps/pep-0572/&quot;&gt;Assignment Expressions&lt;/a&gt; in Python 3.8 it becomes quite nice:</source>
          <target state="translated">使用Python 3.8中的&lt;a href=&quot;https://www.python.org/dev/peps/pep-0572/&quot;&gt;赋值表达式&lt;/a&gt; ，它变得非常不错：</target>
        </trans-unit>
        <trans-unit id="e81ab559adc970d663d23724576742b3e62a7248" translate="yes" xml:space="preserve">
          <source>Without calling len() which is good for large lists:</source>
          <target state="translated">没有调用len(),这对于大的列表是很好的。</target>
        </trans-unit>
        <trans-unit id="e4eaae3f6d5fe8325131510e654ca9103ed32e13" translate="yes" xml:space="preserve">
          <source>You can create n-tuple for any n. If &lt;code&gt;a = range(1, 15)&lt;/code&gt;, then the result will be:</source>
          <target state="translated">您可以为任何n个创建n个元组。 如果 &lt;code&gt;a = range(1, 15)&lt;/code&gt; ，则结果将是：</target>
        </trans-unit>
        <trans-unit id="58e01c1308a4e76507dfd9bfbc03b3c0bd4ab7ea" translate="yes" xml:space="preserve">
          <source>You can install &lt;a href=&quot;https://pypi.python.org/pypi/utilspie&quot;&gt;&lt;code&gt;utilspie&lt;/code&gt;&lt;/a&gt; via pip:</source>
          <target state="translated">您可以通过pip安装&lt;a href=&quot;https://pypi.python.org/pypi/utilspie&quot;&gt; &lt;code&gt;utilspie&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="c63f793d1aadeef671378f417f94a070ffde5e01" translate="yes" xml:space="preserve">
          <source>You may also use &lt;a href=&quot;http://utilspie.readthedocs.io/en/latest/#get-chunks&quot;&gt;&lt;code&gt;get_chunks&lt;/code&gt;&lt;/a&gt; function of &lt;a href=&quot;http://utilspie.readthedocs.io&quot;&gt;&lt;code&gt;utilspie&lt;/code&gt;&lt;/a&gt; library as:</source>
          <target state="translated">您也可以使用&lt;a href=&quot;http://utilspie.readthedocs.io&quot;&gt; &lt;code&gt;utilspie&lt;/code&gt; &lt;/a&gt;库的&lt;a href=&quot;http://utilspie.readthedocs.io/en/latest/#get-chunks&quot;&gt; &lt;code&gt;get_chunks&lt;/code&gt; &lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="4fc19dd49d67bc4ce99ea768a6c767c51047c281" translate="yes" xml:space="preserve">
          <source>code:</source>
          <target state="translated">code:</target>
        </trans-unit>
        <trans-unit id="07d20acd3d6d3a65dab86aac1963f8fc7266dde3" translate="yes" xml:space="preserve">
          <source>for example:</source>
          <target state="translated">比如说。</target>
        </trans-unit>
        <trans-unit id="868a36da4eb71c0342f273350a197b11e69d1c66" translate="yes" xml:space="preserve">
          <source>heh, one line version</source>
          <target state="translated">呵呵,单行本</target>
        </trans-unit>
        <trans-unit id="39a25778f91a825c38533cb5a85e43cc0130f38a" translate="yes" xml:space="preserve">
          <source>it is not very explicit</source>
          <target state="translated">说得不太清楚</target>
        </trans-unit>
        <trans-unit id="23d29a1e5ae63b782e6282a05f8eba18a5eebc52" translate="yes" xml:space="preserve">
          <source>or if you prefer:</source>
          <target state="translated">或者,如果你喜欢的话,</target>
        </trans-unit>
        <trans-unit id="d575e92f6e78dfc9ee7b6d9f6680fd8e354625d8" translate="yes" xml:space="preserve">
          <source>result:</source>
          <target state="translated">result:</target>
        </trans-unit>
        <trans-unit id="7fb777990060cd6a13fa8c404b0c52ae3c520ed2" translate="yes" xml:space="preserve">
          <source>source:
&lt;a href=&quot;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&quot;&gt;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&lt;/a&gt;</source>
          <target state="translated">source:
&lt;a href=&quot;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&quot;&gt;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d99f66b852fef055214f1f6c4e0864afe932b13e" translate="yes" xml:space="preserve">
          <source>usage:</source>
          <target state="translated">usage:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
