<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/312443">
    <body>
      <group id="312443">
        <trans-unit id="afc62f24d04a757a3fed298ee0502acbf641cc78" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.defaultdict&quot;&gt;&lt;code&gt;collections.defaultdict&lt;/code&gt;&lt;/a&gt;  (ordered results requires Python 3.6+)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.defaultdict&quot;&gt; &lt;code&gt;collections.defaultdict&lt;/code&gt; &lt;/a&gt; (для упорядоченных результатов требуется Python 3.6+)</target>
        </trans-unit>
        <trans-unit id="58e6d793c579e3e4ec49e97cc8c906104c1d4c0d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.zip_longest&quot;&gt;&lt;code&gt;zip_longest&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/3125186#3125186&quot;&gt;related post&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/29009933#29009933&quot;&gt;related post&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.zip_longest&quot;&gt; &lt;code&gt;zip_longest&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/3125186#3125186&quot;&gt;связанный пост&lt;/a&gt; , &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/29009933#29009933&quot;&gt;связанный пост&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="11757f2a8c1187933509721f8f085fdedce709a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.setdefault&quot;&gt;&lt;code&gt;setdefault&lt;/code&gt;&lt;/a&gt; (ordered results requires Python 3.6+)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.setdefault&quot;&gt; &lt;code&gt;setdefault&lt;/code&gt; &lt;/a&gt; (для упорядоченных результатов требуется Python 3.6+)</target>
        </trans-unit>
        <trans-unit id="e0cfc75ee17c3572b6f56675f60c272896e59887" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;em&gt;&lt;code&gt;more_itertools&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;sup&gt;+&lt;/sup&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;em&gt;&lt;code&gt;more_itertools&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;sup&gt;+&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="709b4f054179d1afa28588c2eb207c1d90f9629b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.chunked&quot;&gt;&lt;code&gt;more_itertools.chunked&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/16315158#16315158&quot;&gt;related posted&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.chunked&quot;&gt; &lt;code&gt;more_itertools.chunked&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/16315158#16315158&quot;&gt;связанный&lt;/a&gt; пост )</target>
        </trans-unit>
        <trans-unit id="1a2f32177b51d0d1415b5b4e4c7e1b2f156dab73" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.grouper&quot;&gt;&lt;code&gt;more_itertools.grouper&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/312644#312644&quot;&gt;related post&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.grouper&quot;&gt; &lt;code&gt;more_itertools.grouper&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/312644#312644&quot;&gt;связанный пост&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="2a6ae8e428ee8fb0f3bf5335e99eadd09d507001" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.windowed&quot;&gt;&lt;code&gt;more_itertools.windowed&lt;/code&gt;&lt;/a&gt; (see also &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.stagger&quot;&gt;&lt;code&gt;stagger&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.zip_offset&quot;&gt;&lt;code&gt;zip_offset&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.windowed&quot;&gt; &lt;code&gt;more_itertools.windowed&lt;/code&gt; &lt;/a&gt; (также см. &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.zip_offset&quot;&gt; &lt;code&gt;zip_offset&lt;/code&gt; &lt;/a&gt; , zip_offset )</target>
        </trans-unit>
        <trans-unit id="4143c70f77b270636a13fe869cc8ef3a270deec2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Disclaimer: I am the creator of &lt;a href=&quot;https://github.com/moin18/utilspie&quot;&gt;utilspie&lt;/a&gt; library&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Отказ от ответственности: я создатель библиотеки &lt;a href=&quot;https://github.com/moin18/utilspie&quot;&gt;utilspie&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="610a42d66a5c2ccc81158b17f6ef8cfa7fb436c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The Standard Library&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Стандартная библиотека&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6607830e66ad80aa66ee0fb7977558ee0e94c1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Given&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Given&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="762b0b987efcf101541560526e8d90e402907514" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;References&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;References&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46d89300e0df73036ac46de568703f812bd19662" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Results:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Results:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c015b0c9104bd29356550baed6c391c2367ace1" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;sup&gt;+&lt;/sup&gt; A third-party library that implements &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;itertools recipes&lt;/a&gt; and more. &lt;code&gt;&amp;gt; pip install more_itertools&lt;/code&gt; &lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;sup&gt;+&lt;/sup&gt; &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;Сторонняя&lt;/a&gt; библиотека, которая реализует рецепты itertools и многое другое.&lt;/sub&gt; &lt;sub&gt; &lt;code&gt;&amp;gt; pip install more_itertools&lt;/code&gt; &lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="0c113960317b7fd4d0b8bd387f0902aaeec55697" translate="yes" xml:space="preserve">
          <source>Also you can simply use list comprehension instead of writing a function, though it's a good idea to encapsulate operations like this in named functions so that your code is easier to understand. Python 3:</source>
          <target state="translated">Также вы можете просто использовать понимание списка вместо того,чтобы писать функцию,хотя это хорошая идея-инкапсулировать подобные операции в именованные функции,чтобы ваш код был легче понятен.Питон 3:</target>
        </trans-unit>
        <trans-unit id="e19011a8b23a7c95dfea6a63f6395685a7497d26" translate="yes" xml:space="preserve">
          <source>Also, in case of massive Alien invasion, a &lt;strong&gt;decorated recursive generator&lt;/strong&gt; might become handy:</source>
          <target state="translated">Кроме того, в случае массового вторжения инопланетян может пригодиться &lt;strong&gt;декорированный рекурсивный генератор&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="466f5c5627dd26bb81e764ceba90451103f9d8cc" translate="yes" xml:space="preserve">
          <source>And I created a generator that does the same if you put it into a list:</source>
          <target state="translated">И я создал генератор,который делает то же самое,если вы поместите его в список:</target>
        </trans-unit>
        <trans-unit id="a16a583c7b9df127020c4200726cd6173125abe2" translate="yes" xml:space="preserve">
          <source>And finally, since I see that all of the above functions return elements in a contiguous order (as they were given):</source>
          <target state="translated">И,наконец,поскольку я вижу,что все вышеперечисленные функции возвращают элементы в едином порядке (как они и были даны):</target>
        </trans-unit>
        <trans-unit id="94291434f78dba4982f11e538ec1bc90b5361cfc" translate="yes" xml:space="preserve">
          <source>And this is for iterables:</source>
          <target state="translated">А это для итерабельных:</target>
        </trans-unit>
        <trans-unit id="b159a861f8ac09fa08f7c361d73a5a0451b7dd73" translate="yes" xml:space="preserve">
          <source>Another more explicit version.</source>
          <target state="translated">Другая более явная версия.</target>
        </trans-unit>
        <trans-unit id="ba794e09d99fdf8a8de1d67d43d30f291b3a0e46" translate="yes" xml:space="preserve">
          <source>As Tomasz Gandor &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/22045226?noredirect=1#comment93566337_22045226&quot;&gt;observed&lt;/a&gt;, the two padding chunkers will stop unexpectedly if they encounter a long sequence of pad values. Here's a final variation that works around that problem in a reasonable way:</source>
          <target state="translated">Как &lt;a href=&quot;https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/22045226?noredirect=1#comment93566337_22045226&quot;&gt;заметил&lt;/a&gt; Томаш Гандор, два чанкера заполнения неожиданно остановятся, если встретят длинную последовательность значений пэдов. Вот последний вариант, который разумным образом решает эту проблему:</target>
        </trans-unit>
        <trans-unit id="684924ad57df650cdd2c98486dd54f22750bac17" translate="yes" xml:space="preserve">
          <source>At this point, I think we need a &lt;strong&gt;recursive generator&lt;/strong&gt;, just in case...</source>
          <target state="translated">На данный момент, я думаю, нам нужен &lt;strong&gt;рекурсивный генератор&lt;/strong&gt; , на всякий случай ...</target>
        </trans-unit>
        <trans-unit id="b708848595848810ad1ac40c9fc5a0ee26de016c" translate="yes" xml:space="preserve">
          <source>But if you don't want to be mercy on memory, you can use old-way and store the full &lt;code&gt;list&lt;/code&gt; in the first place with &lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked&quot;&gt;&lt;code&gt;iterutils.chunked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Но если вы не хотите помиловать память, вы можете использовать old-way и сохранить полный &lt;code&gt;list&lt;/code&gt; в первую очередь с помощью &lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked&quot;&gt; &lt;code&gt;iterutils.chunked&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0217590d01991aeb18e3cba8bb8c5866ca27dc94" translate="yes" xml:space="preserve">
          <source>Consider using &lt;a href=&quot;http://matplotlib.sourceforge.net/&quot;&gt;matplotlib.cbook&lt;/a&gt; pieces</source>
          <target state="translated">Рассмотрите возможность использования кусочков &lt;a href=&quot;http://matplotlib.sourceforge.net/&quot;&gt;matplotlib.cbook&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a9d2b49e8f4df50e8b1ac623f6bb7a7b4bd6a4e" translate="yes" xml:space="preserve">
          <source>Critique of other answers here:</source>
          <target state="translated">Критика других ответов здесь:</target>
        </trans-unit>
        <trans-unit id="83d36288b5c8873730d74ec2bee7f0a6e4883b2f" translate="yes" xml:space="preserve">
          <source>Demo:</source>
          <target state="translated">Demo:</target>
        </trans-unit>
        <trans-unit id="f6bc2643cbb300ad6f87ceb89b786afa73254a5b" translate="yes" xml:space="preserve">
          <source>Directly from the (old) Python documentation (recipes for itertools):</source>
          <target state="translated">Прямо из (старой)документации Python (рецепты итертуалов):</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="abeb6a534299e04695514a9d009939b0be5ee7f8" translate="yes" xml:space="preserve">
          <source>For example, the current top answer ends with:</source>
          <target state="translated">Например,текущий верхний ответ заканчивается:</target>
        </trans-unit>
        <trans-unit id="42fe4dc988463309c34e2c538e2fc0593a3da661" translate="yes" xml:space="preserve">
          <source>Here is a generator that work on arbitrary iterables:</source>
          <target state="translated">Вот генератор,который работает с произвольными итерабелями:</target>
        </trans-unit>
        <trans-unit id="6118f1efb5132ea152c00e94763f8cc7da5935f7" translate="yes" xml:space="preserve">
          <source>Here is a list of additional approaches:</source>
          <target state="translated">Вот список дополнительных подходов:</target>
        </trans-unit>
        <trans-unit id="bc7408adabbd85102b98cc213e0b34ec73d9656a" translate="yes" xml:space="preserve">
          <source>Here's a balanced solution, adapted from a function I've used in production (Note in Python 3 to replace &lt;code&gt;xrange&lt;/code&gt; with &lt;code&gt;range&lt;/code&gt;):</source>
          <target state="translated">Вот сбалансированное решение, адаптированное из функции, которую я использовал в производственной среде (Примечание в Python 3 для замены &lt;code&gt;xrange&lt;/code&gt; &lt;code&gt;range&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="475e0ad532c2a9677552254e743eb1f3f0cfeb3e" translate="yes" xml:space="preserve">
          <source>Here's a generator that yields the chunks you want:</source>
          <target state="translated">Вот генератор,который дает те куски,которые ты хочешь:</target>
        </trans-unit>
        <trans-unit id="1b8977bd5e42e4e93b5e4e519f5b2ddce0307dc6" translate="yes" xml:space="preserve">
          <source>How do you split a list into evenly sized chunks</source>
          <target state="translated">Как разбить список на равномерные по размеру куски.</target>
        </trans-unit>
        <trans-unit id="259b93bbd5391d6658f5c36fa7eb12deb846d34f" translate="yes" xml:space="preserve">
          <source>I believe this is the shortest chunker proposed that offers optional padding.</source>
          <target state="translated">Я считаю,что это самый короткий из предложенных,который предлагает опциональную подкладку.</target>
        </trans-unit>
        <trans-unit id="dd756cc216563d48dfc2970de60f4103eea9c827" translate="yes" xml:space="preserve">
          <source>I guess Guido's time machine works&amp;mdash;worked&amp;mdash;will work&amp;mdash;will have worked&amp;mdash;was working again.</source>
          <target state="translated">Я думаю, машина времени Гвидо работает - работала - будет работать - будет работать - снова работала.</target>
        </trans-unit>
        <trans-unit id="b0e9da2531173131f600ba521b0148ce5d316a49" translate="yes" xml:space="preserve">
          <source>I have a list of arbitrary length, and I need to split it up into equal size chunks and operate on it. There are some obvious ways to do this, like keeping a counter and two lists, and when the second list fills up, add it to the first list and empty the second list for the next round of data, but this is potentially extremely expensive.</source>
          <target state="translated">У меня есть список произвольной длины,и мне нужно разбить его на куски одинакового размера и работать над ним.Есть несколько очевидных способов сделать это,например,оставить счетчик и два списка,а когда второй список заполнится,добавить его в первый список и опустошить второй список для следующего раунда данных,но это потенциально чрезвычайно дорого.</target>
        </trans-unit>
        <trans-unit id="4e7311dd17ddc4d2548d04628d3db9f3eb615d09" translate="yes" xml:space="preserve">
          <source>I just hate that runt at the end!</source>
          <target state="translated">Я просто ненавижу этого коротышку в конце!</target>
        </trans-unit>
        <trans-unit id="6991457426a330552fa2b53cc1cd9baf2eda5d4d" translate="yes" xml:space="preserve">
          <source>I know this is kind of old but nobody yet mentioned &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_split.html&quot;&gt;&lt;code&gt;numpy.array_split&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Я знаю, что это старое, но никто еще не упомянул &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_split.html&quot;&gt; &lt;code&gt;numpy.array_split&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="917f3cb33b9d8fc32db26c4c1d42ba79be308ac2" translate="yes" xml:space="preserve">
          <source>I like the Python doc's version proposed by tzot and J.F.Sebastian a lot,
 but it has two shortcomings:</source>
          <target state="translated">Мне очень нравится версия Python doc,предложенная tzot и J.F.Sebastian,но в ней есть два недостатка:</target>
        </trans-unit>
        <trans-unit id="5e3a64e79ca9f8b6363ea8116d1b83a71d6de8b2" translate="yes" xml:space="preserve">
          <source>I saw the most awesome Python-ish answer in a &lt;a href=&quot;https://stackoverflow.com/questions/23286254/convert-list-to-a-list-of-tuples-python&quot;&gt;duplicate&lt;/a&gt; of this question:</source>
          <target state="translated">Я видел самый удивительный ответ Python-ish в &lt;a href=&quot;https://stackoverflow.com/questions/23286254/convert-list-to-a-list-of-tuples-python&quot;&gt;дубликате&lt;/a&gt; этого вопроса:</target>
        </trans-unit>
        <trans-unit id="90a677670a1371ced290b5e2e08bddb3c581b545" translate="yes" xml:space="preserve">
          <source>I usually don't want a fill value in the last chunk</source>
          <target state="translated">Обычно я не хочу,чтобы в последнем кусочке был наполнитель.</target>
        </trans-unit>
        <trans-unit id="f1a4cd279695e4cab40018189926107de127ebd9" translate="yes" xml:space="preserve">
          <source>I was curious about the performance of different approaches and here it is:</source>
          <target state="translated">Мне было любопытно узнать,как работают различные подходы,и вот оно:</target>
        </trans-unit>
        <trans-unit id="29613d33898c9e3aec1192dd3959128eeeaed9fe" translate="yes" xml:space="preserve">
          <source>I was looking for something useful in &lt;code&gt;itertools&lt;/code&gt; but I couldn't find anything obviously useful. Might've missed it, though.</source>
          <target state="translated">Я искал что-то полезное в &lt;code&gt;itertools&lt;/code&gt; , но не смог найти что-то полезное. Возможно, я пропустил это.</target>
        </trans-unit>
        <trans-unit id="bac2dd4a60fa37bbf263a540d9fa81fa040d5743" translate="yes" xml:space="preserve">
          <source>I was wondering if anyone had a good solution to this for lists of any length, e.g. using generators.</source>
          <target state="translated">Мне было интересно,есть ли у кого-нибудь хорошее решение для списков любой длины,например,с использованием генераторов.</target>
        </trans-unit>
        <trans-unit id="327e2511d640cd43b47f579330504ab03a8329e1" translate="yes" xml:space="preserve">
          <source>I would use this when my chunk size is fixed number I can type, e.g. '3', and would never change.</source>
          <target state="translated">Я бы использовал это,когда мой размер порции фиксированное число,которое я могу набрать,например,'3',и никогда бы не изменился.</target>
        </trans-unit>
        <trans-unit id="9d08e2202ebb0e7dc670d4c4a6a76969c5c407b9" translate="yes" xml:space="preserve">
          <source>I'm surprised nobody has thought of using &lt;code&gt;iter&lt;/code&gt;'s &lt;a href=&quot;http://docs.python.org/2/library/functions.html#iter&quot;&gt;two-argument form&lt;/a&gt;:</source>
          <target state="translated">Я удивлен, что никто не думал об использовании формы &lt;code&gt;iter&lt;/code&gt; с &lt;a href=&quot;http://docs.python.org/2/library/functions.html#iter&quot;&gt;двумя аргументами&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e58be21445a654631cbca714b7d8b95f296a6e61" translate="yes" xml:space="preserve">
          <source>I'm using this one a lot in my code:</source>
          <target state="translated">Я часто использую это в своем коде:</target>
        </trans-unit>
        <trans-unit id="83268aaf64878571e40a4b3ddea382e550652a4b" translate="yes" xml:space="preserve">
          <source>If the list is divided evenly, then you can replace &lt;code&gt;zip_longest&lt;/code&gt; with &lt;code&gt;zip&lt;/code&gt;, otherwise the triplet &lt;code&gt;(13, 14, None)&lt;/code&gt; would be lost. Python 3 is used above. For Python 2, use &lt;code&gt;izip_longest&lt;/code&gt;.</source>
          <target state="translated">Если список разделен поровну, вы можете заменить &lt;code&gt;zip_longest&lt;/code&gt; на &lt;code&gt;zip&lt;/code&gt; , иначе триплет &lt;code&gt;(13, 14, None)&lt;/code&gt; будет потерян. Python 3 используется выше. Для Python 2 используйте &lt;code&gt;izip_longest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec5170c60b383c50bed6d0ed79270c3d4ebe5132" translate="yes" xml:space="preserve">
          <source>If you don't (an iterator):</source>
          <target state="translated">Если ты этого не сделаешь (итератор):</target>
        </trans-unit>
        <trans-unit id="eddfb5e7767850909b409b1a2b176629677801ee" translate="yes" xml:space="preserve">
          <source>If you had a chunk size of 3 for example, you could do:</source>
          <target state="translated">Если бы,например,у вас был кусок размером 3,вы могли бы это сделать:</target>
        </trans-unit>
        <trans-unit id="27eb8d0c6e9a173ad4d54f2902a79e97d196089b" translate="yes" xml:space="preserve">
          <source>If you know list size:</source>
          <target state="translated">Если вы знаете размер списка:</target>
        </trans-unit>
        <trans-unit id="ff962a30cc841787ba98f0e5697fc8787d38cdab" translate="yes" xml:space="preserve">
          <source>If you want something super simple:</source>
          <target state="translated">Если ты хочешь чего-то суперпростого:</target>
        </trans-unit>
        <trans-unit id="a92329ae6bbc2a5040204df33f2716aecd3924d3" translate="yes" xml:space="preserve">
          <source>If you're using Python 2, you should use &lt;code&gt;xrange()&lt;/code&gt; instead of &lt;code&gt;range()&lt;/code&gt;:</source>
          <target state="translated">Если вы используете Python 2, вы должны использовать &lt;code&gt;xrange()&lt;/code&gt; вместо &lt;code&gt;range()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="50140409745590859a22a654b9d2d2bf667150ea" translate="yes" xml:space="preserve">
          <source>In python 2:</source>
          <target state="translated">На питоне 2:</target>
        </trans-unit>
        <trans-unit id="ed6aded6af5e50183bd509e4af49bc6f8f430810" translate="yes" xml:space="preserve">
          <source>In python 3:</source>
          <target state="translated">На питоне 3:</target>
        </trans-unit>
        <trans-unit id="6ac245ac8f98f44abef3718b96f8f30922b4f9fe" translate="yes" xml:space="preserve">
          <source>In the latter case, it can be rephrased in a more beautiful way if you can be sure that the sequence always contains a whole number of chunks of given size (i.e. there is no incomplete last chunk).</source>
          <target state="translated">В последнем случае ее можно перефразировать красивее,если быть уверенным,что последовательность всегда содержит целое число кусков заданного размера (т.е.нет незавершенного последнего кусочка).</target>
        </trans-unit>
        <trans-unit id="b508194a7c943e4f0e63ec041cd324e913fa524d" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;izip_longest&lt;/code&gt;-based solutions, the above &lt;em&gt;always&lt;/em&gt; pads. As far as I know, there's no one- or two-line itertools recipe for a function that &lt;em&gt;optionally&lt;/em&gt; pads. By combining the above two approaches, this one comes pretty close:</source>
          <target state="translated">Как и в &lt;code&gt;izip_longest&lt;/code&gt; основе izip_longest , вышеприведенные &lt;em&gt;всегда&lt;/em&gt; дополнения . Насколько я знаю, не существует одно- или двухстрочного рецепта itertools для функции, которая &lt;em&gt;может быть&lt;/em&gt; дополнена. Комбинируя два вышеупомянутых подхода, этот подход довольно близок:</target>
        </trans-unit>
        <trans-unit id="d8e673b11cbca16e0478d7e50c1a8ee8964a0366" translate="yes" xml:space="preserve">
          <source>My Solution(s)</source>
          <target state="translated">Мои решения</target>
        </trans-unit>
        <trans-unit id="d16d82e7085b348c197150b20ab37cad4152300a" translate="yes" xml:space="preserve">
          <source>None of these answers are evenly sized chunks, they all leave a runt chunk at the end, so they're not completely balanced. If you were using these functions to distribute work, you've built-in the prospect of one likely finishing well before the others, so it would sit around doing nothing while the others continued working hard.</source>
          <target state="translated">Ни один из этих ответов не является равномерным по размеру куском,все они оставляют в конце кусок карлика,поэтому они не полностью сбалансированы.Если бы вы использовали эти функции для распределения работы,вы встроили перспективу того,что один,скорее всего,закончит работу задолго до других,так что он будет сидеть и ничего не делать,в то время как другие будут продолжать упорно работать.</target>
        </trans-unit>
        <trans-unit id="4fb5cd16340841226cb584a92c0d56a59cc45ff9" translate="yes" xml:space="preserve">
          <source>Notice that the contiguous generator provide chunks in the same length patterns as the other two, but the items are all in order, and they are as evenly divided as one may divide a list of discrete elements.</source>
          <target state="translated">Обратите внимание на то,что в генераторе сопрягаемых элементов имеются куски одинаковой длины,но все элементы расположены по порядку,и они равномерно разделены так,как можно разделить список дискретных элементов.</target>
        </trans-unit>
        <trans-unit id="6f253cbf35cc30170ea6d83c8b71ed090a9a84a9" translate="yes" xml:space="preserve">
          <source>OR:</source>
          <target state="translated">OR:</target>
        </trans-unit>
        <trans-unit id="17a9b13128644f1d8b18cb515e3e01c79a026853" translate="yes" xml:space="preserve">
          <source>One more solution</source>
          <target state="translated">Еще одно решение</target>
        </trans-unit>
        <trans-unit id="f9199d6541466df87c407771ffe310862754415b" translate="yes" xml:space="preserve">
          <source>Others, like &lt;code&gt;list(grouper(3, xrange(7)))&lt;/code&gt;, and &lt;code&gt;chunk(xrange(7), 3)&lt;/code&gt; both return: &lt;code&gt;[(0, 1, 2), (3, 4, 5), (6, None, None)]&lt;/code&gt;. The &lt;code&gt;None&lt;/code&gt;'s are just padding, and rather inelegant in my opinion. They are NOT evenly chunking the iterables.</source>
          <target state="translated">Другие, такие как &lt;code&gt;list(grouper(3, xrange(7)))&lt;/code&gt; и &lt;code&gt;chunk(xrange(7), 3)&lt;/code&gt; оба возвращают: &lt;code&gt;[(0, 1, 2), (3, 4, 5), (6, None, None)]&lt;/code&gt; . &lt;code&gt;None&lt;/code&gt; 's просто дополняют, и, на мой взгляд, довольно не элегантны. Они НЕ равномерно разбивают фрагменты.</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="c0bf8c95093739ba9b7bafbe08dbe897abd95683" translate="yes" xml:space="preserve">
          <source>Python 2 version:</source>
          <target state="translated">Версия на питоне 2:</target>
        </trans-unit>
        <trans-unit id="260cdb02eef94c3ec0c5d6feeb1243b43c8d1491" translate="yes" xml:space="preserve">
          <source>Python3</source>
          <target state="translated">Python3</target>
        </trans-unit>
        <trans-unit id="71849193d7d4d55164b78c9896f7a9dc772ed9fe" translate="yes" xml:space="preserve">
          <source>Related question: &lt;a href=&quot;https://stackoverflow.com/questions/434287/what-is-the-most-pythonic-way-to-iterate-over-a-list-in-chunks&quot;&gt;What is the most &amp;ldquo;pythonic&amp;rdquo; way to iterate over a list in chunks?&lt;/a&gt;</source>
          <target state="translated">Смежный вопрос: &lt;a href=&quot;https://stackoverflow.com/questions/434287/what-is-the-most-pythonic-way-to-iterate-over-a-list-in-chunks&quot;&gt;Какой самый &amp;laquo;питонный&amp;raquo; способ перебирать список по частям?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="981fcb2aa39ba3a18ef848f7e642cdf5f8ecd7fc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://docs.python.org/3.3/library/functions.html?highlight=zip#zip&quot;&gt;this reference&lt;/a&gt;</source>
          <target state="translated">Смотрите &lt;a href=&quot;http://docs.python.org/3.3/library/functions.html?highlight=zip#zip&quot;&gt;эту ссылку&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c89e1bf8261d7f316330a5faf8a9a46b0e582595" translate="yes" xml:space="preserve">
          <source>Simple yet elegant</source>
          <target state="translated">Простой,но элегантный</target>
        </trans-unit>
        <trans-unit id="2ff35546249ad5b66d0fb9d1fe43700554f6319c" translate="yes" xml:space="preserve">
          <source>Since everybody here talking about iterators. &lt;a href=&quot;https://boltons.readthedocs.io/&quot;&gt;&lt;code&gt;boltons&lt;/code&gt;&lt;/a&gt; has perfect method for that, called &lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked_iter&quot;&gt;&lt;code&gt;iterutils.chunked_iter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Так как все здесь говорят об итераторах. &lt;a href=&quot;https://boltons.readthedocs.io/&quot;&gt; &lt;code&gt;boltons&lt;/code&gt; &lt;/a&gt; есть идеальный метод для этого, который называется &lt;a href=&quot;https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked_iter&quot;&gt; &lt;code&gt;iterutils.chunked_iter&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74deacfe8465d3eece5467e74021e02845fce531" translate="yes" xml:space="preserve">
          <source>Tested on Python 3.5.1</source>
          <target state="translated">Протестировано на питоне 3.5.1.</target>
        </trans-unit>
        <trans-unit id="a070904a56ca5749113b247909c8f4172a684de4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/pytoolz/toolz&quot;&gt;toolz&lt;/a&gt; library has the &lt;code&gt;partition&lt;/code&gt; function for this:</source>
          <target state="translated">Библиотека &lt;a href=&quot;https://github.com/pytoolz/toolz&quot;&gt;toolz&lt;/a&gt; имеет функцию &lt;code&gt;partition&lt;/code&gt; для этого:</target>
        </trans-unit>
        <trans-unit id="0e222ece4f0d63b0c3a30d4b1cff53a12ec0b0d7" translate="yes" xml:space="preserve">
          <source>The current version, as suggested by J.F.Sebastian:</source>
          <target state="translated">Текущая версия,как предложил Дж.Ф.Себастьян:</target>
        </trans-unit>
        <trans-unit id="303084aa1cd175ed003cf0c538e9a51c8ce3ee48" translate="yes" xml:space="preserve">
          <source>The functional flavour of the above:</source>
          <target state="translated">Функциональный аромат вышеперечисленного:</target>
        </trans-unit>
        <trans-unit id="2d31acba4646b7046246eb5ec8c89ea9ba1453d6" translate="yes" xml:space="preserve">
          <source>These solutions work because &lt;code&gt;[iter(iterable)]*n&lt;/code&gt; (or the equivalent in the earlier version) creates &lt;em&gt;one&lt;/em&gt; iterator, repeated &lt;code&gt;n&lt;/code&gt; times in the list. &lt;code&gt;izip_longest&lt;/code&gt; then effectively performs a round-robin of &quot;each&quot; iterator; because this is the same iterator, it is advanced by each such call, resulting in each such zip-roundrobin generating one tuple of &lt;code&gt;n&lt;/code&gt; items.</source>
          <target state="translated">Эти решения работают, потому что &lt;code&gt;[iter(iterable)]*n&lt;/code&gt; (или эквивалент в более ранней версии) создает &lt;em&gt;один&lt;/em&gt; итератор, повторенный &lt;code&gt;n&lt;/code&gt; раз в списке. &lt;code&gt;izip_longest&lt;/code&gt; эффективно выполняет циклический перебор &amp;laquo;каждого&amp;raquo; итератора; поскольку это один и тот же итератор, он продвигается при каждом таком вызове, в результате чего каждый такой zip-циклический робин генерирует один кортеж из &lt;code&gt;n&lt;/code&gt; элементов.</target>
        </trans-unit>
        <trans-unit id="3351ae97164ad34d25cfa1a87ba90d402b29e7dc" translate="yes" xml:space="preserve">
          <source>This works on an arbitrary iterable, not just a list.</source>
          <target state="translated">Это работает на произвольном итерабельном,а не просто на списке.</target>
        </trans-unit>
        <trans-unit id="f72c8b9833ef44f668e605f6c6b47726e8e3f946" translate="yes" xml:space="preserve">
          <source>This works with any iterable and produces output lazily. It returns tuples rather than iterators, but I think it has a certain elegance nonetheless. It also doesn't pad; if you want padding, a simple variation on the above will suffice:</source>
          <target state="translated">Это работает с любыми итерациями и производит продукцию лениво.Он возвращает кортежи,а не итераторы,но я думаю,что он все же имеет определенную элегантность.Он также не пробивает;если вы хотите пробивать,достаточно простого варианта:</target>
        </trans-unit>
        <trans-unit id="c8c4d7f83e6f3c9aad0f35fb413eb0e5fbdd3d02" translate="yes" xml:space="preserve">
          <source>To test them out:</source>
          <target state="translated">Чтобы проверить их:</target>
        </trans-unit>
        <trans-unit id="7e2bf240c51921bc85786da57f64d4d7ffb9b537" translate="yes" xml:space="preserve">
          <source>UPDATE: A lazy chunks version:</source>
          <target state="translated">Версия с ленивыми кусочками:</target>
        </trans-unit>
        <trans-unit id="379fa67eaaf9d4bf3b4cb8fe4251da2145554ba4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;xrange()&lt;/code&gt; instead of &lt;code&gt;range()&lt;/code&gt; in the case of Python 2.x</source>
          <target state="translated">Используйте &lt;code&gt;xrange()&lt;/code&gt; вместо &lt;code&gt;range()&lt;/code&gt; в случае Python 2.x</target>
        </trans-unit>
        <trans-unit id="f610215c01d3050c4bc4007ebaf25e124322c260" translate="yes" xml:space="preserve">
          <source>Where AA is array, SS is chunk size. For example:</source>
          <target state="translated">Где AA-массив,SS-размер фрагмента.Например:</target>
        </trans-unit>
        <trans-unit id="37716ed00d633b81920f80390744e2f570994984" translate="yes" xml:space="preserve">
          <source>Which prints out:</source>
          <target state="translated">Которые распечатывают:</target>
        </trans-unit>
        <trans-unit id="de34eeea45ec51d962a89827c68f30b24f15f868" translate="yes" xml:space="preserve">
          <source>Why can't we divide these better?</source>
          <target state="translated">Почему мы не можем разделить их лучше?</target>
        </trans-unit>
        <trans-unit id="d1a8e487c7ddd714dc6aa815c7a65005ebeb7b81" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://www.python.org/dev/peps/pep-0572/&quot;&gt;Assignment Expressions&lt;/a&gt; in Python 3.8 it becomes quite nice:</source>
          <target state="translated">С помощью &lt;a href=&quot;https://www.python.org/dev/peps/pep-0572/&quot;&gt;Assignment Expressions&lt;/a&gt; в Python 3.8 это становится довольно приятно:</target>
        </trans-unit>
        <trans-unit id="e81ab559adc970d663d23724576742b3e62a7248" translate="yes" xml:space="preserve">
          <source>Without calling len() which is good for large lists:</source>
          <target state="translated">Без вызова len(),что хорошо для больших списков:</target>
        </trans-unit>
        <trans-unit id="e4eaae3f6d5fe8325131510e654ca9103ed32e13" translate="yes" xml:space="preserve">
          <source>You can create n-tuple for any n. If &lt;code&gt;a = range(1, 15)&lt;/code&gt;, then the result will be:</source>
          <target state="translated">Вы можете создать n-кортеж для любого n. Если &lt;code&gt;a = range(1, 15)&lt;/code&gt; , то результатом будет:</target>
        </trans-unit>
        <trans-unit id="58e01c1308a4e76507dfd9bfbc03b3c0bd4ab7ea" translate="yes" xml:space="preserve">
          <source>You can install &lt;a href=&quot;https://pypi.python.org/pypi/utilspie&quot;&gt;&lt;code&gt;utilspie&lt;/code&gt;&lt;/a&gt; via pip:</source>
          <target state="translated">Вы можете установить &lt;a href=&quot;https://pypi.python.org/pypi/utilspie&quot;&gt; &lt;code&gt;utilspie&lt;/code&gt; &lt;/a&gt; через pip:</target>
        </trans-unit>
        <trans-unit id="c63f793d1aadeef671378f417f94a070ffde5e01" translate="yes" xml:space="preserve">
          <source>You may also use &lt;a href=&quot;http://utilspie.readthedocs.io/en/latest/#get-chunks&quot;&gt;&lt;code&gt;get_chunks&lt;/code&gt;&lt;/a&gt; function of &lt;a href=&quot;http://utilspie.readthedocs.io&quot;&gt;&lt;code&gt;utilspie&lt;/code&gt;&lt;/a&gt; library as:</source>
          <target state="translated">Вы также можете использовать функцию &lt;a href=&quot;http://utilspie.readthedocs.io&quot;&gt; &lt;code&gt;utilspie&lt;/code&gt; &lt;/a&gt; библиотеки utilspie :</target>
        </trans-unit>
        <trans-unit id="4fc19dd49d67bc4ce99ea768a6c767c51047c281" translate="yes" xml:space="preserve">
          <source>code:</source>
          <target state="translated">code:</target>
        </trans-unit>
        <trans-unit id="07d20acd3d6d3a65dab86aac1963f8fc7266dde3" translate="yes" xml:space="preserve">
          <source>for example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="868a36da4eb71c0342f273350a197b11e69d1c66" translate="yes" xml:space="preserve">
          <source>heh, one line version</source>
          <target state="translated">хех,однострочная версия</target>
        </trans-unit>
        <trans-unit id="39a25778f91a825c38533cb5a85e43cc0130f38a" translate="yes" xml:space="preserve">
          <source>it is not very explicit</source>
          <target state="translated">не очень-то прямолинейно</target>
        </trans-unit>
        <trans-unit id="23d29a1e5ae63b782e6282a05f8eba18a5eebc52" translate="yes" xml:space="preserve">
          <source>or if you prefer:</source>
          <target state="translated">или если хочешь:</target>
        </trans-unit>
        <trans-unit id="d575e92f6e78dfc9ee7b6d9f6680fd8e354625d8" translate="yes" xml:space="preserve">
          <source>result:</source>
          <target state="translated">result:</target>
        </trans-unit>
        <trans-unit id="7fb777990060cd6a13fa8c404b0c52ae3c520ed2" translate="yes" xml:space="preserve">
          <source>source:
&lt;a href=&quot;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&quot;&gt;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&lt;/a&gt;</source>
          <target state="translated">source:
&lt;a href=&quot;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&quot;&gt;http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d99f66b852fef055214f1f6c4e0864afe932b13e" translate="yes" xml:space="preserve">
          <source>usage:</source>
          <target state="translated">usage:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
