<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/31044">
    <body>
      <group id="31044">
        <trans-unit id="be141f8a42560351d06c57f2013ba04b3aa4acb7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://api.jquery.com/jQuery.contains/&quot;&gt;jQuery.contains&lt;/a&gt; takes two DOM elements and checks whether the first one contains the second one.</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/jQuery.contains/&quot;&gt;jQuery.contains&lt;/a&gt; 는 두 개의 DOM 요소를 가져 와서 첫 번째 요소가 두 번째 요소를 포함하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="253208cdb2739f610e1475e2e8bb36c50ee17f81" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://learn.jquery.com/using-jquery-core/faq/how-do-i-test-whether-an-element-exists/&quot;&gt;Checking for existence of an element&lt;/a&gt; is documented neatly in the official jQuery website itself!</source>
          <target state="translated">&lt;a href=&quot;https://learn.jquery.com/using-jquery-core/faq/how-do-i-test-whether-an-element-exists/&quot;&gt;요소&lt;/a&gt; 가 있는지 확인하는 것은 공식 jQuery 웹 사이트 자체에 깔끔하게 문서화되어 있습니다!</target>
        </trans-unit>
        <trans-unit id="15460a52022f912174fbd67441e18c7f42ea770c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$(&quot;selector&quot;&lt;/code&gt;) returns an object which has the &lt;code&gt;length&lt;/code&gt; property. If the selector finds any elements, they will be included in the object. So if you check its length you can see if any elements exist. In JavaScript &lt;code&gt;0 == false&lt;/code&gt;, so if you don't get &lt;code&gt;0&lt;/code&gt; your code will run.</source>
          <target state="translated">&lt;code&gt;$(&quot;selector&quot;&lt;/code&gt; )는 &lt;code&gt;length&lt;/code&gt; 속성이있는 객체를 반환합니다. 선택기가 요소를 찾으면 해당 요소가 객체에 포함됩니다. 따라서 길이를 확인하면 요소가 있는지 확인할 수 있습니다. JavaScript &lt;code&gt;0 == false&lt;/code&gt; 이므로 &lt;code&gt;0&lt;/code&gt; 을 얻지 않으면 코드가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="363f3fa2ec89e17be56878352706aeebeb10e9ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note&lt;/em&gt;&lt;/strong&gt;: The first argument must be a DOM element, not a jQuery object or plain JavaScript object.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;참고&lt;/em&gt;&lt;/strong&gt; : 첫 번째 인수는 jQuery 객체 또는 일반 JavaScript 객체가 아닌 DOM 요소 여야합니다.</target>
        </trans-unit>
        <trans-unit id="90f2c4bad014276e5d3dc2a1e554c18a38786ea4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FINAL SOLUTION&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;마지막 해결책&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd064ce7707f60287475ad847261b94e14b223ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NB:&lt;/strong&gt; Notice the lack of an '#' before the &lt;code&gt;element_id&lt;/code&gt; (since this is plain JS, not &lt;code&gt;jQuery&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;NB :&lt;/strong&gt; &lt;code&gt;element_id&lt;/code&gt; 앞에 '#'이 없다는 것을 알 수 있습니다 ( &lt;code&gt;jQuery&lt;/code&gt; 가 아닌 일반 JS이므로).</target>
        </trans-unit>
        <trans-unit id="adb39f4a8cec0df89e2b475cd992eaa7d63aab84" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;little&lt;/strong&gt; more elegant, perhaps.</source>
          <target state="translated">아마도 &lt;strong&gt;조금&lt;/strong&gt; 더 우아 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8b8b0ff7a35e9caa15a5ba208384ed1248887b7" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;a href=&quot;http://learn.jquery.com/using-jquery-core/faq/how-do-i-test-whether-an-element-exists/&quot;&gt;from the FAQ&lt;/a&gt;:</source>
          <target state="translated">또는 &lt;a href=&quot;http://learn.jquery.com/using-jquery-core/faq/how-do-i-test-whether-an-element-exists/&quot;&gt;FAQ에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="680b4bec362e0e97999ad585a8a21f4a4aa21a3c" translate="yes" xml:space="preserve">
          <source>And it is better than the alternative of writing your own &lt;code&gt;jQuery&lt;/code&gt; function. That alternative is slower, for the reasons @snover stated. But it would also give other programmers the impression that the &lt;code&gt;exists()&lt;/code&gt; function is something inherent to jQuery. &lt;code&gt;JavaScript&lt;/code&gt; would/should be understood by others editing your code, without increased knowledge debt.</source>
          <target state="translated">그리고 자체 &lt;code&gt;jQuery&lt;/code&gt; 함수를 작성하는 것보다 낫습니다. @snover가 언급 한 이유 때문에 그 대안이 더 느립니다. 그러나 또한 다른 프로그래머에게 &lt;code&gt;exists()&lt;/code&gt; 함수가 jQuery 고유의 것임을 인상 할 것입니다. 지식 부채 증가없이 코드를 편집하는 다른 사람들이 &lt;code&gt;JavaScript&lt;/code&gt; 를 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ff35c2f7ca7c5422602c66d12ad5e6d5c0957ce" translate="yes" xml:space="preserve">
          <source>And now i can write code like this -</source>
          <target state="translated">이제 이런 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1888c5589c987ce35f03566f176d96494dd3421f" translate="yes" xml:space="preserve">
          <source>Below, I've put together a snippet that compares &lt;code&gt;jQuery.exists()&lt;/code&gt; against the &lt;code&gt;$(sel)[0]&lt;/code&gt; and &lt;code&gt;$(sel).length&lt;/code&gt; approaches which both return &lt;code&gt;truthy&lt;/code&gt; values for &lt;code&gt;$(4)&lt;/code&gt; while &lt;code&gt;$(4).exists()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. In the context of &lt;strong&gt;checking for existence&lt;/strong&gt; of an element in the DOM this seems to be the &lt;strong&gt;desired result&lt;/strong&gt;.</source>
          <target state="translated">아래에서는 &lt;code&gt;jQuery.exists()&lt;/code&gt; 를 &lt;code&gt;$(sel)[0]&lt;/code&gt; 및 &lt;code&gt;$(sel).length&lt;/code&gt; 접근 방식과 &lt;code&gt;truthy&lt;/code&gt; 하여 &lt;code&gt;$(4)&lt;/code&gt; 동안 &lt;code&gt;$(4).exists()&lt;/code&gt; 대해 진솔한 값을 반환하는 스 니펫을 구성 했습니다. () 는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다. DOM에 요소가 &lt;strong&gt;있는지 검사&lt;/strong&gt; 하는 상황에서 이것은 &lt;strong&gt;원하는 결과 인&lt;/strong&gt; 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="614f7d8f91ec8a997545c3ffb6b56b85e36b1e31" translate="yes" xml:space="preserve">
          <source>Edit: &lt;strong&gt;WARNING!&lt;/strong&gt; This doesn't work in IE when &lt;code&gt;selector&lt;/code&gt; is a string.</source>
          <target state="translated">편집 : &lt;strong&gt;경고!&lt;/strong&gt; &lt;code&gt;selector&lt;/code&gt; 가 문자열 인 경우 IE에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbfdfa363d5febf67bec9401327c62825e8c4aeb" translate="yes" xml:space="preserve">
          <source>Example Uses</source>
          <target state="translated">사용 예</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="c08d85561b30a4293f197bb268373c96c96f5561" translate="yes" xml:space="preserve">
          <source>Execute the chain only if a jQuery element exist  - &lt;a href=&quot;http://jsfiddle.net/andres_314/vbNM3/2/&quot;&gt;http://jsfiddle.net/andres_314/vbNM3/2/&lt;/a&gt;</source>
          <target state="translated">jQuery 요소가 존재하는 경우에만 체인을 실행하십시오 &lt;a href=&quot;http://jsfiddle.net/andres_314/vbNM3/2/&quot;&gt;-http&lt;/a&gt; : //jsfiddle.net/andres_314/vbNM3/2/</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="344f84627f5be0108f168722814ac89e634b1fc2" translate="yes" xml:space="preserve">
          <source>Here is my favorite &lt;code&gt;exist&lt;/code&gt; method in jQuery</source>
          <target state="translated">여기 jQuery에서 내가 좋아하는 &lt;code&gt;exist&lt;/code&gt; 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="84ef2cc74f3e435f0bb06454c76f10422f6dd041" translate="yes" xml:space="preserve">
          <source>Here is the complete example of different situations and way to check if element exists using direct if on jQuery selector may or may not work because it returns array or elements.</source>
          <target state="translated">다음은 jQuery 선택기에서 배열 또는 요소를 반환하기 때문에 직접 if를 사용하여 요소가 존재하는지 여부를 확인하는 다양한 상황과 방법의 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="e75030adb468b3a20795417b746e352d74186766" translate="yes" xml:space="preserve">
          <source>How about:</source>
          <target state="translated">어때요?</target>
        </trans-unit>
        <trans-unit id="ee7880a0fc768ef10b1fd552a69a813d09fe35a3" translate="yes" xml:space="preserve">
          <source>How can I check the existence of an element in jQuery?</source>
          <target state="translated">jQuery에서 요소의 존재를 어떻게 확인할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="c834c92215659d3c1ed8aa78f0c33a029dc48552" translate="yes" xml:space="preserve">
          <source>However this method leaves us with the actual object being returned; which is fine if it isn't going to be saved as variable and used repeatedly (thus keeping the reference around if we forget).</source>
          <target state="translated">그러나이 메소드는 실제 객체가 반환되도록합니다. 변수로 저장되지 않고 반복적으로 사용되지 않으면 괜찮습니다 (따라서 잊어 버린 경우 참조를 유지합니다).</target>
        </trans-unit>
        <trans-unit id="772eaee22a5f028e404f604d0d8204a4380daaac" translate="yes" xml:space="preserve">
          <source>I had a case where I wanted to see if an object exists inside of another so I added something to the first answer to check for a selector inside the selector..</source>
          <target state="translated">객체가 다른 객체 안에 존재하는지 확인하고 싶었 기 때문에 첫 번째 답변에 무언가를 추가하여 선택기 내부의 선택기를 확인했습니다.</target>
        </trans-unit>
        <trans-unit id="23e7679d619274a1c050a6555167b90aa2259957" translate="yes" xml:space="preserve">
          <source>I have found &lt;code&gt;if ($(selector).length) {}&lt;/code&gt; to be insufficient. It will silently break your app when &lt;code&gt;selector&lt;/code&gt; is an empty object &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if ($(selector).length) {}&lt;/code&gt; 이 충분하지 않은 것으로 나타났습니다. &lt;code&gt;selector&lt;/code&gt; 가 빈 객체 &lt;code&gt;{}&lt;/code&gt; 인 경우 자동으로 앱이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="b8cfad0044d460ee15f65d57d74661386d54ee9c" translate="yes" xml:space="preserve">
          <source>I just like to use plain vanilla javascript to do this.</source>
          <target state="translated">나는 이것을하기 위해 일반 바닐라 자바 ​​스크립트를 사용하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="743ced2e69b7301f1883136d7ed6feeae12adcd4" translate="yes" xml:space="preserve">
          <source>I see most of the answers here are &lt;strong&gt;not accurate&lt;/strong&gt; as they should be, they check element length, it can be &lt;strong&gt;OK&lt;/strong&gt; in many cases, but &lt;strong&gt;not 100%&lt;/strong&gt;, imagine if number pass to the function instead, so I prototype a function which check all conditions and return the answer as it should be:</source>
          <target state="translated">나는 여기에있는 대부분의 대답이 &lt;strong&gt;정확하지 않다는&lt;/strong&gt; 것을 알았습니다. 요소 길이를 &lt;strong&gt;확인합니다&lt;/strong&gt; . 많은 경우 &lt;strong&gt;OK&lt;/strong&gt; 일 수 있지만 &lt;strong&gt;100 %는 아닙니다.&lt;/strong&gt; 숫자가 함수에 대신 전달되는지 상상해보십시오. 조건에 따라 답을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="2aec2eec2e008faa93776b4e53f65ead7f768c65" translate="yes" xml:space="preserve">
          <source>I stumbled upon this question and i'd like to share a snippet of code i currently use:</source>
          <target state="translated">나는이 질문에 걸려 넘어졌고 현재 사용중인 코드 스 니펫을 공유하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="7aafedd09b64bc92c115a85a5dc8d8daf8911943" translate="yes" xml:space="preserve">
          <source>I'm still looking for a better solution though as this one is a bit heavy.</source>
          <target state="translated">나는 이것이 조금 무겁지만 여전히 더 나은 해결책을 찾고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aff9b68fdb743fcc4af055791e7099cada839c9" translate="yes" xml:space="preserve">
          <source>I'm using this:</source>
          <target state="translated">나는 이것을 사용하고있다 :</target>
        </trans-unit>
        <trans-unit id="cfdbd71bd1bdf3874f47be3d2f9bba7f7da1d542" translate="yes" xml:space="preserve">
          <source>If for any reason you don't want to put an id to the element, you can still use any other JavaScript method designed to access the DOM.</source>
          <target state="translated">어떤 이유로 든 요소에 ID를 넣고 싶지 않은 경우 DOM에 액세스하도록 설계된 다른 JavaScript 메소드를 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f21c59ea1e1f4e2747c773afe86e76c95a6cd69" translate="yes" xml:space="preserve">
          <source>If you don't actually need the element and want to get/store just a true/false, just double not it !!  It works for shoes that come untied, so why knot here?</source>
          <target state="translated">실제로 요소가 필요하지 않고 true / false 만 가져 오거나 저장하려면 두 배로 늘리지 마십시오 !! 묶이지 않은 신발에 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdf305996aea41c30698f859a49459079c15daf9" translate="yes" xml:space="preserve">
          <source>If you used</source>
          <target state="translated">사용한 경우</target>
        </trans-unit>
        <trans-unit id="154feac1548385fac7cc0e787b9a77e02e537a24" translate="yes" xml:space="preserve">
          <source>In JavaScript, everything is 'truthy' or 'falsy', and for numbers &lt;code&gt;0&lt;/code&gt; (and NaN) means &lt;code&gt;false&lt;/code&gt;, everything else &lt;code&gt;true&lt;/code&gt;. So you could write:</source>
          <target state="translated">JavaScript에서 모든 것은 'truthy'또는 'falsy'이며 숫자 &lt;code&gt;0&lt;/code&gt; (및 NaN)의 경우 &lt;code&gt;false&lt;/code&gt; , 다른 모든 것은 &lt;code&gt;true&lt;/code&gt; 입니다. 그래서 당신은 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6ff17e14f64cb7cd29b7e49a91dbe03caa66d00d" translate="yes" xml:space="preserve">
          <source>In some cases this may be desired.  It can be used in a for loop like this:</source>
          <target state="translated">어떤 경우에는 이것이 필요할 수 있습니다. 다음과 같이 for 루프에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef3cc795e01ffe8544bb322757ff3892b10b7cf0" translate="yes" xml:space="preserve">
          <source>Inspired by &lt;a href=&quot;https://stackoverflow.com/a/19533724/177710&quot;&gt;hiway's answer&lt;/a&gt; I came up with the following:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/19533724/177710&quot;&gt;hiway의 답변에서&lt;/a&gt; 영감을 얻은 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ad867bd6e09d6144016154307fc89aff81e21ac" translate="yes" xml:space="preserve">
          <source>Is &lt;a href=&quot;http://api.jquery.com/jQuery.contains/&quot;&gt;&lt;code&gt;$.contains()&lt;/code&gt;&lt;/a&gt; what you want?</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/jQuery.contains/&quot;&gt; &lt;code&gt;$.contains()&lt;/code&gt; &lt;/a&gt; 원하는 것입니까?</target>
        </trans-unit>
        <trans-unit id="7670762e5368024d94ec800cbc48b6ff05f379d5" translate="yes" xml:space="preserve">
          <source>Is there a more elegant way to approach this? Perhaps a plugin or a function?</source>
          <target state="translated">이것에 접근하는 더 우아한 방법이 있습니까? 아마도 플러그인이나 함수입니까?</target>
        </trans-unit>
        <trans-unit id="dbb40afe618fc71e22f0fa14353a861d9f0d56f7" translate="yes" xml:space="preserve">
          <source>Is there an “exists” function for jQuery</source>
          <target state="translated">jQuery에 대한 &quot;존재&quot;기능이 있습니까?</target>
        </trans-unit>
        <trans-unit id="cde248b0a1335dec914e6fc113d65b505d291f71" translate="yes" xml:space="preserve">
          <source>It is a bit longer to write than the jQuery length alternative, but executes faster since it is a native JS method.</source>
          <target state="translated">jQuery 길이 대안보다 작성하는 것이 약간 더 길지만 기본 JS 메소드이므로 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4d0514a9277b4466c81ce0b5704dde4ca1afff02" translate="yes" xml:space="preserve">
          <source>It might seem a lot of code, but when written in CoffeeScript it is quite small:</source>
          <target state="translated">많은 코드처럼 보일지 모르지만 CoffeeScript로 작성되면 상당히 작습니다.</target>
        </trans-unit>
        <trans-unit id="d8f03b7b0e94e631429e819e9c4f257e02c76fb6" translate="yes" xml:space="preserve">
          <source>It's very minimal and saves you having to enclose the selector with &lt;code&gt;$()&lt;/code&gt; every time.</source>
          <target state="translated">그것은 매우 작으며 매번 &lt;code&gt;$()&lt;/code&gt; 선택자를 묶을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7686a45a941b2348674f2a56597fa3056e1c75bb" translate="yes" xml:space="preserve">
          <source>Keep in mind that using the &lt;strong&gt;callback variant helps maintain chainability&lt;/strong&gt; &amp;ndash; the element is returned and you can continue chaining commands as with any other jQuery method!</source>
          <target state="translated">&lt;strong&gt;콜백 변형&lt;/strong&gt; 을 사용하면 체인 성 &lt;strong&gt;을 유지하는 데 도움이됩니다&lt;/strong&gt; . 요소가 반환되고 다른 jQuery 메소드와 마찬가지로 체인 명령을 계속할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="f6cb336ffa2bb157f146e2dadef9cde9d4507919" translate="yes" xml:space="preserve">
          <source>Much more performant option below(notice lack of a dot before a-class).</source>
          <target state="translated">아래에서 훨씬 더 성능이 좋은 옵션 (클래스 전에 점이 없음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="d0f6ccf98cff584a5c8b827b8e8878b2ccc925c1" translate="yes" xml:space="preserve">
          <source>My only suggestion is to perform an additional check for &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">내 제안은 &lt;code&gt;{}&lt;/code&gt; 에 대한 추가 검사를 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="57cbe7fe2124e87fd2bd9494aa89983ffc8f89b1" translate="yes" xml:space="preserve">
          <source>No need for jQuery (basic solution)</source>
          <target state="translated">jQuery 불필요 (기본 솔루션)</target>
        </trans-unit>
        <trans-unit id="c74dea4541d4eab744f05a03c0973705052f601c" translate="yes" xml:space="preserve">
          <source>Note that it isn't always necessary to test whether an element exists.
  The following code will show the element if it exists, and do nothing
  (with no errors) if it does not:</source>
          <target state="translated">요소가 존재하는지 항상 테스트 할 필요는 없습니다. 다음 코드는 요소가 존재하는 경우 표시하고, 존재하지 않으면 아무 것도하지 않고 (오류없이) 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8dc208f8ebe86aa9ee6a37d49d48058be5364bff" translate="yes" xml:space="preserve">
          <source>Plugin</source>
          <target state="translated">Plugin</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">코드 스 니펫 표시</target>
        </trans-unit>
        <trans-unit id="25a09eb6d4c1d491451c5f908a0fa3643fb4cd17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.contains()&lt;/code&gt; method returns true if the DOM element provided by the second argument is a descendant of the DOM element provided by the first argument, whether it is a direct child or nested more deeply. Otherwise, it returns false. Only element nodes are supported; if the second argument is a text or comment node, &lt;code&gt;$.contains()&lt;/code&gt; will return false.</source>
          <target state="translated">&lt;code&gt;$.contains()&lt;/code&gt; 메소드는 두 번째 인수가 제공 한 DOM 요소가 첫 번째 인수가 제공 한 DOM 요소의 하위 요소 (직접 하위 항목이든 더 깊이 중첩되어 있는지) 인 경우 true를 리턴합니다. 그렇지 않으면 false를 반환합니다. 요소 노드 만 지원됩니다. 두 번째 인수가 텍스트 또는 주석 노드 인 경우 &lt;code&gt;$.contains()&lt;/code&gt; 는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d468d7904b06ac13ec3b9d3d59250bd1eaadcb2d" translate="yes" xml:space="preserve">
          <source>The ['length'] parameter is not needed or useful and the code will be a lot faster if you directly use &lt;code&gt;document.querySelector(selector)&lt;/code&gt; instead, because it returns the first element it matches or null if not found.</source>
          <target state="translated">[ 'length'] 매개 변수는 필요하지 않거나 유용하지 않으며, &lt;code&gt;document.querySelector(selector)&lt;/code&gt; 대신 직접 사용하는 경우 코드가 훨씬 빠릅니다. 첫 번째 요소는 일치하는 첫 번째 요소를 리턴하거나 찾지 못하면 널을 리턴하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a1616540a15ecaca15bb65b97b613da676efadc0" translate="yes" xml:space="preserve">
          <source>The current code that I have is this:</source>
          <target state="translated">내가 가지고있는 현재 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35ae8a285c093d5a6b7e9df2d6a3c25037e953a4" translate="yes" xml:space="preserve">
          <source>The fastest and most semantically self explaining way to check for existence is actually by using plain &lt;code&gt;JavaScript&lt;/code&gt;:</source>
          <target state="translated">존재 여부를 확인하는 가장 빠르고 의미 론적으로 자체 설명하는 방법은 실제로 일반 &lt;code&gt;JavaScript&lt;/code&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="da9bb3c7186056f293e557fd9098059f8e30999c" translate="yes" xml:space="preserve">
          <source>The reason all of the previous answers require the &lt;code&gt;.length&lt;/code&gt; parameter is that they are mostly using jquery's &lt;code&gt;$()&lt;/code&gt; selector which has querySelectorAll behind the curtains (or they are using it directly).  This method is rather slow because it needs to parse the entire DOM tree looking for &lt;strong&gt;all&lt;/strong&gt; matches to that selector and populating an array with them.</source>
          <target state="translated">이전의 모든 답변에 &lt;code&gt;.length&lt;/code&gt; 매개 변수가 필요한 이유는 주로 커튼 뒤에 querySelectorAll이있는 jquery의 &lt;code&gt;$()&lt;/code&gt; 선택기를 사용하기 때문입니다 (또는 직접 사용합니다). 이 방법은 전체 DOM 트리를 구문 분석하여 해당 선택기와 일치하는 &lt;strong&gt;모든 항목을&lt;/strong&gt; 찾고 배열을 채울 필요가 있기 때문에 속도가 느립니다.</target>
        </trans-unit>
        <trans-unit id="bd6b5063f86bfb5c2634c6f6052bb3ea97b76571" translate="yes" xml:space="preserve">
          <source>There's no need for jQuery really. With plain JavaScript it's easier and semantically correct to check for:</source>
          <target state="translated">실제로 jQuery가 필요하지 않습니다. 일반 JavaScript를 사용하면 다음을 확인하는 것이 더 쉽고 의미 론적으로 정확합니다.</target>
        </trans-unit>
        <trans-unit id="77c257982afcfdc7c1258664833940b28411a704" translate="yes" xml:space="preserve">
          <source>This is in response to: &lt;a href=&quot;http://herdingcode.com/?p=36&quot;&gt;Herding Code podcast with Jeff Atwood&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://herdingcode.com/?p=36&quot;&gt;Jeff Atwood 님의 Herding Code podcast&lt;/a&gt; 님의 질문에 답변</target>
        </trans-unit>
        <trans-unit id="f1c6c94d5a1be2cdbd431df9d749af37fcaad99b" translate="yes" xml:space="preserve">
          <source>This plugin can be used in an &lt;code&gt;if&lt;/code&gt; statement like &lt;code&gt;if ($(ele).exist()) { /* DO WORK */ }&lt;/code&gt; or using a callback.</source>
          <target state="translated">이 플러그인은 &lt;code&gt;if ($(ele).exist()) { /* DO WORK */ }&lt;/code&gt; 또는 콜백과 같은 &lt;code&gt;if&lt;/code&gt; 문에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52f26379092f2e1ba7457b89654a67fe2a86cbe1" translate="yes" xml:space="preserve">
          <source>This will check both length and type, Now you can check it this way:</source>
          <target state="translated">길이와 유형을 모두 확인하므로 다음과 같이 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf2317b8d8707bcffb90533f9d5734210f67456e" translate="yes" xml:space="preserve">
          <source>This works because each jQuery object also masquerades as an array, so we can use the array dereferencing operator to get the first item from the &lt;em&gt;array&lt;/em&gt;. It returns &lt;code&gt;undefined&lt;/code&gt; if there is no item at the specified index.</source>
          <target state="translated">이것은 각 jQuery 객체가 배열로 가장하기 때문에 배열 역 참조 연산자를 사용하여 배열에서 첫 번째 항목을 가져올 수 있기 때문에 작동합니다. 지정된 인덱스에 항목이 없으면 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="201f177460224ad73737ff35d885f30138910484" translate="yes" xml:space="preserve">
          <source>This would be better:</source>
          <target state="translated">이것은 더 나을 것입니다 :</target>
        </trans-unit>
        <trans-unit id="e6a567763ce7d6d4dc5bcc760439c508de62c0d9" translate="yes" xml:space="preserve">
          <source>Try testing for &lt;code&gt;DOM&lt;/code&gt; element</source>
          <target state="translated">&lt;code&gt;DOM&lt;/code&gt; 요소 테스트</target>
        </trans-unit>
        <trans-unit id="a87ca91762ace67fb8a20322ab0b28758e410071" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://api.jquery.com/length/&quot;&gt;.length&lt;/a&gt; property of the jQuery collection returned by your
  selector:</source>
          <target state="translated">선택기에서 리턴 한 jQuery 콜렉션의 &lt;a href=&quot;https://api.jquery.com/length/&quot;&gt;.length&lt;/a&gt; 특성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2918cc8bc0c0a725b62a688a00c8342fe252dc11" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;document.documentElement&lt;/code&gt; as the first argument fulfills the semantics of the &lt;code&gt;exists&lt;/code&gt; method when we want to apply it solely to check the existence of an element in the current document.</source>
          <target state="translated">&lt;code&gt;document.documentElement&lt;/code&gt; 를 첫 번째 인수로 사용하면 현재 문서에서 요소의 존재를 확인하기 위해서만 적용하려는 경우 &lt;code&gt;exists&lt;/code&gt; 메소드의 의미를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="ee33f374675522a91be7d6eacf2f658b43a6f135" translate="yes" xml:space="preserve">
          <source>Yes!</source>
          <target state="translated">Yes!</target>
        </trans-unit>
        <trans-unit id="b3cbb04a93ea0a79bad6f1960439dd18334069fe" translate="yes" xml:space="preserve">
          <source>You can check element is present or not using length in java script.
   If length is greater than zero then element is present if length is zero then
   element is not present</source>
          <target state="translated">Java 스크립트에서 요소가 존재하는지 또는 길이를 사용하지 않는지 확인할 수 있습니다. 길이가 0보다 크면 요소가 존재하고 길이가 0이면 요소가 존재하지 않습니다</target>
        </trans-unit>
        <trans-unit id="e3ff5ee11330ec14aba012f2e60059dd21eff504" translate="yes" xml:space="preserve">
          <source>You can save a few bytes by writing:</source>
          <target state="translated">다음과 같이 작성하여 몇 바이트를 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5b799049d31606a4bf737328c6f8e5743e4e30d" translate="yes" xml:space="preserve">
          <source>You can use this:</source>
          <target state="translated">이것을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="28ce5baaf2a7e364a9e6393430ef2a639312b251" translate="yes" xml:space="preserve">
          <source>You can use:</source>
          <target state="translated">당신이 사용할 수있는:</target>
        </trans-unit>
        <trans-unit id="c480476ffd3bde220dc7e1a84098b57fbc6d9c09" translate="yes" xml:space="preserve">
          <source>You could also use the following. If there are no values in the jQuery object array then getting the first item in the array would return undefined.</source>
          <target state="translated">다음을 사용할 수도 있습니다. jQuery 객체 배열에 값이 없으면 배열의 첫 번째 항목을 가져 오면 정의되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7441cbe277117316f893d76b94521e13057322a1" translate="yes" xml:space="preserve">
          <source>You could use this:</source>
          <target state="translated">이것을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="18545f96300c6e7c4a1ac307b16f236fb93af59f" translate="yes" xml:space="preserve">
          <source>You don't have to check if it's greater than &lt;code&gt;0&lt;/code&gt; like &lt;code&gt;$(selector).length &amp;gt; 0&lt;/code&gt;, &lt;code&gt;$(selector).length&lt;/code&gt; it's enough and a elegant way to check the existence of elements. I don't think that is worth to write a function only for this, if you want to do more extra things, yes.</source>
          <target state="translated">&lt;code&gt;$(selector).length &amp;gt; 0&lt;/code&gt; , &lt;code&gt;$(selector).length&lt;/code&gt; 와 같이 &lt;code&gt;0&lt;/code&gt; 보다 큰지 여부는 충분하지 않으며 요소의 존재를 확인하는 데 충분합니다. 더 많은 일을하고 싶다면이 기능을 작성하는 것이 가치가 있다고 생각하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5ef08c968e3729ff30fb266c436d8f12902aa4e" translate="yes" xml:space="preserve">
          <source>You don't need that &lt;code&gt;&amp;gt;0&lt;/code&gt; part.</source>
          <target state="translated">&lt;code&gt;&amp;gt;0&lt;/code&gt; 부분이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30e11c4fd83394b248b6bdc162b4ba26f33da89a" translate="yes" xml:space="preserve">
          <source>You may specify one or two callbacks. The first one will fire if the element exists, the second one will fire if the element does &lt;em&gt;not&lt;/em&gt; exist. However, if you choose to pass only one function, it will only fire when the element exists. Thus, the chain will die if the selected element does &lt;em&gt;not&lt;/em&gt; exist. Of course, if it does exist, the first function will fire and the chain will continue.</source>
          <target state="translated">하나 또는 두 개의 콜백을 지정할 수 있습니다. 첫 번째 요소는 요소가 있으면 시작되고 두 번째 요소는 요소가 &lt;em&gt;없으면 시작&lt;/em&gt; 됩니다. 그러나 하나의 함수 만 전달하도록 선택하면 요소가 존재하는 경우에만 실행됩니다. 따라서 선택한 요소가 존재하지 &lt;em&gt;않으면&lt;/em&gt; 체인이 죽습니다. 물론 존재하는 경우 첫 번째 기능이 실행되고 체인이 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bff71c613c510c23eaca83f56580a486026d81db" translate="yes" xml:space="preserve">
          <source>and other version which supports callback when selector does not exist</source>
          <target state="translated">선택기가 존재하지 않을 때 콜백을 지원하는 다른 버전</target>
        </trans-unit>
        <trans-unit id="5f64c6dac7f90118a331bbbc6df086986b8b9a68" translate="yes" xml:space="preserve">
          <source>jQuery is really cool, but don't let pure JavaScript fall into oblivion...</source>
          <target state="translated">jQuery는 정말 멋지지만 순수한 JavaScript가 망각에 빠지지 않도록하십시오 ...</target>
        </trans-unit>
        <trans-unit id="de873d4bf1ac12c3470094c9888a2e0eda22977a" translate="yes" xml:space="preserve">
          <source>jsFiddle</source>
          <target state="translated">jsFiddle</target>
        </trans-unit>
        <trans-unit id="75a59f9fa327efb10e2c0dde455e9ab6b4ca803c" translate="yes" xml:space="preserve">
          <source>querySelector uses a proper matching engine like $() (sizzle) in jQuery and uses more computing power but in 99% cases will do just fine. The second option is more explicit and tells the code exactly what to do. It's much faster according to jsperf &lt;a href=&quot;https://jsperf.com/getelementsbyclassname-vs-queryselectorall/25&quot;&gt;https://jsperf.com/getelementsbyclassname-vs-queryselectorall/25&lt;/a&gt;</source>
          <target state="translated">querySelector는 jQuery에서 $ () (sizzle)과 같은 적절한 일치 엔진을 사용하고 더 많은 컴퓨팅 성능을 사용하지만 99 %의 경우에는 정상적으로 작동합니다. 두 번째 옵션은보다 명확하며 코드에 정확히 무엇을 지시합니다. jsperf &lt;a href=&quot;https://jsperf.com/getelementsbyclassname-vs-queryselectorall/25&quot;&gt;https://jsperf.com/getelementsbyclassname-vs-queryselectorall/25&lt;/a&gt; 에 따르면 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="f108514ad53b76a0829c9ca8c111877203a2995a" translate="yes" xml:space="preserve">
          <source>this is very similar to all of the answers, but why not use the &lt;code&gt;!&lt;/code&gt; operator twice so you can get a boolean:</source>
          <target state="translated">이것은 모든 답변과 매우 유사하지만 &lt;code&gt;!&lt;/code&gt; 연산자를 두 번 사용하여 부울을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2ba144213117538614a736fbcbc46be39ec0a74" translate="yes" xml:space="preserve">
          <source>you would imply that chaining was possible when it is not.</source>
          <target state="translated">체인이 불가능할 때 체인이 가능했음을 암시합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
