<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/31816095">
    <body>
      <group id="31816095">
        <trans-unit id="ed51437f4e3d2eef017e692b9bfd62b6feec3005" translate="yes" xml:space="preserve">
          <source>#include &amp;lt;bits/stdc++.h&amp;gt; with visual studio does not compile</source>
          <target state="translated">Visual Studio에서 #include &amp;lt;bits / stdc ++. h&amp;gt;가 컴파일되지 않습니다</target>
        </trans-unit>
        <trans-unit id="6ecbd70d981a33fd6e16bc244252d711604a53c5" translate="yes" xml:space="preserve">
          <source>&amp;lt;bits/stdc++.h&amp;gt; also carries a warning:</source>
          <target state="translated">&amp;lt;bits / stdc ++. h&amp;gt;에도 경고가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac0a980e9727549af0b1b4493ff29a3628c9259a" translate="yes" xml:space="preserve">
          <source>17.6.1.2 Headers [headers]</source>
          <target state="translated">17.6.1.2 헤더 [헤더]</target>
        </trans-unit>
        <trans-unit id="e06b1808529277b7c27259e1c0d5ea1302f93451" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Code_golf&quot;&gt;Code Golf&lt;/a&gt; is &quot;a type of recreational computer programming competition in which participants strive to achieve the shortest possible source code that implements a certain algorithm.&quot; In the answers on the PP&amp;amp;CG site, you'll see people specify the number of bytes in their answers. When they find a way to shave off a few bytes, they'll strike out the original number and record the new one.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Code_golf&quot;&gt;코드 골프&lt;/a&gt; 는 &quot;참가자가 특정 알고리즘을 구현하는 가장 짧은 소스 코드를 달성하기 위해 노력하는 레크리에이션 컴퓨터 프로그래밍 경쟁의 한 유형입니다.&quot; PP &amp;amp; CG 사이트의 답변에서 사람들이 답변에 바이트 수를 지정하는 것을 볼 수 있습니다. 그들이 몇 바이트를 깎을 수있는 방법을 찾으면, 원래 숫자를 지우고 새로운 숫자를 기록 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="3211abdfc1183d3b4d79d96ffbae6dc7b2ce2519" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;To anyone writing such &quot;tutorials&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;그런 &quot;자습서&quot;를 쓰는 사람에게&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="103d03c4c1cf54adf8cc719dbddd0279dce1b20c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't do it!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;하지마!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f444cf0ef37c345704f21b46365415326764cd5" translate="yes" xml:space="preserve">
          <source>As you might expect, code golfing rewards extreme programming language abuse. One-letter variable names. No whitespace. Creative use of library functions. Undocumented features. Nonstandard programming practices. Appalling hacks.</source>
          <target state="translated">예상대로 코드 골프는 프로그래밍 언어 남용에 대한 보상입니다. 한글자 변수 이름 공백이 없습니다. 라이브러리 기능을 창의적으로 사용합니다. 문서화되지 않은 기능. 비표준 프로그래밍 실습. 끔찍한 해킹.</target>
        </trans-unit>
        <trans-unit id="3e07d03fd8d5df3e7056370a22fdb378d3907093" translate="yes" xml:space="preserve">
          <source>Each element of the C++ standard library is declared or defined (as appropriate) in a header.</source>
          <target state="translated">C ++ 표준 라이브러리의 각 요소는 헤더에서 적절하게 선언 또는 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="4c2c5decb38ee215c6329ae20f0aec7161fc2d91" translate="yes" xml:space="preserve">
          <source>Even just upgrading your compiler to its own next version may break your program</source>
          <target state="translated">컴파일러를 다음 버전으로 업그레이드해도 프로그램이 손상 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c9a48c02521331a393d7f0fa745303b95698e194" translate="yes" xml:space="preserve">
          <source>Every single standard header must be parsed and compiled along with your source code, which is slow and results in a bulky executable under certain compilation settings</source>
          <target state="translated">모든 단일 표준 헤더를 소스 코드와 함께 구문 분석하고 컴파일해야합니다. 느리고 특정 컴파일 설정에서 대량 실행 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a553598db8ffe9c4b23b1f5050dc29054fc5a380" translate="yes" xml:space="preserve">
          <source>Example of why Quora is bad:</source>
          <target state="translated">Quora가 나쁜 이유의 예 :</target>
        </trans-unit>
        <trans-unit id="8ebcae3327c1699056869c34171c65eee91d0f63" translate="yes" xml:space="preserve">
          <source>From N4606, Working Draft, Standard for Programming Language C++ :</source>
          <target state="translated">프로그래밍 언어 C ++의 표준 인 N4606부터 작업 초안 :</target>
        </trans-unit>
        <trans-unit id="0184ce24529753c881fd7b500e60a2ba54cbbf8c" translate="yes" xml:space="preserve">
          <source>How does #include &amp;lt;bits/stdc++.h&amp;gt; work in C++?</source>
          <target state="translated">C ++에서 #include &amp;lt;bits / stdc ++. h&amp;gt;는 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="43c2302ab3b0c2be1034d114bbfcc212096623d3" translate="yes" xml:space="preserve">
          <source>I have discovered - to my horror and disbelief - that there is a well-known tutorial site where &lt;strong&gt;every C++ example seems to include this header&lt;/strong&gt;. The world is mad. That's the proof.</source>
          <target state="translated">나는 &lt;strong&gt;모든 C ++ 예제가이 헤더를 포함하고있는 것으로&lt;/strong&gt; 알려진 잘 알려진 튜토리얼 사이트가 있다는 것을 공포와 불신으로 발견했다. 세상은 화났어 이것이 증거입니다.</target>
        </trans-unit>
        <trans-unit id="fbad24faa4e61b994b21dc2f0d9cc187d72e80a3" translate="yes" xml:space="preserve">
          <source>I imagine the advantages are vaguely given thus:</source>
          <target state="translated">나는 이점이 모호하게 주어진다고 상상한다.</target>
        </trans-unit>
        <trans-unit id="d2b694e37fa77d5c6edd569c688ffd8b7d23e91c" translate="yes" xml:space="preserve">
          <source>I posted a question with my code whose only &lt;code&gt;#include&lt;/code&gt; directive was the following:</source>
          <target state="translated">&lt;code&gt;#include&lt;/code&gt; 지시문 만 다음과 같은 코드로 질문을 게시했습니다.</target>
        </trans-unit>
        <trans-unit id="39aa15acd0fb4495d7dd505f9c2dadbb295911f9" translate="yes" xml:space="preserve">
          <source>If a programmer submitted a pull request at work containing golf-style code, it would be rejected. Their co-workers would laugh at them. Their manager would drop by their desk for a chat. Even so, programmers amuse themselves by submitting answers to PP&amp;amp;CG.</source>
          <target state="translated">프로그래머가 직장에서 골프 스타일 코드가 포함 된 풀 요청을 제출 한 경우 거부됩니다. 그들의 동료들은 그들을 비웃을 것입니다. 그들의 관리자는 채팅을 위해 책상 옆으로 떨어졌습니다. 그럼에도 불구하고 프로그래머는 PP &amp;amp; CG에 답변을 제출하여 스스로 즐겁게합니다.</target>
        </trans-unit>
        <trans-unit id="092e89e5ff285bc6c183da6d4b6bb3ce152138cf" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/code&gt; appears to be an increasingly common thing to see on Stack Overflow, perhaps something newly added to a national curriculum in the current academic year.</source>
          <target state="translated">&lt;code&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/code&gt; 를 포함하는 것은 Stack Overflow에서 볼 수있는 일반적인 것으로 보이며, 아마도 현재 학년도에 국가 교과 과정에 새로 추가 된 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="57ddd425c34e4cd9a35bbeb5d9f553933c0e92ec" translate="yes" xml:space="preserve">
          <source>Is it good practice to use #include &amp;lt;bits/stdc++.h&amp;gt; in programming contests instead of listing a lot of includes?</source>
          <target state="translated">포함을 많이 나열하는 대신 프로그래밍 콘테스트에서 #include &amp;lt;bits / stdc ++. h&amp;gt;를 사용하는 것이 좋습니다?</target>
        </trans-unit>
        <trans-unit id="9b9c10639efdd8d26d8cec07869f9fdddcd449b9" translate="yes" xml:space="preserve">
          <source>Is this is a good idea? Let's check the list of disadvantages. Portability? It doesn't matter since these coding events use a specific compiler version that contestants know in advance. Standards compliance? Not relevant for a block of code whose useful life is less than one hour. Compile time and executable size? These aren't part of the contest's scoring rubric.</source>
          <target state="translated">이것이 좋은 생각입니까? 단점 목록을 확인하십시오. 이식성? 이러한 코딩 이벤트는 참가자가 미리 알고있는 특정 컴파일러 버전을 사용하므로 중요하지 않습니다. 표준 준수? 유효 수명이 1 시간 미만인 코드 블록과는 관련이 없습니다. 컴파일 시간과 실행 가능한 크기? 이것들은 컨테스트의 점수 기준에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bb033406448459223d5a7d15243f4e41b9f1e8b" translate="yes" xml:space="preserve">
          <source>It turns out that some people like &lt;em&gt;programming puzzles&lt;/em&gt; without the &lt;em&gt;code golf&lt;/em&gt;. They get together and compete at events like ACM-ICPC, Google Code Jam, and Facebook Hacker Cup, or on sites like Topcoder and Codeforces. Their rank is based on program correctness, execution speed, and how fast they submit a solution. To maximize execution speed, many participants use C++. To maximize coding speed, some of them use &lt;code&gt;stdc++.h&lt;/code&gt;.</source>
          <target state="translated">어떤 사람들은 &lt;em&gt;코드 골프&lt;/em&gt; 없이 &lt;em&gt;프로그래밍 퍼즐&lt;/em&gt; 을 좋아한다는 것이 밝혀졌다. ACM-ICPC, Google Code Jam 및 Facebook Hacker Cup과 같은 이벤트 또는 Topcoder 및 Codeforces와 같은 사이트에서 함께 모여 경쟁합니다. 그들의 순위는 프로그램 정확성, 실행 속도 및 솔루션 제출 속도에 따라 결정됩니다. 실행 속도를 최대화하기 위해 많은 참가자가 C ++을 사용합니다. 코딩 속도를 최대화하기 위해 일부는 &lt;code&gt;stdc++.h&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="276e91294003c9b29f02eac0dfe3d7a6af1beb09" translate="yes" xml:space="preserve">
          <source>It will probably only work on that compiler</source>
          <target state="translated">아마도 해당 컴파일러에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="02febe21fcd28cd0e0816a5ad762195185c7e4e5" translate="yes" xml:space="preserve">
          <source>More information:</source>
          <target state="translated">추가 정보:</target>
        </trans-unit>
        <trans-unit id="bcfbf234d0ab16edf4f16becb196eeedff573a93" translate="yes" xml:space="preserve">
          <source>My teacher told me to do this, but in the comments section I was informed that I shouldn't.</source>
          <target state="translated">선생님은 저에게 이렇게하라고 하셨지만, 의견 섹션에서 내가해서는 안된다는 정보를 받았습니다.</target>
        </trans-unit>
        <trans-unit id="ac97e8b3520949916bee5c469c50f3d4daf6457c" translate="yes" xml:space="preserve">
          <source>P.P.S. No, there was no practical need for it. There aren't that many C++ standard headers, and they are well documented. If you teach, you're doing your students a disservice by adding such &quot;magic&quot;. Producing programmers with a magical mindset is the last thing we want. If you need to offer students a subset of C++ to make their life easier, just produce a handout with the short list of headers applicable to the course you teach, and with concise documentation for the library constructs you expect the students to use.</source>
          <target state="translated">PPS 아니요, 실질적인 필요는 없었습니다. C ++ 표준 헤더는 많지 않으며 문서화가 잘되어 있습니다. 당신이 가르치면, 당신은 그런 &quot;마법&quot;을 추가함으로써 학생들에게 장애를 겪고 있습니다. 마법의 사고 방식으로 프로그래머를 생산하는 것이 우리가 원하는 마지막 것입니다. 학생들에게 인생을 편하게하기 위해 C ++의 부분 집합을 제공해야하는 경우, 가르치는 과정에 적용 할 수있는 간단한 헤더 목록과 학생들이 사용할 라이브러리 구성에 대한 간결한 문서를 제공하는 유인물을 만드십시오.</target>
        </trans-unit>
        <trans-unit id="4a09a488bdc9357434491d46f0d8824b89fa0bd2" translate="yes" xml:space="preserve">
          <source>P.S. I can well imagine the abominable &quot;teaching standard&quot; where this wicked idea might have taken place, and the circumstances that led to it. Just because there seemed to be a practical need for it doesn't make it acceptable - not even in retrospect.</source>
          <target state="translated">추신 : 저는이 악한 생각이 일어 났을 수있는 가증스러운 &quot;교습 표준&quot;과 그로 인해 발생한 상황을 잘 상상할 수 있습니다. 실질적인 요구가있는 것처럼 보였기 때문에 그것을 회고하지 않아도 받아 들일 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b2999cdf881fb72dc6b19fbf71bddb6426b99a3" translate="yes" xml:space="preserve">
          <source>Please stop using this header. Forget about it. Don't propagate this insanity. If you're unwilling to understand why doing this is &lt;strong&gt;Wrong&lt;/strong&gt;, take my word for it. I'm not OK being treated as a figure of authority on anything at all, and I'm probably full of it half the time, but I'll make an exception in this one case only. I claim that I know what I'm talking about here. Take me on my word. I implore you.</source>
          <target state="translated">이 헤더 사용을 중지하십시오. 잊어 버려 이 광기를 전파하지 마십시오. 왜 이것이 &lt;strong&gt;잘못&lt;/strong&gt; 되었는지 이해하지 않으려면 내 말을 들어보십시오. 나는 어떤 것에 대한 권위의 인물로 취급되는 것은 좋지 않으며 아마도 반 시간으로 가득 차 있지만이 경우에는 예외를 만들 것입니다. 나는 내가 여기서 말하는 것을 알고 있다고 주장한다. 내 말을 들어 줘 당신을 간청합니다.</target>
        </trans-unit>
        <trans-unit id="44bd43ed0ebc5577cb5d3e9e1657a65ee44651ab" translate="yes" xml:space="preserve">
          <source>So the question of whether to use &lt;code&gt;stdc++.h&lt;/code&gt; comes down to whether the coding speed benefits in a programming contest outweigh the bad habits that one might develop by using it.</source>
          <target state="translated">따라서 &lt;code&gt;stdc++.h&lt;/code&gt; 를 사용할 지에 대한 문제는 프로그래밍 콘테스트에서 코딩 속도 이점이이를 사용하여 개발할 수있는 나쁜 습관을 능가하는지 여부에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="239a2260863a483f3ec3cdd90b3634e5b45b8495" translate="yes" xml:space="preserve">
          <source>So we're left with bad habits. This is a valid objection. By using this header file, contestants are avoiding the chance to learn which standard header file defines the functionality they're using in their program. When they're writing real-world code (and not using &lt;code&gt;stdc++.h&lt;/code&gt;) they'll have to spend time looking up this information, which means they'll be less productive. That's the downside of practicing with &lt;code&gt;stdc++.h&lt;/code&gt;.</source>
          <target state="translated">그래서 우리는 나쁜 습관에 빠져 있습니다. 이것은 유효한 이의 제기입니다. 참가자는이 헤더 파일을 사용하여 프로그램에서 사용중인 기능을 정의하는 표준 헤더 파일을 배울 기회를 피할 수 있습니다. 실제 코드를 작성할 때 ( &lt;code&gt;stdc++.h&lt;/code&gt; 사용하지 않음)이 정보를 찾는 데 시간을 소비해야하므로 생산성이 떨어집니다. 그것은 &lt;code&gt;stdc++.h&lt;/code&gt; 연습의 단점입니다.</target>
        </trans-unit>
        <trans-unit id="39ec4f2a5d5a066178d0d4fb1ad88c01109b0604" translate="yes" xml:space="preserve">
          <source>Table 14 &amp;mdash; C++ library headers</source>
          <target state="translated">표 14 &amp;mdash; C ++ 라이브러리 헤더</target>
        </trans-unit>
        <trans-unit id="217e579d4314a3e6967ebc9146377a5722bc851e" translate="yes" xml:space="preserve">
          <source>The C++ standard library provides 61 C++ library headers, as shown in Table 14.</source>
          <target state="translated">C ++ 표준 라이브러리는 표 14에 표시된 것처럼 61 개의 C ++ 라이브러리 헤더를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a9bcd4e2c8add93cbb911e47b0c2044336636190" translate="yes" xml:space="preserve">
          <source>The disadvantages include:</source>
          <target state="translated">단점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4413e8a45b5f2173516c7d64e16d2bcef3437c9a" translate="yes" xml:space="preserve">
          <source>There's a Stack Exchange site called &lt;a href=&quot;https://codegolf.stackexchange.com/&quot;&gt;Programming Puzzles &amp;amp; Code Golf&lt;/a&gt;. The &lt;em&gt;programming puzzles&lt;/em&gt; on that site fit this definition of &lt;a href=&quot;https://www.dictionary.com/browse/puzzle&quot;&gt;puzzle&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://codegolf.stackexchange.com/&quot;&gt;Programming Puzzles &amp;amp; Code Golf&lt;/a&gt; 라는 스택 교환 사이트가 있습니다. 해당 사이트의 &lt;em&gt;프로그래밍 퍼즐&lt;/em&gt; 은 &lt;a href=&quot;https://www.dictionary.com/browse/puzzle&quot;&gt;퍼즐의&lt;/a&gt; 다음 정의에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="5ff0be9e34d030520485c268606b44e79d1ef4eb" translate="yes" xml:space="preserve">
          <source>There's no &amp;lt;bits/stdc++.h&amp;gt; there. This is not surprising, since &amp;lt;bits/...&amp;gt; headers are  implementation detail, and usually carry a warning:</source>
          <target state="translated">&amp;lt;bits / stdc ++. h&amp;gt;는 없습니다. &amp;lt;bits / ...&amp;gt; 헤더는 구현 세부 사항이며 일반적으로 경고를 표시하므로 이는 놀라운 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e68d42367e8df8d019d55f5601b98691429390ca" translate="yes" xml:space="preserve">
          <source>These are all valid and correct objections. So why would anyone use this monstrosity?</source>
          <target state="translated">이것들은 모두 유효하고 올바른 반대입니다. 그렇다면 왜이 괴물을 사용합니까?</target>
        </trans-unit>
        <trans-unit id="ae5dc0af222ddcc786d29fc134d10a103d3487a0" translate="yes" xml:space="preserve">
          <source>They are designed to amuse, and not in the way that a working programmer might be amused by a real-world problem encountered in their daily work.</source>
          <target state="translated">이들은 일상적인 작업에서 발생하는 실제 문제로 작업 프로그래머를 즐겁게하는 방식이 아니라 재미있게 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="d760db932e13a0248bfa450b6787a1b76a2a588b" translate="yes" xml:space="preserve">
          <source>This question asks: &quot;Why should I not #include &lt;code&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/code&gt;?&quot; I realize that it was asked and answered to make a point, and the accepted answer is intended to be the One True Answer to this question. But the question isn't &quot;Why should I not #include &lt;code&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/code&gt; in production code?&quot; Therefore, I think it's reasonable to consider other scenarios where the answer may be different.</source>
          <target state="translated">이 질문은 &quot;왜 #include &lt;code&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/code&gt; 하지 않아야합니까?&quot; 나는 그것이 요점을 물으라는 요청과 대답을 받았으며, 받아 들여진 대답은이 질문에 대한 하나의 진정한 답이되도록 의도되었다. 그러나 &quot;왜 프로덕션 코드에 &lt;code&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/code&gt; 를 포함 시키지 말아야 합니까?&quot; 따라서 답이 다른 다른 시나리오를 고려하는 것이 합리적이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="41b7148ed2c1a282d26cd8b52ba1e74a804e3f78" translate="yes" xml:space="preserve">
          <source>This raises the question of why it's worth taking part in competitive programming at all if it encourages bad habits like using &lt;code&gt;stdc++.h&lt;/code&gt; and violating other coding standards. One answer is that people do it for the same reason they post programs on PP&amp;amp;CG: some programmers find it enjoyable to use their coding skills in a game-like context.</source>
          <target state="translated">이것은 &lt;code&gt;stdc++.h&lt;/code&gt; 하고 다른 코딩 표준을 위반하는 것과 같은 나쁜 습관을 조장하는 경우 경쟁 프로그래밍에 참여할 가치가있는 이유에 대한 의문을 제기합니다. 한 가지 대답은 사람들이 PP &amp;amp; CG에 프로그램을 게시하는 것과 같은 이유로 그렇게하는 것입니다. 일부 프로그래머는 게임과 같은 맥락에서 코딩 기술을 사용하는 것이 즐겁다는 것을 알게됩니다.</target>
        </trans-unit>
        <trans-unit id="425b4e7136346e6ed916db66ddbe629bd2fbc1cf" translate="yes" xml:space="preserve">
          <source>Unfortunately, this is a lazy hack, naming a GCC internal header directly instead of individual standard headers like &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;. It ruins portability and fosters terrible habits.</source>
          <target state="translated">불행히도 이것은 게으른 핵이며 &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; 와 같은 개별 표준 헤더 대신 GCC 내부 헤더의 이름을 직접 지정합니다. 휴대 성을 망치고 끔찍한 습관을 키 웁니다.</target>
        </trans-unit>
        <trans-unit id="5a129d811454321d42b960a8844a971ce2ad3179" translate="yes" xml:space="preserve">
          <source>What does this have to do with &lt;code&gt;stdc++.h&lt;/code&gt;? As others have pointed out, using it is lazy. It's non-portable, so you don't know if it will work on your compiler or the next version of your compiler. It fosters bad habits. It's non-standard, so your program's behavior may differ from what you expect. It may increase compile time and executable size.</source>
          <target state="translated">이것은 &lt;code&gt;stdc++.h&lt;/code&gt; 와 어떤 관련이 있습니까? 다른 사람들이 지적했듯이 그것을 사용하는 것은 게으르다. 이식성이 없으므로 컴파일러 또는 다음 버전의 컴파일러에서 작동하는지 알 수 없습니다. 나쁜 습관을 키 웁니다. 비표준이므로 프로그램의 동작이 예상과 다를 수 있습니다. 컴파일 시간과 실행 파일 크기가 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1e1b88691fe90d726866ebcfc2e83f6bde1d68c" translate="yes" xml:space="preserve">
          <source>Why should I not #include &lt;bits/stdc++.h&gt;</source>
          <target state="translated">내가 #include하지 않아야하는 이유 &lt;bits stdc++.h=&quot;&quot;&gt;&lt;/bits&gt;</target>
        </trans-unit>
        <trans-unit id="d77989c1e3c0e0ace735631597dc367ffdfa6f32" translate="yes" xml:space="preserve">
          <source>Why?</source>
          <target state="translated">Why?</target>
        </trans-unit>
        <trans-unit id="cf5f824e155c7cb15ad3bacefc6661ba7e021d0c" translate="yes" xml:space="preserve">
          <source>Why? Because it is used as if it was supposed to be a C++ standard header, but no standard mentions it. So your code is non-portable by construction. You won't find any documentation for it on &lt;a href=&quot;https://en.cppreference.com&quot;&gt;cppreference&lt;/a&gt;. So it might as well not exist. It's a figment of someone's imagination :)</source>
          <target state="translated">왜? 마치 C ++ 표준 헤더 인 것처럼 사용되지만 표준에 대한 언급은 없기 때문입니다. 따라서 코드는 구성으로 이식 할 수 없습니다. &lt;a href=&quot;https://en.cppreference.com&quot;&gt;cppreference&lt;/a&gt; 에 대한 문서는 없습니다. 따라서 존재하지 않을 수도 있습니다. 누군가의 상상력의 조각입니다 :)</target>
        </trans-unit>
        <trans-unit id="2fbd6990a9110b4fd96777704dbf54e19d3a4b34" translate="yes" xml:space="preserve">
          <source>You do not need to look up which standard header everything is in</source>
          <target state="translated">모든 표준 헤더를 찾을 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b1ac8fc863c0a29c5c317291e3b4fa874ab4030" translate="yes" xml:space="preserve">
          <source>You have no idea what it'll do when you use it, because its contents are not set by a standard</source>
          <target state="translated">내용이 표준으로 설정되어 있지 않기 때문에 사용할 때 무엇을 해야할지 전혀 모릅니다</target>
        </trans-unit>
        <trans-unit id="cbc564b39675bbed0ed122414e264322c63d09f9" translate="yes" xml:space="preserve">
          <source>You only need write one &lt;code&gt;#include&lt;/code&gt; line</source>
          <target state="translated">하나의 &lt;code&gt;#include&lt;/code&gt; 줄만 작성하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a537225c59d3274a443f8f17c0de8efb398362a9" translate="yes" xml:space="preserve">
          <source>a toy, problem, or other contrivance designed to amuse by presenting difficulties to be solved by ingenuity or patient effort.</source>
          <target state="translated">독창성 또는 환자의 노력으로 해결해야 할 어려움을 제시함으로써 즐겁게 사용하도록 고안된 장난감, 문제 또는 기타 구성.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
