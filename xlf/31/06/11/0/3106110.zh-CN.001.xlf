<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3106110">
    <body>
      <group id="3106110">
        <trans-unit id="df0fd2702057b417c35ac16135733ca9fa59293f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::move(some_lvalue)&lt;/code&gt; casts an lvalue to an rvalue, thus enabling a subsequent move.</source>
          <target state="translated">&lt;code&gt;std::move(some_lvalue)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将左值转换为右值，从而启用后续移动。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50f6f367eb9f6b3f8bc2138fd21d734104676605" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Move semantics&lt;/strong&gt; is about &lt;strong&gt;transferring resources rather than copying them&lt;/strong&gt; when nobody needs the source value anymore.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动语义&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是关于&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转移资源，而不是&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在没有人再需要源值时&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复制资源&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6792b6f126f7677728171c0bfe42b4de3714768a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two&lt;/strong&gt; new objects have been constructed, one of which is a temporary object that's only used for the duration of the function.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;构造了&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两个&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;新对象，其中一个是仅在功能期间使用的临时对象。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a95152a9e43e530501f6b99af74270415868a62a" translate="yes" xml:space="preserve">
          <source>A named rvalue reference is an lvalue, just like any other variable.</source>
          <target state="translated">一个命名的r值引用是一个l值,就像其他变量一样。</target>
        </trans-unit>
        <trans-unit id="f040209caa6e8f4d4e43aa329b98ebb25520ebed" translate="yes" xml:space="preserve">
          <source>A useful example of a function with an &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; parameter is the &lt;em&gt;move constructor&lt;/em&gt;&lt;code&gt;X::X(X&amp;amp;&amp;amp; source)&lt;/code&gt;. Its purpose is to transfer ownership of the managed resource from the source into the current object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的函数的一个有用示例&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;move构造函数&lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;X::X(X&amp;amp;&amp;amp; source)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其目的是将托管资源的所有权从源转移到当前对象。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abef74394b5449ff6f5131eaf664d8e46d148d79" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;rvalue&lt;/code&gt; reference works pretty much like an &lt;code&gt;lvalue&lt;/code&gt; reference with one important difference:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;引用的作品非常像一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;lvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有一个重要区别参考：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1400246cab7166daac5095b766ba4438e047c79f" translate="yes" xml:space="preserve">
          <source>An rvalue is a temporary object, which is going to be destroyed at the end of the expression. In current C++, rvalues only bind to &lt;code&gt;const&lt;/code&gt; references. C++1x will allow non-&lt;code&gt;const&lt;/code&gt; rvalue references, spelled &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, which are references to an rvalue objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个右值是一个临时对象，它将在表达式末尾销毁。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在当前的C ++中，右值仅绑定到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;引用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 1X将允许非&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; rvalue引用，斯佩尔特&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这对于一个右值对象的引用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ec69c00d4b9b0c380efb9f8ecec0d4b04714fba" translate="yes" xml:space="preserve">
          <source>An rvalue of class type is an expression whose evaluation creates a temporary object.
  Under normal circumstances, no other expression inside the same scope denotes the same temporary object.</source>
          <target state="translated">类类型的r值是一个表达式,它的评价会创建一个临时对象。在正常情况下,同一范围内没有其他表达式表示相同的临时对象。</target>
        </trans-unit>
        <trans-unit id="3fe43eb5a17970d62352f3daf0ab3389b2294910" translate="yes" xml:space="preserve">
          <source>An rvalue reference &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; is a new kind of reference that only binds to rvalues.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右值引用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是仅绑定到&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的新型引用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b951ee76f644338afecca76aa03ce849f6e9a636" translate="yes" xml:space="preserve">
          <source>And what is &lt;strong&gt;perfect forwarding&lt;/strong&gt;? It is important to know that a &quot;rvalue reference&quot; is a reference to a named object in the &quot;caller's scope&quot;. But in the actual scope, a rvalue reference is a name to an object, so, it acts as a named object. If you pass an rvalue reference to another function, you are passing a named object, so, the object isn't received like a temporal object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;什么是&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完美的转发&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重要的是要知道&amp;ldquo;右值引用&amp;rdquo;是对&amp;ldquo;调用者作用域&amp;rdquo;中已命名对象的引用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是在实际范围中，右值引用是对象的名称，因此它充当命名对象。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果将右值引用传递给另一个函数，则意味着传递的是命名对象，因此不会像时间对象那样接收该对象。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cdb7ef1ba819235b13a473fac62029ba510795b0" translate="yes" xml:space="preserve">
          <source>And yet, one of them invokes undefined behavior, whereas the other one does not. So what is the difference between the expressions &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;make_triangle()&lt;/code&gt;? Aren't they both of the same type? Indeed they are, but they have different &lt;em&gt;value categories&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，其中一个调用了未定义的行为，而另一个则没有。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那么表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; 有&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;什么&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;区别&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他们不是同一类型吗？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;确实是，但是它们具有不同的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;价值类别&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0eeed3546c92bc7d030625e964a6a1e8f2f93dd1" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;move&lt;/code&gt; accepts any kind of parameter thanks to the forwarding reference &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, and it returns an rvalue reference. The &lt;code&gt;std::remove_reference&amp;lt;T&amp;gt;::type&lt;/code&gt; meta-function call is necessary because otherwise, for lvalues of type &lt;code&gt;X&lt;/code&gt;, the return type would be &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt;, which would collapse into &lt;code&gt;X&amp;amp;&lt;/code&gt;. Since &lt;code&gt;t&lt;/code&gt; is always an lvalue (remember that a named rvalue reference is an lvalue), but we want to bind &lt;code&gt;t&lt;/code&gt; to an rvalue reference, we have to explicitly cast &lt;code&gt;t&lt;/code&gt; to the correct return type.
The call of a function that returns an rvalue reference is itself an xvalue. Now you know where xvalues come from ;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如您所见，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于转发引用&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;接受任何类型的参数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并且它返回右值引用。所述&lt;/font&gt; &lt;code&gt;std::remove_reference&amp;lt;T&amp;gt;::type&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;的元函数调用是必要的，因为否则，对于类型的左值&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则返回类型将是&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这将折叠成&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;始终是一个左值（请记住，命名的右值引用是一个左值），但是我们想将&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;绑定&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到右值引用，因此必须将&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;显式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转换为正确的返回类型。返回右值引用的函数的调用本身就是一个xvalue。现在您知道xvalue的来源;）&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5a6f247186a6ec51d7763851bdd8e18f434a0b74" translate="yes" xml:space="preserve">
          <source>Basically, the compiler will complain that &lt;code&gt;parameter&lt;/code&gt; is an lvalue. If you look at its type, you see an rvalue reference, but an rvalue reference simply means &quot;a reference that is bound to an rvalue&quot;; it does &lt;em&gt;not&lt;/em&gt; mean that the reference itself is an rvalue! Indeed, &lt;code&gt;parameter&lt;/code&gt; is just an ordinary variable with a name. You can use &lt;code&gt;parameter&lt;/code&gt; as often as you like inside the body of the constructor, and it always denotes the same object. Implicitly moving from it would be dangerous, hence the language forbids it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基本上，编译器会抱怨&lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个左值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果查看其类型，则会看到一个右值引用，但是右值引用仅表示&amp;ldquo;绑定到右值的引用&amp;rdquo;；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它并&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不能&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;意味着引用本身就是右值！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上，形&lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只是带有名称的普通变量。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在构造函数体内&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;随意使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它始终表示同一对象。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;隐式离开它是危险的，因此该语言禁止这样做。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e378544bfb07451e6088433236851c65b1e84876" translate="yes" xml:space="preserve">
          <source>Because the function also &lt;em&gt;returns by value&lt;/em&gt;, another new object is constructed for the return value:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为该函数还&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;按value返回，&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所以将&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为该返回值构造另一个新对象：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e819a9290ce3be37f7d22e748fce09e94c70c736" translate="yes" xml:space="preserve">
          <source>Both prvalues and xvalues are rvalues. Xvalues and lvalues are both &lt;em&gt;glvalues&lt;/em&gt; (Generalized lvalues). The relationships are easier to grasp with a diagram:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;prvalue和xvalue均为rvalue。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;X值和左值都是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;glvalues&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（广义&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;左值&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用图更容易理解这些关系：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef1b8b9546c894e61fe1d619148e7bed5cc0fc49" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;auto_ptr&lt;/code&gt; is not &lt;em&gt;always&lt;/em&gt; dangerous. Factory functions are a perfectly fine use case for &lt;code&gt;auto_ptr&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并不&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;总是很&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;危险。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;工厂函数是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个很好的用例&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e6a400bc51fb91373f9c57144a4bd019862c564" translate="yes" xml:space="preserve">
          <source>But if you say &lt;code&gt;a = x + y&lt;/code&gt;, the &lt;em&gt;move constructor&lt;/em&gt; will initialize &lt;code&gt;that&lt;/code&gt; (because the expression &lt;code&gt;x + y&lt;/code&gt; is an rvalue), so there is no deep copy involved, only an efficient move.
&lt;code&gt;that&lt;/code&gt; is still an independent object from the argument, but its construction was trivial,
since the heap data didn't have to be copied, just moved. It wasn't necessary to copy it because &lt;code&gt;x + y&lt;/code&gt; is an rvalue, and again, it is okay to move from string objects denoted by rvalues.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但如果你说&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a = x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，在&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动构造函数&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将初始化&lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（因为表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个右值），所以没有深拷贝参与进来，只有一个有效举措。 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从参数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它仍然是一个独立的对象，但是它的构造很简单，因为不必复制堆数据，只需移动它即可。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不必复制它，因为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个右值，同样，可以从以右值表示的字符串对象中移动。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="32822acac85aaeec4278db58d224f2fe9f3f352c" translate="yes" xml:space="preserve">
          <source>But, is that not dangerous? Of course, you could destruct a dynamic object twice (segmentation fault). So, to avoid that, you should &quot;invalidate&quot; the source pointers to avoid destructing them twice:</source>
          <target state="translated">但是,这不是很危险吗?当然,你可能会破坏一个动态对象两次(分段故障)。所以,为了避免这种情况,你应该对源指针进行 &quot;无效化&quot;,以避免破坏两次。</target>
        </trans-unit>
        <trans-unit id="c8a8d115ca80240745b86fe8f011228ba83a9e3b" translate="yes" xml:space="preserve">
          <source>C++0x introduces a new mechanism called &quot;rvalue reference&quot; which, among other things,
allows us to detect rvalue arguments via function overloading. All we have to do is write a constructor with an rvalue reference parameter. Inside that constructor we can do &lt;em&gt;anything we want&lt;/em&gt; with the source, as long as we leave it in &lt;em&gt;some&lt;/em&gt; valid state:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 0x引入了一种称为&amp;ldquo;右值引用&amp;rdquo;的新机制，该机制除其他外，使我们能够通过函数重载来检测右值参数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们要做的就是编写一个带有右值引用参数的构造函数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在该构造函数中，我们可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对源&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;执行&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任何操作&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，只要我们将其保持在&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;某种&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有效状态即可：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd0492dc5e0b6d5d91433b74385064b17d458bf4" translate="yes" xml:space="preserve">
          <source>C++11's answer to this problem is &lt;em&gt;rvalue references&lt;/em&gt;. An rvalue reference is a new kind of reference that only binds to rvalues, and the syntax is &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt;. The good old reference &lt;code&gt;X&amp;amp;&lt;/code&gt; is now known as an &lt;em&gt;lvalue reference&lt;/em&gt;. (Note that &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a reference to a reference; there is no such thing in C++.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11对这个问题的答案是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右值引用&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右值引用是仅绑定到右值的一种新型引用，语法为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;良好的旧参考&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在称为&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;左值参考&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（请注意，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到的基准的基准;没有这样的事情在C ++）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="023a6a48d15ef2c95fc40e5be2aa59fe9b54efad" translate="yes" xml:space="preserve">
          <source>C++98 implicitly declares three special member functions on demand, that is, when they are needed somewhere: the copy constructor, the copy assignment operator and the destructor.</source>
          <target state="translated">C++98隐含地声明了三个特殊成员函数的需求,也就是当某个地方需要它们的时候,会隐含地声明三个特殊成员函数:复制构造函数、复制赋值操作符和解析器。</target>
        </trans-unit>
        <trans-unit id="c779770f0201fc38c70bf3c75d9a6f84752c9e0a" translate="yes" xml:space="preserve">
          <source>C++98 rvalues are known as prvalues in C++11. Mentally replace all occurrences of &quot;rvalue&quot; in the preceding paragraphs with &quot;prvalue&quot;.</source>
          <target state="translated">C++98的r值在C++11中被称为prvalues,将前文中所有出现过的 &quot;r值 &quot;都用 &quot;pr值 &quot;代替。</target>
        </trans-unit>
        <trans-unit id="132f3ce3182bbd08fe44f45ff771c82759cf58e2" translate="yes" xml:space="preserve">
          <source>Congratulations, you now understand the basics of move semantics! Let's continue by implementing the assignment operator. If you're unfamiliar with the &lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;copy and swap idiom&lt;/a&gt;, learn it and come back, because it's an awesome C++ idiom related to exception safety.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;恭喜，您现在了解了移动语义的基础！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;让我们继续实现赋值运算符。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您不熟悉&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复制和交换惯用语&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，请学习并回来，因为它是与异常安全性相关的很棒的C ++惯用语。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec6e7926adcc44088c147ea22db81f9c26b87174" translate="yes" xml:space="preserve">
          <source>Consider the following function template:</source>
          <target state="translated">考虑一下下面的函数模板。</target>
        </trans-unit>
        <trans-unit id="a22158725623f7c0e74173ef7dccec9292a51ae4" translate="yes" xml:space="preserve">
          <source>Copying an object means copying its &quot;static&quot; members and calling the &lt;code&gt;new&lt;/code&gt; operator for its dynamic objects. Right?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复制对象意味着复制其&amp;ldquo;静态&amp;rdquo;成员，并&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为其动态对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4bd58a0d0236432df5def76d9e83073103fc10f" translate="yes" xml:space="preserve">
          <source>Dangerous and harmless moves</source>
          <target state="translated">危险和无害的动作</target>
        </trans-unit>
        <trans-unit id="8cdb90911daa2d1059f97197edc4cbc56200db7d" translate="yes" xml:space="preserve">
          <source>Depending on the class, maybe its a container with very much data, then that could represent much &lt;em&gt;time&lt;/em&gt; and &lt;em&gt;memory usage&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据类的不同，也许它是一个包含大量数据的容器，那么这可能代表大量的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时间&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内存使用量&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da91507e4d455dd873c3a8569cb70baddddfd087" translate="yes" xml:space="preserve">
          <source>Forwarding references (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf&quot;&gt;previously&lt;/a&gt; known as &lt;em&gt;Universal references&lt;/em&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转发参考（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以前&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;称为&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通用参考&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b55f1baad0eb4d648fab85d1a0b7b027bc44527" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/move_constructor&quot;&gt;cppreference.com&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来自&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/move_constructor&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cppreference.com&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9831a9d72fc41bc7b1a34c6df1cc9330199f0d3" translate="yes" xml:space="preserve">
          <source>Here is how you explicitly move from an lvalue:</source>
          <target state="translated">下面是你如何明确地从l值移动。</target>
        </trans-unit>
        <trans-unit id="ad658fc75be5325793f2c751d9cbdad9efe908d2" translate="yes" xml:space="preserve">
          <source>Here's a function that takes an object of type &lt;code&gt;T&lt;/code&gt; and returns an object of the same type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一个函数，它接受类型&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的对象并返回相同类型&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="472a84ed15750c08597c803026e48d9c509d8f33" translate="yes" xml:space="preserve">
          <source>How come the move constructor accepts the lvalue &lt;code&gt;result&lt;/code&gt; as an argument? The scope of &lt;code&gt;result&lt;/code&gt; is about to end, and it will be destroyed during stack unwinding. Nobody could possibly complain afterwards that &lt;code&gt;result&lt;/code&gt; had changed somehow; when control flow is back at the caller, &lt;code&gt;result&lt;/code&gt; does not exist anymore! For that reason, C++11 has a special rule that allows returning automatic objects from functions without having to write &lt;code&gt;std::move&lt;/code&gt;. In fact, you should &lt;em&gt;never&lt;/em&gt; use &lt;code&gt;std::move&lt;/code&gt; to move automatic objects out of functions, as this inhibits the &quot;named return value optimization&quot; (NRVO).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;move构造函数如何接受左值&lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为参数？&lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;范围&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即将结束，并且在堆栈展开期间将销毁它。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此后，没人会抱怨&lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有所改变。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当控制流返回到调用者时，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不再存在！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，C ++ 11有一条特殊的规则，该规则允许从函数中返回自动对象，而无需编写&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上，您&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;永远不要&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将自动对象移出函数，因为这会阻止&amp;ldquo;命名返回值优化&amp;rdquo;（NRVO）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b78fb8d2a72d70a2b646e5838f76a391fca0bd1" translate="yes" xml:space="preserve">
          <source>However, to &lt;strong&gt;move&lt;/strong&gt; an object (I repeat, in a practical point of view) implies only to copy the pointers of dynamic objects, and not to create new ones.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象（从实际的角度来看，我会重复）仅意味着复制动态对象的指针，而不创建新的指针。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be9d897b4ed75e9712b0896110f82792f56d7b57" translate="yes" xml:space="preserve">
          <source>Huh, that's it? &quot;Where's the rvalue reference?&quot; you might ask. &quot;We don't need it here!&quot; is my answer :)</source>
          <target state="translated">咦,就这样了?&quot;R值参考在哪里?&quot;你可能会问。&quot;我们这里不需要它!&quot;我的回答是:)</target>
        </trans-unit>
        <trans-unit id="dcad3bfb835bd226281cdb3832ed9fbd595b0efa" translate="yes" xml:space="preserve">
          <source>I find it easiest to understand move semantics with example code. Let's start with a very simple string class which only holds a pointer to a heap-allocated block of memory:</source>
          <target state="translated">我觉得用示例代码来理解移动语义是最容易的。让我们从一个非常简单的字符串类开始,它只持有一个指向堆分配的内存块的指针。</target>
        </trans-unit>
        <trans-unit id="55918cb4dcbdcb99697ef67c5bfaed72dce39cdf" translate="yes" xml:space="preserve">
          <source>I hope this example got the main point across. There is a lot more to rvalue references and move semantics which I intentionally left out to keep it simple. If you want more details please see &lt;a href=&quot;https://stackoverflow.com/a/11540204/179917&quot;&gt;my supplementary answer&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我希望这个例子能说明重点。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右值引用和移动语义还有很多，我有意省略以使其保持简单。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您需要更多详细信息，请参阅&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/11540204/179917&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我的补充答案&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e26477129fa8f03bbac0d3249cb6cbea6421174" translate="yes" xml:space="preserve">
          <source>I just finished listening to the Software Engineering radio &lt;a href=&quot;http://www.se-radio.net/2010/04/episode-159-c-0x-with-scott-meyers/&quot;&gt;podcast interview with Scott Meyers&lt;/a&gt; regarding &lt;a href=&quot;http://en.wikipedia.org/wiki/C++11&quot;&gt;C++0x&lt;/a&gt;. Most of the new features made sense to me, and I am actually excited about C++0x now, with the exception of one. I still don't get &lt;em&gt;move semantics&lt;/em&gt;... What is it exactly?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我刚刚结束了对&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.se-radio.net/2010/04/episode-159-c-0x-with-scott-meyers/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Scott Meyers&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的Software Engineering广播&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;播客&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关于&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/C++11&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 0x的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;采访&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大多数新功能对我来说都是有意义的，除了一个功能，我现在对C ++ 0x感到非常兴奋。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我仍然没有&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动语义&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;hellip;&amp;hellip;这到底是什么？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="adf922abf7820e8db1f54450dd73fbd3b62dfdc5" translate="yes" xml:space="preserve">
          <source>I'm writing this to make sure I understand it properly.</source>
          <target state="translated">我写这个是为了确保自己能正确理解。</target>
        </trans-unit>
        <trans-unit id="ea09e01c3b05274835a4c830a79abe380ae9f1ce" translate="yes" xml:space="preserve">
          <source>If the argument is an rvalue of type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; is deduced to be &lt;code&gt;X&lt;/code&gt;, hence &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; means &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt;. This is what anyone would expect.
But if the argument is an lvalue of type &lt;code&gt;X&lt;/code&gt;, due to a special rule, &lt;code&gt;T&lt;/code&gt; is deduced to be &lt;code&gt;X&amp;amp;&lt;/code&gt;, hence &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; would mean something like &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt;. But since C++ still has no notion of references to references, the type &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; is &lt;em&gt;collapsed&lt;/em&gt; into &lt;code&gt;X&amp;amp;&lt;/code&gt;. This may sound confusing and useless at first, but reference collapsing is essential for &lt;em&gt;perfect forwarding&lt;/em&gt; (which will not be discussed here).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果自变量是类型&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的右值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;则推论得出&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。这就是任何人所期望的。但是，如果该参数是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型的左值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则由于特殊规则，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;被推导为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;含义类似于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。但是由于C ++仍然没有引用的引用概念，因此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;被&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;折叠&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。乍一看这可能让人感到困惑和无用，但是参考折叠对于&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完美转发&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;至关重要&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; （此处将不讨论）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eaf342f5b650317d7bfa03afecf3ae79d590c46f" translate="yes" xml:space="preserve">
          <source>If we throw &lt;code&gt;const&lt;/code&gt; into the mix, we already have four different kinds of references. What kinds of expressions of type &lt;code&gt;X&lt;/code&gt; can they bind to?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;放入组合中，我们已经有四种不同类型的引用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它们可以绑定到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型的哪种表达式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ff4084df9c7bfd662c531429fd1f1577ffe7f6b" translate="yes" xml:space="preserve">
          <source>If you are really interested in a good, in-depth explanation of move semantics, I'd highly recommend reading the original paper on them, &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm&quot;&gt;&quot;A Proposal to Add Move Semantics Support to the C++ Language.&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您真的真正想对动作语义学有一个很好的深入的解释，我强烈建议您阅读有关它们的原始论文，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;向C ++语言添加动作语义支持的建议&amp;rdquo;。&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1199d462777552484944164f0bb197d84758ee45" translate="yes" xml:space="preserve">
          <source>If you want to constrain a function template to rvalues, you can combine &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/sfinae&quot;&gt;SFINAE&lt;/a&gt; with type traits:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果要将函数模板限制为右值，可以将&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/sfinae&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SFINAE&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与特征类型&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;结合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6da7cd499914cd7d580cba25f4db0148f6ddfea4" translate="yes" xml:space="preserve">
          <source>If you write a class without unmanaged resources, there is no need to declare any of the five special member functions yourself, and you will get correct copy semantics and move semantics for free. Otherwise, you will have to implement the special member functions yourself. Of course, if your class does not benefit from move semantics, there is no need to implement the special move operations.</source>
          <target state="translated">如果你写的类没有非管理资源,那么就不需要自己声明这五个特殊成员函数中的任何一个,可以免费获得正确的复制语义和移动语义。否则,你必须自己去实现特殊成员函数。当然,如果你的类没有从移动语义中受益,也就没有必要实现特殊的移动操作。</target>
        </trans-unit>
        <trans-unit id="937ed34b756d18c282b5b2e827b2ade63aff5ec5" translate="yes" xml:space="preserve">
          <source>If your object is complex and the destructor has other secondary effects, like calling to a library's function, calling to other global functions or whatever it is, perhaps is better to signal a movement with a flag:</source>
          <target state="translated">如果你的对象很复杂,而destructor有其他的次要作用,比如调用到库中的函数,调用到其他全局函数或者其他的全局函数什么的,也许用一个标志来发出动作信号会更好。</target>
        </trans-unit>
        <trans-unit id="7a9339c8c4d94e2f90667ec0345c001b70cea00e" translate="yes" xml:space="preserve">
          <source>Implementation of move</source>
          <target state="translated">搬迁的执行情况</target>
        </trans-unit>
        <trans-unit id="52c0adee2f966c6d6cae560ab2e2d18938668573" translate="yes" xml:space="preserve">
          <source>Implementing safe &quot;move-only&quot; types; that is, types for which copying does not make sense, but moving does.  Examples include locks, file handles, and smart pointers with unique ownership semantics. Note: This answer discusses &lt;code&gt;std::auto_ptr&lt;/code&gt;, a deprecated C++98 standard library template, which was replaced by &lt;code&gt;std::unique_ptr&lt;/code&gt; in C++11. Intermediate C++ programmers are probably at least somewhat familiar with &lt;code&gt;std::auto_ptr&lt;/code&gt;, and because of the &quot;move semantics&quot; it displays, it seems like a good starting point for discussing move semantics in C++11. YMMV.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实施安全的&amp;ldquo;仅移动&amp;rdquo;类型；也就是说，复制没有意义，而移动则有意义。示例包括具有唯一所有权语义的锁，文件句柄和智能指针。注意：此答案讨论&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这是一个已弃用的C ++ 98标准库模板，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C ++ 11中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;已由&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;替换&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。中级C ++程序员可能至少对&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有点熟悉&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并且由于它显示的&amp;ldquo;移动语义&amp;rdquo;，这似乎是讨论C ++ 11中移动语义的一个很好的起点。 YMMV。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a454cb8b77503090cbd9a357441f356bcc77421b" translate="yes" xml:space="preserve">
          <source>Implicit conversions</source>
          <target state="translated">隐含转换</target>
        </trans-unit>
        <trans-unit id="bb86577e32db06fdf51943d408f139502900a7ec" translate="yes" xml:space="preserve">
          <source>In C++03, objects are often copied, only to be destroyed or assigned-over before any code uses the value again.  For example, when you return by value from a function&amp;mdash;unless RVO kicks in&amp;mdash;the value you're returning is copied to the caller's stack frame, and then it goes out of scope and is destroyed.  This is just one of many examples: see pass-by-value when the source object is a temporary, algorithms like &lt;code&gt;sort&lt;/code&gt; that just rearrange items, reallocation in &lt;code&gt;vector&lt;/code&gt; when its &lt;code&gt;capacity()&lt;/code&gt; is exceeded, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C ++ 03中，通常会复制对象，仅在任何代码再次使用该值之前将其销毁或分配。例如，当您从函数按值返回时（除非RVO插入），您所返回的值将被复制到调用方的堆栈框架中，然后超出范围并被销毁。这只是许多示例之一：当源对象是临时对象时，请参见传递值；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仅对项目进行重新&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sort&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;；在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;超过&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其&lt;/font&gt; &lt;code&gt;capacity()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重新分配&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3a5b25589cda5ecaab0c938846dc8a956cfda45" translate="yes" xml:space="preserve">
          <source>In C++11, &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; has been replaced by &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; which takes advantage of rvalue references. I will develop and discuss a simplified version of &lt;code&gt;unique_ptr&lt;/code&gt;. First, we encapsulate a raw pointer and overload the operators &lt;code&gt;-&amp;gt;&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, so our class feels like a pointer:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C ++ 11中，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;已被&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;取代，该&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: unique_ptr &amp;lt;T&amp;gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;利用了右值引用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我将开发并讨论&lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的简化版本&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首先，我们封装了一个原始指针并重载了运算符&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此我们的类感觉就像一个指针：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c090c2258bd3627e3ec4d8b649121749fe3c3bd" translate="yes" xml:space="preserve">
          <source>In easy (practical) terms:</source>
          <target state="translated">用简单(实用)的话来说。</target>
        </trans-unit>
        <trans-unit id="b398d9ad5637d0de4ed8f0bf75e5761b7e55916e" translate="yes" xml:space="preserve">
          <source>In languages which do not allow the creation of local objects (that is, objects on the stack) these types of problems do not occur as all objects are allocated on the heap and are always accessed by reference.</source>
          <target state="translated">在不允许创建本地对象(即堆栈上的对象)的语言中,这些类型的问题不会发生,因为所有的对象都是在堆上分配的,并且总是通过引用访问。</target>
        </trans-unit>
        <trans-unit id="27637ef20b376dcf19cbb5d2e6d093390e3f522d" translate="yes" xml:space="preserve">
          <source>In practice, you can forget about &lt;code&gt;const X&amp;amp;&amp;amp;&lt;/code&gt;. Being restricted to read from rvalues is not very useful.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上，您可以忘记&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;限制从右值读取不是很有用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1103ccac7d3cbd997a56ab0386ee5fb290dec2d2" translate="yes" xml:space="preserve">
          <source>In that situation, an anonymous object is created, next copied to the function parameter, and afterwards deleted. So, here it is better to move the object, because you don't need the anonymous object and you can save time and memory.</source>
          <target state="translated">在这种情况下,创建一个匿名对象,接下来复制到函数参数中,然后再删除。所以,这里最好是移动对象,因为你不需要匿名对象,可以节省时间和内存。</target>
        </trans-unit>
        <trans-unit id="43e85843d22aecda603952ad3f28eb8d579f2003" translate="yes" xml:space="preserve">
          <source>In the above code, with old compilers the result of &lt;code&gt;f()&lt;/code&gt; is &lt;strong&gt;&lt;em&gt;copied&lt;/em&gt;&lt;/strong&gt; into &lt;code&gt;x&lt;/code&gt; using &lt;code&gt;X&lt;/code&gt;'s copy constructor. If your compiler supports move semantics and &lt;code&gt;X&lt;/code&gt; has a move-constructor, then that is called instead. Since its &lt;code&gt;rhs&lt;/code&gt; argument is an &lt;em&gt;rvalue&lt;/em&gt;, we know it's not needed any longer and we can steal its value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在上面的代码中，用旧的编译器的结果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f()&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;被&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复制&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的拷贝构造。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您的编译器支持move语义，并且&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有move-constructor，则将调用它。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于它的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;rhs&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参数是一个&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我们知道它不再需要了，我们可以窃取它的值。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da927e9aca357b1650ec6103ca59d8bb2cb33301" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;&quot;hello world&quot;&lt;/code&gt; is an lvalue of type &lt;code&gt;const char[12]&lt;/code&gt;. Since there is an implicit conversion from &lt;code&gt;const char[12]&lt;/code&gt; through &lt;code&gt;const char*&lt;/code&gt; to &lt;code&gt;std::string&lt;/code&gt;, a temporary of type &lt;code&gt;std::string&lt;/code&gt; is created, and &lt;code&gt;r&lt;/code&gt; is bound to that temporary. This is one of the cases where the distinction between rvalues (expressions) and temporaries (objects) is a bit blurry.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在上面的示例中，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;hello world&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是类型为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char[12]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的左值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于存在从&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char[12]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的隐式转换，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此创建&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;了一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型的临时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变量&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;绑定到该临时变量。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是右值（表达式）和临时对象（对象）之间的区别有点模糊的情况之一。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc3e683553dc45c7f890c6646a6841181eb6dec4" translate="yes" xml:space="preserve">
          <source>In this case, when an object of type &lt;code&gt;A&lt;/code&gt; should be &quot;copied&quot;, the compiler creates a lvalue reference or a rvalue reference according to if the passed object is named or not. When not, your move-constructor is called and you know the object is temporal and you can move its dynamic objects instead of copying them, saving space and memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，当&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应该&amp;ldquo;复制&amp;rdquo; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的对象时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，编译器将根据传递的对象是否命名来创建左值引用或右值引用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;否则，将调用您的移动构造函数，并且您知道该对象是临时对象，可以移动其动态对象而不是复制它们，从而节省了空间和内存。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="d04bb2623f5288427463db7edef0eb602a9ed94a" translate="yes" xml:space="preserve">
          <source>Is that perfect forwarding? Not, but we are very close. Perfect forwarding is only useful to work with templates, with the purpose to say: if I need to pass an object to another function, I need that if I receive a named object, the object is passed as a named object, and when not, I want to pass it like a unnamed object:</source>
          <target state="translated">那是完美的转发吗?不是,但我们已经很接近了。完美转发只适用于模板的工作,目的是说:如果我需要把一个对象传给另一个函数,我需要的是,如果我收到一个命名的对象,这个对象就作为一个命名的对象来传,当不需要的时候,我想把它像未命名的对象一样传给它。</target>
        </trans-unit>
        <trans-unit id="697f3bc7df8e26b6f96ff8496435e846fe70c4d6" translate="yes" xml:space="preserve">
          <source>It is important to remember that &quot;static&quot; objects are always copied. There's no ways to &quot;move&quot; a static object (object in stack and not on heap). So, the distinction &quot;move&quot;/ &quot;copy&quot; when an object has no dynamic members (directly or indirectly) is irrelevant.</source>
          <target state="translated">需要记住的是,&quot;静态 &quot;对象总是被复制。没有任何方法可以 &quot;移动 &quot;一个静态对象(对象在堆中而不是在堆上)。所以,当一个对象没有动态成员(直接或间接)时,&quot;移动&quot;&quot;复制 &quot;的区别是无关紧要的。</target>
        </trans-unit>
        <trans-unit id="e9d98f8e9d5357e09bdb4ad11e6dbd887aa316f7" translate="yes" xml:space="preserve">
          <source>It must first initialize the object, then copy all the relevant data from the old object to the new one.</source>
          <target state="translated">它必须首先对对象进行初始化,然后将所有相关数据从旧对象中复制到新对象中。</target>
        </trans-unit>
        <trans-unit id="3203ece5d832b88a426ed868437b3f103470fad2" translate="yes" xml:space="preserve">
          <source>It's like copy semantics, but instead of having to duplicate all of the data you get to steal the data from the object being &quot;moved&quot; from.</source>
          <target state="translated">这就像复制语义,但你不必复制所有的数据,而是从被 &quot;移动 &quot;的对象中窃取数据。</target>
        </trans-unit>
        <trans-unit id="90e6d34c95a16f345f4e07cab166d7088702a308" translate="yes" xml:space="preserve">
          <source>It's very accessible and easy to read and it makes an excellent case for the benefits that they offer.  There are other more recent and up to date papers about move semantics available on &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/&quot;&gt;the WG21 website&lt;/a&gt;, but this one is probably the most straightforward since it approaches things from a top-level view and doesn't get very much into the gritty language details.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它非常易于访问且易于阅读，并且很好地说明了它们提供的好处。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;WG21网站&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上还有其他有关移动语义&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的文章&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但这可能是最直接的，因为它是从顶级角度处理问题的，并且对粗俗的语言细节了解不多。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3214661671ef9aff8765af8c7d203ac41c5e3e99" translate="yes" xml:space="preserve">
          <source>Move assignment operators</source>
          <target state="translated">移动分配操作员</target>
        </trans-unit>
        <trans-unit id="76c87719ef4631d051ec31847319db90f2a38c3c" translate="yes" xml:space="preserve">
          <source>Move constructors</source>
          <target state="translated">移动构造函数</target>
        </trans-unit>
        <trans-unit id="21df78e8312204ee0ae1344d1d1244c5ab2567b2" translate="yes" xml:space="preserve">
          <source>Move semantics allows an object, under certain conditions, to take ownership of some other object's external resources. This is important in two ways:</source>
          <target state="translated">移动语义允许一个对象在一定的条件下,对其他一些对象的外部资源拥有所有权。这有两个方面的重要意义。</target>
        </trans-unit>
        <trans-unit id="ff2c5f0ff5c8b72e423fa0fe0eb25bf31e14356c" translate="yes" xml:space="preserve">
          <source>Move semantics are based on &lt;strong&gt;&lt;em&gt;rvalue references&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动语义基于&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右值引用&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b1fd88c02c0af8c30b9a31838ee4311178338b21" translate="yes" xml:space="preserve">
          <source>Move semantics is basically a user-defined type with constructor that takes an r-value reference (new type of reference using &amp;amp;&amp;amp; (yes two ampersands)) which is non-const, this is called a move constructor, same goes for assignment operator. So what does a move constructor do, well instead of copying memory from it's source argument it 'moves' memory from the source to the destination.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Move语义基本上是用户定义的类型，具有带非常量的r值引用（使用&amp;amp;&amp;amp;（是两个＆符）的新型引用）的构造函数，这称为Move构造函数，赋值运算符也是如此。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，move构造函数会做什么，而不是从其源参数复制内存，而是将内存从源&amp;ldquo;移动&amp;rdquo;到目标。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60affa9a44a9bad8c292beedae93936057dc4f21" translate="yes" xml:space="preserve">
          <source>Move semantics were created to avoid the unnecessary copying of large objects.  Bjarne Stroustrup in his book &quot;The C++ Programming Language&quot; uses two examples where unnecessary copying occurs by default: one, the swapping of two large objects, and two, the returning of a large object from a method.</source>
          <target state="translated">移动语义的产生就是为了避免大对象的不必要的复制。Bjarne Stroustrup在他的《C++编程语言》一书中使用了两个默认情况下会发生不必要的复制的例子:一是两个大对象的互换,二是方法中的大对象的返回。</target>
        </trans-unit>
        <trans-unit id="f19144fcd990c500b4ac693c567a9549f27dfd2c" translate="yes" xml:space="preserve">
          <source>Moving from lvalues</source>
          <target state="translated">从l值转移到</target>
        </trans-unit>
        <trans-unit id="d64e12206734f5c30656ba8ea9b5782042bd423a" translate="yes" xml:space="preserve">
          <source>Moving from lvalues such as &lt;code&gt;a&lt;/code&gt; is dangerous, because we could later try to call a member function via &lt;code&gt;a&lt;/code&gt;, invoking undefined behavior. On the other hand, moving from rvalues such as &lt;code&gt;make_triangle()&lt;/code&gt; is perfectly safe, because after the copy constructor has done its job, we cannot use the temporary again. There is no expression that denotes said temporary; if we simply write &lt;code&gt;make_triangle()&lt;/code&gt; again, we get a &lt;em&gt;different&lt;/em&gt; temporary. In fact, the moved-from temporary is already gone on the next line:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从左值（例如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移出&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是危险的，因为稍后我们可以尝试通过&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;成员函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，从而调用未定义的行为。另一方面，从诸如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; 之&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右值移出&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是完全安全的，因为在复制构造函数完成其工作之后，我们无法再次使用该临时值。没有表示临时的表达；如果我们&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;再次&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;简单地编写&lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;则会&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;得到一个&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不同的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;临时值。实际上，移出的临时目录已经在下一行中消失了：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a63742120d0d7b0e09c3bb18048c15fda0b0e774" translate="yes" xml:space="preserve">
          <source>Moving into members</source>
          <target state="translated">迁入会员</target>
        </trans-unit>
        <trans-unit id="55a56ac4401dd0eaa2dcf2e8a8396e846706642c" translate="yes" xml:space="preserve">
          <source>Moving out of functions</source>
          <target state="translated">职能外移</target>
        </trans-unit>
        <trans-unit id="2a77a62dac1e84715dce30b39e1eca21de49ebaa" translate="yes" xml:space="preserve">
          <source>Moving the data involves re-associating the data with the new object. And &lt;em&gt;no copy takes place&lt;/em&gt; at all.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动数据涉及将数据与新对象重新关联。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而且&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完全不会进行复制&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="694f6377ae54f3d5a6a8d632f41c5ee6694d13aa" translate="yes" xml:space="preserve">
          <source>My first answer was an extremely simplified introduction to move semantics, and many details were left out on purpose to keep it simple.
However, there is a lot more to move semantics, and I thought it was time for a second answer to fill the gaps.
The first answer is already quite old, and it did not feel right to simply replace it with a completely different text. I think it still serves well as a first introduction. But if you want to dig deeper, read on :)</source>
          <target state="translated">我的第一个答案是关于移动语义的介绍,我的第一个答案是一个极其简化的介绍,为了保持简单,故意遗漏了很多细节。但是,移动语义的内容还有很多,我想是时候再做第二个答案来填补空白了。第一个答案已经相当陈旧,简单地用一个完全不同的文字代替,感觉不妥。我觉得它作为第一篇的介绍,还是很有作用的。但如果你想深入了解,请继续阅读:)</target>
        </trans-unit>
        <trans-unit id="2273c40caec113ed4c70f21b9c59f72191a4ef03" translate="yes" xml:space="preserve">
          <source>Never return automatic objects by rvalue reference. Moving is exclusively performed by the move constructor, not by &lt;code&gt;std::move&lt;/code&gt;, and not by merely binding an rvalue to an rvalue reference.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;切勿通过右值引用返回自动对象。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动仅由move构造函数执行，而不是由&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，而不是仅将右值绑定到右值引用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c87b215e468265e84456567f5fd96732627b217" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;std::move&lt;/code&gt; to move automatic objects out of functions.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;切勿使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将自动对象移出功能。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5620a89fc44e99a7e64f46bd1660b0fe78ec31ff" translate="yes" xml:space="preserve">
          <source>Note how both examples follow the same syntactic pattern:</source>
          <target state="translated">注意这两个例子如何遵循相同的句法模式。</target>
        </trans-unit>
        <trans-unit id="9ffaa4649e35625dc8efbe19265d4da4843b9b9e" translate="yes" xml:space="preserve">
          <source>Note how the initialization of &lt;code&gt;b&lt;/code&gt; with &lt;code&gt;a&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; copy the triangle, but instead transfers the ownership of the triangle from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;. We also say &quot;&lt;code&gt;a&lt;/code&gt; is &lt;em&gt;moved into&lt;/em&gt;&lt;code&gt;b&lt;/code&gt;&quot; or &quot;the triangle is &lt;em&gt;moved&lt;/em&gt; from &lt;code&gt;a&lt;/code&gt;&lt;em&gt;to&lt;/em&gt;&lt;code&gt;b&lt;/code&gt;&quot;. This may sound confusing, because the triangle itself always stays at the same place in memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意如何初始化&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复制三角形，而是将来自于三角形的所有权&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们也可以说&amp;ldquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;被&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动到&lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;或&amp;ldquo;三角形&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这听起来可能会造成混淆，因为三角形本身始终位于内存中的同一位置。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4e30ddde6f9383ffb25516635c9c73988eaf920" translate="yes" xml:space="preserve">
          <source>Note how this implementation of the move assignment operator duplicates logic of both the destructor and the move constructor. Are you familiar with the copy-and-swap idiom? It can also be applied to move semantics as the move-and-swap idiom:</source>
          <target state="translated">请注意这种实现移动分配操作符是如何重复了destructor和移动构造函数的逻辑。你熟悉复制和互换的成语吗?它也可以像move-and-swap这个成语一样应用于移动语义。</target>
        </trans-unit>
        <trans-unit id="bc1ed59cd37ede9518aedf02a407061ed06f096c" translate="yes" xml:space="preserve">
          <source>Note that after the third line, &lt;code&gt;a&lt;/code&gt; no longer owns a triangle. That's okay, because by &lt;em&gt;explicitly&lt;/em&gt; writing &lt;code&gt;std::move(a)&lt;/code&gt;, we made our intentions clear: &quot;Dear constructor, do whatever you want with &lt;code&gt;a&lt;/code&gt; in order to initialize &lt;code&gt;c&lt;/code&gt;; I don't care about &lt;code&gt;a&lt;/code&gt; anymore. Feel free to have your way with &lt;code&gt;a&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;需要注意的是第三行之后，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不再拥有一个三角形。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没关系，因为通过&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;显式&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编写&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我们明确了我们的意图：&amp;ldquo;亲爱的构造函数，使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您想做的任何事情&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以初始化&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;；我不再关心&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;了。随意拥有用自己的方式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;ldquo;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b545f2bda15018d01523f9ff1692f25b2b72840e" translate="yes" xml:space="preserve">
          <source>Note that even though &lt;code&gt;std::move(a)&lt;/code&gt; is an rvalue, its evaluation does &lt;em&gt;not&lt;/em&gt; create a temporary object. This conundrum forced the committee to introduce a third value category. Something that can be bound to an rvalue reference, even though it is not an rvalue in the traditional sense, is called an &lt;em&gt;xvalue&lt;/em&gt; (eXpiring value). The traditional rvalues were renamed to &lt;em&gt;prvalues&lt;/em&gt; (Pure rvalues).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，即使&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个右值，其评估也&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不会&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;创建临时对象。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这个难题迫使委员会引入了第三个价值类别。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即使不是传统意义上的右值，也可以绑定到右值引用的东西称为&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;xvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（eXpiring值）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;传统的右值被重命名为&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;prvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（纯右值）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6197c8328d3615627bdcb1f1810f59a11b3231ca" translate="yes" xml:space="preserve">
          <source>Note that in both factory functions, the return type is a value, not an rvalue reference. Rvalue references are still references, and as always, you should never return a reference to an automatic object; the caller would end up with a dangling reference if you tricked the compiler into accepting your code, like this:</source>
          <target state="translated">注意,在这两个工厂函数中,返回类型是值,而不是r值引用。r值引用仍然是引用,一如既往,你永远不应该返回一个自动对象的引用;如果你欺骗编译器接受你的代码,调用者最终会得到一个悬空的引用,就像这样。</target>
        </trans-unit>
        <trans-unit id="895f41e9bd9293af7e0f16ad424d9f9981e26c97" translate="yes" xml:space="preserve">
          <source>Note that only xvalues are really new; the rest is just due to renaming and grouping.</source>
          <target state="translated">注意,只有x值是真正的新的,其他的只是由于重命名和分组。</target>
        </trans-unit>
        <trans-unit id="3432dccea5cbc5683d11346e5fcd0b1d26cea00a" translate="yes" xml:space="preserve">
          <source>Note that returning by rvalue reference is fine in this example, because &lt;code&gt;t&lt;/code&gt; does not denote an automatic object, but instead an object that was passed in by the caller.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，在此示例中，通过右值引用返回是可以的，因为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并不表示自动对象，而是表示调用者传递的对象。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89ea05e38d59c5aed95819ce421844b145c2084c" translate="yes" xml:space="preserve">
          <source>Note that the copy assignment operator and the move assignment operator can be fused into a single, unified assignment operator, taking its argument by value:</source>
          <target state="translated">注意,复制赋值算子和移动赋值算子可以融合成一个统一的赋值算子,取其参数的值。</target>
        </trans-unit>
        <trans-unit id="545ad832cdf421948e5760aa53c065f811afa6d0" translate="yes" xml:space="preserve">
          <source>Note that the letters &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; have a historic origin in the left-hand side and right-hand side of an assignment. This is no longer true in C++, because there are lvalues which cannot appear on the left-hand side of an assignment (like arrays or user-defined types without an assignment operator), and there are rvalues which can (all rvalues of class types with an assignment operator).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，字母&lt;/font&gt;&lt;/font&gt; &lt;code&gt;l&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在作业的左侧和右侧具有历史渊源。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C ++中，这不再成立，因为有些左值不能出现在赋值的左侧（例如没有赋值运算符的数组或用户定义的类型），并且有些左值可以（类类型的所有右值）和一个赋值运算符）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eaab0e119523ba0a6a6a259204c53d3659b8a758" translate="yes" xml:space="preserve">
          <source>Note that we pass the parameter &lt;code&gt;that&lt;/code&gt;&lt;em&gt;by value&lt;/em&gt;, so &lt;code&gt;that&lt;/code&gt; has to be initialized just like any other string object. Exactly how is &lt;code&gt;that&lt;/code&gt; going to be initialized? In the olden days of &lt;a href=&quot;http://en.wikipedia.org/wiki/C++#Standardization&quot;&gt;C++98&lt;/a&gt;, the answer would have been &quot;by the copy constructor&quot;. In C++0x, the compiler chooses between the copy constructor and the move constructor based on whether the argument to the assignment operator is an lvalue or an rvalue.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，我们通过参数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;按值&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须要像任何其他字符串对象初始化。究竟如何&lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要被初始化？在过去的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/C++#Standardization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98中&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，答案应该是&amp;ldquo;通过复制构造函数&amp;rdquo;。在C ++ 0x中，编译器根据赋值运算符的参数是左值还是右值，在复制构造函数和move构造函数之间进行选择。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="292b4ec9384f8616eaa92d7632778a096d02a026" translate="yes" xml:space="preserve">
          <source>Now comes the interesting part, the move constructor:</source>
          <target state="translated">现在,有趣的部分来了,移动构造器。</target>
        </trans-unit>
        <trans-unit id="9eeb4639b40950f86cdb1f7ee968470d998ea4aa" translate="yes" xml:space="preserve">
          <source>Now comes the key insight into move semantics. Note that only in the first line where we copy &lt;code&gt;x&lt;/code&gt; is this deep copy really necessary, because we might want to inspect &lt;code&gt;x&lt;/code&gt; later and would be very surprised if &lt;code&gt;x&lt;/code&gt; had changed somehow. Did you notice how I just said &lt;code&gt;x&lt;/code&gt; three times (four times if you include this sentence) and meant the &lt;em&gt;exact same object&lt;/em&gt; every time? We call expressions such as &lt;code&gt;x&lt;/code&gt; &quot;lvalues&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在是对移动语义的关键了解。请注意，仅在复制&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的第一行中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;才真正需要此深层复制，因为我们可能想&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;稍后&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;再检查&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并且如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有所更改&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;会感到非常惊讶&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。您是否注意到我只是说&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;了三遍&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（如果包括这句话，四遍），并且&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每次都&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完全相同的对象&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;吗？我们称&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; 之类的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表达式为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;左值&amp;rdquo;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="931b9f3d55a132fec2e5e039741e883dded73c53" translate="yes" xml:space="preserve">
          <source>Now that &lt;code&gt;source&lt;/code&gt; is a variable of type &lt;code&gt;unique_ptr&lt;/code&gt;, it will be initialized by the move constructor; that is, the argument will be moved into the parameter. The argument is still required to be an rvalue, because the move constructor itself has an rvalue reference parameter. When control flow reaches the closing brace of &lt;code&gt;operator=&lt;/code&gt;, &lt;code&gt;source&lt;/code&gt; goes out of scope, releasing the old resource automatically.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是类型为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的变量&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它将由move构造函数初始化；也就是说，参数将被移入参数。仍然需要将参数设为右值，因为move构造函数本身具有右值引用参数。当控制流到达&lt;/font&gt;&lt;/font&gt; &lt;code&gt;operator=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的结尾时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;超出范围，自动释放旧资源。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="298a83fc83958407292172112721d7fac6f19495" translate="yes" xml:space="preserve">
          <source>Now that you understand reference collapsing, here is how &lt;code&gt;std::move&lt;/code&gt; is implemented:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;既然您了解了参考折叠，下面就是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的实现方式：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c53f94e863e826764f4562c8d505588624c09e3e" translate="yes" xml:space="preserve">
          <source>Now, let's consider what a &lt;em&gt;copy constructor&lt;/em&gt; does.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，让我们考虑一下&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复制构造函数的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf61830673a8f5c2707029863a04957daf0b7f26" translate="yes" xml:space="preserve">
          <source>Obviously, there must be some profound difference between the expression &lt;code&gt;a&lt;/code&gt; which denotes an &lt;code&gt;auto_ptr&lt;/code&gt; variable, and the expression &lt;code&gt;make_triangle()&lt;/code&gt; which denotes the call of a function that returns an &lt;code&gt;auto_ptr&lt;/code&gt; by value, thus creating a fresh temporary &lt;code&gt;auto_ptr&lt;/code&gt; object every time it is called. &lt;code&gt;a&lt;/code&gt; is an example of an &lt;em&gt;lvalue&lt;/em&gt;, whereas &lt;code&gt;make_triangle()&lt;/code&gt; is an example of an &lt;em&gt;rvalue&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;显然，表示&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变量&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的表达式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;a&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示表示&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;按值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;返回&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;的函数的调用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之间必须存在一些深刻的区别&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每次调用它时都会&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;创建一个新的临时&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象。&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;左值&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的示例&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，而&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右值&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的示例&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f59b333eedae45f10bcefb5eb8e11c7862dbf00" translate="yes" xml:space="preserve">
          <source>Ok, but if I move an object, the source object becomes useless, no? Of course, but in certain situations that's very useful. The most evident one is when I call a function with an anonymous object (temporal, rvalue object, ..., you can call it with different names):</source>
          <target state="translated">好吧,但如果我移动一个对象,源对象就会变得无用,不是吗?当然,但在某些情况下,这是很有用的。最明显的例子是当我用一个匿名对象(temporal,r值对象,...........,你可以用不同的名字来调用它)调用一个函数。</target>
        </trans-unit>
        <trans-unit id="ff03efad6b4f508d07644ba3ac921a54bad39daa" translate="yes" xml:space="preserve">
          <source>Other typical question: what is the difference between &lt;code&gt;A&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;const A&amp;amp;&amp;amp;&lt;/code&gt;? Of course, in the first case, you can modify the object and in the second not, but, practical meaning? In the second case, you can't modify it, so you have no ways to invalidate the object (except with a mutable flag or something like that), and there is no practical difference to a copy constructor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其他典型问题：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const A&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;什么&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;区别&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？当然，在第一种情况下，您可以修改对象，而在第二种情况下，不是，但是，具有实际意义？在第二种情况下，您无法对其进行修改，因此您无法使对象无效（带有可变标志或类似标记的对象除外），并且复制构造函数没有实际区别。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70836291e05cb08b074706c1896b5e4d3e0d1003" translate="yes" xml:space="preserve">
          <source>Perhaps surprisingly, automatic objects (local variables that are not declared as &lt;code&gt;static&lt;/code&gt;) can also be &lt;em&gt;implicitly&lt;/em&gt; moved out of functions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也许令人惊讶的是，自动对象（未声明为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;static&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;局部变量&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）也可以&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;隐式&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移出函数：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="047060b19a709b1338cf8e5a234066acfcd19213" translate="yes" xml:space="preserve">
          <source>Returning an object from a method by default involves making a copy of the local object and its associated data in a location which is accessible to the caller (because the local object is not accessible to the caller and disappears when the method finishes).  When a built-in type is being returned, this operation is very fast, but if a large object is being returned, this could take a long time.  The move constructor allows the programmer to override this default behavior and instead &quot;reuse&quot; the heap data associated with the local object by pointing the object being returned to the caller to heap data associated with the local object.  Thus no copying is required.</source>
          <target state="translated">默认情况下,从方法中返回一个对象涉及到在调用者可以访问的位置上复制一个本地对象及其相关数据(因为本地对象是调用者无法访问的,并且在方法结束时消失)。当返回一个内置类型时,这个操作是非常快的,但如果是返回一个大对象,这可能需要很长时间。移动构造函数允许程序员推翻这种默认行为,而是通过将被返回的对象指向与本地对象相关联的堆数据,从而 &quot;重用 &quot;与本地对象相关联的堆数据。因此不需要复制。</target>
        </trans-unit>
        <trans-unit id="e5592cd0fb417300cbaac9ee976b933b1a98a51d" translate="yes" xml:space="preserve">
          <source>Rvalue references</source>
          <target state="translated">R值参考</target>
        </trans-unit>
        <trans-unit id="5dc3c807bd559ab077dd1e1206e50e03c15ccaf6" translate="yes" xml:space="preserve">
          <source>Rvalue references went through several versions. Since version 2.1, an rvalue reference &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; also binds to all value categories of a different type &lt;code&gt;Y&lt;/code&gt;, provided there is an implicit conversion from &lt;code&gt;Y&lt;/code&gt; to &lt;code&gt;X&lt;/code&gt;. In that case, a temporary of type &lt;code&gt;X&lt;/code&gt; is created, and the rvalue reference is bound to that temporary:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右值引用经历了多个版本。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从版本2.1开始，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只要存在从&lt;/font&gt; &lt;code&gt;Y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;的隐式转换&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，右值引用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还会绑定到其他类型&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Y&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有值类别&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，将&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;创建&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;的临时目录&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并且右值引用绑定到该临时目录：&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="681732688880af87e8358c431edcf6c36bc387ab" translate="yes" xml:space="preserve">
          <source>Rvalue references went through several versions. Since version 3.0, C++11 declares two additional special member functions on demand: the move constructor and the move assignment operator. Note that neither VC10 nor VC11 conform to version 3.0 yet, so you will have to implement them yourself.</source>
          <target state="translated">R值引用经历了几个版本。从3.0版本开始,C++11按需声明了两个额外的特殊成员函数:移动构造函数和移动赋值操作符。注意,VC10和VC11都还不符合3.0版本,所以你必须自己去实现。</target>
        </trans-unit>
        <trans-unit id="ae0b0234229935b2ce05de8879beb6e5cb6cf659" translate="yes" xml:space="preserve">
          <source>Since an rvalue is going to die at the end of an expression, you can &lt;em&gt;steal its data&lt;/em&gt;. Instead of &lt;em&gt;copying&lt;/em&gt; it into another object, you &lt;em&gt;move&lt;/em&gt; its data into it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于右值将在表达式的末尾消失，因此您可以&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;窃取其数据&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无需&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复制&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到另一个对象中，而是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其数据移入其中。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48e1e601d0414c91d7bb8d787fc5e6f1a4660de9" translate="yes" xml:space="preserve">
          <source>Since we chose to manage the memory ourselves, we need to follow the &lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29&quot;&gt;rule of three&lt;/a&gt;. I am going to defer writing the assignment operator and only implement the destructor and the copy constructor for now:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于我们选择自己管理内存，因此我们需要遵循&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;三个规则&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我将推迟编写赋值运算符，现在仅实现析构函数和复制构造函数：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0099f828c7759a2abbdb4ba58fd52bd3abe97f90" translate="yes" xml:space="preserve">
          <source>So far, we have seen movement into local variables, and into function parameters. But moving is also possible in the opposite direction. If a function returns by value, some object at call site (probably a local variable or a temporary, but could be any kind of object) is initialized with the expression after the &lt;code&gt;return&lt;/code&gt; statement as an argument to the move constructor:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到目前为止，我们已经看到了向局部变量和函数参数的移动。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是也可以朝相反的方向移动。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果一个函数按值返回，则调用站点上的某些对象（可能是局部变量或临时对象，但可以是任何类型的对象）都用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;return&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语句&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;后的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表达式作为move构造函数的参数进行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;初始化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="034b89ff4264e6ea18c21f67aa398614ed9889ef" translate="yes" xml:space="preserve">
          <source>So if you say &lt;code&gt;a = b&lt;/code&gt;, the &lt;em&gt;copy constructor&lt;/em&gt; will initialize &lt;code&gt;that&lt;/code&gt; (because the expression &lt;code&gt;b&lt;/code&gt; is an lvalue), and the assignment operator swaps the contents with a freshly created, deep copy. That is the very definition of the copy and swap idiom -- make a copy, swap the contents with the copy, and then get rid of the copy by leaving the scope. Nothing new here.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所以，如果你说&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a = b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;拷贝构造函数&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将初始化&lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（因为表达&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个左值），并赋值运算符互换与刚创建，深拷贝的内容。这就是复制和交换惯用法的确切定义-制作一个副本，将内容与该副本交换，然后通过保留范围来摆脱该副本。这里没有新内容。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54d00ee61a37d56aa5dd7aa4758e0bd04233cb62" translate="yes" xml:space="preserve">
          <source>So the value is &lt;strong&gt;&lt;em&gt;moved&lt;/em&gt;&lt;/strong&gt; from the unnamed temporary returned from &lt;code&gt;f()&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; (while the data of &lt;code&gt;x&lt;/code&gt;, initialized to an empty &lt;code&gt;X&lt;/code&gt;, is moved into the temporary, which will get destroyed after the assignment).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，该值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将从&lt;/font&gt; &lt;code&gt;f()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;返回的未命名临时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变量&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;（同时将&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;初始化为空&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;数据&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移入&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该临时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变量&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，在赋值后将被销毁）。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f7961a9153c9247dac8ea0516cb0ae78c84857c" translate="yes" xml:space="preserve">
          <source>So, if &lt;code&gt;T&lt;/code&gt; is a lvalue reference to &lt;code&gt;A&lt;/code&gt; (&lt;strong&gt;T&lt;/strong&gt; = A&amp;amp;), &lt;code&gt;a&lt;/code&gt; also (&lt;strong&gt;A&amp;amp;&lt;/strong&gt; &amp;amp;&amp;amp; =&amp;gt; A&amp;amp;). If &lt;code&gt;T&lt;/code&gt; is a rvalue reference to &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; also (A&amp;amp;&amp;amp; &amp;amp;&amp;amp; =&amp;gt; A&amp;amp;&amp;amp;). In both cases, &lt;code&gt;a&lt;/code&gt; is a named object in the actual scope, but &lt;code&gt;T&lt;/code&gt; contains the information of its &quot;reference type&quot; from the caller scope's point of view. This information (&lt;code&gt;T&lt;/code&gt;) is passed as template parameter to &lt;code&gt;forward&lt;/code&gt; and 'a' is moved or not according to the type of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所以，如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个左值参照&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ť&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; = A＆），&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也（&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A＆&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;amp;&amp;amp; =&amp;gt; A＆）。如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是右值参照&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也（A &amp;amp;&amp;amp; &amp;amp;&amp;amp; =&amp;gt;甲&amp;amp;&amp;amp;）。在这两种情况下，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;都是实际作用域中的命名对象，但是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从调用者作用域的角度来看&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包含其&amp;ldquo;引用类型&amp;rdquo;的信息。此信息（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）作为模板参数传递到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;forward&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，而根据&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的类型，是否移动&amp;ldquo; a&amp;rdquo; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="093fc5e367c5e2bf6fc8ca5b593b0df072b3d2ce" translate="yes" xml:space="preserve">
          <source>So, your code is shorter (you don't need to do a &lt;code&gt;nullptr&lt;/code&gt; assignment for each dynamic member) and more general.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，您的代码更短（您无需&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为每个动态成员&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;执行&lt;/font&gt;&lt;/font&gt; &lt;code&gt;nullptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分配），并且更通用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68b9a6a0be10d20ad14f2d271cf26db0796998be" translate="yes" xml:space="preserve">
          <source>Sometimes, we want to move from lvalues. That is, sometimes we want the compiler to treat an lvalue as if it were an rvalue, so it can invoke the move constructor, even though it could be potentially unsafe.
For this purpose, C++11 offers a standard library function template called &lt;code&gt;std::move&lt;/code&gt; inside the header &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;.
This name is a bit unfortunate, because &lt;code&gt;std::move&lt;/code&gt; simply casts an lvalue to an rvalue; it does &lt;em&gt;not&lt;/em&gt; move anything by itself. It merely &lt;em&gt;enables&lt;/em&gt; moving. Maybe it should have been named &lt;code&gt;std::cast_to_rvalue&lt;/code&gt; or &lt;code&gt;std::enable_move&lt;/code&gt;, but we are stuck with the name by now.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有时，我们想从左值转移。也就是说，有时我们希望编译器将左值当作右值对待，因此即使它可能不安全，它也可以调用move构造函数。为此，C ++ 11 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在标头&lt;/font&gt; &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提供了一个称为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的标准库函数模板&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。这个名字有点不幸，因为&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;只是将一个左值转换为一个右值。它本身&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不会&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动任何东西。它仅&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;允许&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动。也许它应该被命名为&lt;/font&gt; &lt;code&gt;std::cast_to_rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt; &lt;code&gt;std::enable_move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到目前为止&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我们仍然使用这个名称。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5301bb25f1b806784df96fdac43504d478adbc18" translate="yes" xml:space="preserve">
          <source>Sooner or later, you are going to write code like this:</source>
          <target state="translated">迟早都要写出这样的代码。</target>
        </trans-unit>
        <trans-unit id="827e6674de363a70897b99e51fffefdb810a4c6e" translate="yes" xml:space="preserve">
          <source>Special member functions</source>
          <target state="translated">特别成员的职能</target>
        </trans-unit>
        <trans-unit id="af929f44893f1dbb0ff36798043c5601a040d9c7" translate="yes" xml:space="preserve">
          <source>Stephan T. Lavavej took the time provide valuable feedback. Thank you very much, Stephan!</source>
          <target state="translated">Stephan T.Lavavej花了很多时间提供了宝贵的反馈。非常感谢你,Stephan!</target>
        </trans-unit>
        <trans-unit id="97edf0f249ffe0384959565a34426727579f471c" translate="yes" xml:space="preserve">
          <source>Suppose you have a function that returns a substantial object:</source>
          <target state="translated">假设你有一个返回一个实质性对象的函数。</target>
        </trans-unit>
        <trans-unit id="76cdc8fdc1131d4b14a54894d4cef5413aad87ac" translate="yes" xml:space="preserve">
          <source>Swapping two large objects usually involves copying the first object to a temporary object, copying the second object to the first object, and copying the temporary object to the second object.  For a built-in type, this is very fast, but for large objects these three copies could take a large amount of time.  A &quot;move assignment&quot; allows the programmer to override the default copy behavior and instead swap references to the objects, which means that there is no copying at all and the swap operation is much faster.  The move assignment can be invoked by calling the std::move() method.</source>
          <target state="translated">交换两个大对象通常需要将第一个对象复制到临时对象,将第二个对象复制到第一个对象,再将临时对象复制到第二个对象。对于一个内置类型来说,这是非常快的,但对于大对象来说,这三次复制可能需要大量的时间。而 &quot;移动赋值 &quot;允许程序员推翻默认的复制行为,转而对对象的引用进行互换,这意味着完全不需要复制,互换操作的速度要快得多。移动赋值可以通过调用 std:::move()方法来调用。</target>
        </trans-unit>
        <trans-unit id="f28b36c8ab1c06a2320bf78626f74f8e645b94e6" translate="yes" xml:space="preserve">
          <source>T&amp;amp;&amp;amp; is not an rvalue reference, but a forwarding reference. It also binds to lvalues, in which case &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; are both lvalue references.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T &amp;amp;&amp;amp;不是右值引用，而是转发引用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它还绑定到&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;左值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，在这种情况下，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;都是左值引用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25e5448ed70f909735a7a46f8300ed37a57706a9" translate="yes" xml:space="preserve">
          <source>That's the signature of a prototypical function that uses perfect forwarding, implemented in C++11 by means of &lt;code&gt;std::forward&lt;/code&gt;. This function exploits some rules of template instantiation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是使用完美转发的原型函数的签名，该函数在C ++ 11中通过&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::forward&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此函数利用模板实例化的一些规则：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2aeb46f404b05b67c1d4b4e933f1b159f28adf0b" translate="yes" xml:space="preserve">
          <source>The C++98 standard library offers a smart pointer with unique ownership semantics called &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. In case you are unfamiliar with &lt;code&gt;auto_ptr&lt;/code&gt;, its purpose is to guarantee that a dynamically allocated object is always released, even in the face of exceptions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98标准库提供了一种智能指针，该指针具有唯一的所有权语义，称为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您不熟悉&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，其目的是即使在遇到异常的情况下，也始终保证释放动态分配的对象：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c5273ddaf8d4d9bd2c708aae41ca02d986a560f" translate="yes" xml:space="preserve">
          <source>The above function uses &lt;em&gt;call by value&lt;/em&gt; which means that when this function is called an object must be &lt;em&gt;constructed&lt;/em&gt; to be used by the function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上面的函数使用&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;按值调用，&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这意味着当调用此函数时，必须&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;构造&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以供该函数使用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="21453336f2384057cccb4c69429d948c05e5271d" translate="yes" xml:space="preserve">
          <source>The arguments in lines 2 and 3 are not lvalues, but rvalues, because the underlying string objects have no names, so the client has no way to inspect them again at a later point in time.
rvalues denote temporary objects which are destroyed at the next semicolon (to be more precise: at the end of the full-expression that lexically contains the rvalue). This is important because during the initialization of &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, we could do whatever we wanted with the source string, and &lt;em&gt;the client couldn't tell a difference&lt;/em&gt;!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第2行和第3行中的参数不是左值，而是右值，因为基础字符串对象没有名称，因此客户端无法在以后的时间再次检查它们。 rvalues表示在下一个分号处销毁的临时对象（更精确地说：在词法上包含rvalue的完整表达式的末尾）。这很重要，因为在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的初始化过程中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我们可以对源字符串做任何想做的事情，而&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;客户端却无法分辨&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;！&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e024a6d6f6f045a7e5fd3e2fd78c563a51190fec" translate="yes" xml:space="preserve">
          <source>The call of a function that returns an rvalue reference, such as &lt;code&gt;std::move&lt;/code&gt;, is an xvalue.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;返回右值引用（例如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的函数的调用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是xvalue。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b626cb0884dddd9379630d99507ae7fe2ff2c15c" translate="yes" xml:space="preserve">
          <source>The constructor takes ownership of the object, and the destructor deletes it:</source>
          <target state="translated">构造函数获取该对象的所有权,而解析器则删除该对象。</target>
        </trans-unit>
        <trans-unit id="e74352db34fd6a5e34f47321ae6e9f914b303f6f" translate="yes" xml:space="preserve">
          <source>The copy constructor defines what it means to copy string objects. The parameter &lt;code&gt;const string&amp;amp; that&lt;/code&gt; binds to all expressions of type string which allows you to make copies in the following examples:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复制构造函数定义复制字符串对象的含义。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;绑定到字符串类型的所有表达式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的参数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const string&amp;amp; that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以在以下示例中进行复制：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="290f16723b4d755e1f94e621b760399ee06c5273" translate="yes" xml:space="preserve">
          <source>The copy constructor of &lt;code&gt;auto_ptr&lt;/code&gt; probably looks something like this (somewhat simplified):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的副本构造函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能看起来像这样（有些简化）：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f162420dc7014f9f7aea09dba5df626cfbba3e4" translate="yes" xml:space="preserve">
          <source>The dangerous thing about &lt;code&gt;auto_ptr&lt;/code&gt; is that what syntactically looks like a copy is actually a move. Trying to call a member function on a moved-from &lt;code&gt;auto_ptr&lt;/code&gt; will invoke undefined behavior, so you have to be very careful not to use an &lt;code&gt;auto_ptr&lt;/code&gt; after it has been moved from:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的危险之&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;处在于，语法上看起来像是副本实际上是移动。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尝试在从&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移出的成员上调用成员函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将调用未定义的行为，因此您必须非常小心，不要在将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从以下位置移出后再&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5518e5be02f103564f3cd6dfbbdb856e00b6efc" translate="yes" xml:space="preserve">
          <source>The last missing piece is the move assignment operator. Its job is to release the old resource and acquire the new resource from its argument:</source>
          <target state="translated">最后一个缺失的部分是移动分配操作符。它的工作是释放旧资源,并从其参数中获取新资源。</target>
        </trans-unit>
        <trans-unit id="e783ee3bf25d0cbf3bd7e4504e938db2d81a4f14" translate="yes" xml:space="preserve">
          <source>The move assignment operator transfers ownership of a managed resource into the current object, releasing the old resource.
  The move-and-swap idiom simplifies the implementation.</source>
          <target state="translated">移动分配操作符将被管理资源的所有权转移到当前对象中,释放旧资源。移动和交换这个成语简化了实现。</target>
        </trans-unit>
        <trans-unit id="a92be27a40d64e9f0284a53eff6b28c4024e3a73" translate="yes" xml:space="preserve">
          <source>The move constructor transfers ownership of a managed resource into the current object.</source>
          <target state="translated">移动构造函数将被管理资源的所有权转移到当前对象中。</target>
        </trans-unit>
        <trans-unit id="369d03b7f7d3482f6aec3906bad55a6bc99dd045" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;a&lt;/code&gt; would be copied to the actual parameter of &lt;code&gt;other_function&lt;/code&gt;. If you want the object &lt;code&gt;a&lt;/code&gt; continues being treated as a temporary object, you should use the &lt;code&gt;std::move&lt;/code&gt; function:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将被复制到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的实际参数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果你希望对象&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继续被视为一个临时的对象，你应该使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;功能：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3f96d5d08d17f40270352611586edfa618dbb5ff" translate="yes" xml:space="preserve">
          <source>The second line fails to compile, because &lt;code&gt;a&lt;/code&gt; is an lvalue, but the parameter &lt;code&gt;unique_ptr&amp;amp;&amp;amp; source&lt;/code&gt; can only be bound to rvalues. This is exactly what we wanted; dangerous moves should never be implicit. The third line compiles just fine, because &lt;code&gt;make_triangle()&lt;/code&gt; is an rvalue. The move constructor will transfer ownership from the temporary to &lt;code&gt;c&lt;/code&gt;. Again, this is exactly what we wanted.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第二行无法编译，因为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是左值，但是参数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&amp;amp;&amp;amp; source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只能绑定到右值。这正是我们想要的。危险的举动绝不能隐含。第三行编译就好了，因为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个右值。 move构造函数会将所有权从临时所有权转让给&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。同样，这正是我们想要的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a3730034e13e4628ec2934efc747b68c3fc3e13d" translate="yes" xml:space="preserve">
          <source>The solution is to manually enable the move:</source>
          <target state="translated">解决的方法是手动启用移动。</target>
        </trans-unit>
        <trans-unit id="08aa002af0a7d7ef8a828f926264d37a71e32e78" translate="yes" xml:space="preserve">
          <source>The unusual thing about &lt;code&gt;auto_ptr&lt;/code&gt; is its &quot;copying&quot; behavior:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的不寻常之&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;处在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;于其&amp;ldquo;复制&amp;rdquo;行为：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3032c490102dbbdc1a53ae3a1e6b530d8d4c02ba" translate="yes" xml:space="preserve">
          <source>These two new special member functions are only implicitly declared if none of the special member functions are declared manually. Also, if you declare your own move constructor or move assignment operator, neither the copy constructor nor the copy assignment operator will be declared implicitly.</source>
          <target state="translated">这两个新的特殊成员函数只有在没有手动声明特殊成员函数的情况下才会隐式声明。另外,如果你声明了自己的移动构造函数或移动分配操作符,那么复制构造函数和复制分配操作符都不会被隐式声明。</target>
        </trans-unit>
        <trans-unit id="83a00c1613c4181d37c495b96f0796b835f18525" translate="yes" xml:space="preserve">
          <source>This is accomplished with an &lt;code&gt;rvalue&lt;/code&gt; reference.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是通过&lt;/font&gt;&lt;/font&gt; &lt;code&gt;rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;引用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完成的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="31ccc28aaac9180efd97b0f2232c9474c45ded9f" translate="yes" xml:space="preserve">
          <source>This is especially important if (like perhaps the &lt;code&gt;Matrix&lt;/code&gt; example above), the object being copied allocates extra memory on the heap to store its internal representation. A copy constructor would have to either make a full copy of the internal representation, or use reference counting and copy-on-write semantics interally. A move constructor would leave the heap memory alone and just copy the pointer inside the &lt;code&gt;Matrix&lt;/code&gt; object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如上面&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Matrix&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;示例）复制的对象在堆上分配了额外的内存来存储其内部表示，则&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这一点尤其重要&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复制构造函数必须要么完整复制内部表示形式，要么在内部使用引用计数和写时复制语义。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动构造函数将只保留堆内存，而仅将指针复制到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Matrix&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象中。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="734c00e55f5d7bfea55f0c53e0033b51b7115120" translate="yes" xml:space="preserve">
          <source>This leads to the concept of an &quot;rvalue&quot; reference. They exist in C++11 only to detect if the received object is anonymous or not. I think you do already know that an &quot;lvalue&quot; is an assignable entity (the left part of the &lt;code&gt;=&lt;/code&gt; operator), so you need a named reference to an object to be capable to act as an lvalue. A rvalue is exactly the opposite, an object with no named references. Because of that, anonymous object and rvalue are synonyms. So:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这导致了&amp;ldquo;右值&amp;rdquo;引用的概念。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它们存在于C ++ 11中，仅用于检测接收到的对象是否为匿名对象。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我想您已经知道&amp;ldquo;左值&amp;rdquo;是可分配的实体（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的左侧&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），因此您需要对对象的命名引用才能用作左值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个右值正好相反，一个没有命名引用的对象。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，匿名对象和右值是同义词。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所以：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2a9839394d8fd7fa5c503f67611a827e38511306" translate="yes" xml:space="preserve">
          <source>This move constructor does exactly what the &lt;code&gt;auto_ptr&lt;/code&gt; copy constructor did, but it can only be supplied with rvalues:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这个move构造函数的功能与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复制构造&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数的功能完全相同&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是只能提供rvalues：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e308529a0760da4187efbb6031e853815d012f5" translate="yes" xml:space="preserve">
          <source>This way, the number of special member functions to implement drops from five to four. There is a tradeoff between exception-safety and efficiency here, but I am not an expert on this issue.</source>
          <target state="translated">这样一来,需要实现的特殊成员函数的数量就从5个降到了4个。这里有一个异常安全和效率之间的权衡,但我不是这个问题的专家。</target>
        </trans-unit>
        <trans-unit id="c835c096c791a7fe0c7b46b42e46e2033cbeb4bc" translate="yes" xml:space="preserve">
          <source>To illustrate the need for &lt;em&gt;move semantics&lt;/em&gt;, let's consider this example without move semantics:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了说明对&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动语义&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的需求&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，让我们考虑不带移动语义的示例：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a7e9e734de9455aa1437dc73d5ab335d653aaac" translate="yes" xml:space="preserve">
          <source>To make strong exception guarantee possible, user-defined move constructors should not throw exceptions. In fact, standard containers typically rely on std::move_if_noexcept to choose between move and copy when container elements need to be relocated.
  If both copy and move constructors are provided, overload resolution selects the move constructor if the argument is an rvalue (either a prvalue such as a nameless temporary or an xvalue such as the result of std::move), and selects the copy constructor if the argument is an lvalue (named object or a function/operator returning lvalue reference). If only the copy constructor is provided, all argument categories select it (as long as it takes a reference to const, since rvalues can bind to const references), which makes copying the fallback for moving, when moving is unavailable.
  In many situations, move constructors are optimized out even if they would produce observable side-effects, see copy elision.
  A constructor is called a 'move constructor' when it takes an rvalue reference as a parameter. It is not obligated to move anything, the class is not required to have a resource to be moved and a 'move constructor' may not be able to move a resource as in the allowable (but maybe not sensible) case where the parameter is a const rvalue reference (const T&amp;amp;&amp;amp;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了使强大的异常保证成为可能，用户定义的move构造函数不应抛出异常。实际上，当容器元素需要重定位时，标准容器通常依赖std :: move_if_noexcept在移动和复制之间进行选择。如果同时提供了copy和move构造函数，则当参数为右值（prvalue（例如，无名的临时值或xvalue，例如std :: move的结果））时，重载分辨率将选择move构造器，如果参数是左值（返回左值引用的命名对象或函数/运算符）。如果仅提供copy构造函数，则所有参数类别都将选择它（只要它引用const，因为rvalues可以绑定到const引用），这使得在移动不可用时复制回退用于移动。在许多情况下，即使移动构造函数会产生明显的副作用，也会对其进行优化，请参见复制省略。当将右值引用作为参数时，构造函数称为&amp;ldquo;移动构造函数&amp;rdquo;。它没有义务移动任何东西，该类不需要具有要移动的资源，并且&amp;ldquo;移动构造函数&amp;rdquo;可能无法移动该资源，就像在参数为a的允许（但可能不明智）的情况下一样常量右值引用（常量T &amp;amp;&amp;amp;）。在参数是常量值引用（const T &amp;amp;&amp;amp;）的允许（但可能不明智）的情况下，可能无法移动资源。在参数是常量值引用（const T &amp;amp;&amp;amp;）的允许（但可能不明智）的情况下，可能无法移动资源。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b31d2be34d67b295038676b6a78d3aa74806629a" translate="yes" xml:space="preserve">
          <source>To move an object means to transfer ownership of some resource it manages to another object.</source>
          <target state="translated">移动一个对象意味着将其管理的某些资源的所有权转移到另一个对象上。</target>
        </trans-unit>
        <trans-unit id="bbf1b3314c139a90af79519c70cc487a725f22d9" translate="yes" xml:space="preserve">
          <source>To summarize, the copy constructor makes a deep copy, because the source must remain untouched.
The move constructor, on the other hand, can just copy the pointer and then set the pointer in the source to null. It is okay to &quot;nullify&quot; the source object in this manner, because the client has no way of inspecting the object again.</source>
          <target state="translated">简而言之,copy构造函数进行了深度复制,因为源中的指针必须保持不变。而移动构造函数则可以直接复制指针,然后将源中的指针设置为空。用这种方式将源对象 &quot;归零 &quot;是没有问题的,因为客户端没有办法再次检查这个对象。</target>
        </trans-unit>
        <trans-unit id="047b60f44c81098eb74095d0ced4e749b86ad68f" translate="yes" xml:space="preserve">
          <source>Turning expensive copies into cheap moves. See my first answer for an example. Note that if an object does not manage at least one external resource (either directly, or indirectly through its member objects), move semantics will not offer any advantages over copy semantics. In that case, copying an object and moving an object means the exact same thing:</source>
          <target state="translated">把昂贵的副本变成廉价的大招。见我的第一个答案的例子。请注意,如果一个对象没有管理至少一个外部资源(直接或通过其成员对象间接管理),那么移动语义不会比复制语义有任何优势。在这种情况下,复制一个对象和移动一个对象的意思完全一样。</target>
        </trans-unit>
        <trans-unit id="de0430a56abae1a9c8cca4fd7a8b8906769e0636" translate="yes" xml:space="preserve">
          <source>Value categories</source>
          <target state="translated">价值类别</target>
        </trans-unit>
        <trans-unit id="2aa8f4165ecd80aeeeeb890eaf78af1a8a3b401b" translate="yes" xml:space="preserve">
          <source>We now understand that moving from lvalues is potentially dangerous, but moving from rvalues is harmless. If C++ had language support to distinguish lvalue arguments from rvalue arguments, we could either completely forbid moving from lvalues, or at least make moving from lvalues &lt;em&gt;explicit&lt;/em&gt; at call site, so that we no longer move by accident.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们现在知道，从左值移出有潜在的危险，但从右值移出是无害的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果C ++具有支持将左值参数与右值参数区分开的语言，则我们可以完全禁止从左值移动，或者至少使&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在调用位置&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从左值移动成为&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;显式&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这样我们就不会再偶然移动了。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c91f5982e73d44e7f4a6ccace5726e523643802" translate="yes" xml:space="preserve">
          <source>What do these rules mean in practice?</source>
          <target state="translated">这些规定在实践中意味着什么?</target>
        </trans-unit>
        <trans-unit id="99565c8cb484efe8d28c4076f67a25e83378c561" translate="yes" xml:space="preserve">
          <source>What have we done here? Instead of deeply copying the heap data, we have just copied the pointer and then set the original pointer to null (to prevent 'delete[]' from source object's destructor from releasing our 'just stolen data'). In effect, we have &quot;stolen&quot; the data that originally belonged to the source string. Again, the key insight is that under no circumstance could the client detect that the source had been modified. Since we don't really do a copy here, we call this constructor a &quot;move constructor&quot;. Its job is to move resources from one object to another instead of copying them.</source>
          <target state="translated">我们在这里做了什么?我们并没有深度复制堆数据,而是直接复制了指针,然后将原始指针设置为null(防止源对象的'delete[]'从源对象的destructor中释放出我们的'刚偷来的数据')。实际上,我们已经 &quot;窃取 &quot;了原本属于源字符串的数据。同样,关键的洞察力是,在任何情况下,客户端都无法检测到源对象被修改。因为我们在这里并没有真正的复制,所以我们把这个构造函数称为 &quot;移动构造函数&quot;。它的工作是将资源从一个对象移动到另一个对象,而不是复制它们。</target>
        </trans-unit>
        <trans-unit id="3334057bf5fdd1df4c8a56b5a8bb56d8d08ac48e" translate="yes" xml:space="preserve">
          <source>What is a move?</source>
          <target state="translated">什么是招式?</target>
        </trans-unit>
        <trans-unit id="ff7bddf15a2315c6021f9e9d0f6b6bce8bcffd35" translate="yes" xml:space="preserve">
          <source>What is move semantics</source>
          <target state="translated">什么是移动语义</target>
        </trans-unit>
        <trans-unit id="22b96be030691f90fe9b2e0240432d1d51dae570" translate="yes" xml:space="preserve">
          <source>When such copy/destroy pairs are expensive, it's typically because the object owns some heavyweight resource. For example, &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; may own a dynamically-allocated memory block containing an array of &lt;code&gt;string&lt;/code&gt; objects, each with its own dynamic memory.  Copying such an object is costly: you have to allocate new memory for each dynamically-allocated blocks in the source, and copy all the values across.  &lt;em&gt;Then&lt;/em&gt; you need deallocate all that memory you just copied.  However, &lt;em&gt;moving&lt;/em&gt; a large &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; means just copying a few pointers (that refer to the dynamic memory block) to the destination and zeroing them out in the source.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当这样的复制/销毁对非常昂贵时，通常是因为对象拥有一些重量级的资源。例如，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能拥有一个动态分配的内存块，其中包含一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，每个&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字符串&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象都有自己的动态内存。复制这样的对象非常昂贵：您必须为源中的每个动态分配的块分配新的内存，然后复制所有值。 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后，&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您需要释放刚复制的所有内存。但是，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;意味着仅将一些指针（指的是动态内存块）复制到目标，并将其在源中归零。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9cd78414f15901d8e86a8d3f4a590968adf4da6" translate="yes" xml:space="preserve">
          <source>When the new object is created from the return value, the copy constructor is called to &lt;em&gt;copy&lt;/em&gt; the contents of the temporary object to the new object b. After the function completes, the temporary object used in the function goes out of scope and is destroyed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从返回值创建新对象时，将调用复制构造函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将临时对象的内容&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复制&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到新对象b。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数完成后，函数中使用的临时对象将超出范围并被销毁。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="07a221a0bb57425e9405956022b30340ca656ba4" translate="yes" xml:space="preserve">
          <source>When would you want to do that? well std::vector is an example, say you created a temporary std::vector and you return it from a function say:</source>
          <target state="translated">std:::vector就是一个例子,比如说你创建了一个临时的 std:::vector,然后你从一个函数中返回它。</target>
        </trans-unit>
        <trans-unit id="74ec9a380d335c03fb7b287be6ff753162c1a3a7" translate="yes" xml:space="preserve">
          <source>When you write code like this:</source>
          <target state="translated">当你写这样的代码时,</target>
        </trans-unit>
        <trans-unit id="221b238f8d5a91baf4778e7b3912f0b81807d155" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;move semantics&lt;/strong&gt; it's now possible to make most of this work less unpleasant by simply &lt;em&gt;moving&lt;/em&gt; the data rather than copying.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动语义&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，现在可以通过简单地&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移动&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数据而不是复制&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来减轻大部分工作的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;麻烦。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1e792bfe219381f99de1182972a3fef81354e659" translate="yes" xml:space="preserve">
          <source>With this line, &lt;code&gt;std::move&lt;/code&gt; will cast &lt;code&gt;a&lt;/code&gt; to an rvalue and &lt;code&gt;other_function&lt;/code&gt; will receive the object as a unnamed object. Of course, if &lt;code&gt;other_function&lt;/code&gt; has not specific overloading to work with unnamed objects, this distinction is not important.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这行代码中，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转换为右值，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;other_function&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将接收该对象作为未命名对象。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然，如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有特定的重载来处理未命名的对象，则此区别并不重要。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a502ae851780f1ddc7db29441700f146506ebb73" translate="yes" xml:space="preserve">
          <source>Xvalues</source>
          <target state="translated">Xvalues</target>
        </trans-unit>
        <trans-unit id="c39f86b271db60b23e48e49da3c4e77b7bf0f5df" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;parameter&lt;/code&gt; by value. For move-only types like &lt;code&gt;unique_ptr&lt;/code&gt;, it seems there is no established idiom yet. Personally, I prefer pass by value, as it causes less clutter in the interface.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您还可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;按值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;传递&lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于像&lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的仅移动类型&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，似乎还没有确定的习语。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;就个人而言，我更喜欢按值传递，因为它可以减少界面中的混乱情况。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e2f4250ebd2eff63e7f150721d9b86649703b85e" translate="yes" xml:space="preserve">
          <source>You could argue that &lt;code&gt;parameter&lt;/code&gt; is not used anymore after the initialization of &lt;code&gt;member&lt;/code&gt;. Why is there no special rule to silently insert &lt;code&gt;std::move&lt;/code&gt; just as with return values? Probably because it would be too much burden on the compiler implementors. For example, what if the constructor body was in another translation unit? By contrast, the return value rule simply has to check the symbol tables to determine whether or not the identifier after the &lt;code&gt;return&lt;/code&gt; keyword denotes an automatic object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可能会争辩说&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，在&lt;/font&gt; &lt;code&gt;member&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;初始化后不再使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为什么没有&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;像返回值一样&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;默默插入&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;特殊规则&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能是因为这会给编译器实现者带来太多负担。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，如果构造函数主体在另一个翻译单元中怎么办？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相比之下，返回值规则仅需检查符号表以确定&lt;/font&gt; &lt;code&gt;return&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;关键字&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;后的标识符是否&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示自动对象。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3ca8091ddd18805cfc713df7dd75868c9a95f47" translate="yes" xml:space="preserve">
          <source>You know what a copy semantics means right? it means you have types which are copyable, for user-defined types you define this either buy explicitly writing a copy constructor &amp;amp; assignment operator or the compiler generates them implicitly. This will do a copy.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您知道复制语义是什么意思吗？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这意味着您具有可复制的类型，对于用户定义的类型，您可以定义此类型，或者购买显式编写副本构造函数和赋值运算符，或者由编译器隐式生成它们。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这将做一个副本。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e2f4bc4c9d48bda3c7ea5e8d13ceacb5e895f12" translate="yes" xml:space="preserve">
          <source>You might expect &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; to only bind to rvalues, because at first glance, it looks like an rvalue reference. As it turns out though, &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; also binds to lvalues:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可能希望&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仅绑定到右值，因为乍一看，它看起来像是右值引用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;事实证明，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还绑定到左值：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d33a97176f7badf8aeef43dbd922269578988791" translate="yes" xml:space="preserve">
          <source>You're going to have overhead from the copy constructor when the function returns, if (and it will in C++0x) std::vector has a move constructor instead of copying it can just set it's pointers and 'move' dynamically allocated memory to the new instance. It's kind of like transfer-of-ownership semantics with std::auto_ptr.</source>
          <target state="translated">当函数返回时,你会从copy构造函数中得到开销,如果(在C++0x中也会这样)std:::vector有一个move构造函数而不是复制,它可以直接设置它的指针,并将动态分配的内存 &quot;移动 &quot;到新的实例。这有点像std:::auto_ptr的所有权转移语义。</target>
        </trans-unit>
        <trans-unit id="e21276ab1166e0e62608292fa54445af12932da1" translate="yes" xml:space="preserve">
          <source>an &lt;em&gt;rvalue reference can be moved&lt;/em&gt; and an &lt;em&gt;lvalue&lt;/em&gt; cannot.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右值引用可以被移动&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;左值&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不能。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="151db36d21b0e8f4a4f6c394902768f00fb00c34" translate="yes" xml:space="preserve">
          <source>then an ordinary C++ compiler will create a temporary object for the result of &lt;code&gt;multiply()&lt;/code&gt;, call the copy constructor to initialise &lt;code&gt;r&lt;/code&gt;, and then destruct the temporary return value. Move semantics in C++0x allow the &quot;move constructor&quot; to be called to initialise &lt;code&gt;r&lt;/code&gt; by copying its contents, and then discard the temporary value without having to destruct it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后普通的C ++编译器将为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;multiply()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的结果创建一个临时对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，调用复制构造函数初始化&lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，然后销毁该临时返回值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 0x中的移动语义允许&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过复制其内容&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来调用&amp;ldquo;移动构造函数&amp;rdquo;以初始化&lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，然后丢弃该临时值而不必对其进行破坏。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
