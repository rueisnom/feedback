<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/3106110">
    <body>
      <group id="3106110">
        <trans-unit id="df0fd2702057b417c35ac16135733ca9fa59293f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::move(some_lvalue)&lt;/code&gt; casts an lvalue to an rvalue, thus enabling a subsequent move.</source>
          <target state="translated">&lt;code&gt;std::move(some_lvalue)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lvalue в rvalue, тем самым обеспечивая последующее перемещение.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50f6f367eb9f6b3f8bc2138fd21d734104676605" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Move semantics&lt;/strong&gt; is about &lt;strong&gt;transferring resources rather than copying them&lt;/strong&gt; when nobody needs the source value anymore.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Семантика перемещения&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;передача ресурсов, а не их копирование,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; когда исходное значение больше никому не нужно.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6792b6f126f7677728171c0bfe42b4de3714768a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two&lt;/strong&gt; new objects have been constructed, one of which is a temporary object that's only used for the duration of the function.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Были&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; созданы &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;два&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; новых объекта, один из которых является временным объектом, который используется только на время выполнения функции.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a95152a9e43e530501f6b99af74270415868a62a" translate="yes" xml:space="preserve">
          <source>A named rvalue reference is an lvalue, just like any other variable.</source>
          <target state="translated">Именованная ссылка rvalue-это lvalue,как и любая другая переменная.</target>
        </trans-unit>
        <trans-unit id="f040209caa6e8f4d4e43aa329b98ebb25520ebed" translate="yes" xml:space="preserve">
          <source>A useful example of a function with an &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; parameter is the &lt;em&gt;move constructor&lt;/em&gt;&lt;code&gt;X::X(X&amp;amp;&amp;amp; source)&lt;/code&gt;. Its purpose is to transfer ownership of the managed resource from the source into the current object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Полезным примером функции с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;параметром &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;конструктор перемещения &lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;X::X(X&amp;amp;&amp;amp; source)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Его целью является передача права собственности на управляемый ресурс из источника в текущий объект.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abef74394b5449ff6f5131eaf664d8e46d148d79" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;rvalue&lt;/code&gt; reference works pretty much like an &lt;code&gt;lvalue&lt;/code&gt; reference with one important difference:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ссылка работает довольно много , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;lvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ссылки с одним важным отличием:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1400246cab7166daac5095b766ba4438e047c79f" translate="yes" xml:space="preserve">
          <source>An rvalue is a temporary object, which is going to be destroyed at the end of the expression. In current C++, rvalues only bind to &lt;code&gt;const&lt;/code&gt; references. C++1x will allow non-&lt;code&gt;const&lt;/code&gt; rvalue references, spelled &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, which are references to an rvalue objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Значение r это временный объект, который будет уничтожен в конце выражения. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В текущем C ++, rvalues только связываются с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ссылок. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 1x допускает &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ссылки на rvalue, записанные как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , которые являются ссылками на объекты rvalue.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ec69c00d4b9b0c380efb9f8ecec0d4b04714fba" translate="yes" xml:space="preserve">
          <source>An rvalue of class type is an expression whose evaluation creates a temporary object.
  Under normal circumstances, no other expression inside the same scope denotes the same temporary object.</source>
          <target state="translated">Значение типа класса-это выражение,оценка которого создает временный объект.При нормальных обстоятельствах ни одно другое выражение в той же области видимости не обозначает тот же временный объект.</target>
        </trans-unit>
        <trans-unit id="3fe43eb5a17970d62352f3daf0ab3389b2294910" translate="yes" xml:space="preserve">
          <source>An rvalue reference &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; is a new kind of reference that only binds to rvalues.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ссылка на rvalue &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это новый тип ссылки, который привязывается только к rvalue.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b951ee76f644338afecca76aa03ce849f6e9a636" translate="yes" xml:space="preserve">
          <source>And what is &lt;strong&gt;perfect forwarding&lt;/strong&gt;? It is important to know that a &quot;rvalue reference&quot; is a reference to a named object in the &quot;caller's scope&quot;. But in the actual scope, a rvalue reference is a name to an object, so, it acts as a named object. If you pass an rvalue reference to another function, you are passing a named object, so, the object isn't received like a temporal object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;А что такое &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;идеальная пересылка&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Важно знать, что &amp;laquo;ссылка на значение&amp;raquo; - это ссылка на именованный объект в &amp;laquo;области действия вызывающего&amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но в реальной области действия ссылка на rvalue является именем объекта, поэтому она действует как именованный объект. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы передаете ссылку на rvalue другой функции, вы передаете именованный объект, поэтому объект не воспринимается как временный объект.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cdb7ef1ba819235b13a473fac62029ba510795b0" translate="yes" xml:space="preserve">
          <source>And yet, one of them invokes undefined behavior, whereas the other one does not. So what is the difference between the expressions &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;make_triangle()&lt;/code&gt;? Aren't they both of the same type? Indeed they are, but they have different &lt;em&gt;value categories&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И все же один из них вызывает неопределенное поведение, а другой - нет. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Так в чем же разница между выражениями &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Разве они не одного типа? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На самом деле они есть, но у них есть разные &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;категории стоимости&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0eeed3546c92bc7d030625e964a6a1e8f2f93dd1" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;move&lt;/code&gt; accepts any kind of parameter thanks to the forwarding reference &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, and it returns an rvalue reference. The &lt;code&gt;std::remove_reference&amp;lt;T&amp;gt;::type&lt;/code&gt; meta-function call is necessary because otherwise, for lvalues of type &lt;code&gt;X&lt;/code&gt;, the return type would be &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt;, which would collapse into &lt;code&gt;X&amp;amp;&lt;/code&gt;. Since &lt;code&gt;t&lt;/code&gt; is always an lvalue (remember that a named rvalue reference is an lvalue), but we want to bind &lt;code&gt;t&lt;/code&gt; to an rvalue reference, we have to explicitly cast &lt;code&gt;t&lt;/code&gt; to the correct return type.
The call of a function that returns an rvalue reference is itself an xvalue. Now you know where xvalues come from ;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как вы можете видеть, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; принимает любой тип параметра благодаря ссылке переадресации &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и возвращает ссылку rvalue. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::remove_reference&amp;lt;T&amp;gt;::type&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вызова мета-функция необходима , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;так как в &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;противном случае, для lvalues типа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , тип возвращаемого значения &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;будет &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , который бы разрушиться в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Так как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; всегда lvalue (помните, что именованная ссылка rvalue является lvalue), но мы хотим связать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; со ссылкой rvalue, мы должны явно привести &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; к правильному типу возвращаемого значения. Вызов функции, которая возвращает ссылку на rvalue, сам по себе является xvalue. Теперь вы знаете, откуда взялись xvalues;)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5a6f247186a6ec51d7763851bdd8e18f434a0b74" translate="yes" xml:space="preserve">
          <source>Basically, the compiler will complain that &lt;code&gt;parameter&lt;/code&gt; is an lvalue. If you look at its type, you see an rvalue reference, but an rvalue reference simply means &quot;a reference that is bound to an rvalue&quot;; it does &lt;em&gt;not&lt;/em&gt; mean that the reference itself is an rvalue! Indeed, &lt;code&gt;parameter&lt;/code&gt; is just an ordinary variable with a name. You can use &lt;code&gt;parameter&lt;/code&gt; as often as you like inside the body of the constructor, and it always denotes the same object. Implicitly moving from it would be dangerous, hence the language forbids it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;По сути, компилятор будет жаловаться, что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является lvalue. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы посмотрите на его тип, вы увидите ссылку rvalue, но ссылка rvalue просто означает &amp;laquo;ссылку, связанную с rvalue&amp;raquo;; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;это &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; значит, что сама ссылка является ценным! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Действительно, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это обычная переменная с именем. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; так часто, как вам нравится внутри тела конструктора, и он всегда обозначает один и тот же объект. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Неявное движение от него было бы опасно, поэтому язык запрещает это.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e378544bfb07451e6088433236851c65b1e84876" translate="yes" xml:space="preserve">
          <source>Because the function also &lt;em&gt;returns by value&lt;/em&gt;, another new object is constructed for the return value:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку функция также &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;возвращает значение&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , для нового &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;значения создается&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; другой новый объект:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e819a9290ce3be37f7d22e748fce09e94c70c736" translate="yes" xml:space="preserve">
          <source>Both prvalues and xvalues are rvalues. Xvalues and lvalues are both &lt;em&gt;glvalues&lt;/em&gt; (Generalized lvalues). The relationships are easier to grasp with a diagram:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И prvalues, и xvalues ​​являются rvalues. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Значения xvalue и lvalue являются &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;glvalues&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (Обобщенные lvalues). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Отношения легче понять с помощью диаграммы:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef1b8b9546c894e61fe1d619148e7bed5cc0fc49" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;auto_ptr&lt;/code&gt; is not &lt;em&gt;always&lt;/em&gt; dangerous. Factory functions are a perfectly fine use case for &lt;code&gt;auto_ptr&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;всегда&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; опасен. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Фабричные функции отлично подходят для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e6a400bc51fb91373f9c57144a4bd019862c564" translate="yes" xml:space="preserve">
          <source>But if you say &lt;code&gt;a = x + y&lt;/code&gt;, the &lt;em&gt;move constructor&lt;/em&gt; will initialize &lt;code&gt;that&lt;/code&gt; (because the expression &lt;code&gt;x + y&lt;/code&gt; is an rvalue), so there is no deep copy involved, only an efficient move.
&lt;code&gt;that&lt;/code&gt; is still an independent object from the argument, but its construction was trivial,
since the heap data didn't have to be copied, just moved. It wasn't necessary to copy it because &lt;code&gt;x + y&lt;/code&gt; is an rvalue, and again, it is okay to move from string objects denoted by rvalues.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но если вы скажете &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a = x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;конструктор перемещения&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; инициализирует &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (так как выражение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является значением r), ​​поэтому глубокая копия не используется, только эффективный ход. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; все еще независимый объект от аргумента, но его конструкция была тривиальной, так как данные кучи не нужно было копировать, просто перемещать. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Не было необходимости копировать его, потому что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является r-значением, и, опять же, можно перейти от строковых объектов, обозначенных как r-значения.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="32822acac85aaeec4278db58d224f2fe9f3f352c" translate="yes" xml:space="preserve">
          <source>But, is that not dangerous? Of course, you could destruct a dynamic object twice (segmentation fault). So, to avoid that, you should &quot;invalidate&quot; the source pointers to avoid destructing them twice:</source>
          <target state="translated">Но разве это не опасно? Конечно,динамический объект можно уничтожить дважды (ошибка сегментации).Поэтому,чтобы избежать этого,следует &quot;аннулировать&quot; указатели на источник,чтобы избежать их двойного уничтожения:</target>
        </trans-unit>
        <trans-unit id="c8a8d115ca80240745b86fe8f011228ba83a9e3b" translate="yes" xml:space="preserve">
          <source>C++0x introduces a new mechanism called &quot;rvalue reference&quot; which, among other things,
allows us to detect rvalue arguments via function overloading. All we have to do is write a constructor with an rvalue reference parameter. Inside that constructor we can do &lt;em&gt;anything we want&lt;/em&gt; with the source, as long as we leave it in &lt;em&gt;some&lt;/em&gt; valid state:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В C ++ 0x появился новый механизм, называемый &amp;laquo;ссылкой на значение&amp;raquo;, который, помимо прочего, позволяет обнаруживать аргументы значения через перегрузку функции. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Все, что нам нужно сделать, это написать конструктор со ссылочным параметром rvalue. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Внутри этого конструктора мы можем делать &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;с источником &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;все, что захотим&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , при условии, что мы оставляем его в &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;каком-то&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; действительном состоянии&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd0492dc5e0b6d5d91433b74385064b17d458bf4" translate="yes" xml:space="preserve">
          <source>C++11's answer to this problem is &lt;em&gt;rvalue references&lt;/em&gt;. An rvalue reference is a new kind of reference that only binds to rvalues, and the syntax is &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt;. The good old reference &lt;code&gt;X&amp;amp;&lt;/code&gt; is now known as an &lt;em&gt;lvalue reference&lt;/em&gt;. (Note that &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a reference to a reference; there is no such thing in C++.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ответ C ++ 11 на эту проблему - &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue ссылки&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ссылка на rvalue - это новый тип ссылок, который привязывается только к rvalue, а синтаксис - &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Старая добрая ссылка &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; теперь известна как &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ссылка lvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Обратите внимание , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; это &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ссылка на ссылки;. Нет такой вещи в C ++)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="023a6a48d15ef2c95fc40e5be2aa59fe9b54efad" translate="yes" xml:space="preserve">
          <source>C++98 implicitly declares three special member functions on demand, that is, when they are needed somewhere: the copy constructor, the copy assignment operator and the destructor.</source>
          <target state="translated">C++98 неявно объявляет по требованию три специальные функции-членов,то есть когда они где-то нужны:конструктор копирования,оператор присваивания копий и деструктор.</target>
        </trans-unit>
        <trans-unit id="c779770f0201fc38c70bf3c75d9a6f84752c9e0a" translate="yes" xml:space="preserve">
          <source>C++98 rvalues are known as prvalues in C++11. Mentally replace all occurrences of &quot;rvalue&quot; in the preceding paragraphs with &quot;prvalue&quot;.</source>
          <target state="translated">Значения C++98 известны как prvalues в C++11.Ментально замените все случаи &quot;rvalue&quot; в предыдущих параграфах на &quot;prvalue&quot;.</target>
        </trans-unit>
        <trans-unit id="132f3ce3182bbd08fe44f45ff771c82759cf58e2" translate="yes" xml:space="preserve">
          <source>Congratulations, you now understand the basics of move semantics! Let's continue by implementing the assignment operator. If you're unfamiliar with the &lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;copy and swap idiom&lt;/a&gt;, learn it and come back, because it's an awesome C++ idiom related to exception safety.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поздравляем, теперь вы понимаете основы семантики перемещения! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Давайте продолжим, реализовав оператор присваивания. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы не знакомы с &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;идиомой копирования и обмена&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , изучите ее и возвращайтесь, потому что это потрясающая идиома C ++, связанная с безопасностью исключений.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec6e7926adcc44088c147ea22db81f9c26b87174" translate="yes" xml:space="preserve">
          <source>Consider the following function template:</source>
          <target state="translated">Рассмотрим следующий шаблон функции:</target>
        </trans-unit>
        <trans-unit id="a22158725623f7c0e74173ef7dccec9292a51ae4" translate="yes" xml:space="preserve">
          <source>Copying an object means copying its &quot;static&quot; members and calling the &lt;code&gt;new&lt;/code&gt; operator for its dynamic objects. Right?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Копирование объекта означает копирование его &amp;laquo;статических&amp;raquo; членов и вызов &lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; оператора для его динамических объектов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Правильно?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4bd58a0d0236432df5def76d9e83073103fc10f" translate="yes" xml:space="preserve">
          <source>Dangerous and harmless moves</source>
          <target state="translated">Опасные и безобидные ходы</target>
        </trans-unit>
        <trans-unit id="8cdb90911daa2d1059f97197edc4cbc56200db7d" translate="yes" xml:space="preserve">
          <source>Depending on the class, maybe its a container with very much data, then that could represent much &lt;em&gt;time&lt;/em&gt; and &lt;em&gt;memory usage&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В зависимости от класса, может быть, это контейнер с очень большим количеством данных, тогда это может представлять много &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;времени&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;использования памяти&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da91507e4d455dd873c3a8569cb70baddddfd087" translate="yes" xml:space="preserve">
          <source>Forwarding references (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf&quot;&gt;previously&lt;/a&gt; known as &lt;em&gt;Universal references&lt;/em&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Пересылка ссылок ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ранее&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; называемых &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;универсальными ссылками&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b55f1baad0eb4d648fab85d1a0b7b027bc44527" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/move_constructor&quot;&gt;cppreference.com&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/move_constructor&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cppreference.com&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9831a9d72fc41bc7b1a34c6df1cc9330199f0d3" translate="yes" xml:space="preserve">
          <source>Here is how you explicitly move from an lvalue:</source>
          <target state="translated">Вот как вы явно двигаетесь от значения:</target>
        </trans-unit>
        <trans-unit id="ad658fc75be5325793f2c751d9cbdad9efe908d2" translate="yes" xml:space="preserve">
          <source>Here's a function that takes an object of type &lt;code&gt;T&lt;/code&gt; and returns an object of the same type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот функция, которая принимает объект типа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и возвращает объект того же типа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="472a84ed15750c08597c803026e48d9c509d8f33" translate="yes" xml:space="preserve">
          <source>How come the move constructor accepts the lvalue &lt;code&gt;result&lt;/code&gt; as an argument? The scope of &lt;code&gt;result&lt;/code&gt; is about to end, and it will be destroyed during stack unwinding. Nobody could possibly complain afterwards that &lt;code&gt;result&lt;/code&gt; had changed somehow; when control flow is back at the caller, &lt;code&gt;result&lt;/code&gt; does not exist anymore! For that reason, C++11 has a special rule that allows returning automatic objects from functions without having to write &lt;code&gt;std::move&lt;/code&gt;. In fact, you should &lt;em&gt;never&lt;/em&gt; use &lt;code&gt;std::move&lt;/code&gt; to move automatic objects out of functions, as this inhibits the &quot;named return value optimization&quot; (NRVO).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Почему конструктор перемещения принимает &lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lvalue &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;в качестве аргумента? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Область &lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; заканчивается, и она будет уничтожена при разматывании стека. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Никто не мог потом жаловаться, что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; как-то изменился; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;когда поток управления возвращается к вызывающей стороне, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; больше не существует! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;По этой причине в C ++ 11 есть специальное правило, которое позволяет возвращать автоматические объекты из функций без необходимости писать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Фактически, вы &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;никогда не&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; должны &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для перемещения автоматических объектов из функций, так как это запрещает &amp;laquo;именованную оптимизацию возвращаемого значения&amp;raquo; (NRVO).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b78fb8d2a72d70a2b646e5838f76a391fca0bd1" translate="yes" xml:space="preserve">
          <source>However, to &lt;strong&gt;move&lt;/strong&gt; an object (I repeat, in a practical point of view) implies only to copy the pointers of dynamic objects, and not to create new ones.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Однако &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;перемещение&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; объекта (я повторяю, с практической точки зрения) подразумевает только копирование указателей динамических объектов, а не создание новых.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be9d897b4ed75e9712b0896110f82792f56d7b57" translate="yes" xml:space="preserve">
          <source>Huh, that's it? &quot;Where's the rvalue reference?&quot; you might ask. &quot;We don't need it here!&quot; is my answer :)</source>
          <target state="translated">И всё? &quot;Где эта ссылка на стоимость?&quot; ты можешь спросить.&quot;Здесь она нам не нужна!&quot;-вот мой ответ :)</target>
        </trans-unit>
        <trans-unit id="dcad3bfb835bd226281cdb3832ed9fbd595b0efa" translate="yes" xml:space="preserve">
          <source>I find it easiest to understand move semantics with example code. Let's start with a very simple string class which only holds a pointer to a heap-allocated block of memory:</source>
          <target state="translated">Я нахожу,что проще всего понять семантику движений с помощью примеров кода.Начнем с очень простого класса строк,который содержит только указатель на выделенный кучами блок памяти:</target>
        </trans-unit>
        <trans-unit id="55918cb4dcbdcb99697ef67c5bfaed72dce39cdf" translate="yes" xml:space="preserve">
          <source>I hope this example got the main point across. There is a lot more to rvalue references and move semantics which I intentionally left out to keep it simple. If you want more details please see &lt;a href=&quot;https://stackoverflow.com/a/11540204/179917&quot;&gt;my supplementary answer&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я надеюсь, что этот пример объяснил главное. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Существует намного больше, чтобы ценить ссылки и перемещать семантику, которую я намеренно оставил для простоты. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы хотите получить более подробную информацию, см. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/11540204/179917&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мой дополнительный ответ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e26477129fa8f03bbac0d3249cb6cbea6421174" translate="yes" xml:space="preserve">
          <source>I just finished listening to the Software Engineering radio &lt;a href=&quot;http://www.se-radio.net/2010/04/episode-159-c-0x-with-scott-meyers/&quot;&gt;podcast interview with Scott Meyers&lt;/a&gt; regarding &lt;a href=&quot;http://en.wikipedia.org/wiki/C++11&quot;&gt;C++0x&lt;/a&gt;. Most of the new features made sense to me, and I am actually excited about C++0x now, with the exception of one. I still don't get &lt;em&gt;move semantics&lt;/em&gt;... What is it exactly?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я только что закончил слушать радио- &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.se-radio.net/2010/04/episode-159-c-0x-with-scott-meyers/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;интервью подкаста&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Software Engineering &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;со Скоттом Мейерсом&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; о &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/C++11&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 0x&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Большинство новых функций имело смысл для меня, и сейчас я на самом деле рад C ++ 0x, за исключением одного. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я до сих пор не понимаю &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;семантику перемещения&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ... Что это такое?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="adf922abf7820e8db1f54450dd73fbd3b62dfdc5" translate="yes" xml:space="preserve">
          <source>I'm writing this to make sure I understand it properly.</source>
          <target state="translated">Я пишу это,чтобы убедиться,что правильно понимаю.</target>
        </trans-unit>
        <trans-unit id="ea09e01c3b05274835a4c830a79abe380ae9f1ce" translate="yes" xml:space="preserve">
          <source>If the argument is an rvalue of type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; is deduced to be &lt;code&gt;X&lt;/code&gt;, hence &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; means &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt;. This is what anyone would expect.
But if the argument is an lvalue of type &lt;code&gt;X&lt;/code&gt;, due to a special rule, &lt;code&gt;T&lt;/code&gt; is deduced to be &lt;code&gt;X&amp;amp;&lt;/code&gt;, hence &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; would mean something like &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt;. But since C++ still has no notion of references to references, the type &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; is &lt;em&gt;collapsed&lt;/em&gt; into &lt;code&gt;X&amp;amp;&lt;/code&gt;. This may sound confusing and useless at first, but reference collapsing is essential for &lt;em&gt;perfect forwarding&lt;/em&gt; (which will not be discussed here).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если аргумент является r-значением типа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; выводится как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , следовательно, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; означает &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Это то, что любой может ожидать. Но если аргумент является lvalue типа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , то из-за специального правила &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; выводится как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , следовательно, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет означать что-то вроде &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Но так как &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ до &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сих пор понятия не имеет ссылок на ссылки, тип &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; это &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;рухнуло&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Поначалу это может показаться запутанным и бесполезным, но свертывание ссылок необходимо для &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;идеальной передачи&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (что не будет обсуждаться здесь).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eaf342f5b650317d7bfa03afecf3ae79d590c46f" translate="yes" xml:space="preserve">
          <source>If we throw &lt;code&gt;const&lt;/code&gt; into the mix, we already have four different kinds of references. What kinds of expressions of type &lt;code&gt;X&lt;/code&gt; can they bind to?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если мы добавим &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в микс, у нас уже есть четыре разных типа ссылок. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С какими выражениями типа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; они могут связываться?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ff4084df9c7bfd662c531429fd1f1577ffe7f6b" translate="yes" xml:space="preserve">
          <source>If you are really interested in a good, in-depth explanation of move semantics, I'd highly recommend reading the original paper on them, &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm&quot;&gt;&quot;A Proposal to Add Move Semantics Support to the C++ Language.&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы действительно заинтересованы в хорошем, глубоком объяснении семантики перемещения, я настоятельно рекомендую прочитать оригинальную статью о них, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;Предложение добавить поддержку семантики перемещения в язык C ++&amp;raquo;.&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1199d462777552484944164f0bb197d84758ee45" translate="yes" xml:space="preserve">
          <source>If you want to constrain a function template to rvalues, you can combine &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/sfinae&quot;&gt;SFINAE&lt;/a&gt; with type traits:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы хотите ограничить шаблон функции значениями r, вы можете комбинировать &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/sfinae&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SFINAE&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с типами:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6da7cd499914cd7d580cba25f4db0148f6ddfea4" translate="yes" xml:space="preserve">
          <source>If you write a class without unmanaged resources, there is no need to declare any of the five special member functions yourself, and you will get correct copy semantics and move semantics for free. Otherwise, you will have to implement the special member functions yourself. Of course, if your class does not benefit from move semantics, there is no need to implement the special move operations.</source>
          <target state="translated">Если вы пишете класс без неуправляемых ресурсов,то нет необходимости самостоятельно объявлять какую-либо из пяти специальных функций-членов,и вы получите правильную копирующую семантику и перемещаете семантику бесплатно.В противном случае,вам придется реализовать специальные функций-членов самостоятельно.Конечно,если Вашему классу не выгодна семантика перемещения,то нет необходимости реализовывать операции перемещения.</target>
        </trans-unit>
        <trans-unit id="937ed34b756d18c282b5b2e827b2ade63aff5ec5" translate="yes" xml:space="preserve">
          <source>If your object is complex and the destructor has other secondary effects, like calling to a library's function, calling to other global functions or whatever it is, perhaps is better to signal a movement with a flag:</source>
          <target state="translated">Если ваш объект сложный и деструктор имеет другие вторичные эффекты,такие как вызов библиотечной функции,вызов других глобальных функций или что-то в этом роде,возможно,лучше сигнализировать о движении с флагом:</target>
        </trans-unit>
        <trans-unit id="7a9339c8c4d94e2f90667ec0345c001b70cea00e" translate="yes" xml:space="preserve">
          <source>Implementation of move</source>
          <target state="translated">Осуществление перехода</target>
        </trans-unit>
        <trans-unit id="52c0adee2f966c6d6cae560ab2e2d18938668573" translate="yes" xml:space="preserve">
          <source>Implementing safe &quot;move-only&quot; types; that is, types for which copying does not make sense, but moving does.  Examples include locks, file handles, and smart pointers with unique ownership semantics. Note: This answer discusses &lt;code&gt;std::auto_ptr&lt;/code&gt;, a deprecated C++98 standard library template, which was replaced by &lt;code&gt;std::unique_ptr&lt;/code&gt; in C++11. Intermediate C++ programmers are probably at least somewhat familiar with &lt;code&gt;std::auto_ptr&lt;/code&gt;, and because of the &quot;move semantics&quot; it displays, it seems like a good starting point for discussing move semantics in C++11. YMMV.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Реализация безопасных типов &amp;laquo;только для перемещения&amp;raquo;; то есть типы, для которых копирование не имеет смысла, но перемещение имеет смысл. Примеры включают в себя блокировки, файловые дескрипторы и интеллектуальные указатели с уникальной семантикой владения. Примечание. В этом ответе обсуждается &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , устаревший шаблон стандартной библиотеки C ++ 98, который был заменен &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в C ++ 11. Программисты среднего уровня C ++, вероятно, хотя бы немного знакомы с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , и из-за отображаемой &amp;laquo;семантики перемещения&amp;raquo; это кажется хорошей отправной точкой для обсуждения семантики перемещения в C ++ 11. YMMV.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a454cb8b77503090cbd9a357441f356bcc77421b" translate="yes" xml:space="preserve">
          <source>Implicit conversions</source>
          <target state="translated">Неявные преобразования</target>
        </trans-unit>
        <trans-unit id="bb86577e32db06fdf51943d408f139502900a7ec" translate="yes" xml:space="preserve">
          <source>In C++03, objects are often copied, only to be destroyed or assigned-over before any code uses the value again.  For example, when you return by value from a function&amp;mdash;unless RVO kicks in&amp;mdash;the value you're returning is copied to the caller's stack frame, and then it goes out of scope and is destroyed.  This is just one of many examples: see pass-by-value when the source object is a temporary, algorithms like &lt;code&gt;sort&lt;/code&gt; that just rearrange items, reallocation in &lt;code&gt;vector&lt;/code&gt; when its &lt;code&gt;capacity()&lt;/code&gt; is exceeded, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В C ++ 03 объекты часто копируются, только чтобы быть уничтоженными или присвоенными, прежде чем какой-либо код снова использует это значение. Например, когда вы возвращаете значение по значению из функции, если только RVO не активируется, возвращаемое вами значение копируется в кадр стека вызывающей стороны, а затем выходит из области видимости и уничтожается. Это только один из многих примеров: см. Передачу по значению, когда исходный объект является временным, алгоритмы типа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sort&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; которые просто переставляют элементы, перераспределение в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; когда его &lt;/font&gt;&lt;/font&gt; &lt;code&gt;capacity()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; превышена, и т. Д.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3a5b25589cda5ecaab0c938846dc8a956cfda45" translate="yes" xml:space="preserve">
          <source>In C++11, &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; has been replaced by &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; which takes advantage of rvalue references. I will develop and discuss a simplified version of &lt;code&gt;unique_ptr&lt;/code&gt;. First, we encapsulate a raw pointer and overload the operators &lt;code&gt;-&amp;gt;&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, so our class feels like a pointer:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В C ++ 11 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; был заменен на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; который использует ссылки на rvalue. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я буду разрабатывать и обсуждать упрощенную версию &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Сначала мы инкапсулируем необработанный указатель и перегружаем операторы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , поэтому наш класс выглядит как указатель:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c090c2258bd3627e3ec4d8b649121749fe3c3bd" translate="yes" xml:space="preserve">
          <source>In easy (practical) terms:</source>
          <target state="translated">Простыми (практическими)словами:</target>
        </trans-unit>
        <trans-unit id="b398d9ad5637d0de4ed8f0bf75e5761b7e55916e" translate="yes" xml:space="preserve">
          <source>In languages which do not allow the creation of local objects (that is, objects on the stack) these types of problems do not occur as all objects are allocated on the heap and are always accessed by reference.</source>
          <target state="translated">В языках,которые не позволяют создавать локальные объекты (т.е.объекты на стеке),такого рода проблемы не возникают,так как все объекты выделяются на куче и всегда доступны по ссылке.</target>
        </trans-unit>
        <trans-unit id="27637ef20b376dcf19cbb5d2e6d093390e3f522d" translate="yes" xml:space="preserve">
          <source>In practice, you can forget about &lt;code&gt;const X&amp;amp;&amp;amp;&lt;/code&gt;. Being restricted to read from rvalues is not very useful.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На практике вы можете забыть о &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ограничение чтения из значений r не очень полезно.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1103ccac7d3cbd997a56ab0386ee5fb290dec2d2" translate="yes" xml:space="preserve">
          <source>In that situation, an anonymous object is created, next copied to the function parameter, and afterwards deleted. So, here it is better to move the object, because you don't need the anonymous object and you can save time and memory.</source>
          <target state="translated">В этой ситуации создается анонимный объект,который затем копируется в параметр функции,а затем удаляется.Поэтому здесь лучше переместить объект,потому что анонимный объект вам не нужен и вы можете сэкономить время и память.</target>
        </trans-unit>
        <trans-unit id="43e85843d22aecda603952ad3f28eb8d579f2003" translate="yes" xml:space="preserve">
          <source>In the above code, with old compilers the result of &lt;code&gt;f()&lt;/code&gt; is &lt;strong&gt;&lt;em&gt;copied&lt;/em&gt;&lt;/strong&gt; into &lt;code&gt;x&lt;/code&gt; using &lt;code&gt;X&lt;/code&gt;'s copy constructor. If your compiler supports move semantics and &lt;code&gt;X&lt;/code&gt; has a move-constructor, then that is called instead. Since its &lt;code&gt;rhs&lt;/code&gt; argument is an &lt;em&gt;rvalue&lt;/em&gt;, we know it's not needed any longer and we can steal its value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В приведенной выше коде, со старыми составителями результата &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;скопировано&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с помощью &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; конструктора копирования &amp;laquo;ы. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если ваш компилятор поддерживает семантику перемещения и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; имеет конструктор перемещения, то он вызывается вместо этого. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку его &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;аргумент &lt;/font&gt;&lt;/font&gt; &lt;code&gt;rhs&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является значением &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;r&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , мы знаем, что он больше не нужен, и можем украсть его значение.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da927e9aca357b1650ec6103ca59d8bb2cb33301" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;&quot;hello world&quot;&lt;/code&gt; is an lvalue of type &lt;code&gt;const char[12]&lt;/code&gt;. Since there is an implicit conversion from &lt;code&gt;const char[12]&lt;/code&gt; through &lt;code&gt;const char*&lt;/code&gt; to &lt;code&gt;std::string&lt;/code&gt;, a temporary of type &lt;code&gt;std::string&lt;/code&gt; is created, and &lt;code&gt;r&lt;/code&gt; is bound to that temporary. This is one of the cases where the distinction between rvalues (expressions) and temporaries (objects) is a bit blurry.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В приведенном выше примере &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;hello world&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является lvalue типа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char[12]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку существует неявное преобразование из &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char[12]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; через &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , создается временный тип типа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; привязывается к этому временному объекту. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это один из случаев, когда различие между значениями (выражениями) и временными значениями (объектами) немного размыто.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc3e683553dc45c7f890c6646a6841181eb6dec4" translate="yes" xml:space="preserve">
          <source>In this case, when an object of type &lt;code&gt;A&lt;/code&gt; should be &quot;copied&quot;, the compiler creates a lvalue reference or a rvalue reference according to if the passed object is named or not. When not, your move-constructor is called and you know the object is temporal and you can move its dynamic objects instead of copying them, saving space and memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В этом случае, когда объект типа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; должен быть &amp;laquo;скопирован&amp;raquo;, компилятор создает ссылку lvalue или ссылку rvalue в зависимости от того, назван ли переданный объект или нет. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если нет, вызывается ваш конструктор перемещения, и вы знаете, что объект является временным, и вы можете перемещать его динамические объекты вместо их копирования, экономя пространство и память.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="d04bb2623f5288427463db7edef0eb602a9ed94a" translate="yes" xml:space="preserve">
          <source>Is that perfect forwarding? Not, but we are very close. Perfect forwarding is only useful to work with templates, with the purpose to say: if I need to pass an object to another function, I need that if I receive a named object, the object is passed as a named object, and when not, I want to pass it like a unnamed object:</source>
          <target state="translated">Это идеальная переадресация? Нет,но мы очень близки.Идеальная переадресация полезна только для работы с шаблонами,с целью сказать:если мне нужно передать объект в другую функцию,мне нужно,чтобы при получении именованного объекта объект передавался как именованный,а когда нет,я хочу передать его как безымянный объект:</target>
        </trans-unit>
        <trans-unit id="697f3bc7df8e26b6f96ff8496435e846fe70c4d6" translate="yes" xml:space="preserve">
          <source>It is important to remember that &quot;static&quot; objects are always copied. There's no ways to &quot;move&quot; a static object (object in stack and not on heap). So, the distinction &quot;move&quot;/ &quot;copy&quot; when an object has no dynamic members (directly or indirectly) is irrelevant.</source>
          <target state="translated">Важно помнить,что &quot;статические&quot; объекты всегда копируются.Нет способа &quot;переместить&quot; статический объект (объект в стеке,а не на кучу).Поэтому различие &quot;перемещать&quot; &quot;копировать&quot;,когда у объекта нет динамических членов (прямо или косвенно),не имеет значения.</target>
        </trans-unit>
        <trans-unit id="e9d98f8e9d5357e09bdb4ad11e6dbd887aa316f7" translate="yes" xml:space="preserve">
          <source>It must first initialize the object, then copy all the relevant data from the old object to the new one.</source>
          <target state="translated">Сначала он должен инициализировать объект,затем скопировать все соответствующие данные со старого объекта на новый.</target>
        </trans-unit>
        <trans-unit id="3203ece5d832b88a426ed868437b3f103470fad2" translate="yes" xml:space="preserve">
          <source>It's like copy semantics, but instead of having to duplicate all of the data you get to steal the data from the object being &quot;moved&quot; from.</source>
          <target state="translated">Это похоже на копирование семантики,но вместо того,чтобы дублировать все данные,вы получаете,чтобы украсть данные из &quot;перемещаемого&quot; объекта.</target>
        </trans-unit>
        <trans-unit id="90e6d34c95a16f345f4e07cab166d7088702a308" translate="yes" xml:space="preserve">
          <source>It's very accessible and easy to read and it makes an excellent case for the benefits that they offer.  There are other more recent and up to date papers about move semantics available on &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/&quot;&gt;the WG21 website&lt;/a&gt;, but this one is probably the most straightforward since it approaches things from a top-level view and doesn't get very much into the gritty language details.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это очень доступно и легко читается, и это превосходное доказательство преимуществ, которые они предлагают. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;веб-сайте WG21&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; есть и другие, более свежие и актуальные статьи о семантике перемещения &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, но эта, пожалуй, самая прямолинейная, так как она подходит к вещам с точки зрения верхнего уровня и не слишком подробно описывает детали языка.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3214661671ef9aff8765af8c7d203ac41c5e3e99" translate="yes" xml:space="preserve">
          <source>Move assignment operators</source>
          <target state="translated">Операторы по распределению перемещений</target>
        </trans-unit>
        <trans-unit id="76c87719ef4631d051ec31847319db90f2a38c3c" translate="yes" xml:space="preserve">
          <source>Move constructors</source>
          <target state="translated">Конструкторы движения</target>
        </trans-unit>
        <trans-unit id="21df78e8312204ee0ae1344d1d1244c5ab2567b2" translate="yes" xml:space="preserve">
          <source>Move semantics allows an object, under certain conditions, to take ownership of some other object's external resources. This is important in two ways:</source>
          <target state="translated">Семантика движения позволяет объекту при определенных условиях получить право собственности на внешние ресурсы какого-то другого объекта.Это важно в двух отношениях:</target>
        </trans-unit>
        <trans-unit id="ff2c5f0ff5c8b72e423fa0fe0eb25bf31e14356c" translate="yes" xml:space="preserve">
          <source>Move semantics are based on &lt;strong&gt;&lt;em&gt;rvalue references&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Семантика перемещения основана на &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ссылках rvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b1fd88c02c0af8c30b9a31838ee4311178338b21" translate="yes" xml:space="preserve">
          <source>Move semantics is basically a user-defined type with constructor that takes an r-value reference (new type of reference using &amp;amp;&amp;amp; (yes two ampersands)) which is non-const, this is called a move constructor, same goes for assignment operator. So what does a move constructor do, well instead of copying memory from it's source argument it 'moves' memory from the source to the destination.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Семантика перемещения - это в основном пользовательский тип с конструктором, который принимает ссылку на r-значение (новый тип ссылки с использованием &amp;amp;&amp;amp; (да, два амперсанда)), который не является константным, это называется конструктором перемещения, то же самое относится и к оператору присваивания. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Так что же делает конструктор перемещения, вместо того, чтобы копировать память из аргумента источника, он &amp;laquo;перемещает&amp;raquo; память из источника в место назначения.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60affa9a44a9bad8c292beedae93936057dc4f21" translate="yes" xml:space="preserve">
          <source>Move semantics were created to avoid the unnecessary copying of large objects.  Bjarne Stroustrup in his book &quot;The C++ Programming Language&quot; uses two examples where unnecessary copying occurs by default: one, the swapping of two large objects, and two, the returning of a large object from a method.</source>
          <target state="translated">Семантика движения была создана для того,чтобы избежать ненужного копирования больших объектов.Бьярне Струструп в своей книге &quot;Язык программирования C++&quot; использует два примера,где по умолчанию происходит ненужное копирование:один-замена двух больших объектов,а второй-возврат большого объекта из метода.</target>
        </trans-unit>
        <trans-unit id="f19144fcd990c500b4ac693c567a9549f27dfd2c" translate="yes" xml:space="preserve">
          <source>Moving from lvalues</source>
          <target state="translated">Переход от ценностей</target>
        </trans-unit>
        <trans-unit id="d64e12206734f5c30656ba8ea9b5782042bd423a" translate="yes" xml:space="preserve">
          <source>Moving from lvalues such as &lt;code&gt;a&lt;/code&gt; is dangerous, because we could later try to call a member function via &lt;code&gt;a&lt;/code&gt;, invoking undefined behavior. On the other hand, moving from rvalues such as &lt;code&gt;make_triangle()&lt;/code&gt; is perfectly safe, because after the copy constructor has done its job, we cannot use the temporary again. There is no expression that denotes said temporary; if we simply write &lt;code&gt;make_triangle()&lt;/code&gt; again, we get a &lt;em&gt;different&lt;/em&gt; temporary. In fact, the moved-from temporary is already gone on the next line:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Переход от lvalues , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;таких как &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;опасно, потому что мы могли бы позже попытаться вызвать функцию - &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;член через &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, вызывая неопределенное поведение. С другой стороны, переход от значений r, таких как &lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; , совершенно безопасен, потому что после того, как конструктор копирования выполнил свою работу, мы не можем снова использовать временные. Нет выражения, которое обозначает временное; если мы просто напишем &lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; снова, мы получим &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;другое&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; временное значение. Фактически, перемещенный из временного уже ушел на следующей строке:&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a63742120d0d7b0e09c3bb18048c15fda0b0e774" translate="yes" xml:space="preserve">
          <source>Moving into members</source>
          <target state="translated">Переезд в члены</target>
        </trans-unit>
        <trans-unit id="55a56ac4401dd0eaa2dcf2e8a8396e846706642c" translate="yes" xml:space="preserve">
          <source>Moving out of functions</source>
          <target state="translated">Отключение функций</target>
        </trans-unit>
        <trans-unit id="2a77a62dac1e84715dce30b39e1eca21de49ebaa" translate="yes" xml:space="preserve">
          <source>Moving the data involves re-associating the data with the new object. And &lt;em&gt;no copy takes place&lt;/em&gt; at all.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Перемещение данных включает в себя повторное связывание данных с новым объектом. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;никакой копии не происходит&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вообще.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="694f6377ae54f3d5a6a8d632f41c5ee6694d13aa" translate="yes" xml:space="preserve">
          <source>My first answer was an extremely simplified introduction to move semantics, and many details were left out on purpose to keep it simple.
However, there is a lot more to move semantics, and I thought it was time for a second answer to fill the gaps.
The first answer is already quite old, and it did not feel right to simply replace it with a completely different text. I think it still serves well as a first introduction. But if you want to dig deeper, read on :)</source>
          <target state="translated">Моим первым ответом было чрезвычайно упрощенное введение в семантику движений,и многие детали были специально оставлены без внимания,чтобы сохранить ее простоту.Тем не менее,семантики в движении осталось гораздо больше,и я подумал,что пришло время второго ответа,чтобы заполнить пробелы.Первый ответ уже достаточно старый,и просто заменить его совершенно другим текстом было бы неправильно.Я думаю,что он все еще служит хорошим первым введением.Но если вы хотите копнуть глубже,читайте дальше :).</target>
        </trans-unit>
        <trans-unit id="2273c40caec113ed4c70f21b9c59f72191a4ef03" translate="yes" xml:space="preserve">
          <source>Never return automatic objects by rvalue reference. Moving is exclusively performed by the move constructor, not by &lt;code&gt;std::move&lt;/code&gt;, and not by merely binding an rvalue to an rvalue reference.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Никогда не возвращайте автоматические объекты по ссылке. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Перемещение выполняется исключительно конструктором &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , а не &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: move&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , и не просто привязывает rvalue к ссылке rvalue.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c87b215e468265e84456567f5fd96732627b217" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;std::move&lt;/code&gt; to move automatic objects out of functions.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Никогда не используйте &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для перемещения автоматических объектов из функций.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5620a89fc44e99a7e64f46bd1660b0fe78ec31ff" translate="yes" xml:space="preserve">
          <source>Note how both examples follow the same syntactic pattern:</source>
          <target state="translated">Обратите внимание,что оба примера следуют одному и тому же синтаксическому шаблону:</target>
        </trans-unit>
        <trans-unit id="9ffaa4649e35625dc8efbe19265d4da4843b9b9e" translate="yes" xml:space="preserve">
          <source>Note how the initialization of &lt;code&gt;b&lt;/code&gt; with &lt;code&gt;a&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; copy the triangle, but instead transfers the ownership of the triangle from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;. We also say &quot;&lt;code&gt;a&lt;/code&gt; is &lt;em&gt;moved into&lt;/em&gt;&lt;code&gt;b&lt;/code&gt;&quot; or &quot;the triangle is &lt;em&gt;moved&lt;/em&gt; from &lt;code&gt;a&lt;/code&gt;&lt;em&gt;to&lt;/em&gt;&lt;code&gt;b&lt;/code&gt;&quot;. This may sound confusing, because the triangle itself always stays at the same place in memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;как инициализация &lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вовсе &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; копировать треугольник, но вместо этого передает право собственности на треугольнике от &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;до &lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мы также говорим , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;будет &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;перемещен в &lt;/font&gt;&lt;/em&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo; или &amp;laquo;треугольник &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;перемещается&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; из &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;к &lt;/font&gt;&lt;/em&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это может показаться странным, потому что сам треугольник всегда остается в памяти в одном месте.&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4e30ddde6f9383ffb25516635c9c73988eaf920" translate="yes" xml:space="preserve">
          <source>Note how this implementation of the move assignment operator duplicates logic of both the destructor and the move constructor. Are you familiar with the copy-and-swap idiom? It can also be applied to move semantics as the move-and-swap idiom:</source>
          <target state="translated">Обратите внимание,что эта реализация оператора присваивания перемещений дублирует логику как деструктора,так и конструктора перемещения.Вы знакомы с идиомой копирования и замены? Она также может быть применена для семантики перемещения в качестве идиомы переноса и замены:</target>
        </trans-unit>
        <trans-unit id="bc1ed59cd37ede9518aedf02a407061ed06f096c" translate="yes" xml:space="preserve">
          <source>Note that after the third line, &lt;code&gt;a&lt;/code&gt; no longer owns a triangle. That's okay, because by &lt;em&gt;explicitly&lt;/em&gt; writing &lt;code&gt;std::move(a)&lt;/code&gt;, we made our intentions clear: &quot;Dear constructor, do whatever you want with &lt;code&gt;a&lt;/code&gt; in order to initialize &lt;code&gt;c&lt;/code&gt;; I don't care about &lt;code&gt;a&lt;/code&gt; anymore. Feel free to have your way with &lt;code&gt;a&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что после третьей линии, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;больше не владеет треугольником. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это нормально, потому что &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;явно&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; писать &lt;/font&gt; &lt;code&gt;std::move(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; , мы сделали наши намерения ясно: &amp;laquo;Дорогой конструктор, делать все , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что вы хотите с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, чтобы инициализировать &lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; , я не забочусь о &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;больше Не &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;стесняйтесь , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;чтобы иметь. ваш путь с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;.&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b545f2bda15018d01523f9ff1692f25b2b72840e" translate="yes" xml:space="preserve">
          <source>Note that even though &lt;code&gt;std::move(a)&lt;/code&gt; is an rvalue, its evaluation does &lt;em&gt;not&lt;/em&gt; create a temporary object. This conundrum forced the committee to introduce a third value category. Something that can be bound to an rvalue reference, even though it is not an rvalue in the traditional sense, is called an &lt;em&gt;xvalue&lt;/em&gt; (eXpiring value). The traditional rvalues were renamed to &lt;em&gt;prvalues&lt;/em&gt; (Pure rvalues).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что хотя &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является значением r, его оценка &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; создает временный объект. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эта загадка вынудила комитет ввести третью категорию стоимости. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;То, что может быть связано с ссылкой на rvalue, даже если оно не является rvalue в традиционном смысле, называется &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;xvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (значение eXpiring). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Традиционные значения были переименованы в &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;prvalues&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (чистые значения).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6197c8328d3615627bdcb1f1810f59a11b3231ca" translate="yes" xml:space="preserve">
          <source>Note that in both factory functions, the return type is a value, not an rvalue reference. Rvalue references are still references, and as always, you should never return a reference to an automatic object; the caller would end up with a dangling reference if you tricked the compiler into accepting your code, like this:</source>
          <target state="translated">Обратите внимание,что в обеих заводских функциях тип возврата является значением,а не ссылкой на значение.Ссылки на значения по-прежнему являются ссылками,и,как всегда,никогда не следует возвращать ссылку на автоматический объект;вызывающий абонент получит висящую ссылку,если вы обманом заставите компилятор принять ваш код,подобно этому:</target>
        </trans-unit>
        <trans-unit id="895f41e9bd9293af7e0f16ad424d9f9981e26c97" translate="yes" xml:space="preserve">
          <source>Note that only xvalues are really new; the rest is just due to renaming and grouping.</source>
          <target state="translated">Обратите внимание,что только x-значения являются действительно новыми;остальное связано только с переименованием и группировкой.</target>
        </trans-unit>
        <trans-unit id="3432dccea5cbc5683d11346e5fcd0b1d26cea00a" translate="yes" xml:space="preserve">
          <source>Note that returning by rvalue reference is fine in this example, because &lt;code&gt;t&lt;/code&gt; does not denote an automatic object, but instead an object that was passed in by the caller.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что возвращение по ссылке rvalue в этом примере хорошо, поскольку &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; обозначает не автоматический объект, а объект, который был передан вызывающей стороной.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89ea05e38d59c5aed95819ce421844b145c2084c" translate="yes" xml:space="preserve">
          <source>Note that the copy assignment operator and the move assignment operator can be fused into a single, unified assignment operator, taking its argument by value:</source>
          <target state="translated">Обратите внимание,что оператор присваивания копии и оператор присваивания перемещения могут быть объединены в один,унифицированный оператор присваивания,принимая его аргумент за значение:</target>
        </trans-unit>
        <trans-unit id="545ad832cdf421948e5760aa53c065f811afa6d0" translate="yes" xml:space="preserve">
          <source>Note that the letters &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; have a historic origin in the left-hand side and right-hand side of an assignment. This is no longer true in C++, because there are lvalues which cannot appear on the left-hand side of an assignment (like arrays or user-defined types without an assignment operator), and there are rvalues which can (all rvalues of class types with an assignment operator).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что буквы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;l&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; имеют историческое происхождение в левой и правой частях задания. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это больше не верно в C ++, потому что есть l-значения, которые не могут появляться в левой части присваивания (например, массивы или пользовательские типы без оператора присваивания), и есть r-значения, которые могут (все r-значения типов классов). с оператором присваивания).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eaab0e119523ba0a6a6a259204c53d3659b8a758" translate="yes" xml:space="preserve">
          <source>Note that we pass the parameter &lt;code&gt;that&lt;/code&gt;&lt;em&gt;by value&lt;/em&gt;, so &lt;code&gt;that&lt;/code&gt; has to be initialized just like any other string object. Exactly how is &lt;code&gt;that&lt;/code&gt; going to be initialized? In the olden days of &lt;a href=&quot;http://en.wikipedia.org/wiki/C++#Standardization&quot;&gt;C++98&lt;/a&gt;, the answer would have been &quot;by the copy constructor&quot;. In C++0x, the compiler chooses between the copy constructor and the move constructor based on whether the argument to the assignment operator is an lvalue or an rvalue.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что мы передаем параметр , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;по значению&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , так &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; должен быть инициализирован так же , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;как и &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;любой другой объект строки. Как именно &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет инициализировано? В старые времена &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/C++#Standardization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ответом был бы &amp;laquo;конструктор копирования&amp;raquo;. В C ++ 0x компилятор выбирает между конструктором копирования и конструктором перемещения в зависимости от того, является ли аргумент оператора присваивания lvalue или rvalue.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="292b4ec9384f8616eaa92d7632778a096d02a026" translate="yes" xml:space="preserve">
          <source>Now comes the interesting part, the move constructor:</source>
          <target state="translated">А теперь интересная часть-конструктор перемещения:</target>
        </trans-unit>
        <trans-unit id="9eeb4639b40950f86cdb1f7ee968470d998ea4aa" translate="yes" xml:space="preserve">
          <source>Now comes the key insight into move semantics. Note that only in the first line where we copy &lt;code&gt;x&lt;/code&gt; is this deep copy really necessary, because we might want to inspect &lt;code&gt;x&lt;/code&gt; later and would be very surprised if &lt;code&gt;x&lt;/code&gt; had changed somehow. Did you notice how I just said &lt;code&gt;x&lt;/code&gt; three times (four times if you include this sentence) and meant the &lt;em&gt;exact same object&lt;/em&gt; every time? We call expressions such as &lt;code&gt;x&lt;/code&gt; &quot;lvalues&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь приходит ключ к пониманию семантики перемещения. Обратите внимание, что только в первой строке, где мы копируем &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , эта глубокая копия действительно необходима, потому что мы могли бы захотеть проверить &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; позже и были бы очень удивлены, если &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; изменилось каким-либо образом. Вы заметили, как я только что сказал &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; три раза (четыре раза, если вы включите это предложение) и имел в виду один и тот &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;же объект&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; каждый раз? Мы называем такие выражения, как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;lvalues&quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="931b9f3d55a132fec2e5e039741e883dded73c53" translate="yes" xml:space="preserve">
          <source>Now that &lt;code&gt;source&lt;/code&gt; is a variable of type &lt;code&gt;unique_ptr&lt;/code&gt;, it will be initialized by the move constructor; that is, the argument will be moved into the parameter. The argument is still required to be an rvalue, because the move constructor itself has an rvalue reference parameter. When control flow reaches the closing brace of &lt;code&gt;operator=&lt;/code&gt;, &lt;code&gt;source&lt;/code&gt; goes out of scope, releasing the old resource automatically.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь этот &lt;/font&gt;&lt;/font&gt; &lt;code&gt;source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является переменной типа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , он будет инициализирован конструктором перемещения; то есть аргумент будет перемещен в параметр. Аргумент все еще должен быть rvalue, потому что сам конструктор перемещения имеет ссылочный параметр rvalue. Когда поток управления достигает закрывающей скобки &lt;/font&gt;&lt;/font&gt; &lt;code&gt;operator=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; выходит из области видимости, высвобождая старый ресурс автоматически.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="298a83fc83958407292172112721d7fac6f19495" translate="yes" xml:space="preserve">
          <source>Now that you understand reference collapsing, here is how &lt;code&gt;std::move&lt;/code&gt; is implemented:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь, когда вы понимаете сворачивание ссылок, вот как &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;реализован &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c53f94e863e826764f4562c8d505588624c09e3e" translate="yes" xml:space="preserve">
          <source>Now, let's consider what a &lt;em&gt;copy constructor&lt;/em&gt; does.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь давайте рассмотрим, что &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;делает &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;конструктор копирования&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf61830673a8f5c2707029863a04957daf0b7f26" translate="yes" xml:space="preserve">
          <source>Obviously, there must be some profound difference between the expression &lt;code&gt;a&lt;/code&gt; which denotes an &lt;code&gt;auto_ptr&lt;/code&gt; variable, and the expression &lt;code&gt;make_triangle()&lt;/code&gt; which denotes the call of a function that returns an &lt;code&gt;auto_ptr&lt;/code&gt; by value, thus creating a fresh temporary &lt;code&gt;auto_ptr&lt;/code&gt; object every time it is called. &lt;code&gt;a&lt;/code&gt; is an example of an &lt;em&gt;lvalue&lt;/em&gt;, whereas &lt;code&gt;make_triangle()&lt;/code&gt; is an example of an &lt;em&gt;rvalue&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Очевидно, что между выражением &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; которое обозначает &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;переменную &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , и выражением &lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; которое обозначает вызов функции, возвращающей &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; по значению, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;должно быть какое-то глубокое различие &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, создавая тем самым свежий временный &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;объект &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; каждый раз, когда он вызывается. , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является примером &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , тогда как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является примером &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f59b333eedae45f10bcefb5eb8e11c7862dbf00" translate="yes" xml:space="preserve">
          <source>Ok, but if I move an object, the source object becomes useless, no? Of course, but in certain situations that's very useful. The most evident one is when I call a function with an anonymous object (temporal, rvalue object, ..., you can call it with different names):</source>
          <target state="translated">Хорошо,но если я перемещаю объект,исходный объект становится бесполезным,не так ли? Конечно,но в некоторых ситуациях это очень полезно.Самая очевидная-это когда я вызываю функцию с анонимным объектом (временным,rvalue-объектом,...можно вызывать его с разными именами):</target>
        </trans-unit>
        <trans-unit id="ff03efad6b4f508d07644ba3ac921a54bad39daa" translate="yes" xml:space="preserve">
          <source>Other typical question: what is the difference between &lt;code&gt;A&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;const A&amp;amp;&amp;amp;&lt;/code&gt;? Of course, in the first case, you can modify the object and in the second not, but, practical meaning? In the second case, you can't modify it, so you have no ways to invalidate the object (except with a mutable flag or something like that), and there is no practical difference to a copy constructor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другой типичный вопрос: в чем разница между &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const A&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? Конечно, в первом случае вы можете изменить объект, а во втором нет, но практический смысл? Во втором случае вы не можете изменить его, поэтому у вас нет способов сделать объект недействительным (кроме как с изменяемым флагом или чем-то в этом роде), и нет никакого практического различия для конструктора копирования.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70836291e05cb08b074706c1896b5e4d3e0d1003" translate="yes" xml:space="preserve">
          <source>Perhaps surprisingly, automatic objects (local variables that are not declared as &lt;code&gt;static&lt;/code&gt;) can also be &lt;em&gt;implicitly&lt;/em&gt; moved out of functions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Возможно, что удивительно, автоматические объекты (локальные переменные, которые не объявлены как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;static&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) также могут быть &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;неявно&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; удалены из функций:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="047060b19a709b1338cf8e5a234066acfcd19213" translate="yes" xml:space="preserve">
          <source>Returning an object from a method by default involves making a copy of the local object and its associated data in a location which is accessible to the caller (because the local object is not accessible to the caller and disappears when the method finishes).  When a built-in type is being returned, this operation is very fast, but if a large object is being returned, this could take a long time.  The move constructor allows the programmer to override this default behavior and instead &quot;reuse&quot; the heap data associated with the local object by pointing the object being returned to the caller to heap data associated with the local object.  Thus no copying is required.</source>
          <target state="translated">Возвращение объекта из метода по умолчанию подразумевает создание копии локального объекта и связанных с ним данных в месте,доступном вызывающему абоненту (поскольку локальный объект недоступен вызывающему абоненту и исчезает по завершении работы метода).При возврате встроенного типа эта операция выполняется очень быстро,но если возвращается большой объект,это может занять много времени.Конструктор перемещения позволяет программисту переопределить это поведение по умолчанию и вместо этого &quot;повторно использовать&quot; кучи данных,связанные с локальным объектом,указывая возвращаемому абоненту на кучи данных,связанные с локальным объектом.Таким образом,копирование не требуется.</target>
        </trans-unit>
        <trans-unit id="e5592cd0fb417300cbaac9ee976b933b1a98a51d" translate="yes" xml:space="preserve">
          <source>Rvalue references</source>
          <target state="translated">Ссылки на стоимость</target>
        </trans-unit>
        <trans-unit id="5dc3c807bd559ab077dd1e1206e50e03c15ccaf6" translate="yes" xml:space="preserve">
          <source>Rvalue references went through several versions. Since version 2.1, an rvalue reference &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; also binds to all value categories of a different type &lt;code&gt;Y&lt;/code&gt;, provided there is an implicit conversion from &lt;code&gt;Y&lt;/code&gt; to &lt;code&gt;X&lt;/code&gt;. In that case, a temporary of type &lt;code&gt;X&lt;/code&gt; is created, and the rvalue reference is bound to that temporary:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Rvalue ссылки прошли через несколько версий. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Начиная с версии 2.1, Rvalue ссылка &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; также связывается с всех категорий значений различного типа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , при &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;условии , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;существует неявное преобразование из &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В этом случае создается временный объект типа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , и ссылка на rvalue привязывается к этому временному объекту:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="681732688880af87e8358c431edcf6c36bc387ab" translate="yes" xml:space="preserve">
          <source>Rvalue references went through several versions. Since version 3.0, C++11 declares two additional special member functions on demand: the move constructor and the move assignment operator. Note that neither VC10 nor VC11 conform to version 3.0 yet, so you will have to implement them yourself.</source>
          <target state="translated">Ссылки на значения прошли через несколько версий.Начиная с версии 3.0,C++11 объявляет по требованию две дополнительные специальные функции-члены:конструктор перемещения и оператор присваивания перемещения.Обратите внимание,что ни VC10,ни VC11 пока не соответствуют версии 3.0,поэтому их придется реализовать самостоятельно.</target>
        </trans-unit>
        <trans-unit id="ae0b0234229935b2ce05de8879beb6e5cb6cf659" translate="yes" xml:space="preserve">
          <source>Since an rvalue is going to die at the end of an expression, you can &lt;em&gt;steal its data&lt;/em&gt;. Instead of &lt;em&gt;copying&lt;/em&gt; it into another object, you &lt;em&gt;move&lt;/em&gt; its data into it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Так как значение r умрет в конце выражения, вы можете &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;украсть его данные&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вместо того, чтобы &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;копировать&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; его в другой объект, вы &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;перемещаете&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в него данные.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48e1e601d0414c91d7bb8d787fc5e6f1a4660de9" translate="yes" xml:space="preserve">
          <source>Since we chose to manage the memory ourselves, we need to follow the &lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29&quot;&gt;rule of three&lt;/a&gt;. I am going to defer writing the assignment operator and only implement the destructor and the copy constructor for now:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку мы решили сами управлять памятью, нам нужно следовать &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;правилу трех&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я собираюсь отложить написание оператора присваивания и пока реализовать только деструктор и конструктор копирования:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0099f828c7759a2abbdb4ba58fd52bd3abe97f90" translate="yes" xml:space="preserve">
          <source>So far, we have seen movement into local variables, and into function parameters. But moving is also possible in the opposite direction. If a function returns by value, some object at call site (probably a local variable or a temporary, but could be any kind of object) is initialized with the expression after the &lt;code&gt;return&lt;/code&gt; statement as an argument to the move constructor:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;До сих пор мы видели движение в локальные переменные и в параметры функции. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но движение также возможно в противоположном направлении. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если функция возвращает значение, некоторый объект на сайте вызова (возможно, локальная переменная или временный, но может быть объект любого типа) инициализируется с выражением после &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;оператора &lt;/font&gt;&lt;/font&gt; &lt;code&gt;return&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в качестве аргумента конструктора перемещения:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="034b89ff4264e6ea18c21f67aa398614ed9889ef" translate="yes" xml:space="preserve">
          <source>So if you say &lt;code&gt;a = b&lt;/code&gt;, the &lt;em&gt;copy constructor&lt;/em&gt; will initialize &lt;code&gt;that&lt;/code&gt; (because the expression &lt;code&gt;b&lt;/code&gt; is an lvalue), and the assignment operator swaps the contents with a freshly created, deep copy. That is the very definition of the copy and swap idiom -- make a copy, swap the contents with the copy, and then get rid of the copy by leaving the scope. Nothing new here.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поэтому, если вы скажете &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a = b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;конструктор копирования&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; инициализирует &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (поскольку выражение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является l-значением), а оператор присваивания заменяет содержимое только что созданной глубокой копией. Это само определение копии и идиома замены - создайте копию, обменяйте содержимое копией, а затем избавьтесь от копии, оставив область действия. Здесь нет ничего нового.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54d00ee61a37d56aa5dd7aa4758e0bd04233cb62" translate="yes" xml:space="preserve">
          <source>So the value is &lt;strong&gt;&lt;em&gt;moved&lt;/em&gt;&lt;/strong&gt; from the unnamed temporary returned from &lt;code&gt;f()&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; (while the data of &lt;code&gt;x&lt;/code&gt;, initialized to an empty &lt;code&gt;X&lt;/code&gt;, is moved into the temporary, which will get destroyed after the assignment).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, значение &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;перемещается&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; из безымянного временного &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;объекта &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;возвращаемого из &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (в то время как данные &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , инициализированные пустым &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , перемещаются во временный &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;объект &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, который будет уничтожен после присваивания).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f7961a9153c9247dac8ea0516cb0ae78c84857c" translate="yes" xml:space="preserve">
          <source>So, if &lt;code&gt;T&lt;/code&gt; is a lvalue reference to &lt;code&gt;A&lt;/code&gt; (&lt;strong&gt;T&lt;/strong&gt; = A&amp;amp;), &lt;code&gt;a&lt;/code&gt; also (&lt;strong&gt;A&amp;amp;&lt;/strong&gt; &amp;amp;&amp;amp; =&amp;gt; A&amp;amp;). If &lt;code&gt;T&lt;/code&gt; is a rvalue reference to &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; also (A&amp;amp;&amp;amp; &amp;amp;&amp;amp; =&amp;gt; A&amp;amp;&amp;amp;). In both cases, &lt;code&gt;a&lt;/code&gt; is a named object in the actual scope, but &lt;code&gt;T&lt;/code&gt; contains the information of its &quot;reference type&quot; from the caller scope's point of view. This information (&lt;code&gt;T&lt;/code&gt;) is passed as template parameter to &lt;code&gt;forward&lt;/code&gt; and 'a' is moved or not according to the type of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, если &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является lvalue ссылкой на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ( &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; = A &amp;amp;), &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; также ( &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A &amp;amp;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;amp;&amp;amp; =&amp;gt; A &amp;amp;). Если &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является r-значением ссылки на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; также (A &amp;amp;&amp;amp; &amp;amp;&amp;amp; =&amp;gt; A &amp;amp;&amp;amp;). В обоих случаях &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является именованным объектом в реальной области видимости, но &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; содержит информацию о его &amp;laquo;ссылочном типе&amp;raquo; с точки зрения области действия вызывающей стороны. Эта информация ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) передается в &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;качестве параметра шаблона , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;чтобы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;forward&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &amp;laquo;а&amp;raquo; перемещен или нет в &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;соответствии с типом &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="093fc5e367c5e2bf6fc8ca5b593b0df072b3d2ce" translate="yes" xml:space="preserve">
          <source>So, your code is shorter (you don't need to do a &lt;code&gt;nullptr&lt;/code&gt; assignment for each dynamic member) and more general.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Итак, ваш код короче (вам не нужно делать &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;присваивание &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nullptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для каждого динамического члена) и &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;носит &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;более общий характер.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68b9a6a0be10d20ad14f2d271cf26db0796998be" translate="yes" xml:space="preserve">
          <source>Sometimes, we want to move from lvalues. That is, sometimes we want the compiler to treat an lvalue as if it were an rvalue, so it can invoke the move constructor, even though it could be potentially unsafe.
For this purpose, C++11 offers a standard library function template called &lt;code&gt;std::move&lt;/code&gt; inside the header &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;.
This name is a bit unfortunate, because &lt;code&gt;std::move&lt;/code&gt; simply casts an lvalue to an rvalue; it does &lt;em&gt;not&lt;/em&gt; move anything by itself. It merely &lt;em&gt;enables&lt;/em&gt; moving. Maybe it should have been named &lt;code&gt;std::cast_to_rvalue&lt;/code&gt; or &lt;code&gt;std::enable_move&lt;/code&gt;, but we are stuck with the name by now.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Иногда мы хотим отойти от lvalues. То есть иногда мы хотим, чтобы компилятор обрабатывал lvalue, как если бы он был rvalue, чтобы он мог вызывать конструктор move, даже если он потенциально может быть небезопасным. Для этого C ++ 11 предлагает стандартный шаблон библиотечной функции &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; внутри заголовка &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Это имя немного неудачно, потому что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; просто &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;переводит&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lvalue в rvalue; он ничего &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; двигает сам по себе. Это просто &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;позволяет&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; двигаться. Может быть, он должен был называться &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::cast_to_rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::enable_move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но мы застряли с именем на данный момент.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5301bb25f1b806784df96fdac43504d478adbc18" translate="yes" xml:space="preserve">
          <source>Sooner or later, you are going to write code like this:</source>
          <target state="translated">Рано или поздно ты будешь писать такой код:</target>
        </trans-unit>
        <trans-unit id="827e6674de363a70897b99e51fffefdb810a4c6e" translate="yes" xml:space="preserve">
          <source>Special member functions</source>
          <target state="translated">Специальные функции члена</target>
        </trans-unit>
        <trans-unit id="af929f44893f1dbb0ff36798043c5601a040d9c7" translate="yes" xml:space="preserve">
          <source>Stephan T. Lavavej took the time provide valuable feedback. Thank you very much, Stephan!</source>
          <target state="translated">Стефан Т.Лававедж потратил время,чтобы дать ценные отзывы.Большое спасибо,Стефан!</target>
        </trans-unit>
        <trans-unit id="97edf0f249ffe0384959565a34426727579f471c" translate="yes" xml:space="preserve">
          <source>Suppose you have a function that returns a substantial object:</source>
          <target state="translated">Предположим,у вас есть функция,которая возвращает существенный объект:</target>
        </trans-unit>
        <trans-unit id="76cdc8fdc1131d4b14a54894d4cef5413aad87ac" translate="yes" xml:space="preserve">
          <source>Swapping two large objects usually involves copying the first object to a temporary object, copying the second object to the first object, and copying the temporary object to the second object.  For a built-in type, this is very fast, but for large objects these three copies could take a large amount of time.  A &quot;move assignment&quot; allows the programmer to override the default copy behavior and instead swap references to the objects, which means that there is no copying at all and the swap operation is much faster.  The move assignment can be invoked by calling the std::move() method.</source>
          <target state="translated">Замена двух больших объектов обычно включает в себя копирование первого объекта на временный объект,копирование второго объекта на первый объект и копирование временного объекта на второй объект.Для встроенного типа это очень быстро,но для больших объектов эти три копии могут занять большое количество времени.Назначение перемещения&quot; позволяет программисту переопределить поведение копирования по умолчанию,а вместо этого поменять местами ссылки на объекты,что означает,что копирование вообще не происходит,а операция подкачки происходит намного быстрее.Присвоение перемещения может быть вызвано вызовом метода std::move().</target>
        </trans-unit>
        <trans-unit id="f28b36c8ab1c06a2320bf78626f74f8e645b94e6" translate="yes" xml:space="preserve">
          <source>T&amp;amp;&amp;amp; is not an rvalue reference, but a forwarding reference. It also binds to lvalues, in which case &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; are both lvalue references.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T &amp;amp;&amp;amp; - это не ссылка на значение, а ссылка на пересылку. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он также привязывается к lvalue, и в этом случае &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; являются ссылками lvalue.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25e5448ed70f909735a7a46f8300ed37a57706a9" translate="yes" xml:space="preserve">
          <source>That's the signature of a prototypical function that uses perfect forwarding, implemented in C++11 by means of &lt;code&gt;std::forward&lt;/code&gt;. This function exploits some rules of template instantiation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это сигнатура прототипной функции, которая использует идеальную пересылку, реализованную в C ++ 11 с помощью &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::forward&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эта функция использует некоторые правила создания шаблона:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2aeb46f404b05b67c1d4b4e933f1b159f28adf0b" translate="yes" xml:space="preserve">
          <source>The C++98 standard library offers a smart pointer with unique ownership semantics called &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. In case you are unfamiliar with &lt;code&gt;auto_ptr&lt;/code&gt;, its purpose is to guarantee that a dynamically allocated object is always released, even in the face of exceptions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Стандартная библиотека C ++ 98 предлагает интеллектуальный указатель с уникальной семантикой владения, называемой &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы не знакомы с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , его цель - гарантировать, что динамически размещаемый объект всегда освобождается, даже при исключениях:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c5273ddaf8d4d9bd2c708aae41ca02d986a560f" translate="yes" xml:space="preserve">
          <source>The above function uses &lt;em&gt;call by value&lt;/em&gt; which means that when this function is called an object must be &lt;em&gt;constructed&lt;/em&gt; to be used by the function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вышеуказанные функции используются &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вызов по значению&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; что означает , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;когда эта функция называется объект должен быть &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;построен&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для использования этой функции.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="21453336f2384057cccb4c69429d948c05e5271d" translate="yes" xml:space="preserve">
          <source>The arguments in lines 2 and 3 are not lvalues, but rvalues, because the underlying string objects have no names, so the client has no way to inspect them again at a later point in time.
rvalues denote temporary objects which are destroyed at the next semicolon (to be more precise: at the end of the full-expression that lexically contains the rvalue). This is important because during the initialization of &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, we could do whatever we wanted with the source string, and &lt;em&gt;the client couldn't tell a difference&lt;/em&gt;!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Аргументы в строках 2 и 3 - это не lvalues, а rvalues, потому что нижележащие строковые объекты не имеют имен, поэтому у клиента нет возможности проверить их снова в более поздний момент времени. Значения r обозначают временные объекты, которые уничтожаются в следующей точке с запятой (точнее: в конце полного выражения, которое лексически содержит значение r). Это важно, потому что во время инициализации &lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; мы могли делать с исходной строкой все, что хотели, а &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;клиент не мог отличить&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; !&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e024a6d6f6f045a7e5fd3e2fd78c563a51190fec" translate="yes" xml:space="preserve">
          <source>The call of a function that returns an rvalue reference, such as &lt;code&gt;std::move&lt;/code&gt;, is an xvalue.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вызов функции, которая возвращает ссылку на rvalue, такую ​​как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , является значением xvalue.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b626cb0884dddd9379630d99507ae7fe2ff2c15c" translate="yes" xml:space="preserve">
          <source>The constructor takes ownership of the object, and the destructor deletes it:</source>
          <target state="translated">Конструктор получает право собственности на объект,а деструктор удаляет его:</target>
        </trans-unit>
        <trans-unit id="e74352db34fd6a5e34f47321ae6e9f914b303f6f" translate="yes" xml:space="preserve">
          <source>The copy constructor defines what it means to copy string objects. The parameter &lt;code&gt;const string&amp;amp; that&lt;/code&gt; binds to all expressions of type string which allows you to make copies in the following examples:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Конструктор копирования определяет, что значит копировать строковые объекты. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Параметр &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const string&amp;amp; that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; связывается со всеми выражениями типа string, позволяет копировать в следующих примерах:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="290f16723b4d755e1f94e621b760399ee06c5273" translate="yes" xml:space="preserve">
          <source>The copy constructor of &lt;code&gt;auto_ptr&lt;/code&gt; probably looks something like this (somewhat simplified):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Конструктор копирования &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вероятно, выглядит примерно так (несколько упрощенно):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f162420dc7014f9f7aea09dba5df626cfbba3e4" translate="yes" xml:space="preserve">
          <source>The dangerous thing about &lt;code&gt;auto_ptr&lt;/code&gt; is that what syntactically looks like a copy is actually a move. Trying to call a member function on a moved-from &lt;code&gt;auto_ptr&lt;/code&gt; will invoke undefined behavior, so you have to be very careful not to use an &lt;code&gt;auto_ptr&lt;/code&gt; after it has been moved from:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Опасная вещь в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; заключается в том, что то, что синтаксически выглядит как копия, на самом деле является движением. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Попытка вызова функции-члена для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;удаленным названием&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вызовет неопределенное поведение, поэтому вы должны быть очень осторожны, чтобы не использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; после его перемещения из:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5518e5be02f103564f3cd6dfbbdb856e00b6efc" translate="yes" xml:space="preserve">
          <source>The last missing piece is the move assignment operator. Its job is to release the old resource and acquire the new resource from its argument:</source>
          <target state="translated">Последняя недостающая деталь-это оператор задания перемещения.Его задача состоит в том,чтобы освободить старый ресурс и получить новый ресурс от его аргументации:</target>
        </trans-unit>
        <trans-unit id="e783ee3bf25d0cbf3bd7e4504e938db2d81a4f14" translate="yes" xml:space="preserve">
          <source>The move assignment operator transfers ownership of a managed resource into the current object, releasing the old resource.
  The move-and-swap idiom simplifies the implementation.</source>
          <target state="translated">Оператор назначения перемещения передает право собственности на управляемый ресурс в текущий объект,освобождая старый ресурс.Идиома move-and-swap упрощает реализацию.</target>
        </trans-unit>
        <trans-unit id="a92be27a40d64e9f0284a53eff6b28c4024e3a73" translate="yes" xml:space="preserve">
          <source>The move constructor transfers ownership of a managed resource into the current object.</source>
          <target state="translated">Конструктор переезда передает право собственности на управляемый ресурс в текущий объект.</target>
        </trans-unit>
        <trans-unit id="369d03b7f7d3482f6aec3906bad55a6bc99dd045" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;a&lt;/code&gt; would be copied to the actual parameter of &lt;code&gt;other_function&lt;/code&gt;. If you want the object &lt;code&gt;a&lt;/code&gt; continues being treated as a temporary object, you should use the &lt;code&gt;std::move&lt;/code&gt; function:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Объект &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет скопирован в фактический параметр &lt;/font&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы хотите, чтобы объект &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; продолжал обрабатываться как временный объект, вы должны использовать &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;функцию &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3f96d5d08d17f40270352611586edfa618dbb5ff" translate="yes" xml:space="preserve">
          <source>The second line fails to compile, because &lt;code&gt;a&lt;/code&gt; is an lvalue, but the parameter &lt;code&gt;unique_ptr&amp;amp;&amp;amp; source&lt;/code&gt; can only be bound to rvalues. This is exactly what we wanted; dangerous moves should never be implicit. The third line compiles just fine, because &lt;code&gt;make_triangle()&lt;/code&gt; is an rvalue. The move constructor will transfer ownership from the temporary to &lt;code&gt;c&lt;/code&gt;. Again, this is exactly what we wanted.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вторая строка не компилируется, потому что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является lvalue, но параметр &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&amp;amp;&amp;amp; source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; может быть привязан только к rvalue. Это именно то, что мы хотели; опасные действия никогда не должны быть скрытыми. Третья строка компилируется просто отлично, потому что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это значение. Конструктор перемещения переведет владение из временного объекта в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Опять же, это именно то, что мы хотели.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a3730034e13e4628ec2934efc747b68c3fc3e13d" translate="yes" xml:space="preserve">
          <source>The solution is to manually enable the move:</source>
          <target state="translated">Решение заключается в ручной активации переезда:</target>
        </trans-unit>
        <trans-unit id="08aa002af0a7d7ef8a828f926264d37a71e32e78" translate="yes" xml:space="preserve">
          <source>The unusual thing about &lt;code&gt;auto_ptr&lt;/code&gt; is its &quot;copying&quot; behavior:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Необычная вещь в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это его поведение &quot;копирования&quot;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3032c490102dbbdc1a53ae3a1e6b530d8d4c02ba" translate="yes" xml:space="preserve">
          <source>These two new special member functions are only implicitly declared if none of the special member functions are declared manually. Also, if you declare your own move constructor or move assignment operator, neither the copy constructor nor the copy assignment operator will be declared implicitly.</source>
          <target state="translated">Эти две новые специальные функции членов неявно объявляются только в том случае,если ни одна из специальных функций членов не объявляется вручную.Кроме того,если вы объявите свой собственный конструктор перемещения или оператор присваивания перемещения,ни конструктор копирования,ни оператор присваивания копии не будут объявлены неявно.</target>
        </trans-unit>
        <trans-unit id="83a00c1613c4181d37c495b96f0796b835f18525" translate="yes" xml:space="preserve">
          <source>This is accomplished with an &lt;code&gt;rvalue&lt;/code&gt; reference.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это достигается с помощью &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ссылки &lt;/font&gt;&lt;/font&gt; &lt;code&gt;rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="31ccc28aaac9180efd97b0f2232c9474c45ded9f" translate="yes" xml:space="preserve">
          <source>This is especially important if (like perhaps the &lt;code&gt;Matrix&lt;/code&gt; example above), the object being copied allocates extra memory on the heap to store its internal representation. A copy constructor would have to either make a full copy of the internal representation, or use reference counting and copy-on-write semantics interally. A move constructor would leave the heap memory alone and just copy the pointer inside the &lt;code&gt;Matrix&lt;/code&gt; object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это особенно важно, если (как, возможно, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;пример &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Matrix&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; выше) копируемый объект выделяет дополнительную память в куче для хранения своего внутреннего представления. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Конструктор копирования должен будет либо создать полную копию внутреннего представления, либо использовать семантику подсчета ссылок и копирования при записи. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Конструктор перемещения оставил бы кучу памяти в одиночку и просто скопировал бы указатель внутри &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;объекта &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Matrix&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="734c00e55f5d7bfea55f0c53e0033b51b7115120" translate="yes" xml:space="preserve">
          <source>This leads to the concept of an &quot;rvalue&quot; reference. They exist in C++11 only to detect if the received object is anonymous or not. I think you do already know that an &quot;lvalue&quot; is an assignable entity (the left part of the &lt;code&gt;=&lt;/code&gt; operator), so you need a named reference to an object to be capable to act as an lvalue. A rvalue is exactly the opposite, an object with no named references. Because of that, anonymous object and rvalue are synonyms. So:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это приводит к понятию &quot;rvalue&quot; ссылка. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Они существуют в C ++ 11 только для определения, является ли полученный объект анонимным или нет. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я думаю, вы уже знаете, что &amp;laquo;lvalue&amp;raquo; является присваиваемой сущностью (левая часть &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;оператора &lt;/font&gt;&lt;/font&gt; &lt;code&gt;=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), поэтому вам нужна именованная ссылка на объект, чтобы иметь возможность выступать в качестве lvalue. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Значение r с точностью до наоборот, объект без именованных ссылок. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Из-за этого анонимный объект и rvalue являются синонимами. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Так:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2a9839394d8fd7fa5c503f67611a827e38511306" translate="yes" xml:space="preserve">
          <source>This move constructor does exactly what the &lt;code&gt;auto_ptr&lt;/code&gt; copy constructor did, but it can only be supplied with rvalues:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот конструктор перемещения делает именно то, что &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сделал конструктор копирования &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но он может быть снабжен только значениями rvalue:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e308529a0760da4187efbb6031e853815d012f5" translate="yes" xml:space="preserve">
          <source>This way, the number of special member functions to implement drops from five to four. There is a tradeoff between exception-safety and efficiency here, but I am not an expert on this issue.</source>
          <target state="translated">Таким образом,число специальных функций членов,подлежащих выполнению,уменьшается с пяти до четырех.Здесь есть компромисс между безопасностью и эффективностью,но я не эксперт в этом вопросе.</target>
        </trans-unit>
        <trans-unit id="c835c096c791a7fe0c7b46b42e46e2033cbeb4bc" translate="yes" xml:space="preserve">
          <source>To illustrate the need for &lt;em&gt;move semantics&lt;/em&gt;, let's consider this example without move semantics:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чтобы проиллюстрировать необходимость &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;семантики перемещения&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , давайте рассмотрим этот пример без семантики перемещения:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a7e9e734de9455aa1437dc73d5ab335d653aaac" translate="yes" xml:space="preserve">
          <source>To make strong exception guarantee possible, user-defined move constructors should not throw exceptions. In fact, standard containers typically rely on std::move_if_noexcept to choose between move and copy when container elements need to be relocated.
  If both copy and move constructors are provided, overload resolution selects the move constructor if the argument is an rvalue (either a prvalue such as a nameless temporary or an xvalue such as the result of std::move), and selects the copy constructor if the argument is an lvalue (named object or a function/operator returning lvalue reference). If only the copy constructor is provided, all argument categories select it (as long as it takes a reference to const, since rvalues can bind to const references), which makes copying the fallback for moving, when moving is unavailable.
  In many situations, move constructors are optimized out even if they would produce observable side-effects, see copy elision.
  A constructor is called a 'move constructor' when it takes an rvalue reference as a parameter. It is not obligated to move anything, the class is not required to have a resource to be moved and a 'move constructor' may not be able to move a resource as in the allowable (but maybe not sensible) case where the parameter is a const rvalue reference (const T&amp;amp;&amp;amp;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чтобы сделать возможным строгое исключение, пользовательские конструкторы перемещения не должны генерировать исключения. Фактически, стандартные контейнеры обычно используют std :: move_if_noexcept для выбора между перемещением и копированием, когда необходимо перемещать элементы контейнера. Если предусмотрены конструкторы копирования и перемещения, разрешение перегрузки выбирает конструктор перемещения, если аргумент является значением rvalue (либо prvalue, например, безымянное временное значение, либо xvalue, например, результат std :: move), и выбирает конструктор копирования, если аргумент является lvalue (именованный объект или функция / оператор, возвращающий ссылку на lvalue). Если предоставляется только конструктор копирования, все категории аргументов выбирают его (при условии, что он принимает ссылку на const, поскольку rvalues ​​может связываться с ссылками на const), что делает копирование запасного варианта для перемещения, когда перемещение недоступно.Во многих ситуациях конструкторы перемещения оптимизируются, даже если они будут вызывать наблюдаемые побочные эффекты, см. Раздел &amp;laquo;Разрешение копирования&amp;raquo;. Конструктор называется &amp;laquo;конструктором перемещения&amp;raquo;, когда он принимает в качестве параметра ссылку на значение. Он не обязан что-либо перемещать, класс не обязан иметь ресурс для перемещения, и &amp;laquo;конструктор перемещения&amp;raquo; может не иметь возможности перемещать ресурс, как в допустимом (но, возможно, нецелесообразном) случае, когда параметр является ссылка на постоянное значение (const T &amp;amp;&amp;amp;).может быть не в состоянии переместить ресурс, как в допустимом (но, возможно, нецелесообразном) случае, когда параметр является ссылкой на постоянное значение (const T &amp;amp;&amp;amp;).может быть не в состоянии переместить ресурс, как в допустимом (но, возможно, нецелесообразном) случае, когда параметр является ссылкой на постоянное значение (const T &amp;amp;&amp;amp;).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b31d2be34d67b295038676b6a78d3aa74806629a" translate="yes" xml:space="preserve">
          <source>To move an object means to transfer ownership of some resource it manages to another object.</source>
          <target state="translated">Переместить объект означает передать право собственности на один ресурс,которым он управляет,другому объекту.</target>
        </trans-unit>
        <trans-unit id="bbf1b3314c139a90af79519c70cc487a725f22d9" translate="yes" xml:space="preserve">
          <source>To summarize, the copy constructor makes a deep copy, because the source must remain untouched.
The move constructor, on the other hand, can just copy the pointer and then set the pointer in the source to null. It is okay to &quot;nullify&quot; the source object in this manner, because the client has no way of inspecting the object again.</source>
          <target state="translated">Подводя итог,конструктор копирования делает глубокую копию,потому что исходный текст должен оставаться нетронутым.Конструктор перемещения,с другой стороны,может просто скопировать указатель,а затем установить нулевой указатель в исходном тексте.Таким образом можно &quot;обнулить&quot; исходный объект,потому что у клиента нет возможности проверить объект еще раз.</target>
        </trans-unit>
        <trans-unit id="047b60f44c81098eb74095d0ced4e749b86ad68f" translate="yes" xml:space="preserve">
          <source>Turning expensive copies into cheap moves. See my first answer for an example. Note that if an object does not manage at least one external resource (either directly, or indirectly through its member objects), move semantics will not offer any advantages over copy semantics. In that case, copying an object and moving an object means the exact same thing:</source>
          <target state="translated">Превращая дорогие копии в дешевые ходы.Смотрите мой первый ответ в качестве примера.Заметьте,что если объект не управляет хотя бы одним внешним ресурсом (прямо или косвенно через объекты-членов),то семантика перемещения не будет иметь никаких преимуществ перед семантикой копирования.В этом случае копирование объекта и перемещение объекта означает то же самое:</target>
        </trans-unit>
        <trans-unit id="de0430a56abae1a9c8cca4fd7a8b8906769e0636" translate="yes" xml:space="preserve">
          <source>Value categories</source>
          <target state="translated">Категории стоимости</target>
        </trans-unit>
        <trans-unit id="2aa8f4165ecd80aeeeeb890eaf78af1a8a3b401b" translate="yes" xml:space="preserve">
          <source>We now understand that moving from lvalues is potentially dangerous, but moving from rvalues is harmless. If C++ had language support to distinguish lvalue arguments from rvalue arguments, we could either completely forbid moving from lvalues, or at least make moving from lvalues &lt;em&gt;explicit&lt;/em&gt; at call site, so that we no longer move by accident.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь мы понимаем, что переход от lvalues ​​потенциально опасен, но переход от rvalues ​​безвреден. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если бы в C ++ была языковая поддержка, чтобы отличать аргументы lvalue от аргументов rvalue, мы могли бы либо полностью запретить переход от lvalue, либо, по крайней мере, сделать переход от lvalue &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;явным&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на сайте вызова, чтобы мы больше не перемещались случайно.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c91f5982e73d44e7f4a6ccace5726e523643802" translate="yes" xml:space="preserve">
          <source>What do these rules mean in practice?</source>
          <target state="translated">Что означают эти правила на практике?</target>
        </trans-unit>
        <trans-unit id="99565c8cb484efe8d28c4076f67a25e83378c561" translate="yes" xml:space="preserve">
          <source>What have we done here? Instead of deeply copying the heap data, we have just copied the pointer and then set the original pointer to null (to prevent 'delete[]' from source object's destructor from releasing our 'just stolen data'). In effect, we have &quot;stolen&quot; the data that originally belonged to the source string. Again, the key insight is that under no circumstance could the client detect that the source had been modified. Since we don't really do a copy here, we call this constructor a &quot;move constructor&quot;. Its job is to move resources from one object to another instead of copying them.</source>
          <target state="translated">Что мы здесь натворили? Вместо того,чтобы глубоко скопировать кучи данных,мы просто скопировали указатель,а затем установили исходный указатель в ноль (чтобы предотвратить освобождение 'delete[]' из деструктора исходного объекта от наших 'только что украденных данных').Фактически,мы &quot;украли&quot; данные,которые изначально принадлежали исходной строке.Опять же,ключевым моментом является то,что клиент ни при каких обстоятельствах не мог обнаружить,что исходный текст был изменен.Так как мы на самом деле не делаем здесь копию,мы называем этот конструктор &quot;конструктор перемещения&quot;.Его работа заключается в перемещении ресурсов с одного объекта на другой вместо их копирования.</target>
        </trans-unit>
        <trans-unit id="3334057bf5fdd1df4c8a56b5a8bb56d8d08ac48e" translate="yes" xml:space="preserve">
          <source>What is a move?</source>
          <target state="translated">Что такое движение?</target>
        </trans-unit>
        <trans-unit id="ff7bddf15a2315c6021f9e9d0f6b6bce8bcffd35" translate="yes" xml:space="preserve">
          <source>What is move semantics</source>
          <target state="translated">Что такое семантика движения</target>
        </trans-unit>
        <trans-unit id="22b96be030691f90fe9b2e0240432d1d51dae570" translate="yes" xml:space="preserve">
          <source>When such copy/destroy pairs are expensive, it's typically because the object owns some heavyweight resource. For example, &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; may own a dynamically-allocated memory block containing an array of &lt;code&gt;string&lt;/code&gt; objects, each with its own dynamic memory.  Copying such an object is costly: you have to allocate new memory for each dynamically-allocated blocks in the source, and copy all the values across.  &lt;em&gt;Then&lt;/em&gt; you need deallocate all that memory you just copied.  However, &lt;em&gt;moving&lt;/em&gt; a large &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; means just copying a few pointers (that refer to the dynamic memory block) to the destination and zeroing them out in the source.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда такие пары копирования / уничтожения дороги, это обычно потому, что объекту принадлежит какой-то тяжеловесный ресурс. Например, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; может иметь динамически выделяемый блок памяти, содержащий массив &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; объектов, каждый из которых имеет свою собственную динамическую память. Копирование такого объекта является дорогостоящим: вы должны выделить новую память для каждого динамически распределяемого блока в источнике и скопировать все значения по всему. &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Затем&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вам нужно освободить всю память, которую вы только что скопировали. Однако &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;перемещение&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; большого &lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; означает просто копирование нескольких указателей (которые относятся к блоку динамической памяти) к месту назначения и обнуление их в источнике.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9cd78414f15901d8e86a8d3f4a590968adf4da6" translate="yes" xml:space="preserve">
          <source>When the new object is created from the return value, the copy constructor is called to &lt;em&gt;copy&lt;/em&gt; the contents of the temporary object to the new object b. After the function completes, the temporary object used in the function goes out of scope and is destroyed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда новый объект создается из возвращаемого значения, вызывается конструктор &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;копирования&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;копирования&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; содержимого временного объекта в новый объект b. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;После завершения функции временный объект, используемый в функции, выходит из области видимости и уничтожается.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="07a221a0bb57425e9405956022b30340ca656ba4" translate="yes" xml:space="preserve">
          <source>When would you want to do that? well std::vector is an example, say you created a temporary std::vector and you return it from a function say:</source>
          <target state="translated">Когда бы вы захотели это сделать? ну std::vector-это пример,скажем,вы создали временный std::vector и возвращаете его из функции say:</target>
        </trans-unit>
        <trans-unit id="74ec9a380d335c03fb7b287be6ff753162c1a3a7" translate="yes" xml:space="preserve">
          <source>When you write code like this:</source>
          <target state="translated">Когда ты пишешь код вот так:</target>
        </trans-unit>
        <trans-unit id="221b238f8d5a91baf4778e7b3912f0b81807d155" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;move semantics&lt;/strong&gt; it's now possible to make most of this work less unpleasant by simply &lt;em&gt;moving&lt;/em&gt; the data rather than copying.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;семантикой перемещения&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; теперь можно сделать большую часть этой работы менее неприятной, просто &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;перемещая&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; данные, а не копируя.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1e792bfe219381f99de1182972a3fef81354e659" translate="yes" xml:space="preserve">
          <source>With this line, &lt;code&gt;std::move&lt;/code&gt; will cast &lt;code&gt;a&lt;/code&gt; to an rvalue and &lt;code&gt;other_function&lt;/code&gt; will receive the object as a unnamed object. Of course, if &lt;code&gt;other_function&lt;/code&gt; has not specific overloading to work with unnamed objects, this distinction is not important.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С этой строкой &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; приведёт &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; к &lt;/font&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; rvalue, а &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;other_function&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; получит объект как безымянный объект. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Конечно, если &lt;/font&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не имеет специальной перегрузки для работы с неназванными объектами, это различие не имеет значения.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a502ae851780f1ddc7db29441700f146506ebb73" translate="yes" xml:space="preserve">
          <source>Xvalues</source>
          <target state="translated">Xvalues</target>
        </trans-unit>
        <trans-unit id="c39f86b271db60b23e48e49da3c4e77b7bf0f5df" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;parameter&lt;/code&gt; by value. For move-only types like &lt;code&gt;unique_ptr&lt;/code&gt;, it seems there is no established idiom yet. Personally, I prefer pass by value, as it causes less clutter in the interface.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы также можете передать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; по значению. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Похоже, что для &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;типов только для перемещения, таких как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , не существует идиомы. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Лично я предпочитаю передавать по значению, так как это вызывает меньше помех в интерфейсе.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e2f4250ebd2eff63e7f150721d9b86649703b85e" translate="yes" xml:space="preserve">
          <source>You could argue that &lt;code&gt;parameter&lt;/code&gt; is not used anymore after the initialization of &lt;code&gt;member&lt;/code&gt;. Why is there no special rule to silently insert &lt;code&gt;std::move&lt;/code&gt; just as with return values? Probably because it would be too much burden on the compiler implementors. For example, what if the constructor body was in another translation unit? By contrast, the return value rule simply has to check the symbol tables to determine whether or not the identifier after the &lt;code&gt;return&lt;/code&gt; keyword denotes an automatic object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете утверждать, что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; больше не используется после инициализации &lt;/font&gt;&lt;/font&gt; &lt;code&gt;member&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Почему нет специального правила для тихой вставки &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; же, как с возвращаемыми значениями? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Возможно, потому что это будет слишком большой нагрузкой для разработчиков компиляторов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, что, если тело конструктора было в другом модуле перевода? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Напротив, правило возвращаемого значения просто должно проверять таблицы символов, чтобы определить, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обозначает &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ли идентификатор после &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ключевого слова &lt;/font&gt;&lt;/font&gt; &lt;code&gt;return&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; автоматический объект.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3ca8091ddd18805cfc713df7dd75868c9a95f47" translate="yes" xml:space="preserve">
          <source>You know what a copy semantics means right? it means you have types which are copyable, for user-defined types you define this either buy explicitly writing a copy constructor &amp;amp; assignment operator or the compiler generates them implicitly. This will do a copy.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы знаете, что означает семантика копирования? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;это означает, что у вас есть типы, которые можно копировать, для пользовательских типов, которые вы определяете, это либо покупайте явно написав конструктор копирования и оператор присваивания, либо компилятор генерирует их неявно. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это сделает копию.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e2f4bc4c9d48bda3c7ea5e8d13ceacb5e895f12" translate="yes" xml:space="preserve">
          <source>You might expect &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; to only bind to rvalues, because at first glance, it looks like an rvalue reference. As it turns out though, &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; also binds to lvalues:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете ожидать, что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет привязываться только к rvalue, потому что на первый взгляд это похоже на ссылку на rvalue. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как оказалось, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; также привязывается к lvalues:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d33a97176f7badf8aeef43dbd922269578988791" translate="yes" xml:space="preserve">
          <source>You're going to have overhead from the copy constructor when the function returns, if (and it will in C++0x) std::vector has a move constructor instead of copying it can just set it's pointers and 'move' dynamically allocated memory to the new instance. It's kind of like transfer-of-ownership semantics with std::auto_ptr.</source>
          <target state="translated">Когда функция вернется,у вас будут накладные расходы из конструктора копирования,если (и будет в C++0x)std::vector имеет конструктор перемещения,то вместо копирования он может просто устанавливать свои указатели и 'перемещать' динамически выделяемую память для нового экземпляра.Это что-то вроде семантики передачи права собственности с помощью std::auto_ptr.</target>
        </trans-unit>
        <trans-unit id="e21276ab1166e0e62608292fa54445af12932da1" translate="yes" xml:space="preserve">
          <source>an &lt;em&gt;rvalue reference can be moved&lt;/em&gt; and an &lt;em&gt;lvalue&lt;/em&gt; cannot.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ссылку Rvalue можно перемещать&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;именующий&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не может.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="151db36d21b0e8f4a4f6c394902768f00fb00c34" translate="yes" xml:space="preserve">
          <source>then an ordinary C++ compiler will create a temporary object for the result of &lt;code&gt;multiply()&lt;/code&gt;, call the copy constructor to initialise &lt;code&gt;r&lt;/code&gt;, and then destruct the temporary return value. Move semantics in C++0x allow the &quot;move constructor&quot; to be called to initialise &lt;code&gt;r&lt;/code&gt; by copying its contents, and then discard the temporary value without having to destruct it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;затем обычный компилятор C ++ создаст временный объект для результата &lt;/font&gt;&lt;/font&gt; &lt;code&gt;multiply()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , вызовет конструктор копирования, чтобы инициализировать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , а затем уничтожит временное возвращаемое значение. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Семантика перемещения в C ++ 0x позволяет вызывать &amp;laquo;конструктор перемещения&amp;raquo; для инициализации &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; путем копирования его содержимого, а затем отбрасывания временного значения без его уничтожения.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
