<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/3106110">
    <body>
      <group id="3106110">
        <trans-unit id="df0fd2702057b417c35ac16135733ca9fa59293f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::move(some_lvalue)&lt;/code&gt; casts an lvalue to an rvalue, thus enabling a subsequent move.</source>
          <target state="translated">&lt;code&gt;std::move(some_lvalue)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 lvalue를 rvalue로 캐스트하여 후속 이동을 가능하게합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50f6f367eb9f6b3f8bc2138fd21d734104676605" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Move semantics&lt;/strong&gt; is about &lt;strong&gt;transferring resources rather than copying them&lt;/strong&gt; when nobody needs the source value anymore.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 의미론&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 이상 소스 값이 필요하지 않을 때 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자원을 복사하지 않고 자원을 전송하는 것&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6792b6f126f7677728171c0bfe42b4de3714768a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two&lt;/strong&gt; new objects have been constructed, one of which is a temporary object that's only used for the duration of the function.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 개의&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 새로운 객체가 만들어졌으며 그 중 하나는 기능 기간 동안 만 사용되는 임시 객체입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a95152a9e43e530501f6b99af74270415868a62a" translate="yes" xml:space="preserve">
          <source>A named rvalue reference is an lvalue, just like any other variable.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;명명 된 rvalue 참조는 다른 변수와 마찬가지로 lvalue입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f040209caa6e8f4d4e43aa329b98ebb25520ebed" translate="yes" xml:space="preserve">
          <source>A useful example of a function with an &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; parameter is the &lt;em&gt;move constructor&lt;/em&gt;&lt;code&gt;X::X(X&amp;amp;&amp;amp; source)&lt;/code&gt;. Its purpose is to transfer ownership of the managed resource from the source into the current object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 매개 변수가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있는 함수의 유용한 예 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 생성자 &lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;X::X(X&amp;amp;&amp;amp; source)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그 목적은 관리 자원의 소유권을 소스에서 현재 오브젝트로 전송하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abef74394b5449ff6f5131eaf664d8e46d148d79" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;rvalue&lt;/code&gt; reference works pretty much like an &lt;code&gt;lvalue&lt;/code&gt; reference with one important difference:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 참조는 거의처럼 작동 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;lvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 한 가지 중요한 차이 참조 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1400246cab7166daac5095b766ba4438e047c79f" translate="yes" xml:space="preserve">
          <source>An rvalue is a temporary object, which is going to be destroyed at the end of the expression. In current C++, rvalues only bind to &lt;code&gt;const&lt;/code&gt; references. C++1x will allow non-&lt;code&gt;const&lt;/code&gt; rvalue references, spelled &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, which are references to an rvalue objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue는 임시 객체이며 표현식의 끝에서 파괴됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;현재 C ++에서 rvalue는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 참조 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에만 바인딩됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 1x는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue 객체에 대한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조 인 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; rvalue 참조 (맞춤법 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;허용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ec69c00d4b9b0c380efb9f8ecec0d4b04714fba" translate="yes" xml:space="preserve">
          <source>An rvalue of class type is an expression whose evaluation creates a temporary object.
  Under normal circumstances, no other expression inside the same scope denotes the same temporary object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 유형의 rvalue는 평가가 임시 오브젝트를 작성하는 표현식입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정상적인 상황에서 같은 범위 내에있는 다른 표현식은 동일한 임시 개체를 나타내지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3fe43eb5a17970d62352f3daf0ab3389b2294910" translate="yes" xml:space="preserve">
          <source>An rvalue reference &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; is a new kind of reference that only binds to rvalues.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue 참조 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에만 바인딩하는 새로운 종류의 참조입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b951ee76f644338afecca76aa03ce849f6e9a636" translate="yes" xml:space="preserve">
          <source>And what is &lt;strong&gt;perfect forwarding&lt;/strong&gt;? It is important to know that a &quot;rvalue reference&quot; is a reference to a named object in the &quot;caller's scope&quot;. But in the actual scope, a rvalue reference is a name to an object, so, it acts as a named object. If you pass an rvalue reference to another function, you are passing a named object, so, the object isn't received like a temporal object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;완벽한 전달&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이란 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;무엇 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;rvalue reference&quot;는 &quot;caller 's scope&quot;에서 명명 된 객체에 대한 참조라는 것을 알아야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 실제 범위에서 rvalue 참조는 객체의 이름이므로 명명 된 객체로 작동합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue 참조를 다른 함수에 전달하면 명명 된 객체가 전달되므로 객체는 임시 객체처럼 수신되지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cdb7ef1ba819235b13a473fac62029ba510795b0" translate="yes" xml:space="preserve">
          <source>And yet, one of them invokes undefined behavior, whereas the other one does not. So what is the difference between the expressions &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;make_triangle()&lt;/code&gt;? Aren't they both of the same type? Indeed they are, but they have different &lt;em&gt;value categories&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 그중 하나는 정의되지 않은 동작을 호출하는 반면 다른 하나는 정의되지 않은 동작을 호출합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래서 표현식 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 차이점은 무엇 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;둘 다 같은 유형이 아닙니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로, 그들은 서로 다른 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가치 범주&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 가지고 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0eeed3546c92bc7d030625e964a6a1e8f2f93dd1" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;move&lt;/code&gt; accepts any kind of parameter thanks to the forwarding reference &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, and it returns an rvalue reference. The &lt;code&gt;std::remove_reference&amp;lt;T&amp;gt;::type&lt;/code&gt; meta-function call is necessary because otherwise, for lvalues of type &lt;code&gt;X&lt;/code&gt;, the return type would be &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt;, which would collapse into &lt;code&gt;X&amp;amp;&lt;/code&gt;. Since &lt;code&gt;t&lt;/code&gt; is always an lvalue (remember that a named rvalue reference is an lvalue), but we want to bind &lt;code&gt;t&lt;/code&gt; to an rvalue reference, we have to explicitly cast &lt;code&gt;t&lt;/code&gt; to the correct return type.
The call of a function that returns an rvalue reference is itself an xvalue. Now you know where xvalues come from ;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보시다시피, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 전달 참조 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 덕분에 모든 종류의 매개 변수를 허용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하며 rvalue 참조를 반환합니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::remove_reference&amp;lt;T&amp;gt;::type&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 그렇지 형의 lvalues 위해 때문에 메타 함수 호출이 필요 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 리턴 유형 될 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 축소 것이다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . 이후 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; 는&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 항상 좌변입니다 (명명를 rvalue 참조가 좌변 있음을 유의)하지만, 우리가 바인딩 할 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 rvalue 참조에, 우리는 명시 적으로 캐스팅해야 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; 을&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 올바른 리턴 유형으로. rvalue 참조를 리턴하는 함수의 호출 자체는 xvalue입니다. 이제 xvalue의 출처를 알 수 있습니다.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5a6f247186a6ec51d7763851bdd8e18f434a0b74" translate="yes" xml:space="preserve">
          <source>Basically, the compiler will complain that &lt;code&gt;parameter&lt;/code&gt; is an lvalue. If you look at its type, you see an rvalue reference, but an rvalue reference simply means &quot;a reference that is bound to an rvalue&quot;; it does &lt;em&gt;not&lt;/em&gt; mean that the reference itself is an rvalue! Indeed, &lt;code&gt;parameter&lt;/code&gt; is just an ordinary variable with a name. You can use &lt;code&gt;parameter&lt;/code&gt; as often as you like inside the body of the constructor, and it always denotes the same object. Implicitly moving from it would be dangerous, hence the language forbids it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본적으로 컴파일러는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 lvalue &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;라고 불평합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;유형을 보면 rvalue 참조가 표시되지만 rvalue 참조는 단순히 &quot;rvalue에 바인딩 된 참조&quot;를 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조 자체가 rvalue라는 의미 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아닙니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 이름을 가진 일반 변수 일뿐입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;생성자의 본문 내에서 원하는만큼 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용할 수 있으며 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;항상 같은 개체를 나타냅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;암시 적으로 이동하면 위험하므로 언어에서 금지합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e378544bfb07451e6088433236851c65b1e84876" translate="yes" xml:space="preserve">
          <source>Because the function also &lt;em&gt;returns by value&lt;/em&gt;, another new object is constructed for the return value:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 함수는 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;value&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로도 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리턴&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하므로 리턴 값에 대해 또 다른 새 오브젝트가 구성됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e819a9290ce3be37f7d22e748fce09e94c70c736" translate="yes" xml:space="preserve">
          <source>Both prvalues and xvalues are rvalues. Xvalues and lvalues are both &lt;em&gt;glvalues&lt;/em&gt; (Generalized lvalues). The relationships are easier to grasp with a diagram:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;prvalue와 xvalue는 모두 rvalue입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;X 값과 l 값은 모두 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;glvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (일반화 된 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;l 값&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다이어그램으로 관계를 파악하기가 더 쉽습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef1b8b9546c894e61fe1d619148e7bed5cc0fc49" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;auto_ptr&lt;/code&gt; is not &lt;em&gt;always&lt;/em&gt; dangerous. Factory functions are a perfectly fine use case for &lt;code&gt;auto_ptr&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;항상&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 위험한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;것은 아닙니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;팩토리 함수는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 완벽한 사용 사례입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e6a400bc51fb91373f9c57144a4bd019862c564" translate="yes" xml:space="preserve">
          <source>But if you say &lt;code&gt;a = x + y&lt;/code&gt;, the &lt;em&gt;move constructor&lt;/em&gt; will initialize &lt;code&gt;that&lt;/code&gt; (because the expression &lt;code&gt;x + y&lt;/code&gt; is an rvalue), so there is no deep copy involved, only an efficient move.
&lt;code&gt;that&lt;/code&gt; is still an independent object from the argument, but its construction was trivial,
since the heap data didn't have to be copied, just moved. It wasn't necessary to copy it because &lt;code&gt;x + y&lt;/code&gt; is an rvalue, and again, it is okay to move from string objects denoted by rvalues.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a = x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하면 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 생성자&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가이를 초기화 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (표현식 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 rvalue이기 때문에). &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 여전히 인수와는 독립적 인 객체이지만 힙 데이터를 복사 할 필요가 없으므로 이동하기 때문에 구성이 간단했습니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 rvalue &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이므로 복사 할 필요가 없으며 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue로 표시된 문자열 객체에서 이동해도됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="32822acac85aaeec4278db58d224f2fe9f3f352c" translate="yes" xml:space="preserve">
          <source>But, is that not dangerous? Of course, you could destruct a dynamic object twice (segmentation fault). So, to avoid that, you should &quot;invalidate&quot; the source pointers to avoid destructing them twice:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 위험하지 않습니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 동적 객체를 두 번 파괴 할 수 있습니다 (세그먼트 결함). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서이를 피하려면 소스 포인터를 &quot;무효화&quot;하여 두 번 파괴하지 않도록해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c8a8d115ca80240745b86fe8f011228ba83a9e3b" translate="yes" xml:space="preserve">
          <source>C++0x introduces a new mechanism called &quot;rvalue reference&quot; which, among other things,
allows us to detect rvalue arguments via function overloading. All we have to do is write a constructor with an rvalue reference parameter. Inside that constructor we can do &lt;em&gt;anything we want&lt;/em&gt; with the source, as long as we leave it in &lt;em&gt;some&lt;/em&gt; valid state:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 0x는 무엇보다도 함수 오버로딩을 통해 rvalue 인수를 감지 할 수있는 &quot;rvalue reference&quot;라는 새로운 메커니즘을 도입했습니다. rvalue 참조 매개 변수를 사용하여 생성자를 작성하기 만하면됩니다. 그 생성자 내부에서 우리가 할 수있는 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리가 원하는 무엇이든&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 우리가 그것을두고만큼으로, 소스와 함께 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;몇 가지&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 유효한 상태 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd0492dc5e0b6d5d91433b74385064b17d458bf4" translate="yes" xml:space="preserve">
          <source>C++11's answer to this problem is &lt;em&gt;rvalue references&lt;/em&gt;. An rvalue reference is a new kind of reference that only binds to rvalues, and the syntax is &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt;. The good old reference &lt;code&gt;X&amp;amp;&lt;/code&gt; is now known as an &lt;em&gt;lvalue reference&lt;/em&gt;. (Note that &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a reference to a reference; there is no such thing in C++.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 문제에 대한 C ++ 11의 대답은 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue reference&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue 참조는 rvalue에만 바인딩하는 새로운 종류의 참조이며 구문은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;좋은 오래된 참조 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 이제 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lvalue 참조&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 알려져 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(참고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 참조에 대한 참조;. 그런 일이 C에 없다가 ++)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="023a6a48d15ef2c95fc40e5be2aa59fe9b54efad" translate="yes" xml:space="preserve">
          <source>C++98 implicitly declares three special member functions on demand, that is, when they are needed somewhere: the copy constructor, the copy assignment operator and the destructor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98은 필요에 따라 즉, 복사 생성자, 복사 할당 연산자 및 소멸자 등 3 개의 특수 멤버 함수를 암시 적으로 선언합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c779770f0201fc38c70bf3c75d9a6f84752c9e0a" translate="yes" xml:space="preserve">
          <source>C++98 rvalues are known as prvalues in C++11. Mentally replace all occurrences of &quot;rvalue&quot; in the preceding paragraphs with &quot;prvalue&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98 rvalue는 C ++ 11에서 prvalue로 알려져 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이전 단락에서 &quot;rvalue&quot;를 모두 &quot;prvalue&quot;로 바꿉니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="132f3ce3182bbd08fe44f45ff771c82759cf58e2" translate="yes" xml:space="preserve">
          <source>Congratulations, you now understand the basics of move semantics! Let's continue by implementing the assignment operator. If you're unfamiliar with the &lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;copy and swap idiom&lt;/a&gt;, learn it and come back, because it's an awesome C++ idiom related to exception safety.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;축하합니다. 이제 이동 의미의 기본을 이해했습니다! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;할당 연산자를 구현하여 계속합시다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;copy and swap 관용구에&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 익숙하지 않은 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예외 안전과 관련된 멋진 C ++ 관용구이기 때문에 그것을 배우고 다시 오십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec6e7926adcc44088c147ea22db81f9c26b87174" translate="yes" xml:space="preserve">
          <source>Consider the following function template:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 함수 템플릿을 고려하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a22158725623f7c0e74173ef7dccec9292a51ae4" translate="yes" xml:space="preserve">
          <source>Copying an object means copying its &quot;static&quot; members and calling the &lt;code&gt;new&lt;/code&gt; operator for its dynamic objects. Right?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체를 복사한다는 것은 &quot;정적&quot;멤버를 복사 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하고 동적 객체에 대해 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 연산자를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;호출하는 것을 의미 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;권리?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4bd58a0d0236432df5def76d9e83073103fc10f" translate="yes" xml:space="preserve">
          <source>Dangerous and harmless moves</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위험하고 무해한 움직임&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8cdb90911daa2d1059f97197edc4cbc56200db7d" translate="yes" xml:space="preserve">
          <source>Depending on the class, maybe its a container with very much data, then that could represent much &lt;em&gt;time&lt;/em&gt; and &lt;em&gt;memory usage&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스에 따라 데이터가 많은 컨테이너 일 수 있으며 많은 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시간&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 사용을&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 나타낼 수 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da91507e4d455dd873c3a8569cb70baddddfd087" translate="yes" xml:space="preserve">
          <source>Forwarding references (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf&quot;&gt;previously&lt;/a&gt; known as &lt;em&gt;Universal references&lt;/em&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조를 전달 ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이전&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 으로 알려진 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;유니버설 참조&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b55f1baad0eb4d648fab85d1a0b7b027bc44527" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/move_constructor&quot;&gt;cppreference.com&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/move_constructor&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cppreference.com&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9831a9d72fc41bc7b1a34c6df1cc9330199f0d3" translate="yes" xml:space="preserve">
          <source>Here is how you explicitly move from an lvalue:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lvalue에서 명시 적으로 이동하는 방법은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ad658fc75be5325793f2c751d9cbdad9efe908d2" translate="yes" xml:space="preserve">
          <source>Here's a function that takes an object of type &lt;code&gt;T&lt;/code&gt; and returns an object of the same type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 유형의 객체를 가져와 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;같은 유형 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 객체를 반환하는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;함수입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="472a84ed15750c08597c803026e48d9c509d8f33" translate="yes" xml:space="preserve">
          <source>How come the move constructor accepts the lvalue &lt;code&gt;result&lt;/code&gt; as an argument? The scope of &lt;code&gt;result&lt;/code&gt; is about to end, and it will be destroyed during stack unwinding. Nobody could possibly complain afterwards that &lt;code&gt;result&lt;/code&gt; had changed somehow; when control flow is back at the caller, &lt;code&gt;result&lt;/code&gt; does not exist anymore! For that reason, C++11 has a special rule that allows returning automatic objects from functions without having to write &lt;code&gt;std::move&lt;/code&gt;. In fact, you should &lt;em&gt;never&lt;/em&gt; use &lt;code&gt;std::move&lt;/code&gt; to move automatic objects out of functions, as this inhibits the &quot;named return value optimization&quot; (NRVO).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 생성자는 lvalue &lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 인수로 어떻게 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;받아들 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니까? &lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 범위 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 곧 끝나고 스택 해제 중에 파괴됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그 이후에는 그 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 어떻게 든 변했다고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아무도 불평 할 수 없었다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;제어 흐름이 호출자에게 돌아 오면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 이상 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 존재하지 않습니다! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 C ++ 11에는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 쓰지 않고도 함수에서 자동 객체를 반환 할 수있는 특수 규칙이 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는 &quot;명명 된 리턴 값 최적화&quot;(NRVO)를 금지하므로 &lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하여 자동 오브젝트를 함수 밖으로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시키지 마십시오&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b78fb8d2a72d70a2b646e5838f76a391fca0bd1" translate="yes" xml:space="preserve">
          <source>However, to &lt;strong&gt;move&lt;/strong&gt; an object (I repeat, in a practical point of view) implies only to copy the pointers of dynamic objects, and not to create new ones.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 한다는 것은 (실제적인 관점에서 반복합니다) 동적 객체의 포인터를 복사하는 것만 의미하며 새로운 객체는 만들지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be9d897b4ed75e9712b0896110f82792f56d7b57" translate="yes" xml:space="preserve">
          <source>Huh, that's it? &quot;Where's the rvalue reference?&quot; you might ask. &quot;We don't need it here!&quot; is my answer :)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;허, 그게 다야? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;rvalue 참조는 어디에 있습니까?&quot; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신은 요청할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;여기 필요하지 않습니다!&quot; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 대답은 :)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dcad3bfb835bd226281cdb3832ed9fbd595b0efa" translate="yes" xml:space="preserve">
          <source>I find it easiest to understand move semantics with example code. Let's start with a very simple string class which only holds a pointer to a heap-allocated block of memory:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예제 코드로 이동 의미를 이해하는 것이 가장 쉽다는 것을 알았습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;힙 할당 메모리 블록에 대한 포인터 만 포함하는 매우 간단한 문자열 클래스부터 시작하겠습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="55918cb4dcbdcb99697ef67c5bfaed72dce39cdf" translate="yes" xml:space="preserve">
          <source>I hope this example got the main point across. There is a lot more to rvalue references and move semantics which I intentionally left out to keep it simple. If you want more details please see &lt;a href=&quot;https://stackoverflow.com/a/11540204/179917&quot;&gt;my supplementary answer&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 예제가 주요 요점을 갖기를 바랍니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조를 rvalue하고 의미를 이동시키는 데 더 많은 것이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 자세한 내용을 원하면 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/11540204/179917&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;제 보충 답변을&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 참조하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e26477129fa8f03bbac0d3249cb6cbea6421174" translate="yes" xml:space="preserve">
          <source>I just finished listening to the Software Engineering radio &lt;a href=&quot;http://www.se-radio.net/2010/04/episode-159-c-0x-with-scott-meyers/&quot;&gt;podcast interview with Scott Meyers&lt;/a&gt; regarding &lt;a href=&quot;http://en.wikipedia.org/wiki/C++11&quot;&gt;C++0x&lt;/a&gt;. Most of the new features made sense to me, and I am actually excited about C++0x now, with the exception of one. I still don't get &lt;em&gt;move semantics&lt;/em&gt;... What is it exactly?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/C++11&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 0x&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 관한 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.se-radio.net/2010/04/episode-159-c-0x-with-scott-meyers/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Scott Meyers와의&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 소프트웨어 엔지니어링 라디오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;팟 캐스트 인터뷰&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 막 끝냈습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;새로운 기능의 대부분은 나에게 의미가 있었고, 실제로는 C ++ 0x에 대해 매우 기쁘게 생각합니다. 하나는 예외입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 여전히 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 의미론을&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 얻지 못합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;... 정확히 무엇입니까?&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="adf922abf7820e8db1f54450dd73fbd3b62dfdc5" translate="yes" xml:space="preserve">
          <source>I'm writing this to make sure I understand it properly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 이것을 올바르게 이해하기 위해 이것을 쓰고 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea09e01c3b05274835a4c830a79abe380ae9f1ce" translate="yes" xml:space="preserve">
          <source>If the argument is an rvalue of type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; is deduced to be &lt;code&gt;X&lt;/code&gt;, hence &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; means &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt;. This is what anyone would expect.
But if the argument is an lvalue of type &lt;code&gt;X&lt;/code&gt;, due to a special rule, &lt;code&gt;T&lt;/code&gt; is deduced to be &lt;code&gt;X&amp;amp;&lt;/code&gt;, hence &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; would mean something like &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt;. But since C++ still has no notion of references to references, the type &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; is &lt;em&gt;collapsed&lt;/em&gt; into &lt;code&gt;X&amp;amp;&lt;/code&gt;. This may sound confusing and useless at first, but reference collapsing is essential for &lt;em&gt;perfect forwarding&lt;/em&gt; (which will not be discussed here).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인수가 입력 r- 수치의 경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; 는&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; 는&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 것으로 추론된다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 따라서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 수단 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . 이것은 누구나 기대할 수있는 것입니다. 그러나 인수가 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 유형의 lvalue 인 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경우 특별한 규칙으로 인해 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 추정 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;되므로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 같은 것을 의미합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 그러나 C 이후 ++ 여전히 참조에 대한 참조의 아무 개념이없는, 타입 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 되어 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;붕괴&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . 처음에는 혼란스럽고 쓸모없는 것처럼 들릴 수 있지만 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;완벽한 전달을&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 위해서는 참조 축소가 필수적입니다.&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (여기서는 설명하지 않습니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eaf342f5b650317d7bfa03afecf3ae79d590c46f" translate="yes" xml:space="preserve">
          <source>If we throw &lt;code&gt;const&lt;/code&gt; into the mix, we already have four different kinds of references. What kinds of expressions of type &lt;code&gt;X&lt;/code&gt; can they bind to?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 믹스를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;던지면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이미 네 가지 종류의 레퍼런스가 있습니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 유형의 어떤 종류의 표현식을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;바인딩 할 수 있습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ff4084df9c7bfd662c531429fd1f1577ffe7f6b" translate="yes" xml:space="preserve">
          <source>If you are really interested in a good, in-depth explanation of move semantics, I'd highly recommend reading the original paper on them, &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm&quot;&gt;&quot;A Proposal to Add Move Semantics Support to the C++ Language.&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 의미에 대한 심도 있고 깊이있는 설명에 관심이 있다면 &lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;C ++ 언어에 이동 의미 지원을 추가하기위한 제안&quot;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 원본 논문을 읽어 보는 것이 좋습니다 &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1199d462777552484944164f0bb197d84758ee45" translate="yes" xml:space="preserve">
          <source>If you want to constrain a function template to rvalues, you can combine &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/sfinae&quot;&gt;SFINAE&lt;/a&gt; with type traits:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;함수 템플릿을 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/sfinae&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 제한하려는 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SFINAE&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 유형 특성과 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결합 할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6da7cd499914cd7d580cba25f4db0148f6ddfea4" translate="yes" xml:space="preserve">
          <source>If you write a class without unmanaged resources, there is no need to declare any of the five special member functions yourself, and you will get correct copy semantics and move semantics for free. Otherwise, you will have to implement the special member functions yourself. Of course, if your class does not benefit from move semantics, there is no need to implement the special move operations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;관리되지 않는 리소스가없는 클래스를 작성하는 경우 5 개의 특수 멤버 함수를 직접 선언 할 필요가 없으며 올바른 카피 시맨틱을 가져오고 시맨틱을 무료로 이동할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇지 않으면 특수 멤버 함수를 직접 구현해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 클래스가 이동 의미론의 이점을 얻지 못하면 특수 이동 작업을 구현할 필요가 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="937ed34b756d18c282b5b2e827b2ade63aff5ec5" translate="yes" xml:space="preserve">
          <source>If your object is complex and the destructor has other secondary effects, like calling to a library's function, calling to other global functions or whatever it is, perhaps is better to signal a movement with a flag:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체가 복잡하고 소멸자가 라이브러리 함수 호출, 다른 전역 함수 호출 또는 그 밖의 다른 함수와 같은 다른 보조 효과가있는 경우 플래그로 움직임을 알리는 것이 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a9339c8c4d94e2f90667ec0345c001b70cea00e" translate="yes" xml:space="preserve">
          <source>Implementation of move</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이사 이행&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="52c0adee2f966c6d6cae560ab2e2d18938668573" translate="yes" xml:space="preserve">
          <source>Implementing safe &quot;move-only&quot; types; that is, types for which copying does not make sense, but moving does.  Examples include locks, file handles, and smart pointers with unique ownership semantics. Note: This answer discusses &lt;code&gt;std::auto_ptr&lt;/code&gt;, a deprecated C++98 standard library template, which was replaced by &lt;code&gt;std::unique_ptr&lt;/code&gt; in C++11. Intermediate C++ programmers are probably at least somewhat familiar with &lt;code&gt;std::auto_ptr&lt;/code&gt;, and because of the &quot;move semantics&quot; it displays, it seems like a good starting point for discussing move semantics in C++11. YMMV.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;안전한 &quot;이동 전용&quot;유형 구현 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 복사가 의미가 없지만 이동하는 유형입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;고유 소유권 의미론을 가진 잠금, 파일 핸들 및 스마트 포인터가 그 예입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참고 :이 답변 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 더 이상 사용되지 않는 C ++ 98 표준 라이브러리 템플릿 인 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대해 설명 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하며 C ++ 11에서는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 대체되었습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;중급 C ++ 프로그래머는 아마도 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대해 어느 정도 익숙 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;할 것입니다. 그리고 표시되는 &quot;이동 시맨틱&quot;때문에 C ++ 11의 이동 시맨틱을 논의하기에 좋은 출발점처럼 보입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;YMMV.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a454cb8b77503090cbd9a357441f356bcc77421b" translate="yes" xml:space="preserve">
          <source>Implicit conversions</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;암시 적 변환&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bb86577e32db06fdf51943d408f139502900a7ec" translate="yes" xml:space="preserve">
          <source>In C++03, objects are often copied, only to be destroyed or assigned-over before any code uses the value again.  For example, when you return by value from a function&amp;mdash;unless RVO kicks in&amp;mdash;the value you're returning is copied to the caller's stack frame, and then it goes out of scope and is destroyed.  This is just one of many examples: see pass-by-value when the source object is a temporary, algorithms like &lt;code&gt;sort&lt;/code&gt; that just rearrange items, reallocation in &lt;code&gt;vector&lt;/code&gt; when its &lt;code&gt;capacity()&lt;/code&gt; is exceeded, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 03에서는 객체가 종종 복사되며 코드에서 값을 다시 사용하기 전에 소멸되거나 할당됩니다. 예를 들어, RVO가 시작되지 않는 한 함수에서 값으로 반환하면 반환하는 값이 호출자의 스택 프레임에 복사 된 다음 범위를 벗어나 파괴됩니다. 이것은 많은 예 중 하나입니다. 소스 객체가 일시적인 경우 값으로 전달, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;항목을 다시 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sort&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정렬&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;같은&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 알고리즘 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, &lt;/font&gt; &lt;code&gt;capacity()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 초과 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;되면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 재 할당 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;등을 참조하십시오.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3a5b25589cda5ecaab0c938846dc8a956cfda45" translate="yes" xml:space="preserve">
          <source>In C++11, &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; has been replaced by &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; which takes advantage of rvalue references. I will develop and discuss a simplified version of &lt;code&gt;unique_ptr&lt;/code&gt;. First, we encapsulate a raw pointer and overload the operators &lt;code&gt;-&amp;gt;&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, so our class feels like a pointer:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue 참조를 이용하는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 대체되었습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 단순화 된 버전을 개발하고 논의 할 것 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;먼저 원시 포인터를 캡슐화하고 연산자 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 오버로드 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하므로 클래스는 포인터처럼 느껴집니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c090c2258bd3627e3ec4d8b649121749fe3c3bd" translate="yes" xml:space="preserve">
          <source>In easy (practical) terms:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;쉬운 (실제적인) 용어로 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b398d9ad5637d0de4ed8f0bf75e5761b7e55916e" translate="yes" xml:space="preserve">
          <source>In languages which do not allow the creation of local objects (that is, objects on the stack) these types of problems do not occur as all objects are allocated on the heap and are always accessed by reference.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로컬 객체 (스택의 객체)를 만들 수없는 언어에서는 모든 객체가 힙에 할당되고 항상 참조로 액세스되므로 이러한 유형의 문제는 발생하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="27637ef20b376dcf19cbb5d2e6d093390e3f522d" translate="yes" xml:space="preserve">
          <source>In practice, you can forget about &lt;code&gt;const X&amp;amp;&amp;amp;&lt;/code&gt;. Being restricted to read from rvalues is not very useful.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 잊어 버릴 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue에서 읽도록 제한되는 것은 그리 유용하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1103ccac7d3cbd997a56ab0386ee5fb290dec2d2" translate="yes" xml:space="preserve">
          <source>In that situation, an anonymous object is created, next copied to the function parameter, and afterwards deleted. So, here it is better to move the object, because you don't need the anonymous object and you can save time and memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 경우 익명 오브젝트가 작성되고 다음에 함수 매개 변수에 복사 된 후 삭제됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 익명 객체가 필요하지 않고 시간과 메모리를 절약 할 수 있으므로 객체를 이동하는 것이 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="43e85843d22aecda603952ad3f28eb8d579f2003" translate="yes" xml:space="preserve">
          <source>In the above code, with old compilers the result of &lt;code&gt;f()&lt;/code&gt; is &lt;strong&gt;&lt;em&gt;copied&lt;/em&gt;&lt;/strong&gt; into &lt;code&gt;x&lt;/code&gt; using &lt;code&gt;X&lt;/code&gt;'s copy constructor. If your compiler supports move semantics and &lt;code&gt;X&lt;/code&gt; has a move-constructor, then that is called instead. Since its &lt;code&gt;rhs&lt;/code&gt; argument is an &lt;em&gt;rvalue&lt;/em&gt;, we know it's not needed any longer and we can steal its value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이전 컴파일러 코드 위의 결과에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 되는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복사&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하여 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 복사 생성자한다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일러가 이동 의미론을 지원하고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 이동 생성자가 있으면 대신 호출됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그 이후 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;rhs&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 인수가이다 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 rvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 우리는 더 이상 필요하지 않은 것을 알고 우리는 그 가치를 훔칠 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da927e9aca357b1650ec6103ca59d8bb2cb33301" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;&quot;hello world&quot;&lt;/code&gt; is an lvalue of type &lt;code&gt;const char[12]&lt;/code&gt;. Since there is an implicit conversion from &lt;code&gt;const char[12]&lt;/code&gt; through &lt;code&gt;const char*&lt;/code&gt; to &lt;code&gt;std::string&lt;/code&gt;, a temporary of type &lt;code&gt;std::string&lt;/code&gt; is created, and &lt;code&gt;r&lt;/code&gt; is bound to that temporary. This is one of the cases where the distinction between rvalues (expressions) and temporaries (objects) is a bit blurry.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위의 예에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;hello world&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char[12]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 유형의 lvalue입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 암시 적으로 변환하기 때문에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char[12]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 내지 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입력의 임시 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 생성되고, 그리고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 그 임시로 결합된다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 rvalue (표현식)와 임시 (객체)의 구분이 약간 모호한 경우 중 하나입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc3e683553dc45c7f890c6646a6841181eb6dec4" translate="yes" xml:space="preserve">
          <source>In this case, when an object of type &lt;code&gt;A&lt;/code&gt; should be &quot;copied&quot;, the compiler creates a lvalue reference or a rvalue reference according to if the passed object is named or not. When not, your move-constructor is called and you know the object is temporal and you can move its dynamic objects instead of copying them, saving space and memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 유형 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 객체를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;복사&quot;해야 할 경우 컴파일러는 전달 된 객체의 이름이 지정되었는지 여부에 따라 lvalue 참조 또는 rvalue 참조를 만듭니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇지 않은 경우 이동 생성자가 호출되고 객체가 시간적이라는 것을 알고 동적 객체를 복사하는 대신 이동하여 공간과 메모리를 절약 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="d04bb2623f5288427463db7edef0eb602a9ed94a" translate="yes" xml:space="preserve">
          <source>Is that perfect forwarding? Not, but we are very close. Perfect forwarding is only useful to work with templates, with the purpose to say: if I need to pass an object to another function, I need that if I receive a named object, the object is passed as a named object, and when not, I want to pass it like a unnamed object:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;완벽한 전달인가요? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아닙니다. 그러나 우리는 매우 가깝습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;퍼펙트 포워딩은 다음과 같은 목적으로 템플릿 작업에만 유용합니다. 객체를 다른 함수에 전달해야하는 경우 명명 된 객체를 수신하면 객체가 명명 된 객체로 전달되고 그렇지 않은 경우에는 명명되지 않은 객체처럼 전달하고 싶습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="697f3bc7df8e26b6f96ff8496435e846fe70c4d6" translate="yes" xml:space="preserve">
          <source>It is important to remember that &quot;static&quot; objects are always copied. There's no ways to &quot;move&quot; a static object (object in stack and not on heap). So, the distinction &quot;move&quot;/ &quot;copy&quot; when an object has no dynamic members (directly or indirectly) is irrelevant.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;정적&quot;객체는 항상 복사된다는 것을 기억해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정적 객체 (스택이 아닌 스택의 객체)를 &quot;이동&quot;할 수있는 방법이 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 개체에 (직접 또는 간접적으로) 동적 멤버가없는 경우 &quot;이동&quot;/ &quot;복사&quot;구분은 중요하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9d98f8e9d5357e09bdb4ad11e6dbd887aa316f7" translate="yes" xml:space="preserve">
          <source>It must first initialize the object, then copy all the relevant data from the old object to the new one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;먼저 개체를 초기화 한 다음 모든 관련 데이터를 이전 개체에서 새 개체로 복사해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3203ece5d832b88a426ed868437b3f103470fad2" translate="yes" xml:space="preserve">
          <source>It's like copy semantics, but instead of having to duplicate all of the data you get to steal the data from the object being &quot;moved&quot; from.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 복사 의미론과 비슷하지만 모든 데이터를 복제하는 대신 &quot;이동&quot;중인 객체에서 데이터를 훔쳐 야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90e6d34c95a16f345f4e07cab166d7088702a308" translate="yes" xml:space="preserve">
          <source>It's very accessible and easy to read and it makes an excellent case for the benefits that they offer.  There are other more recent and up to date papers about move semantics available on &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/&quot;&gt;the WG21 website&lt;/a&gt;, but this one is probably the most straightforward since it approaches things from a top-level view and doesn't get very much into the gritty language details.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;접근하기 쉽고 읽기 쉬우 며 제공하는 이점에 대한 훌륭한 사례입니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;WG21 웹 사이트&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용할 수있는 이동 의미론에 대한 최신의 최신 문서가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있지만,이 문서는 최상위 수준의 관점에서 접근 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하고 엉뚱한&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 언어 세부 정보에 많이 들어 가지 않기 때문에 가장 간단합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3214661671ef9aff8765af8c7d203ac41c5e3e99" translate="yes" xml:space="preserve">
          <source>Move assignment operators</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;할당 연산자 이동&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76c87719ef4631d051ec31847319db90f2a38c3c" translate="yes" xml:space="preserve">
          <source>Move constructors</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;생성자 이동&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="21df78e8312204ee0ae1344d1d1244c5ab2567b2" translate="yes" xml:space="preserve">
          <source>Move semantics allows an object, under certain conditions, to take ownership of some other object's external resources. This is important in two ways:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 의미론은 특정 조건에서 객체가 다른 객체의 외부 리소스를 소유 할 수 있도록합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 두 가지 방식으로 중요합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff2c5f0ff5c8b72e423fa0fe0eb25bf31e14356c" translate="yes" xml:space="preserve">
          <source>Move semantics are based on &lt;strong&gt;&lt;em&gt;rvalue references&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 의미론은 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue 참조를&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 기반으로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b1fd88c02c0af8c30b9a31838ee4311178338b21" translate="yes" xml:space="preserve">
          <source>Move semantics is basically a user-defined type with constructor that takes an r-value reference (new type of reference using &amp;amp;&amp;amp; (yes two ampersands)) which is non-const, this is called a move constructor, same goes for assignment operator. So what does a move constructor do, well instead of copying memory from it's source argument it 'moves' memory from the source to the destination.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 의미론은 기본적으로 r- 값 참조 (&amp;amp;&amp;amp; (예 : 두 앰퍼샌드를 사용하는 새로운 유형의 참조)를 사용하는 생성자가있는 사용자 정의 유형이며, 이는 상수가 아니며 이동 생성자라고하며 할당 연산자와 동일합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 이동 생성자가 수행하는 작업은 소스 인수에서 메모리를 복사하는 대신 소스에서 대상으로 메모리를 '이동'합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60affa9a44a9bad8c292beedae93936057dc4f21" translate="yes" xml:space="preserve">
          <source>Move semantics were created to avoid the unnecessary copying of large objects.  Bjarne Stroustrup in his book &quot;The C++ Programming Language&quot; uses two examples where unnecessary copying occurs by default: one, the swapping of two large objects, and two, the returning of a large object from a method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대형 객체의 불필요한 복사를 피하기 위해 이동 의미론이 작성되었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bjarne Stroustrup은 자신의 저서 &quot;C ++ Programming Language&quot;에서 기본적으로 불필요한 복사가 발생하는 두 가지 예를 사용합니다. 하나는 두 개의 큰 객체를 교체하고 두 번째는 메소드에서 큰 객체를 반환합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f19144fcd990c500b4ac693c567a9549f27dfd2c" translate="yes" xml:space="preserve">
          <source>Moving from lvalues</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lvalue에서 이동&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d64e12206734f5c30656ba8ea9b5782042bd423a" translate="yes" xml:space="preserve">
          <source>Moving from lvalues such as &lt;code&gt;a&lt;/code&gt; is dangerous, because we could later try to call a member function via &lt;code&gt;a&lt;/code&gt;, invoking undefined behavior. On the other hand, moving from rvalues such as &lt;code&gt;make_triangle()&lt;/code&gt; is perfectly safe, because after the copy constructor has done its job, we cannot use the temporary again. There is no expression that denotes said temporary; if we simply write &lt;code&gt;make_triangle()&lt;/code&gt; again, we get a &lt;em&gt;different&lt;/em&gt; temporary. In fact, the moved-from temporary is already gone on the next line:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;같은 lvalues에서 이동 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 우리가 나중에 통해 멤버 함수를 호출 할 수 있기 때문에, 위험 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정의되지 않은 동작을 호출. 반면, &lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 같은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 이동하는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;것은 완벽하게 안전합니다. 복사 생성자가 작업을 수행 한 후에는 임시를 다시 사용할 수 없기 때문입니다. 상기 임시를 나타내는 표현은 없다; 단순히 &lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 다시 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작성 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하면 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 임시 값을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;얻게 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;됩니다. 실제로 이동 한 임시는 이미 다음 줄에 있습니다.&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a63742120d0d7b0e09c3bb18048c15fda0b0e774" translate="yes" xml:space="preserve">
          <source>Moving into members</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;회원으로 이동&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="55a56ac4401dd0eaa2dcf2e8a8396e846706642c" translate="yes" xml:space="preserve">
          <source>Moving out of functions</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기능에서 벗어나기&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2a77a62dac1e84715dce30b39e1eca21de49ebaa" translate="yes" xml:space="preserve">
          <source>Moving the data involves re-associating the data with the new object. And &lt;em&gt;no copy takes place&lt;/em&gt; at all.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터를 이동하려면 데이터를 새 개체와 다시 연결해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전혀 사본이 없습니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="694f6377ae54f3d5a6a8d632f41c5ee6694d13aa" translate="yes" xml:space="preserve">
          <source>My first answer was an extremely simplified introduction to move semantics, and many details were left out on purpose to keep it simple.
However, there is a lot more to move semantics, and I thought it was time for a second answer to fill the gaps.
The first answer is already quite old, and it did not feel right to simply replace it with a completely different text. I think it still serves well as a first introduction. But if you want to dig deeper, read on :)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;첫 번째 대답은 의미 체계를 이동하는 매우 간단한 소개였으며 단순하게 유지하기 위해 많은 세부 사항이 생략되었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 의미론을 옮기는 것이 훨씬 더 많으며 두 번째 대답이 차이를 메울 시간이라고 생각했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;첫 번째 대답은 이미 오래되었지만 완전히 다른 텍스트로 간단히 바꾸는 것이 옳지 않았습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 그것이 여전히 첫 번째 소개 역할을한다고 생각합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 더 깊이 파고 싶다면 다음을 읽으십시오. :)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2273c40caec113ed4c70f21b9c59f72191a4ef03" translate="yes" xml:space="preserve">
          <source>Never return automatic objects by rvalue reference. Moving is exclusively performed by the move constructor, not by &lt;code&gt;std::move&lt;/code&gt;, and not by merely binding an rvalue to an rvalue reference.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue 참조로 자동 객체를 반환하지 마십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue를 rvalue 참조에 바인딩하는 것이 아니라 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 아니라 move 생성자에 의해 독점적으로 수행됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c87b215e468265e84456567f5fd96732627b217" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;std::move&lt;/code&gt; to move automatic objects out of functions.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하여 자동 객체를 기능 밖으로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하지 마십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5620a89fc44e99a7e64f46bd1660b0fe78ec31ff" translate="yes" xml:space="preserve">
          <source>Note how both examples follow the same syntactic pattern:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 예제 모두 동일한 구문 패턴을 따르는 방법에 유의하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ffaa4649e35625dc8efbe19265d4da4843b9b9e" translate="yes" xml:space="preserve">
          <source>Note how the initialization of &lt;code&gt;b&lt;/code&gt; with &lt;code&gt;a&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; copy the triangle, but instead transfers the ownership of the triangle from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;. We also say &quot;&lt;code&gt;a&lt;/code&gt; is &lt;em&gt;moved into&lt;/em&gt;&lt;code&gt;b&lt;/code&gt;&quot; or &quot;the triangle is &lt;em&gt;moved&lt;/em&gt; from &lt;code&gt;a&lt;/code&gt;&lt;em&gt;to&lt;/em&gt;&lt;code&gt;b&lt;/code&gt;&quot;. This may sound confusing, because the triangle itself always stays at the same place in memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;b&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;초기화 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하면 삼각형이 복사 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;되지 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;않고&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대신 삼각형의 소유권이 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 전송되는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;방법에 유의하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 또한 &quot;라고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 됩니다 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로 이동 &lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;삼각형입니다 &quot;또는 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에 &lt;/font&gt;&lt;/em&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;삼각형 자체는 항상 메모리의 동일한 위치에 있기 때문에 혼란 스러울 수 있습니다.&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4e30ddde6f9383ffb25516635c9c73988eaf920" translate="yes" xml:space="preserve">
          <source>Note how this implementation of the move assignment operator duplicates logic of both the destructor and the move constructor. Are you familiar with the copy-and-swap idiom? It can also be applied to move semantics as the move-and-swap idiom:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 할당 연산자의이 구현이 소멸자와 이동 생성자의 논리를 어떻게 복제하는지 주목하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복사 및 교체 관용구에 익숙하십니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 이동 및 스왑 관용구로 의미를 이동하는 데 적용 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc1ed59cd37ede9518aedf02a407061ed06f096c" translate="yes" xml:space="preserve">
          <source>Note that after the third line, &lt;code&gt;a&lt;/code&gt; no longer owns a triangle. That's okay, because by &lt;em&gt;explicitly&lt;/em&gt; writing &lt;code&gt;std::move(a)&lt;/code&gt;, we made our intentions clear: &quot;Dear constructor, do whatever you want with &lt;code&gt;a&lt;/code&gt; in order to initialize &lt;code&gt;c&lt;/code&gt;; I don't care about &lt;code&gt;a&lt;/code&gt; anymore. Feel free to have your way with &lt;code&gt;a&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;세 번째 줄 뒤에는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 이상 삼각형 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그 때문에로, 괜찮아 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;명시 적으로&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 서면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 우리는 분명 우리의 의도를 만든 : 당신이 원하는 무엇이든 할 &quot;친애하는 생성자 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;초기화하기 위해 &lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 나는 걱정하지 않는다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 이상 가지고 주시기 바랍니다. 와 당신의 방법 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &quot;&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b545f2bda15018d01523f9ff1692f25b2b72840e" translate="yes" xml:space="preserve">
          <source>Note that even though &lt;code&gt;std::move(a)&lt;/code&gt; is an rvalue, its evaluation does &lt;em&gt;not&lt;/em&gt; create a temporary object. This conundrum forced the committee to introduce a third value category. Something that can be bound to an rvalue reference, even though it is not an rvalue in the traditional sense, is called an &lt;em&gt;xvalue&lt;/em&gt; (eXpiring value). The traditional rvalues were renamed to &lt;em&gt;prvalues&lt;/em&gt; (Pure rvalues).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;std::move(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 rvalue &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;임에도 불구 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하고 평가는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;임시 오브젝트를 작성 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;않습니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 수수께끼는위원회가 세 번째 가치 범주를 도입하도록 강요했다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전통적인 의미에서 rvalue가 아니지만 rvalue 참조에 바인딩 할 수있는 것을 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;xvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (eXpiring value) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;라고합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기존의 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue는 prvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (Pure &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue)&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 이름이 바뀌 었습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6197c8328d3615627bdcb1f1810f59a11b3231ca" translate="yes" xml:space="preserve">
          <source>Note that in both factory functions, the return type is a value, not an rvalue reference. Rvalue references are still references, and as always, you should never return a reference to an automatic object; the caller would end up with a dangling reference if you tricked the compiler into accepting your code, like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 팩토리 함수에서 리턴 유형은 rvalue 참조가 아닌 값입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Rvalue 참조는 여전히 참조이므로 항상 자동 개체에 대한 참조를 반환해서는 안됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일러가 다음과 같이 코드를 수락하도록 속인 경우 호출자는 매달려있는 참조로 끝납니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="895f41e9bd9293af7e0f16ad424d9f9981e26c97" translate="yes" xml:space="preserve">
          <source>Note that only xvalues are really new; the rest is just due to renaming and grouping.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;xvalues만이 실제로 새롭다는 점에 유의하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나머지는 이름을 바꾸고 그룹화하기 때문입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3432dccea5cbc5683d11346e5fcd0b1d26cea00a" translate="yes" xml:space="preserve">
          <source>Note that returning by rvalue reference is fine in this example, because &lt;code&gt;t&lt;/code&gt; does not denote an automatic object, but instead an object that was passed in by the caller.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 자동 객체가 아니라 호출자가 전달한 객체를 나타 내기 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;때문에 rvalue 참조로 반환하는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;것이 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89ea05e38d59c5aed95819ce421844b145c2084c" translate="yes" xml:space="preserve">
          <source>Note that the copy assignment operator and the move assignment operator can be fused into a single, unified assignment operator, taking its argument by value:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복사 대입 연산자와 이동 대입 연산자는 인수를 값으로 사용하여 단일 통합 대입 연산자로 통합 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="545ad832cdf421948e5760aa53c065f811afa6d0" translate="yes" xml:space="preserve">
          <source>Note that the letters &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; have a historic origin in the left-hand side and right-hand side of an assignment. This is no longer true in C++, because there are lvalues which cannot appear on the left-hand side of an assignment (like arrays or user-defined types without an assignment operator), and there are rvalues which can (all rvalues of class types with an assignment operator).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문자 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;l&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 과제의 왼쪽과 오른쪽에 역사적인 기원이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;할당 왼쪽에 표시 할 수없는 lvalue (배열 연산자가없는 배열 또는 사용자 정의 형식 등)가있을 수 있고 rvalue가있을 수 있으므로 (클래스 유형의 모든 rvalue) C ++에서는 더 이상 사실이 아닙니다. 할당 연산자와 함께).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eaab0e119523ba0a6a6a259204c53d3659b8a758" translate="yes" xml:space="preserve">
          <source>Note that we pass the parameter &lt;code&gt;that&lt;/code&gt;&lt;em&gt;by value&lt;/em&gt;, so &lt;code&gt;that&lt;/code&gt; has to be initialized just like any other string object. Exactly how is &lt;code&gt;that&lt;/code&gt; going to be initialized? In the olden days of &lt;a href=&quot;http://en.wikipedia.org/wiki/C++#Standardization&quot;&gt;C++98&lt;/a&gt;, the answer would have been &quot;by the copy constructor&quot;. In C++0x, the compiler chooses between the copy constructor and the move constructor based on whether the argument to the assignment operator is an lvalue or an rvalue.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 매개 변수를 전달합니다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;값으로&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 그래서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 다른 모든 문자열 객체처럼 초기화 할 수 있습니다. 정확히 어떻게되어 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 초기화 될 것? 예전의 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/C++#Standardization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서는 &quot;복사 생성자에 의한&quot;대답이있었습니다. C ++ 0x에서 컴파일러는 할당 연산자에 대한 인수가 lvalue인지 rvalue인지에 따라 복사 생성자와 이동 생성자 중에서 선택합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="292b4ec9384f8616eaa92d7632778a096d02a026" translate="yes" xml:space="preserve">
          <source>Now comes the interesting part, the move constructor:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 재미있는 생성자 인 이동 생성자가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9eeb4639b40950f86cdb1f7ee968470d998ea4aa" translate="yes" xml:space="preserve">
          <source>Now comes the key insight into move semantics. Note that only in the first line where we copy &lt;code&gt;x&lt;/code&gt; is this deep copy really necessary, because we might want to inspect &lt;code&gt;x&lt;/code&gt; later and would be very surprised if &lt;code&gt;x&lt;/code&gt; had changed somehow. Did you notice how I just said &lt;code&gt;x&lt;/code&gt; three times (four times if you include this sentence) and meant the &lt;em&gt;exact same object&lt;/em&gt; every time? We call expressions such as &lt;code&gt;x&lt;/code&gt; &quot;lvalues&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 이동 의미론에 대한 주요 통찰력이 제공됩니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 복사하는 첫 번째 줄에만 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 딥 카피가 필요합니다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 나중에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;검사 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 어떻게 든 변경 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;되면 매우 놀라 울 것 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 세 번 (이 문장을 포함하면 네 번) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어떻게 말했는지 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;매번 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;똑같은 물건을&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의미 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;했습니까? &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;lvalues&quot; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;와 같은 표현식을 호출합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="931b9f3d55a132fec2e5e039741e883dded73c53" translate="yes" xml:space="preserve">
          <source>Now that &lt;code&gt;source&lt;/code&gt; is a variable of type &lt;code&gt;unique_ptr&lt;/code&gt;, it will be initialized by the move constructor; that is, the argument will be moved into the parameter. The argument is still required to be an rvalue, because the move constructor itself has an rvalue reference parameter. When control flow reaches the closing brace of &lt;code&gt;operator=&lt;/code&gt;, &lt;code&gt;source&lt;/code&gt; goes out of scope, releasing the old resource automatically.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 유형의 변수이므로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 생성자에 의해 초기화됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 인수가 매개 변수로 이동됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 생성자 자체에는 rvalue 참조 매개 변수가 있으므로 인수는 여전히 rvalue 여야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;제어 흐름의 폐쇄 브레이스 이르면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;operator=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 자동으로 이전 리소스를 해제 범위를 벗어나.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="298a83fc83958407292172112721d7fac6f19495" translate="yes" xml:space="preserve">
          <source>Now that you understand reference collapsing, here is how &lt;code&gt;std::move&lt;/code&gt; is implemented:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조 축소를 이해 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 구현되는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;방법 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c53f94e863e826764f4562c8d505588624c09e3e" translate="yes" xml:space="preserve">
          <source>Now, let's consider what a &lt;em&gt;copy constructor&lt;/em&gt; does.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복사 생성자&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하는 일을 생각해 봅시다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf61830673a8f5c2707029863a04957daf0b7f26" translate="yes" xml:space="preserve">
          <source>Obviously, there must be some profound difference between the expression &lt;code&gt;a&lt;/code&gt; which denotes an &lt;code&gt;auto_ptr&lt;/code&gt; variable, and the expression &lt;code&gt;make_triangle()&lt;/code&gt; which denotes the call of a function that returns an &lt;code&gt;auto_ptr&lt;/code&gt; by value, thus creating a fresh temporary &lt;code&gt;auto_ptr&lt;/code&gt; object every time it is called. &lt;code&gt;a&lt;/code&gt; is an example of an &lt;em&gt;lvalue&lt;/em&gt;, whereas &lt;code&gt;make_triangle()&lt;/code&gt; is an example of an &lt;em&gt;rvalue&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;분명히, &lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 변수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 나타내는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;표현식 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;값 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;으로 &lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 리턴하는 함수의 호출을 나타내는 &lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 표현식 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사이에는 깊은 차이가 있어야합니다. 따라서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;호출 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;될 때마다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;새로운 임시 &lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 오브젝트 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 작성합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lvalue&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 예 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이고, &lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 예입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f59b333eedae45f10bcefb5eb8e11c7862dbf00" translate="yes" xml:space="preserve">
          <source>Ok, but if I move an object, the source object becomes useless, no? Of course, but in certain situations that's very useful. The most evident one is when I call a function with an anonymous object (temporal, rvalue object, ..., you can call it with different names):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;좋아, 그러나 객체를 움직이면 소스 객체가 쓸모 없어집니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 특정 상황에서는 매우 유용합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가장 확실한 것은 익명의 객체 (임시, rvalue 객체, ..., 다른 이름으로 호출 할 수 있음)로 함수를 호출 할 때입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff03efad6b4f508d07644ba3ac921a54bad39daa" translate="yes" xml:space="preserve">
          <source>Other typical question: what is the difference between &lt;code&gt;A&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;const A&amp;amp;&amp;amp;&lt;/code&gt;? Of course, in the first case, you can modify the object and in the second not, but, practical meaning? In the second case, you can't modify it, so you have no ways to invalidate the object (except with a mutable flag or something like that), and there is no practical difference to a copy constructor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 일반적인 질문 : &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const A&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 차이점은 무엇 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 첫 번째 경우에는 객체를 수정할 수 있고 두 번째 경우에는 실용적이지 않습니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 번째 경우에는 객체를 수정할 수 없으므로 객체를 무효화하는 방법이 없으며 (변경 가능한 플래그 또는 이와 유사한 것을 제외하고) 복사 생성자와 실질적인 차이가 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70836291e05cb08b074706c1896b5e4d3e0d1003" translate="yes" xml:space="preserve">
          <source>Perhaps surprisingly, automatic objects (local variables that are not declared as &lt;code&gt;static&lt;/code&gt;) can also be &lt;em&gt;implicitly&lt;/em&gt; moved out of functions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;놀랍게도 자동 객체 ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;static&lt;/code&gt; 으로&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 선언되지 않은 로컬 변수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;)는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;함수에서 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;암시 적&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 으로 이동할 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="047060b19a709b1338cf8e5a234066acfcd19213" translate="yes" xml:space="preserve">
          <source>Returning an object from a method by default involves making a copy of the local object and its associated data in a location which is accessible to the caller (because the local object is not accessible to the caller and disappears when the method finishes).  When a built-in type is being returned, this operation is very fast, but if a large object is being returned, this could take a long time.  The move constructor allows the programmer to override this default behavior and instead &quot;reuse&quot; the heap data associated with the local object by pointing the object being returned to the caller to heap data associated with the local object.  Thus no copying is required.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본적으로 메서드에서 개체를 반환하려면 호출자가 액세스 할 수있는 위치에 로컬 개체와 관련 데이터를 복사해야합니다 (로컬 개체는 호출자가 액세스 할 수없고 메서드가 완료되면 사라지기 때문에). 내장 유형이 리턴 될 때이 조작은 매우 빠르지 만 큰 오브젝트가 리턴되는 경우 시간이 오래 걸릴 수 있습니다. 이동 생성자는 프로그래머가이 기본 동작을 무시하고 대신 호출자에게 리턴되는 오브젝트가 로컬 오브젝트와 연관된 힙 데이터를 가리 키도록하여 로컬 오브젝트와 연관된 힙 데이터를 &quot;재사용&quot;할 수 있도록합니다. 따라서 복사가 필요하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e5592cd0fb417300cbaac9ee976b933b1a98a51d" translate="yes" xml:space="preserve">
          <source>Rvalue references</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;R 값 참조&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5dc3c807bd559ab077dd1e1206e50e03c15ccaf6" translate="yes" xml:space="preserve">
          <source>Rvalue references went through several versions. Since version 2.1, an rvalue reference &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; also binds to all value categories of a different type &lt;code&gt;Y&lt;/code&gt;, provided there is an implicit conversion from &lt;code&gt;Y&lt;/code&gt; to &lt;code&gt;X&lt;/code&gt;. In that case, a temporary of type &lt;code&gt;X&lt;/code&gt; is created, and the rvalue reference is bound to that temporary:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Rvalue 참조는 여러 버전을 거쳤습니다. 버전 2.1부터, rvalue 참조 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt; &lt;code&gt;Y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 &lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로의 암시 적 변환이있는 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 유형 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 모든 값 범주에 바인딩합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 이 경우 &lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 유형의 임시 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 작성되고 rvalue 참조가 해당 임시에 바인드됩니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="681732688880af87e8358c431edcf6c36bc387ab" translate="yes" xml:space="preserve">
          <source>Rvalue references went through several versions. Since version 3.0, C++11 declares two additional special member functions on demand: the move constructor and the move assignment operator. Note that neither VC10 nor VC11 conform to version 3.0 yet, so you will have to implement them yourself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Rvalue 참조는 여러 버전을 거쳤습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;버전 3.0부터 C ++ 11은 필요에 따라 이동 생성자와 이동 할당 연산자라는 두 가지 추가 특수 멤버 함수를 선언합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;VC10이나 VC11은 아직 버전 3.0을 따르지 않으므로 직접 구현해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae0b0234229935b2ce05de8879beb6e5cb6cf659" translate="yes" xml:space="preserve">
          <source>Since an rvalue is going to die at the end of an expression, you can &lt;em&gt;steal its data&lt;/em&gt;. Instead of &lt;em&gt;copying&lt;/em&gt; it into another object, you &lt;em&gt;move&lt;/em&gt; its data into it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;표현식이 끝나면 rvalue가 죽을 것이기 때문에 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터를 훔칠&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 객체로 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복사&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대신 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로 옮깁니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48e1e601d0414c91d7bb8d787fc5e6f1a4660de9" translate="yes" xml:space="preserve">
          <source>Since we chose to manage the memory ourselves, we need to follow the &lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29&quot;&gt;rule of three&lt;/a&gt;. I am going to defer writing the assignment operator and only implement the destructor and the copy constructor for now:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 스스로 메모리를 관리하기로 결정했기 때문에 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;세 가지 규칙&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 따라야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;할당 연산자 작성을 연기하고 지금은 소멸자와 복사 생성자 만 구현하려고합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0099f828c7759a2abbdb4ba58fd52bd3abe97f90" translate="yes" xml:space="preserve">
          <source>So far, we have seen movement into local variables, and into function parameters. But moving is also possible in the opposite direction. If a function returns by value, some object at call site (probably a local variable or a temporary, but could be any kind of object) is initialized with the expression after the &lt;code&gt;return&lt;/code&gt; statement as an argument to the move constructor:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지금까지 지역 변수와 함수 매개 변수로 이동하는 것을 보았습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 반대 방향으로도 이동할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;함수가 값으로 반환하면 호출 사이트의 일부 객체 (로컬 변수 또는 임시이지만 모든 종류의 객체 일 수 있음)는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;return&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 생성자 다음 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 표현식으로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 생성자에 대한 인수로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;초기화됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="034b89ff4264e6ea18c21f67aa398614ed9889ef" translate="yes" xml:space="preserve">
          <source>So if you say &lt;code&gt;a = b&lt;/code&gt;, the &lt;em&gt;copy constructor&lt;/em&gt; will initialize &lt;code&gt;that&lt;/code&gt; (because the expression &lt;code&gt;b&lt;/code&gt; is an lvalue), and the assignment operator swaps the contents with a freshly created, deep copy. That is the very definition of the copy and swap idiom -- make a copy, swap the contents with the copy, and then get rid of the copy by leaving the scope. Nothing new here.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a = b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하면 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복사 생성자&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가이를 초기화 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (식 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 lvalue &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이기 때문에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;) 할당 연산자는 컨텐츠를 새로 작성된 깊은 사본으로 교체합니다. 이것이 바로 사본 및 교환 관용구의 정의입니다. 사본을 만들고 내용을 사본으로 바꾸고 범위를 벗어나면 사본을 제거하십시오. 여기에 새로운 것은 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54d00ee61a37d56aa5dd7aa4758e0bd04233cb62" translate="yes" xml:space="preserve">
          <source>So the value is &lt;strong&gt;&lt;em&gt;moved&lt;/em&gt;&lt;/strong&gt; from the unnamed temporary returned from &lt;code&gt;f()&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; (while the data of &lt;code&gt;x&lt;/code&gt;, initialized to an empty &lt;code&gt;X&lt;/code&gt;, is moved into the temporary, which will get destroyed after the assignment).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;값이되도록 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 반환 된 이름이 일시적에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 대한 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (의 데이터하면서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 빈 초기화, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 할당 후 파괴 얻을 것이다, 임시로 이동).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f7961a9153c9247dac8ea0516cb0ae78c84857c" translate="yes" xml:space="preserve">
          <source>So, if &lt;code&gt;T&lt;/code&gt; is a lvalue reference to &lt;code&gt;A&lt;/code&gt; (&lt;strong&gt;T&lt;/strong&gt; = A&amp;amp;), &lt;code&gt;a&lt;/code&gt; also (&lt;strong&gt;A&amp;amp;&lt;/strong&gt; &amp;amp;&amp;amp; =&amp;gt; A&amp;amp;). If &lt;code&gt;T&lt;/code&gt; is a rvalue reference to &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; also (A&amp;amp;&amp;amp; &amp;amp;&amp;amp; =&amp;gt; A&amp;amp;&amp;amp;). In both cases, &lt;code&gt;a&lt;/code&gt; is a named object in the actual scope, but &lt;code&gt;T&lt;/code&gt; contains the information of its &quot;reference type&quot; from the caller scope's point of view. This information (&lt;code&gt;T&lt;/code&gt;) is passed as template parameter to &lt;code&gt;forward&lt;/code&gt; and 'a' is moved or not according to the type of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서, 만일 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; 가&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 좌변 기준이다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;( &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; = A &amp;amp;) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 ( &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A &amp;amp;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;amp;&amp;amp; =&amp;gt; A &amp;amp;가). 경우 &lt;/font&gt; &lt;code&gt;T&lt;/code&gt; 는&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 r- 수치 기준이다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 (A &amp;amp;&amp;amp; &amp;amp;&amp;amp; =&amp;gt;를 &amp;amp;&amp;amp;). 두 경우 모두 &lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 실제 범위의 명명 된 객체이지만 &lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 호출자 범위의 관점에서 &quot;참조 유형&quot;정보를 포함합니다. 이 정보 ( &lt;/font&gt; &lt;code&gt;T&lt;/code&gt; 는&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )하는 템플릿 파라미터로 전달되는 &lt;/font&gt; &lt;code&gt;forward&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 'A'의 종류에 따라 이동 아닌지 &lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="093fc5e367c5e2bf6fc8ca5b593b0df072b3d2ce" translate="yes" xml:space="preserve">
          <source>So, your code is shorter (you don't need to do a &lt;code&gt;nullptr&lt;/code&gt; assignment for each dynamic member) and more general.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 코드가 짧아지고 ( &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 동적 멤버에 대해 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nullptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 할당 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;을 수행 할 필요가 없음 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;) 더 일반적입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68b9a6a0be10d20ad14f2d271cf26db0796998be" translate="yes" xml:space="preserve">
          <source>Sometimes, we want to move from lvalues. That is, sometimes we want the compiler to treat an lvalue as if it were an rvalue, so it can invoke the move constructor, even though it could be potentially unsafe.
For this purpose, C++11 offers a standard library function template called &lt;code&gt;std::move&lt;/code&gt; inside the header &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;.
This name is a bit unfortunate, because &lt;code&gt;std::move&lt;/code&gt; simply casts an lvalue to an rvalue; it does &lt;em&gt;not&lt;/em&gt; move anything by itself. It merely &lt;em&gt;enables&lt;/em&gt; moving. Maybe it should have been named &lt;code&gt;std::cast_to_rvalue&lt;/code&gt; or &lt;code&gt;std::enable_move&lt;/code&gt;, but we are stuck with the name by now.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;때때로 우리는 lvalue에서 벗어나고 싶어합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 컴파일러가 lvalue를 rvalue 인 것처럼 lvalue를 처리하여 잠재적으로 안전하지 않은 경우에도 이동 생성자를 호출 할 수 있기를 원합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 위해 C ++ 11은 &lt;/font&gt; &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 헤더 안에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라는 표준 라이브러리 함수 템플릿을 제공합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 단순히 lvalue를 rvalue로 캐스팅 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하기 때문에이 이름은 약간 불행합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 않습니다 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 그 자체로 아무것도 이동합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;만 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가능&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아마도 이름이 &lt;/font&gt; &lt;code&gt;std::cast_to_rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt; &lt;code&gt;std::enable_move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;였을지&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 모르지만 지금은 이름이 붙어 있습니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5301bb25f1b806784df96fdac43504d478adbc18" translate="yes" xml:space="preserve">
          <source>Sooner or later, you are going to write code like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;조만간 다음과 같은 코드를 작성하게됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="827e6674de363a70897b99e51fffefdb810a4c6e" translate="yes" xml:space="preserve">
          <source>Special member functions</source>
          <target state="translated">특별 회원 기능</target>
        </trans-unit>
        <trans-unit id="af929f44893f1dbb0ff36798043c5601a040d9c7" translate="yes" xml:space="preserve">
          <source>Stephan T. Lavavej took the time provide valuable feedback. Thank you very much, Stephan!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Stephan T. Lavavej는 소중한 피드백을 제공하는 데 시간이 걸렸습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스테판 감사합니다!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97edf0f249ffe0384959565a34426727579f471c" translate="yes" xml:space="preserve">
          <source>Suppose you have a function that returns a substantial object:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상당한 객체를 반환하는 함수가 있다고 가정합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76cdc8fdc1131d4b14a54894d4cef5413aad87ac" translate="yes" xml:space="preserve">
          <source>Swapping two large objects usually involves copying the first object to a temporary object, copying the second object to the first object, and copying the temporary object to the second object.  For a built-in type, this is very fast, but for large objects these three copies could take a large amount of time.  A &quot;move assignment&quot; allows the programmer to override the default copy behavior and instead swap references to the objects, which means that there is no copying at all and the swap operation is much faster.  The move assignment can be invoked by calling the std::move() method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 개의 큰 객체를 바꾸려면 일반적으로 첫 번째 객체를 임시 객체로 복사하고, 두 번째 객체를 첫 번째 객체로 복사하고, 임시 객체를 두 번째 객체로 복사합니다. 내장 유형의 경우 매우 빠르지 만 큰 객체의 경우이 세 복사본에 많은 시간이 걸릴 수 있습니다. &quot;이동 할당&quot;을 사용하면 프로그래머가 기본 복사 동작을 무시하고 대신 객체에 대한 참조를 교체 할 수 있습니다. 즉, 복사가 전혀없고 교체 작업이 훨씬 빠릅니다. std :: move () 메소드를 호출하여 이동 지정을 호출 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f28b36c8ab1c06a2320bf78626f74f8e645b94e6" translate="yes" xml:space="preserve">
          <source>T&amp;amp;&amp;amp; is not an rvalue reference, but a forwarding reference. It also binds to lvalues, in which case &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; are both lvalue references.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T &amp;amp;&amp;amp;는 rvalue 참조가 아니라 전달 참조입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 lvalue에 바인딩되며,이 경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 모두 lvalue 참조입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25e5448ed70f909735a7a46f8300ed37a57706a9" translate="yes" xml:space="preserve">
          <source>That's the signature of a prototypical function that uses perfect forwarding, implemented in C++11 by means of &lt;code&gt;std::forward&lt;/code&gt;. This function exploits some rules of template instantiation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::forward&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 통해 C ++ 11에서 구현 된 완벽한 전달을 사용하는 프로토 타입 함수의 시그니처입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 이 함수는 템플릿 인스턴스화 규칙을 활용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2aeb46f404b05b67c1d4b4e933f1b159f28adf0b" translate="yes" xml:space="preserve">
          <source>The C++98 standard library offers a smart pointer with unique ownership semantics called &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. In case you are unfamiliar with &lt;code&gt;auto_ptr&lt;/code&gt;, its purpose is to guarantee that a dynamically allocated object is always released, even in the face of exceptions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98 표준 라이브러리는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라는 고유 소유권 의미론을 가진 스마트 포인터를 제공합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 익숙하지 않은 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예외 상황에서도 동적으로 할당 된 객체가 항상 해제되도록하는 것이 목적입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c5273ddaf8d4d9bd2c708aae41ca02d986a560f" translate="yes" xml:space="preserve">
          <source>The above function uses &lt;em&gt;call by value&lt;/em&gt; which means that when this function is called an object must be &lt;em&gt;constructed&lt;/em&gt; to be used by the function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위의 함수는 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;값으로 호출을&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다. 즉,이 함수가 호출 될 때 함수가 사용하도록 객체를 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구성&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 해야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="21453336f2384057cccb4c69429d948c05e5271d" translate="yes" xml:space="preserve">
          <source>The arguments in lines 2 and 3 are not lvalues, but rvalues, because the underlying string objects have no names, so the client has no way to inspect them again at a later point in time.
rvalues denote temporary objects which are destroyed at the next semicolon (to be more precise: at the end of the full-expression that lexically contains the rvalue). This is important because during the initialization of &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, we could do whatever we wanted with the source string, and &lt;em&gt;the client couldn't tell a difference&lt;/em&gt;!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 문자열 개체에는 이름이 없으므로 클라이언트는 나중에 다시 검사 할 방법이 없기 때문에 2 행과 3 행의 인수는 lvalue가 아니라 rvalue입니다. rvalue는 다음 세미콜론에서 파괴되는 임시 객체를 나타냅니다 (정확하게 말하면 r 식을 포함하는 전체 표현의 끝에서). &lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 초기화 중에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;소스 문자열로 원하는 것을 할 수 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있고 클라이언트가 차이를 말할 수&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 없기 때문에 이것은 중요합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e024a6d6f6f045a7e5fd3e2fd78c563a51190fec" translate="yes" xml:space="preserve">
          <source>The call of a function that returns an rvalue reference, such as &lt;code&gt;std::move&lt;/code&gt;, is an xvalue.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 같은 rvalue 참조를 리턴하는 함수의 호출은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;xvalue입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b626cb0884dddd9379630d99507ae7fe2ff2c15c" translate="yes" xml:space="preserve">
          <source>The constructor takes ownership of the object, and the destructor deletes it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;생성자는 객체의 소유권을 가져오고 소멸자는이를 삭제합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e74352db34fd6a5e34f47321ae6e9f914b303f6f" translate="yes" xml:space="preserve">
          <source>The copy constructor defines what it means to copy string objects. The parameter &lt;code&gt;const string&amp;amp; that&lt;/code&gt; binds to all expressions of type string which allows you to make copies in the following examples:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복사 생성자는 문자열 객체를 복사하는 의미를 정의합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 예에서 복사 할 수있는 문자열 유형의 모든 표현식에 바인딩되는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const string&amp;amp; that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 매개 변수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="290f16723b4d755e1f94e621b760399ee06c5273" translate="yes" xml:space="preserve">
          <source>The copy constructor of &lt;code&gt;auto_ptr&lt;/code&gt; probably looks something like this (somewhat simplified):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 복사 생성자는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아마도 다음과 같이 보일 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f162420dc7014f9f7aea09dba5df626cfbba3e4" translate="yes" xml:space="preserve">
          <source>The dangerous thing about &lt;code&gt;auto_ptr&lt;/code&gt; is that what syntactically looks like a copy is actually a move. Trying to call a member function on a moved-from &lt;code&gt;auto_ptr&lt;/code&gt; will invoke undefined behavior, so you have to be very careful not to use an &lt;code&gt;auto_ptr&lt;/code&gt; after it has been moved from:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 위험한 점은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구문 적으로 사본처럼 보이는 것이 실제로는 이동이라는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 된 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 멤버 함수를 호출하려고하면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정의되지 않은 동작이 호출되므로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 이동 된 후에는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용하지 않도록 매우주의해야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5518e5be02f103564f3cd6dfbbdb856e00b6efc" translate="yes" xml:space="preserve">
          <source>The last missing piece is the move assignment operator. Its job is to release the old resource and acquire the new resource from its argument:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마지막으로 누락 된 부분은 이동 할당 연산자입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그 역할은 이전 리소스를 해제하고 인수에서 새 리소스를 얻는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e783ee3bf25d0cbf3bd7e4504e938db2d81a4f14" translate="yes" xml:space="preserve">
          <source>The move assignment operator transfers ownership of a managed resource into the current object, releasing the old resource.
  The move-and-swap idiom simplifies the implementation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 할당 연산자는 관리 자원의 소유권을 현재 오브젝트로 이전하여 이전 자원을 해제합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 및 교체 관용구는 구현을 단순화합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a92be27a40d64e9f0284a53eff6b28c4024e3a73" translate="yes" xml:space="preserve">
          <source>The move constructor transfers ownership of a managed resource into the current object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 생성자는 관리 자원의 소유권을 현재 오브젝트로 전송합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="369d03b7f7d3482f6aec3906bad55a6bc99dd045" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;a&lt;/code&gt; would be copied to the actual parameter of &lt;code&gt;other_function&lt;/code&gt;. If you want the object &lt;code&gt;a&lt;/code&gt; continues being treated as a temporary object, you should use the &lt;code&gt;std::move&lt;/code&gt; function:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 실제 매개 변수에 복사됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 계속 임시 객체로 취급하려면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 함수를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용해야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3f96d5d08d17f40270352611586edfa618dbb5ff" translate="yes" xml:space="preserve">
          <source>The second line fails to compile, because &lt;code&gt;a&lt;/code&gt; is an lvalue, but the parameter &lt;code&gt;unique_ptr&amp;amp;&amp;amp; source&lt;/code&gt; can only be bound to rvalues. This is exactly what we wanted; dangerous moves should never be implicit. The third line compiles just fine, because &lt;code&gt;make_triangle()&lt;/code&gt; is an rvalue. The move constructor will transfer ownership from the temporary to &lt;code&gt;c&lt;/code&gt;. Again, this is exactly what we wanted.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 lvalue &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이므로 두 번째 줄은 컴파일에 실패 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지만 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&amp;amp;&amp;amp; source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 매개 변수는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에만 바인딩 될 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 바로 우리가 원하는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위험한 움직임은 절대로 암시해서는 안됩니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 rvalue &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이므로 세 번째 줄은 잘 컴파일됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 생성자는 소유권을 임시에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; 로 이전&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다시, 이것은 우리가 정확히 원하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a3730034e13e4628ec2934efc747b68c3fc3e13d" translate="yes" xml:space="preserve">
          <source>The solution is to manually enable the move:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해결책은 수동으로 이동을 활성화하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="08aa002af0a7d7ef8a828f926264d37a71e32e78" translate="yes" xml:space="preserve">
          <source>The unusual thing about &lt;code&gt;auto_ptr&lt;/code&gt; is its &quot;copying&quot; behavior:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 특이한 점은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;복사&quot;동작입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3032c490102dbbdc1a53ae3a1e6b530d8d4c02ba" translate="yes" xml:space="preserve">
          <source>These two new special member functions are only implicitly declared if none of the special member functions are declared manually. Also, if you declare your own move constructor or move assignment operator, neither the copy constructor nor the copy assignment operator will be declared implicitly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 두 가지 특수 멤버 함수는 특수 멤버 함수를 수동으로 선언하지 않은 경우에만 암시 적으로 선언됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 고유 한 이동 생성자 또는 이동 할당 연산자를 선언하면 복사 생성 자나 복사 할당 연산자가 암시 적으로 선언되지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83a00c1613c4181d37c495b96f0796b835f18525" translate="yes" xml:space="preserve">
          <source>This is accomplished with an &lt;code&gt;rvalue&lt;/code&gt; reference.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 참조로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수행됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="31ccc28aaac9180efd97b0f2232c9474c45ded9f" translate="yes" xml:space="preserve">
          <source>This is especially important if (like perhaps the &lt;code&gt;Matrix&lt;/code&gt; example above), the object being copied allocates extra memory on the heap to store its internal representation. A copy constructor would have to either make a full copy of the internal representation, or use reference counting and copy-on-write semantics interally. A move constructor would leave the heap memory alone and just copy the pointer inside the &lt;code&gt;Matrix&lt;/code&gt; object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Matrix&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 예제와 같이 복사되는 객체가 힙에 추가 메모리를 할당하여 내부 표현을 저장하는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경우 특히 중요합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;카피 생성자는 내부 표현의 전체 카피를 만들거나 참조 카운팅과 COW (Copy-On-Write) 의미를 내부적으로 사용해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 생성자는 힙 메모리 만 남겨두고 포인터를 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Matrix&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 객체 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내부에 복사 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="734c00e55f5d7bfea55f0c53e0033b51b7115120" translate="yes" xml:space="preserve">
          <source>This leads to the concept of an &quot;rvalue&quot; reference. They exist in C++11 only to detect if the received object is anonymous or not. I think you do already know that an &quot;lvalue&quot; is an assignable entity (the left part of the &lt;code&gt;=&lt;/code&gt; operator), so you need a named reference to an object to be capable to act as an lvalue. A rvalue is exactly the opposite, an object with no named references. Because of that, anonymous object and rvalue are synonyms. So:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이는 &quot;rvalue&quot;참조의 개념으로 이어집니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수신 된 객체가 익명인지 아닌지를 감지하기 위해서만 C ++ 11에 존재합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;lvalue&quot;가 할당 가능한 엔티티 ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 연산자 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 왼쪽 부분)라는 것을 이미 알고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있으므로 lvalue로 작동 할 수있는 개체에 대한 명명 된 참조가 필요합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue는 명명 된 참조가없는 객체와 정확히 반대입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 익명 객체와 rvalue는 동의어입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래서:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2a9839394d8fd7fa5c503f67611a827e38511306" translate="yes" xml:space="preserve">
          <source>This move constructor does exactly what the &lt;code&gt;auto_ptr&lt;/code&gt; copy constructor did, but it can only be supplied with rvalues:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 이동 생성자는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 복사 생성자가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수행 한 작업을 정확하게 수행 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지만 rvalue 만 제공 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e308529a0760da4187efbb6031e853815d012f5" translate="yes" xml:space="preserve">
          <source>This way, the number of special member functions to implement drops from five to four. There is a tradeoff between exception-safety and efficiency here, but I am not an expert on this issue.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이런 식으로 구현할 특수 멤버 함수의 수는 5에서 4로 줄어 듭니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에는 예외 안전과 효율성 사이에 상충 관계가 있지만이 문제의 전문가는 아닙니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c835c096c791a7fe0c7b46b42e46e2033cbeb4bc" translate="yes" xml:space="preserve">
          <source>To illustrate the need for &lt;em&gt;move semantics&lt;/em&gt;, let's consider this example without move semantics:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 의미론&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 필요성을 설명하기 위해 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 의미론&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 없이이 예제를 고려해 보겠습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a7e9e734de9455aa1437dc73d5ab335d653aaac" translate="yes" xml:space="preserve">
          <source>To make strong exception guarantee possible, user-defined move constructors should not throw exceptions. In fact, standard containers typically rely on std::move_if_noexcept to choose between move and copy when container elements need to be relocated.
  If both copy and move constructors are provided, overload resolution selects the move constructor if the argument is an rvalue (either a prvalue such as a nameless temporary or an xvalue such as the result of std::move), and selects the copy constructor if the argument is an lvalue (named object or a function/operator returning lvalue reference). If only the copy constructor is provided, all argument categories select it (as long as it takes a reference to const, since rvalues can bind to const references), which makes copying the fallback for moving, when moving is unavailable.
  In many situations, move constructors are optimized out even if they would produce observable side-effects, see copy elision.
  A constructor is called a 'move constructor' when it takes an rvalue reference as a parameter. It is not obligated to move anything, the class is not required to have a resource to be moved and a 'move constructor' may not be able to move a resource as in the allowable (but maybe not sensible) case where the parameter is a const rvalue reference (const T&amp;amp;&amp;amp;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;강력한 예외 보장을 가능하게하기 위해 사용자 정의 이동 생성자는 예외를 발생시키지 않아야합니다. 실제로 표준 컨테이너는 일반적으로 std :: move_if_noexcept를 사용하여 컨테이너 요소를 재배치해야 할 때 이동 및 복사 중에서 선택합니다. 복사 및 이동 생성자가 모두 제공되는 경우 인수가 rvalue (이름없는 임시와 같은 prvalue 또는 std :: move의 결과와 같은 xvalue) 인 경우 과부하 해결은 이동 생성자를 선택하고, 복사 생성자를 선택합니다. 인수는 lvalue (명명 된 오브젝트 또는 lvalue 참조를 리턴하는 함수 / 연산자)입니다. 복사 생성자 만 제공되는 경우 모든 인수 범주는 rvalue가 const 참조에 바인딩 될 수 있으므로 const에 대한 참조가 필요한 한 해당 인수를 선택하여 이동이 불가능할 때 이동을위한 폴백을 복사합니다.많은 상황에서 이동 생성자는 관찰 가능한 부작용이 발생하더라도 최적화됩니다. 복사 제거를 참조하십시오. rvalue 참조를 매개 변수로 사용할 경우 생성자를 '이동 생성자'라고합니다. 아무것도 이동해야 할 의무는 없으며 클래스에 이동할 리소스가 없어도되며 'move constructor'은 매개 변수가 다음과 같은 허용 가능한 (그러나 합당하지 않은) 경우와 같이 리소스를 이동할 수 없습니다. const rvalue 참조 (const T &amp;amp;&amp;amp;).매개 변수가 const rvalue 참조 (const T &amp;amp;&amp;amp;) 인 허용 가능한 (그러나 합당하지 않은) 경우처럼 자원을 이동할 수 없습니다.매개 변수가 const rvalue 참조 (const T &amp;amp;&amp;amp;) 인 허용 가능한 (그러나 적절하지 않은) 경우처럼 자원을 이동할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b31d2be34d67b295038676b6a78d3aa74806629a" translate="yes" xml:space="preserve">
          <source>To move an object means to transfer ownership of some resource it manages to another object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개체를 이동한다는 것은 관리하는 일부 리소스의 소유권을 다른 개체로 이전하는 것을 의미합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bbf1b3314c139a90af79519c70cc487a725f22d9" translate="yes" xml:space="preserve">
          <source>To summarize, the copy constructor makes a deep copy, because the source must remain untouched.
The move constructor, on the other hand, can just copy the pointer and then set the pointer in the source to null. It is okay to &quot;nullify&quot; the source object in this manner, because the client has no way of inspecting the object again.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;요약하면 소스는 그대로 유지해야하므로 복사 생성자는 딥 카피를 만듭니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반면에 이동 생성자는 포인터를 복사 한 다음 소스의 포인터를 null로 설정할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클라이언트가 객체를 다시 검사 할 방법이 없기 때문에 이런 방식으로 소스 객체를 &quot;무효화&quot;해도됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="047b60f44c81098eb74095d0ced4e749b86ad68f" translate="yes" xml:space="preserve">
          <source>Turning expensive copies into cheap moves. See my first answer for an example. Note that if an object does not manage at least one external resource (either directly, or indirectly through its member objects), move semantics will not offer any advantages over copy semantics. In that case, copying an object and moving an object means the exact same thing:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;값 비싼 사본을 저렴한 가격으로 전환 예를 들어 첫 번째 답변을 참조하십시오. 객체가 하나 이상의 외부 리소스를 직접 또는 간접적으로 멤버 객체를 통해 관리하지 않는 경우 이동 시맨틱은 복사 시맨틱보다 이점을 제공하지 않습니다. 이 경우 객체를 복사하고 이동하는 것은 똑같은 의미입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="de0430a56abae1a9c8cca4fd7a8b8906769e0636" translate="yes" xml:space="preserve">
          <source>Value categories</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가치 범주&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2aa8f4165ecd80aeeeeb890eaf78af1a8a3b401b" translate="yes" xml:space="preserve">
          <source>We now understand that moving from lvalues is potentially dangerous, but moving from rvalues is harmless. If C++ had language support to distinguish lvalue arguments from rvalue arguments, we could either completely forbid moving from lvalues, or at least make moving from lvalues &lt;em&gt;explicit&lt;/em&gt; at call site, so that we no longer move by accident.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 우리는 lvalues에서 이동하는 것이 잠재적으로 위험하지만 rvalues에서 이동하는 것은 무해하다는 것을 이해합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++에서 lvalue 인수와 rvalue 인수를 구별하는 언어 지원이있는 경우 lvalue에서 이동하는 것을 완전히 금지하거나 적어도 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;콜 사이트 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 lvalue에서 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;명시 적으로&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이동하여 실수로 더 이상 이동하지 않도록 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c91f5982e73d44e7f4a6ccace5726e523643802" translate="yes" xml:space="preserve">
          <source>What do these rules mean in practice?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 규칙은 실제로 무엇을 의미합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="99565c8cb484efe8d28c4076f67a25e83378c561" translate="yes" xml:space="preserve">
          <source>What have we done here? Instead of deeply copying the heap data, we have just copied the pointer and then set the original pointer to null (to prevent 'delete[]' from source object's destructor from releasing our 'just stolen data'). In effect, we have &quot;stolen&quot; the data that originally belonged to the source string. Again, the key insight is that under no circumstance could the client detect that the source had been modified. Since we don't really do a copy here, we call this constructor a &quot;move constructor&quot;. Its job is to move resources from one object to another instead of copying them.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 여기서 무엇을 했습니까? 힙 데이터를 깊이 복사하는 대신 포인터를 복사 한 다음 소스 포인터의 소멸자에서 'delete []'가 '단지 도난당한 데이터'를 공개하지 못하도록 원래 포인터를 null로 설정했습니다. 실제로 소스 문자열에 원래 있던 데이터를 &quot;도난&quot;했습니다. 다시 한 번 핵심 통찰력은 어떠한 상황에서도 클라이언트가 소스가 수정되었음을 감지 할 수 없다는 것입니다. 여기서는 실제로 사본을 만들지 않기 때문에이 생성자를 &quot;이동 생성자&quot;라고합니다. 그 작업은 자원을 복사하는 대신 한 오브젝트에서 다른 오브젝트로 자원을 이동시키는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3334057bf5fdd1df4c8a56b5a8bb56d8d08ac48e" translate="yes" xml:space="preserve">
          <source>What is a move?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동이란 무엇입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff7bddf15a2315c6021f9e9d0f6b6bce8bcffd35" translate="yes" xml:space="preserve">
          <source>What is move semantics</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 의미 란 무엇입니까&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="22b96be030691f90fe9b2e0240432d1d51dae570" translate="yes" xml:space="preserve">
          <source>When such copy/destroy pairs are expensive, it's typically because the object owns some heavyweight resource. For example, &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; may own a dynamically-allocated memory block containing an array of &lt;code&gt;string&lt;/code&gt; objects, each with its own dynamic memory.  Copying such an object is costly: you have to allocate new memory for each dynamically-allocated blocks in the source, and copy all the values across.  &lt;em&gt;Then&lt;/em&gt; you need deallocate all that memory you just copied.  However, &lt;em&gt;moving&lt;/em&gt; a large &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; means just copying a few pointers (that refer to the dynamic memory block) to the destination and zeroing them out in the source.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 복사 / 파괴 쌍이 비싸면 일반적으로 개체에 무거운 리소스가 있기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각각 고유 한 동적 메모리를 가진 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 객체 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 배열을 포함하는 동적으로 할당 된 메모리 블록을 소유 할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 객체를 복사하는 것은 비용이 많이 듭니다. 소스에서 동적으로 할당 된 각 블록에 새 메모리를 할당하고 모든 값을 복사해야합니다. &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 다음&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 방금 복사 한 모든 메모리를 할당 해제해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;큰 &lt;/font&gt; &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;몇 개의 포인터 (동적 메모리 블록 참조)를 대상에 복사하고 소스에서 제로화하는 것을 의미합니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9cd78414f15901d8e86a8d3f4a590968adf4da6" translate="yes" xml:space="preserve">
          <source>When the new object is created from the return value, the copy constructor is called to &lt;em&gt;copy&lt;/em&gt; the contents of the temporary object to the new object b. After the function completes, the temporary object used in the function goes out of scope and is destroyed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반환 값 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 새 개체를 만들면 임시 개체의 내용을 새 개체 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복사&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하기 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위해 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복사&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 생성자가 호출됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. b. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;함수가 완료된 후 함수에 사용 된 임시 오브젝트가 범위를 벗어나서 소멸됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="07a221a0bb57425e9405956022b30340ca656ba4" translate="yes" xml:space="preserve">
          <source>When would you want to do that? well std::vector is an example, say you created a temporary std::vector and you return it from a function say:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;언제하고 싶니? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;잘 std :: vector는 예입니다. 임시 std :: vector를 작성하고 함수 say에서 반환한다고 가정하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74ec9a380d335c03fb7b287be6ff753162c1a3a7" translate="yes" xml:space="preserve">
          <source>When you write code like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음과 같은 코드를 작성할 때 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="221b238f8d5a91baf4778e7b3912f0b81807d155" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;move semantics&lt;/strong&gt; it's now possible to make most of this work less unpleasant by simply &lt;em&gt;moving&lt;/em&gt; the data rather than copying.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동 의미론을&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용하면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복사가 아닌 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단순히 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이동&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하여 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분의 작업을 덜 불쾌하게 만들 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1e792bfe219381f99de1182972a3fef81354e659" translate="yes" xml:space="preserve">
          <source>With this line, &lt;code&gt;std::move&lt;/code&gt; will cast &lt;code&gt;a&lt;/code&gt; to an rvalue and &lt;code&gt;other_function&lt;/code&gt; will receive the object as a unnamed object. Of course, if &lt;code&gt;other_function&lt;/code&gt; has not specific overloading to work with unnamed objects, this distinction is not important.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 줄을 사용하면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 rvalue로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;캐스팅 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 명명되지 않은 객체로 객체를받습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 명명되지 않은 객체로 작업하기 위해 특정 오버로딩을하지 않은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;,이 구별은 중요하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a502ae851780f1ddc7db29441700f146506ebb73" translate="yes" xml:space="preserve">
          <source>Xvalues</source>
          <target state="translated">Xvalues</target>
        </trans-unit>
        <trans-unit id="c39f86b271db60b23e48e49da3c4e77b7bf0f5df" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;parameter&lt;/code&gt; by value. For move-only types like &lt;code&gt;unique_ptr&lt;/code&gt;, it seems there is no established idiom yet. Personally, I prefer pass by value, as it causes less clutter in the interface.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;값으로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전달할 수도 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 같은 이동 전용 유형의 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경우 아직 확립 된 관용구가없는 것 같습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개인적으로, 나는 인터페이스를 덜 혼란스럽게 만들기 때문에 값으로 전달하는 것을 선호합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e2f4250ebd2eff63e7f150721d9b86649703b85e" translate="yes" xml:space="preserve">
          <source>You could argue that &lt;code&gt;parameter&lt;/code&gt; is not used anymore after the initialization of &lt;code&gt;member&lt;/code&gt;. Why is there no special rule to silently insert &lt;code&gt;std::move&lt;/code&gt; just as with return values? Probably because it would be too much burden on the compiler implementors. For example, what if the constructor body was in another translation unit? By contrast, the return value rule simply has to check the symbol tables to determine whether or not the identifier after the &lt;code&gt;return&lt;/code&gt; keyword denotes an automatic object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &lt;code&gt;member&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 초기화 후 더 이상 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 사용되지 않는다고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주장 할 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반환 값과 마찬가지로 &lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 자동으로 삽입하는 특별한 규칙이없는 이유는 무엇 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아마도 컴파일러 구현 자에게 너무 많은 부담이 있기 때문일 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 생성자 본문이 다른 번역 단위에 있다면 어떻게해야합니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반대로, 리턴 값 규칙은 단순히 &lt;/font&gt; &lt;code&gt;return&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 키워드 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;뒤의 식별자 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 자동 오브젝트를 나타내는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지 여부를 판별하기 위해 기호 테이블을 점검하기 만하면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;됩니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3ca8091ddd18805cfc713df7dd75868c9a95f47" translate="yes" xml:space="preserve">
          <source>You know what a copy semantics means right? it means you have types which are copyable, for user-defined types you define this either buy explicitly writing a copy constructor &amp;amp; assignment operator or the compiler generates them implicitly. This will do a copy.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;카피 의미가 무엇을 의미하는지 아십니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복사 가능한 유형이 있음을 의미합니다. 사용자 정의 유형의 경우 복사 생성자 및 할당 연산자를 명시 적으로 작성하거나 컴파일러가 암시 적으로 생성합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 사본을 수행합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e2f4bc4c9d48bda3c7ea5e8d13ceacb5e895f12" translate="yes" xml:space="preserve">
          <source>You might expect &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; to only bind to rvalues, because at first glance, it looks like an rvalue reference. As it turns out though, &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; also binds to lvalues:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;언뜻보기에는 rvalue 참조처럼 보이기 때문에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 rvalue에만 바인드 할 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 lvalue에도 바인딩합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d33a97176f7badf8aeef43dbd922269578988791" translate="yes" xml:space="preserve">
          <source>You're going to have overhead from the copy constructor when the function returns, if (and it will in C++0x) std::vector has a move constructor instead of copying it can just set it's pointers and 'move' dynamically allocated memory to the new instance. It's kind of like transfer-of-ownership semantics with std::auto_ptr.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: vector가 복사하는 대신 이동 생성자를 가지고 있으면 포인터를 설정하고 '이동'을 동적으로 할당 할 수있는 경우 함수가 반환 할 때 복사 생성자에서 오버 헤드가 발생합니다 (C ++ 0x에있을 것입니다) 새 인스턴스에 대한 메모리. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: auto_ptr을 가진 소유권 이전 의미론과 비슷합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e21276ab1166e0e62608292fa54445af12932da1" translate="yes" xml:space="preserve">
          <source>an &lt;em&gt;rvalue reference can be moved&lt;/em&gt; and an &lt;em&gt;lvalue&lt;/em&gt; cannot.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;r- 수치 참조는 이동 가능&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하고, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;좌변이&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="151db36d21b0e8f4a4f6c394902768f00fb00c34" translate="yes" xml:space="preserve">
          <source>then an ordinary C++ compiler will create a temporary object for the result of &lt;code&gt;multiply()&lt;/code&gt;, call the copy constructor to initialise &lt;code&gt;r&lt;/code&gt;, and then destruct the temporary return value. Move semantics in C++0x allow the &quot;move constructor&quot; to be called to initialise &lt;code&gt;r&lt;/code&gt; by copying its contents, and then discard the temporary value without having to destruct it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반 C ++ 컴파일러는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;multiply()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 결과에 대한 임시 객체를 만들고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복사 생성자를 호출하여 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 초기화 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한 다음 임시 반환 값을 삭제합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 0x의 이동 의미론은 &quot;이동 생성자&quot;를 호출하여 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내용을 복사하여 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 초기화 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한 다음 임시 값을 삭제하지 않고 버립니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
