<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/3106110">
    <body>
      <group id="3106110">
        <trans-unit id="df0fd2702057b417c35ac16135733ca9fa59293f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::move(some_lvalue)&lt;/code&gt; casts an lvalue to an rvalue, thus enabling a subsequent move.</source>
          <target state="translated">&lt;code&gt;std::move(some_lvalue)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、左辺値を右辺値にキャストするため、後続の移動が可能になります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50f6f367eb9f6b3f8bc2138fd21d734104676605" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Move semantics&lt;/strong&gt; is about &lt;strong&gt;transferring resources rather than copying them&lt;/strong&gt; when nobody needs the source value anymore.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動セマンティクス&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、ソース値が&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不要になった&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ときに&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リソースをコピーするのではなく、転送すること&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6792b6f126f7677728171c0bfe42b4de3714768a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two&lt;/strong&gt; new objects have been constructed, one of which is a temporary object that's only used for the duration of the function.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2つの&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;新しいオブジェクトが作成されました。そのうちの1つは、関数の実行中にのみ使用される一時オブジェクトです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a95152a9e43e530501f6b99af74270415868a62a" translate="yes" xml:space="preserve">
          <source>A named rvalue reference is an lvalue, just like any other variable.</source>
          <target state="translated">名前付き rvalue 参照は、他の変数と同じように lvalue です。</target>
        </trans-unit>
        <trans-unit id="f040209caa6e8f4d4e43aa329b98ebb25520ebed" translate="yes" xml:space="preserve">
          <source>A useful example of a function with an &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; parameter is the &lt;em&gt;move constructor&lt;/em&gt;&lt;code&gt;X::X(X&amp;amp;&amp;amp; source)&lt;/code&gt;. Its purpose is to transfer ownership of the managed resource from the source into the current object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;パラメータ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を持つ関数の便利な例&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動コンストラクタ&lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;X::X(X&amp;amp;&amp;amp; source)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その目的は、管理対象リソースの所有権をソースから現在のオブジェクトに転送することです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abef74394b5449ff6f5131eaf664d8e46d148d79" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;rvalue&lt;/code&gt; reference works pretty much like an &lt;code&gt;lvalue&lt;/code&gt; reference with one important difference:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照はかなりのように動作します&lt;/font&gt;&lt;/font&gt; &lt;code&gt;lvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一つの重要な違いを持つ参照：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1400246cab7166daac5095b766ba4438e047c79f" translate="yes" xml:space="preserve">
          <source>An rvalue is a temporary object, which is going to be destroyed at the end of the expression. In current C++, rvalues only bind to &lt;code&gt;const&lt;/code&gt; references. C++1x will allow non-&lt;code&gt;const&lt;/code&gt; rvalue references, spelled &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, which are references to an rvalue objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値は一時的なオブジェクトであり、式の最後で破棄されます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;現在のC ++では、右辺値は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のみバインドされ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 1xでは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、右辺値オブジェクトへの参照である&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; 以外の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値参照（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スペル）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が許可さ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;れ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ec69c00d4b9b0c380efb9f8ecec0d4b04714fba" translate="yes" xml:space="preserve">
          <source>An rvalue of class type is an expression whose evaluation creates a temporary object.
  Under normal circumstances, no other expression inside the same scope denotes the same temporary object.</source>
          <target state="translated">クラス型の rvalue は、その評価が一時オブジェクトを作成する式です。通常の状況では、同じスコープ内の他の式が同じテンポラリオブジェクトを表すことはありません。</target>
        </trans-unit>
        <trans-unit id="3fe43eb5a17970d62352f3daf0ab3389b2294910" translate="yes" xml:space="preserve">
          <source>An rvalue reference &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; is a new kind of reference that only binds to rvalues.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値参照&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のみバインドする新しい種類の参照です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b951ee76f644338afecca76aa03ce849f6e9a636" translate="yes" xml:space="preserve">
          <source>And what is &lt;strong&gt;perfect forwarding&lt;/strong&gt;? It is important to know that a &quot;rvalue reference&quot; is a reference to a named object in the &quot;caller's scope&quot;. But in the actual scope, a rvalue reference is a name to an object, so, it acts as a named object. If you pass an rvalue reference to another function, you are passing a named object, so, the object isn't received like a temporal object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そして、&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完璧な転送&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;とは何&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ですか？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「右辺値参照」は「呼び出し元のスコープ」内の名前付きオブジェクトへの参照であることを理解することが重要です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし、実際のスコープでは、右辺値参照はオブジェクトの名前であるため、名前付きオブジェクトとして機能します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値参照を別の関数に渡すと、名前付きオブジェクトを渡すことになるため、オブジェクトは一時オブジェクトのように受け取られません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cdb7ef1ba819235b13a473fac62029ba510795b0" translate="yes" xml:space="preserve">
          <source>And yet, one of them invokes undefined behavior, whereas the other one does not. So what is the difference between the expressions &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;make_triangle()&lt;/code&gt;? Aren't they both of the same type? Indeed they are, but they have different &lt;em&gt;value categories&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それでも、1つは未定義の動作を呼び出しますが、もう1つは呼び出しません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;では、式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の違いは何&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ですか？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;どちらも同じタイプではないですか？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;確かにそうですが、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;価値カテゴリ&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は異なり&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0eeed3546c92bc7d030625e964a6a1e8f2f93dd1" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;move&lt;/code&gt; accepts any kind of parameter thanks to the forwarding reference &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, and it returns an rvalue reference. The &lt;code&gt;std::remove_reference&amp;lt;T&amp;gt;::type&lt;/code&gt; meta-function call is necessary because otherwise, for lvalues of type &lt;code&gt;X&lt;/code&gt;, the return type would be &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt;, which would collapse into &lt;code&gt;X&amp;amp;&lt;/code&gt;. Since &lt;code&gt;t&lt;/code&gt; is always an lvalue (remember that a named rvalue reference is an lvalue), but we want to bind &lt;code&gt;t&lt;/code&gt; to an rvalue reference, we have to explicitly cast &lt;code&gt;t&lt;/code&gt; to the correct return type.
The call of a function that returns an rvalue reference is itself an xvalue. Now you know where xvalues come from ;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ご覧のとおり、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は転送参照&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;おかげであらゆる種類のパラメーターを受け入れ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、右辺値参照を返します。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::remove_reference&amp;lt;T&amp;gt;::type&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それ以外の場合、型の左辺値のためにので、メタ関数呼び出しが必要である&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、戻り型は次のようになり&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に崩壊する、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以来&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; は&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;常に左辺値である（という名前の右辺値参照は左辺値であることを覚えている）が、私たちは、バインドしたい&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値参照に、我々は明示的にキャストする必要があり&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正しい戻り値の型に。右辺値参照を返す関数の呼び出し自体がx値です。これで、xvalueがどこから来たかがわかります;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5a6f247186a6ec51d7763851bdd8e18f434a0b74" translate="yes" xml:space="preserve">
          <source>Basically, the compiler will complain that &lt;code&gt;parameter&lt;/code&gt; is an lvalue. If you look at its type, you see an rvalue reference, but an rvalue reference simply means &quot;a reference that is bound to an rvalue&quot;; it does &lt;em&gt;not&lt;/em&gt; mean that the reference itself is an rvalue! Indeed, &lt;code&gt;parameter&lt;/code&gt; is just an ordinary variable with a name. You can use &lt;code&gt;parameter&lt;/code&gt; as often as you like inside the body of the constructor, and it always denotes the same object. Implicitly moving from it would be dangerous, hence the language forbids it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基本的に、コンパイラーは&lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が左辺値で&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あると文句を言うでしょう&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その型を見ると、右辺値参照が表示されますが、右辺値参照は、単に「右辺値にバインドされている参照」を意味します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照自体が右辺値であるという意味&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ではありませ&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ん&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は名前を持つ通常の変数です。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はコンストラクタの本体内で何度でも&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;でき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、常に同じオブジェクトを示します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;暗黙的にそこから移動することは危険であり、したがって言語はそれを禁止します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e378544bfb07451e6088433236851c65b1e84876" translate="yes" xml:space="preserve">
          <source>Because the function also &lt;em&gt;returns by value&lt;/em&gt;, another new object is constructed for the return value:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数も&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;値によって戻る&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ため、戻り値用に別の新しいオブジェクトが作成されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e819a9290ce3be37f7d22e748fce09e94c70c736" translate="yes" xml:space="preserve">
          <source>Both prvalues and xvalues are rvalues. Xvalues and lvalues are both &lt;em&gt;glvalues&lt;/em&gt; (Generalized lvalues). The relationships are easier to grasp with a diagram:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;prvaluesとxvaluesはどちらも右辺値です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;X値とl値はどちらも&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;glvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（一般化された&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;l&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;値）です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関係は図で把握するのが簡単です：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef1b8b9546c894e61fe1d619148e7bed5cc0fc49" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;auto_ptr&lt;/code&gt; is not &lt;em&gt;always&lt;/em&gt; dangerous. Factory functions are a perfectly fine use case for &lt;code&gt;auto_ptr&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;常に&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;危険である&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;とは&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;限り&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ませ&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ん&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ファクトリ関数は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完全に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;適切&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;な使用例です&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e6a400bc51fb91373f9c57144a4bd019862c564" translate="yes" xml:space="preserve">
          <source>But if you say &lt;code&gt;a = x + y&lt;/code&gt;, the &lt;em&gt;move constructor&lt;/em&gt; will initialize &lt;code&gt;that&lt;/code&gt; (because the expression &lt;code&gt;x + y&lt;/code&gt; is an rvalue), so there is no deep copy involved, only an efficient move.
&lt;code&gt;that&lt;/code&gt; is still an independent object from the argument, but its construction was trivial,
since the heap data didn't have to be copied, just moved. It wasn't necessary to copy it because &lt;code&gt;x + y&lt;/code&gt; is an rvalue, and again, it is okay to move from string objects denoted by rvalues.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a = x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と言うと&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動コンストラクター&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;がそれを初期化&lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が右辺値であるため）。したがって、深いコピーは含まれず、効率的な移動のみが行われます。 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はまだ引数から独立したオブジェクトですが、ヒープデータをコピーする必要がなく、移動しただけなので、その構築は簡単でした。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は右辺値な&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ので、コピーする必要はありませんでした。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここでも、右辺値で示された文字列オブジェクトから移動してもかまいません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="32822acac85aaeec4278db58d224f2fe9f3f352c" translate="yes" xml:space="preserve">
          <source>But, is that not dangerous? Of course, you could destruct a dynamic object twice (segmentation fault). So, to avoid that, you should &quot;invalidate&quot; the source pointers to avoid destructing them twice:</source>
          <target state="translated">しかし、それは危険ではないでしょうか?もちろん、動的なオブジェクトを二度もデストラクトしてしまう可能性があります(セグメンテーションフォルト)。なので、それを避けるためには、ソースポインタを「無効化」して二度破壊しないようにしましょう。</target>
        </trans-unit>
        <trans-unit id="c8a8d115ca80240745b86fe8f011228ba83a9e3b" translate="yes" xml:space="preserve">
          <source>C++0x introduces a new mechanism called &quot;rvalue reference&quot; which, among other things,
allows us to detect rvalue arguments via function overloading. All we have to do is write a constructor with an rvalue reference parameter. Inside that constructor we can do &lt;em&gt;anything we want&lt;/em&gt; with the source, as long as we leave it in &lt;em&gt;some&lt;/em&gt; valid state:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 0xには、「右辺値参照」と呼ばれる新しいメカニズムが導入されています。これにより、関数のオーバーロードを介して右辺値引数を検出できます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必要なのは、右辺値参照パラメーターを使用してコンストラクターを作成することだけです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのコンストラクタ内では行うことができます&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私たちが望むものを&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;限り、私たちがそれを残すように、ソースと&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;いくつかの&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有効な状態：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd0492dc5e0b6d5d91433b74385064b17d458bf4" translate="yes" xml:space="preserve">
          <source>C++11's answer to this problem is &lt;em&gt;rvalue references&lt;/em&gt;. An rvalue reference is a new kind of reference that only binds to rvalues, and the syntax is &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt;. The good old reference &lt;code&gt;X&amp;amp;&lt;/code&gt; is now known as an &lt;em&gt;lvalue reference&lt;/em&gt;. (Note that &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a reference to a reference; there is no such thing in C++.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この問題に対するC ++ 11の答えは、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値参照&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値参照は、右辺値にのみバインドされる新しい種類の参照であり、構文は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;古き良きリファレンス&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は現在、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;左辺値リファレンス&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;として知られてい&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照への参照で&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ない&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことに注意してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。C++にはそのようなものはありません。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="023a6a48d15ef2c95fc40e5be2aa59fe9b54efad" translate="yes" xml:space="preserve">
          <source>C++98 implicitly declares three special member functions on demand, that is, when they are needed somewhere: the copy constructor, the copy assignment operator and the destructor.</source>
          <target state="translated">C++98 では、3 つの特別なメンバ関数が必要に応じて暗黙的に宣言されています。つまり、どこかで必要とされる場合には、コピー コンストラクタ、コピー代入演算子、およびデストラクタです。</target>
        </trans-unit>
        <trans-unit id="c779770f0201fc38c70bf3c75d9a6f84752c9e0a" translate="yes" xml:space="preserve">
          <source>C++98 rvalues are known as prvalues in C++11. Mentally replace all occurrences of &quot;rvalue&quot; in the preceding paragraphs with &quot;prvalue&quot;.</source>
          <target state="translated">C++98 の r 値は、C++11 では pr 値として知られています。 前の段落で出現した「rvalue」をすべて「prvalue」に置き換えてください。</target>
        </trans-unit>
        <trans-unit id="132f3ce3182bbd08fe44f45ff771c82759cf58e2" translate="yes" xml:space="preserve">
          <source>Congratulations, you now understand the basics of move semantics! Let's continue by implementing the assignment operator. If you're unfamiliar with the &lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;copy and swap idiom&lt;/a&gt;, learn it and come back, because it's an awesome C++ idiom related to exception safety.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;おめでとうございます。これで移動セマンティクスの基本が理解できました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代入演算子を実装して続けましょう。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コピーとスワップのイディオム&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;慣れていない場合は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、例外の安全性に関連する素晴らしいC ++イディオムであるため、学んで戻ってきてください。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec6e7926adcc44088c147ea22db81f9c26b87174" translate="yes" xml:space="preserve">
          <source>Consider the following function template:</source>
          <target state="translated">次のような関数テンプレートを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="a22158725623f7c0e74173ef7dccec9292a51ae4" translate="yes" xml:space="preserve">
          <source>Copying an object means copying its &quot;static&quot; members and calling the &lt;code&gt;new&lt;/code&gt; operator for its dynamic objects. Right?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクトのコピーとは、「静的」メンバーをコピーし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、動的オブジェクトの&lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;演算子を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;呼び出すことを意味し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正しい？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4bd58a0d0236432df5def76d9e83073103fc10f" translate="yes" xml:space="preserve">
          <source>Dangerous and harmless moves</source>
          <target state="translated">危険で無害な動き</target>
        </trans-unit>
        <trans-unit id="8cdb90911daa2d1059f97197edc4cbc56200db7d" translate="yes" xml:space="preserve">
          <source>Depending on the class, maybe its a container with very much data, then that could represent much &lt;em&gt;time&lt;/em&gt; and &lt;em&gt;memory usage&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クラスによっては、おそらく非常に多くのデータを含むコンテナであり、それは多くの&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;時間&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メモリ使用量を&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表す可能性が&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あり&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da91507e4d455dd873c3a8569cb70baddddfd087" translate="yes" xml:space="preserve">
          <source>Forwarding references (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf&quot;&gt;previously&lt;/a&gt; known as &lt;em&gt;Universal references&lt;/em&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;転送参照（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以前&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ユニバーサル参照&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;として知られ&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ていました&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b55f1baad0eb4d648fab85d1a0b7b027bc44527" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/move_constructor&quot;&gt;cppreference.com&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/move_constructor&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cppreference.com&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9831a9d72fc41bc7b1a34c6df1cc9330199f0d3" translate="yes" xml:space="preserve">
          <source>Here is how you explicitly move from an lvalue:</source>
          <target state="translated">ここでは、lvalueから明示的に移動する方法を説明します。</target>
        </trans-unit>
        <trans-unit id="ad658fc75be5325793f2c751d9cbdad9efe908d2" translate="yes" xml:space="preserve">
          <source>Here's a function that takes an object of type &lt;code&gt;T&lt;/code&gt; and returns an object of the same type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;型のオブジェクトを受け取り&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、同じ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;型のオブジェクトを返す&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数を次に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;示します&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="472a84ed15750c08597c803026e48d9c509d8f33" translate="yes" xml:space="preserve">
          <source>How come the move constructor accepts the lvalue &lt;code&gt;result&lt;/code&gt; as an argument? The scope of &lt;code&gt;result&lt;/code&gt; is about to end, and it will be destroyed during stack unwinding. Nobody could possibly complain afterwards that &lt;code&gt;result&lt;/code&gt; had changed somehow; when control flow is back at the caller, &lt;code&gt;result&lt;/code&gt; does not exist anymore! For that reason, C++11 has a special rule that allows returning automatic objects from functions without having to write &lt;code&gt;std::move&lt;/code&gt;. In fact, you should &lt;em&gt;never&lt;/em&gt; use &lt;code&gt;std::move&lt;/code&gt; to move automatic objects out of functions, as this inhibits the &quot;named return value optimization&quot; (NRVO).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;moveコンストラクターがlvalueの&lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を引数として&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;受け入れるのは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;なぜですか？&lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の範囲は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;間もなく&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;終了し、スタックの巻き戻し中に破棄されます。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;がどういうわけか変わった&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;後、誰もおそらく文句を言うことができませんでした&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;制御フローが呼び出し元に戻ったとき、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はもう存在しません！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのため、C ++ 11には、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を記述せずに関数から自動オブジェクトを返すことができる特別なルールがあります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「名前付き戻り値の最適化」（NRVO）を阻害するため、関数から自動オブジェクトを移動&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;するために&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用し&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ない&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;でください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b78fb8d2a72d70a2b646e5838f76a391fca0bd1" translate="yes" xml:space="preserve">
          <source>However, to &lt;strong&gt;move&lt;/strong&gt; an object (I repeat, in a practical point of view) implies only to copy the pointers of dynamic objects, and not to create new ones.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクト&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する（実際の観点では繰り返します）とは、動的オブジェクトのポインターをコピーすることのみを意味し、新しいオブジェクトを作成することを意味しません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be9d897b4ed75e9712b0896110f82792f56d7b57" translate="yes" xml:space="preserve">
          <source>Huh, that's it? &quot;Where's the rvalue reference?&quot; you might ask. &quot;We don't need it here!&quot; is my answer :)</source>
          <target state="translated">はぁ、それだけ?&quot;rvalueのリファレンスはどこにあるの?&quot;と聞かれるかもしれません。&quot;ここでは必要ありません!&quot; が私の答えです :)</target>
        </trans-unit>
        <trans-unit id="dcad3bfb835bd226281cdb3832ed9fbd595b0efa" translate="yes" xml:space="preserve">
          <source>I find it easiest to understand move semantics with example code. Let's start with a very simple string class which only holds a pointer to a heap-allocated block of memory:</source>
          <target state="translated">移動のセマンティクスを理解するには、コード例を見ながら理解するのが一番簡単だと思います。ヒープに割り当てられたメモリブロックへのポインタを保持するだけの非常にシンプルな文字列クラスから始めてみましょう。</target>
        </trans-unit>
        <trans-unit id="55918cb4dcbdcb99697ef67c5bfaed72dce39cdf" translate="yes" xml:space="preserve">
          <source>I hope this example got the main point across. There is a lot more to rvalue references and move semantics which I intentionally left out to keep it simple. If you want more details please see &lt;a href=&quot;https://stackoverflow.com/a/11540204/179917&quot;&gt;my supplementary answer&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この例が重要なポイントになったと思います。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照を評価し、セマンティクスを移動する方法は他にもたくさんあります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;詳細については&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/11540204/179917&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、私の補足回答&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;をご覧ください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e26477129fa8f03bbac0d3249cb6cbea6421174" translate="yes" xml:space="preserve">
          <source>I just finished listening to the Software Engineering radio &lt;a href=&quot;http://www.se-radio.net/2010/04/episode-159-c-0x-with-scott-meyers/&quot;&gt;podcast interview with Scott Meyers&lt;/a&gt; regarding &lt;a href=&quot;http://en.wikipedia.org/wiki/C++11&quot;&gt;C++0x&lt;/a&gt;. Most of the new features made sense to me, and I am actually excited about C++0x now, with the exception of one. I still don't get &lt;em&gt;move semantics&lt;/em&gt;... What is it exactly?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/C++11&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 0x&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に関する&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.se-radio.net/2010/04/episode-159-c-0x-with-scott-meyers/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Scott Meyersとの&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ソフトウェアエンジニアリングラジオ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ポッドキャストインタビューを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;聞いたところです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;新機能のほとんどは私には理にかなっており、私は実際にC ++ 0xに興奮しています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私はまだ&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動セマンティクスを&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;取得しません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;...それは正確には何ですか？&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="adf922abf7820e8db1f54450dd73fbd3b62dfdc5" translate="yes" xml:space="preserve">
          <source>I'm writing this to make sure I understand it properly.</source>
          <target state="translated">きちんと理解するために書いています。</target>
        </trans-unit>
        <trans-unit id="ea09e01c3b05274835a4c830a79abe380ae9f1ce" translate="yes" xml:space="preserve">
          <source>If the argument is an rvalue of type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; is deduced to be &lt;code&gt;X&lt;/code&gt;, hence &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; means &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt;. This is what anyone would expect.
But if the argument is an lvalue of type &lt;code&gt;X&lt;/code&gt;, due to a special rule, &lt;code&gt;T&lt;/code&gt; is deduced to be &lt;code&gt;X&amp;amp;&lt;/code&gt;, hence &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; would mean something like &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt;. But since C++ still has no notion of references to references, the type &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; is &lt;em&gt;collapsed&lt;/em&gt; into &lt;code&gt;X&amp;amp;&lt;/code&gt;. This may sound confusing and useless at first, but reference collapsing is essential for &lt;em&gt;perfect forwarding&lt;/em&gt; (which will not be discussed here).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;引数は、型の右辺値である場合&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; は、&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;であると推定される&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、したがって&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;手段&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。これは誰もが期待することです。ただし、引数が&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;型の左辺値である場合、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特別な規則により、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あると推定される&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ため、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ようなものを意味します&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。しかし、C ++ので、まだ参照への参照という概念がないタイプ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;される&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;崩壊&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは最初は混乱して役に立たないように思えるかもしれませんが、&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完全な転送に&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は参照の折りたたみが不可欠です&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; （ここでは説明しません）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eaf342f5b650317d7bfa03afecf3ae79d590c46f" translate="yes" xml:space="preserve">
          <source>If we throw &lt;code&gt;const&lt;/code&gt; into the mix, we already have four different kinds of references. What kinds of expressions of type &lt;code&gt;X&lt;/code&gt; can they bind to?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我々は投げる場合&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ミックスに、我々はすでに参照の4種類があります。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;型のどのような種類の式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;にバインドできますか？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ff4084df9c7bfd662c531429fd1f1577ffe7f6b" translate="yes" xml:space="preserve">
          <source>If you are really interested in a good, in-depth explanation of move semantics, I'd highly recommend reading the original paper on them, &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm&quot;&gt;&quot;A Proposal to Add Move Semantics Support to the C++ Language.&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動セマンティクスの優れた詳細な説明に本当に興味がある場合は、それらに関する元の論文&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「C ++言語に移動セマンティクスサポートを追加する提案」を&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;読むことを強くお勧めします&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1199d462777552484944164f0bb197d84758ee45" translate="yes" xml:space="preserve">
          <source>If you want to constrain a function template to rvalues, you can combine &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/sfinae&quot;&gt;SFINAE&lt;/a&gt; with type traits:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数テンプレートを右辺値に制限したい場合は、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/sfinae&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SFINAE&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;をタイプ特性と&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;組み合わせることができます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6da7cd499914cd7d580cba25f4db0148f6ddfea4" translate="yes" xml:space="preserve">
          <source>If you write a class without unmanaged resources, there is no need to declare any of the five special member functions yourself, and you will get correct copy semantics and move semantics for free. Otherwise, you will have to implement the special member functions yourself. Of course, if your class does not benefit from move semantics, there is no need to implement the special move operations.</source>
          <target state="translated">管理されていないリソースを持たないクラスを書けば、5つの特別なメンバ関数を自分で宣言する必要はなく、正しいコピーセマンティクスとムーブセマンティクスを無料で得ることができます。そうでなければ、特別なメンバ関数を自分で実装しなければなりません。もちろん、あなたのクラスが移動セマンティクスの恩恵を受けない場合は、特別な移動操作を実装する必要はありません。</target>
        </trans-unit>
        <trans-unit id="937ed34b756d18c282b5b2e827b2ade63aff5ec5" translate="yes" xml:space="preserve">
          <source>If your object is complex and the destructor has other secondary effects, like calling to a library's function, calling to other global functions or whatever it is, perhaps is better to signal a movement with a flag:</source>
          <target state="translated">オブジェクトが複雑で、デストラクタがライブラリの関数を呼び出したり、他のグローバル関数を呼び出したりと、他の副次的な効果を持っている場合は、フラグを使って動きを知らせる方が良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="7a9339c8c4d94e2f90667ec0345c001b70cea00e" translate="yes" xml:space="preserve">
          <source>Implementation of move</source>
          <target state="translated">引越しの実施</target>
        </trans-unit>
        <trans-unit id="52c0adee2f966c6d6cae560ab2e2d18938668573" translate="yes" xml:space="preserve">
          <source>Implementing safe &quot;move-only&quot; types; that is, types for which copying does not make sense, but moving does.  Examples include locks, file handles, and smart pointers with unique ownership semantics. Note: This answer discusses &lt;code&gt;std::auto_ptr&lt;/code&gt;, a deprecated C++98 standard library template, which was replaced by &lt;code&gt;std::unique_ptr&lt;/code&gt; in C++11. Intermediate C++ programmers are probably at least somewhat familiar with &lt;code&gt;std::auto_ptr&lt;/code&gt;, and because of the &quot;move semantics&quot; it displays, it seems like a good starting point for discussing move semantics in C++11. YMMV.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;安全な「移動専用」タイプの実装。つまり、コピーには意味がなく、移動には意味があるタイプです。例としては、ロック、ファイルハンドル、一意の所有権セマンティクスを持つスマートポインターなどがあります。注：この回答では&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、廃止予定のC ++ 98標準ライブラリテンプレートである&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;について説明します。これ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、C ++ 11では&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;置き換えられました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。中級のC ++プログラマーは、おそらく&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ある程度精通し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ており、表示される「移動のセマンティクス」のため、C ++ 11での移動のセマンティクスについて説明するための良い出発点のようです。 YMMV。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a454cb8b77503090cbd9a357441f356bcc77421b" translate="yes" xml:space="preserve">
          <source>Implicit conversions</source>
          <target state="translated">暗黙の変換</target>
        </trans-unit>
        <trans-unit id="bb86577e32db06fdf51943d408f139502900a7ec" translate="yes" xml:space="preserve">
          <source>In C++03, objects are often copied, only to be destroyed or assigned-over before any code uses the value again.  For example, when you return by value from a function&amp;mdash;unless RVO kicks in&amp;mdash;the value you're returning is copied to the caller's stack frame, and then it goes out of scope and is destroyed.  This is just one of many examples: see pass-by-value when the source object is a temporary, algorithms like &lt;code&gt;sort&lt;/code&gt; that just rearrange items, reallocation in &lt;code&gt;vector&lt;/code&gt; when its &lt;code&gt;capacity()&lt;/code&gt; is exceeded, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 03では、オブジェクトがコピーされることが多く、コードが値を再び使用する前に破棄または割り当てられます。たとえば、RVOが起動しない限り、関数から値で戻ると、返される値は呼び出し元のスタックフレームにコピーされ、その後スコープ外になり破棄されます。これはほんの一多くの例である：ソースオブジェクトのような一時的なアルゴリズムである場合、パスごとの値を参照して&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sort&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;だけ再配置項目に再配置その&lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;capacity()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;超えて、等&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3a5b25589cda5ecaab0c938846dc8a956cfda45" translate="yes" xml:space="preserve">
          <source>In C++11, &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; has been replaced by &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; which takes advantage of rvalue references. I will develop and discuss a simplified version of &lt;code&gt;unique_ptr&lt;/code&gt;. First, we encapsulate a raw pointer and overload the operators &lt;code&gt;-&amp;gt;&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, so our class feels like a pointer:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11では、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、右辺値参照を利用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;置き換えられました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;簡易バージョンを開発して説明し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最初に、生のポインターをカプセル化し、演算子&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;および&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;をオーバーロードする&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ため、クラスはポインターのように見えます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c090c2258bd3627e3ec4d8b649121749fe3c3bd" translate="yes" xml:space="preserve">
          <source>In easy (practical) terms:</source>
          <target state="translated">簡単な(実用的な)言葉で</target>
        </trans-unit>
        <trans-unit id="b398d9ad5637d0de4ed8f0bf75e5761b7e55916e" translate="yes" xml:space="preserve">
          <source>In languages which do not allow the creation of local objects (that is, objects on the stack) these types of problems do not occur as all objects are allocated on the heap and are always accessed by reference.</source>
          <target state="translated">ローカルオブジェクト(スタック上のオブジェクト)の作成を許可していない言語では、すべてのオブジェクトはヒープ上に割り当てられ、常に参照によってアクセスされるため、このようなタイプの問題は発生しません。</target>
        </trans-unit>
        <trans-unit id="27637ef20b376dcf19cbb5d2e6d093390e3f522d" translate="yes" xml:space="preserve">
          <source>In practice, you can forget about &lt;code&gt;const X&amp;amp;&amp;amp;&lt;/code&gt;. Being restricted to read from rvalues is not very useful.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際には、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は忘れることができます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値からの読み取りに制限されていることはあまり役に立ちません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1103ccac7d3cbd997a56ab0386ee5fb290dec2d2" translate="yes" xml:space="preserve">
          <source>In that situation, an anonymous object is created, next copied to the function parameter, and afterwards deleted. So, here it is better to move the object, because you don't need the anonymous object and you can save time and memory.</source>
          <target state="translated">その場合、匿名オブジェクトが作成され、次に関数のパラメータにコピーされ、その後削除されます。ですから、ここではオブジェクトを移動させた方が、匿名オブジェクトが不要になり、時間とメモリの節約になります。</target>
        </trans-unit>
        <trans-unit id="43e85843d22aecda603952ad3f28eb8d579f2003" translate="yes" xml:space="preserve">
          <source>In the above code, with old compilers the result of &lt;code&gt;f()&lt;/code&gt; is &lt;strong&gt;&lt;em&gt;copied&lt;/em&gt;&lt;/strong&gt; into &lt;code&gt;x&lt;/code&gt; using &lt;code&gt;X&lt;/code&gt;'s copy constructor. If your compiler supports move semantics and &lt;code&gt;X&lt;/code&gt; has a move-constructor, then that is called instead. Since its &lt;code&gt;rhs&lt;/code&gt; argument is an &lt;em&gt;rvalue&lt;/em&gt;, we know it's not needed any longer and we can steal its value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;古いコンパイラの結果に上記のコードでは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;されている&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コピー&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用いて&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のコピーコンストラクタを。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンパイラがmoveセマンティクスをサポートし、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;にmove-constructorがある場合は、代わりにそれが呼び出されます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その以来&lt;/font&gt;&lt;/font&gt; &lt;code&gt;rhs&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;引数が&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、我々はそれがもはや必要ないことを知っていると我々はその価値を盗むことができます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da927e9aca357b1650ec6103ca59d8bb2cb33301" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;&quot;hello world&quot;&lt;/code&gt; is an lvalue of type &lt;code&gt;const char[12]&lt;/code&gt;. Since there is an implicit conversion from &lt;code&gt;const char[12]&lt;/code&gt; through &lt;code&gt;const char*&lt;/code&gt; to &lt;code&gt;std::string&lt;/code&gt;, a temporary of type &lt;code&gt;std::string&lt;/code&gt; is created, and &lt;code&gt;r&lt;/code&gt; is bound to that temporary. This is one of the cases where the distinction between rvalues (expressions) and temporaries (objects) is a bit blurry.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上記の例では、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;hello world&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は型&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char[12]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;左辺値です&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char[12]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;介し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;て&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;暗黙的に変換される&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ため、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: string&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;タイプの一時&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が作成され、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;がその一時ファイルにバインドされます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、右辺値（式）と一時値（オブジェクト）の区別が少しぼやけている場合の1つです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc3e683553dc45c7f890c6646a6841181eb6dec4" translate="yes" xml:space="preserve">
          <source>In this case, when an object of type &lt;code&gt;A&lt;/code&gt; should be &quot;copied&quot;, the compiler creates a lvalue reference or a rvalue reference according to if the passed object is named or not. When not, your move-constructor is called and you know the object is temporal and you can move its dynamic objects instead of copying them, saving space and memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この場合、タイプ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクトを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「コピー」&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必要がある場合、コンパイラーは、渡されたオブジェクトが名前付きかどうかに応じて、左辺値参照または右辺値参照を作成します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そうでない場合は、moveコンストラクターが呼び出され、オブジェクトが一時的であることがわかっているため、動的オブジェクトをコピーする代わりに移動して、スペースとメモリを節約できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="d04bb2623f5288427463db7edef0eb602a9ed94a" translate="yes" xml:space="preserve">
          <source>Is that perfect forwarding? Not, but we are very close. Perfect forwarding is only useful to work with templates, with the purpose to say: if I need to pass an object to another function, I need that if I receive a named object, the object is passed as a named object, and when not, I want to pass it like a unnamed object:</source>
          <target state="translated">完璧な転送ですか?そうではありませんが、非常に近いです。完全な転送は、テンプレートを使って作業するときにのみ有用で、その目的は次のように言います:オブジェクトを別の関数に渡す必要がある場合、名前付きオブジェクトを受け取った場合には、そのオブジェクトは名前付きオブジェクトとして渡され、そうでない場合には、名前付きでないオブジェクトのように渡したいということです。</target>
        </trans-unit>
        <trans-unit id="697f3bc7df8e26b6f96ff8496435e846fe70c4d6" translate="yes" xml:space="preserve">
          <source>It is important to remember that &quot;static&quot; objects are always copied. There's no ways to &quot;move&quot; a static object (object in stack and not on heap). So, the distinction &quot;move&quot;/ &quot;copy&quot; when an object has no dynamic members (directly or indirectly) is irrelevant.</source>
          <target state="translated">静的な」オブジェクトは常にコピーされることを覚えておくことが重要です。静的なオブジェクト(スタック上のオブジェクトでヒープ上のオブジェクトではない)を &quot;移動 &quot;する方法はありません。ですから、オブジェクトが動的なメンバを持たない場合の &quot;move&quot; &quot;copy&quot; という区別は (直接的か間接的かに関わらず)無関係です。</target>
        </trans-unit>
        <trans-unit id="e9d98f8e9d5357e09bdb4ad11e6dbd887aa316f7" translate="yes" xml:space="preserve">
          <source>It must first initialize the object, then copy all the relevant data from the old object to the new one.</source>
          <target state="translated">最初にオブジェクトを初期化し、古いオブジェクトから新しいオブジェクトに関連するすべてのデータをコピーしなければなりません。</target>
        </trans-unit>
        <trans-unit id="3203ece5d832b88a426ed868437b3f103470fad2" translate="yes" xml:space="preserve">
          <source>It's like copy semantics, but instead of having to duplicate all of the data you get to steal the data from the object being &quot;moved&quot; from.</source>
          <target state="translated">これはコピーセマンティクスのようなものですが、すべてのデータを複製しなければならない代わりに、「移動」されたオブジェクトからデータを盗むことができます。</target>
        </trans-unit>
        <trans-unit id="90e6d34c95a16f345f4e07cab166d7088702a308" translate="yes" xml:space="preserve">
          <source>It's very accessible and easy to read and it makes an excellent case for the benefits that they offer.  There are other more recent and up to date papers about move semantics available on &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/&quot;&gt;the WG21 website&lt;/a&gt;, but this one is probably the most straightforward since it approaches things from a top-level view and doesn't get very much into the gritty language details.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それは非常にアクセスしやすく、読みやすく、彼らが提供する利点の優れた例になります。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;WG21のWebサイトでは&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動のセマンティクスに関する最新の最新の論文が他にもありますが&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、これはトップレベルの視点から物事に取り組み&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、粗末&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;な言語の詳細にあまり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;触れ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ないため、おそらく最も簡単なものです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3214661671ef9aff8765af8c7d203ac41c5e3e99" translate="yes" xml:space="preserve">
          <source>Move assignment operators</source>
          <target state="translated">代入演算子の移動</target>
        </trans-unit>
        <trans-unit id="76c87719ef4631d051ec31847319db90f2a38c3c" translate="yes" xml:space="preserve">
          <source>Move constructors</source>
          <target state="translated">コンストラクタの移動</target>
        </trans-unit>
        <trans-unit id="21df78e8312204ee0ae1344d1d1244c5ab2567b2" translate="yes" xml:space="preserve">
          <source>Move semantics allows an object, under certain conditions, to take ownership of some other object's external resources. This is important in two ways:</source>
          <target state="translated">移動セマンティクスでは、あるオブジェクトは、ある条件の下で、他のオブジェクトの外部リソースの所有権を取得することができます。これは2つの点で重要です。</target>
        </trans-unit>
        <trans-unit id="ff2c5f0ff5c8b72e423fa0fe0eb25bf31e14356c" translate="yes" xml:space="preserve">
          <source>Move semantics are based on &lt;strong&gt;&lt;em&gt;rvalue references&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動セマンティクスは&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値参照に&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基づいてい&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b1fd88c02c0af8c30b9a31838ee4311178338b21" translate="yes" xml:space="preserve">
          <source>Move semantics is basically a user-defined type with constructor that takes an r-value reference (new type of reference using &amp;amp;&amp;amp; (yes two ampersands)) which is non-const, this is called a move constructor, same goes for assignment operator. So what does a move constructor do, well instead of copying memory from it's source argument it 'moves' memory from the source to the destination.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動セマンティクスは基本的に、const以外のr値参照（&amp;amp;&amp;amp;（はい2つのアンパサンド）を使用した新しいタイプの参照）を取るコンストラクターを持つユーザー定義型です。これは移動コンストラクターと呼ばれ、割り当て演算子と同じです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり、移動コンストラクタは何をするのでしょうか？そのソース引数からメモリをコピーする代わりに、ソースから宛先にメモリを「移動」します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60affa9a44a9bad8c292beedae93936057dc4f21" translate="yes" xml:space="preserve">
          <source>Move semantics were created to avoid the unnecessary copying of large objects.  Bjarne Stroustrup in his book &quot;The C++ Programming Language&quot; uses two examples where unnecessary copying occurs by default: one, the swapping of two large objects, and two, the returning of a large object from a method.</source>
          <target state="translated">Moveセマンティクスは、ラージオブジェクトの不必要なコピーを避けるために作成されました。Bjarne Stroustrup氏は著書 &quot;The C++Programming Language &quot;の中で、不必要なコピーがデフォルトで発生する2つの例を使っています。</target>
        </trans-unit>
        <trans-unit id="f19144fcd990c500b4ac693c567a9549f27dfd2c" translate="yes" xml:space="preserve">
          <source>Moving from lvalues</source>
          <target state="translated">l値からの移行</target>
        </trans-unit>
        <trans-unit id="d64e12206734f5c30656ba8ea9b5782042bd423a" translate="yes" xml:space="preserve">
          <source>Moving from lvalues such as &lt;code&gt;a&lt;/code&gt; is dangerous, because we could later try to call a member function via &lt;code&gt;a&lt;/code&gt;, invoking undefined behavior. On the other hand, moving from rvalues such as &lt;code&gt;make_triangle()&lt;/code&gt; is perfectly safe, because after the copy constructor has done its job, we cannot use the temporary again. There is no expression that denotes said temporary; if we simply write &lt;code&gt;make_triangle()&lt;/code&gt; again, we get a &lt;em&gt;different&lt;/em&gt; temporary. In fact, the moved-from temporary is already gone on the next line:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のような左辺値からの移動&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は危険です。後でを介し&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;メンバー関数を呼び出そう&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;として&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;未定義の動作が呼び出さ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;れる可能性があるため&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。一方、&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;などの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;からの移動&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は完全に安全です。これは、コピーコンストラクターがその仕事を終えた後は、一時&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;変数を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;再び使用できないためです。この一時的なものを表す表現はありません。単に&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;再度&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;記述するだけで&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;別の&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一時&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ファイルが&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;取得され&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。実際、moved-fromテンポラリはすでに次の行にあります。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a63742120d0d7b0e09c3bb18048c15fda0b0e774" translate="yes" xml:space="preserve">
          <source>Moving into members</source>
          <target state="translated">メンバーへの転入</target>
        </trans-unit>
        <trans-unit id="55a56ac4401dd0eaa2dcf2e8a8396e846706642c" translate="yes" xml:space="preserve">
          <source>Moving out of functions</source>
          <target state="translated">機能の引越し</target>
        </trans-unit>
        <trans-unit id="2a77a62dac1e84715dce30b39e1eca21de49ebaa" translate="yes" xml:space="preserve">
          <source>Moving the data involves re-associating the data with the new object. And &lt;em&gt;no copy takes place&lt;/em&gt; at all.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;データを移動するには、データを新しいオブジェクトに再度関連付ける必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そして&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、コピーは&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;まったく&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;行わ&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;れ&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ません&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="694f6377ae54f3d5a6a8d632f41c5ee6694d13aa" translate="yes" xml:space="preserve">
          <source>My first answer was an extremely simplified introduction to move semantics, and many details were left out on purpose to keep it simple.
However, there is a lot more to move semantics, and I thought it was time for a second answer to fill the gaps.
The first answer is already quite old, and it did not feel right to simply replace it with a completely different text. I think it still serves well as a first introduction. But if you want to dig deeper, read on :)</source>
          <target state="translated">私の最初の回答は、ムーブセマンティクスの紹介を非常に簡略化したもので、シンプルにするために多くの詳細を省いています。しかし、ムーブセマンティクスにはもっと多くのことがあり、そのギャップを埋めるために2つ目の回答が必要だと考えました。最初の回答はすでにかなり古いものであり、単純に全く別の文章に置き換えるのは適切ではありませんでした。私はそれがまだ最初の入門書として十分に役立つと思います。しかし、もしあなたがもっと深く掘り下げたいのであれば、読んでみてください :)</target>
        </trans-unit>
        <trans-unit id="2273c40caec113ed4c70f21b9c59f72191a4ef03" translate="yes" xml:space="preserve">
          <source>Never return automatic objects by rvalue reference. Moving is exclusively performed by the move constructor, not by &lt;code&gt;std::move&lt;/code&gt;, and not by merely binding an rvalue to an rvalue reference.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値参照によって自動オブジェクトを返さないでください。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ではなく、右辺値を右辺値参照にバインドするだけ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ではなく、移動コンストラクタによって排他的に実行され&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c87b215e468265e84456567f5fd96732627b217" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;std::move&lt;/code&gt; to move automatic objects out of functions.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用して&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自動オブジェクトを関数から移動し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ないでください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5620a89fc44e99a7e64f46bd1660b0fe78ec31ff" translate="yes" xml:space="preserve">
          <source>Note how both examples follow the same syntactic pattern:</source>
          <target state="translated">両方の例が同じ構文パターンに従っていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9ffaa4649e35625dc8efbe19265d4da4843b9b9e" translate="yes" xml:space="preserve">
          <source>Note how the initialization of &lt;code&gt;b&lt;/code&gt; with &lt;code&gt;a&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; copy the triangle, but instead transfers the ownership of the triangle from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;. We also say &quot;&lt;code&gt;a&lt;/code&gt; is &lt;em&gt;moved into&lt;/em&gt;&lt;code&gt;b&lt;/code&gt;&quot; or &quot;the triangle is &lt;em&gt;moved&lt;/em&gt; from &lt;code&gt;a&lt;/code&gt;&lt;em&gt;to&lt;/em&gt;&lt;code&gt;b&lt;/code&gt;&quot;. This may sound confusing, because the triangle itself always stays at the same place in memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注どのように初期の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ん&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ではない&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;三角形をコピーし、代わりの三角形の所有権転送&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我々はまた、「言っ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ている&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に移動&lt;/font&gt;&lt;/em&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;」または「三角形がされて&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動する&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;/em&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;」。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;三角形自体は常にメモリ内の同じ場所にあるので、これは混乱するように聞こえるかもしれません。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4e30ddde6f9383ffb25516635c9c73988eaf920" translate="yes" xml:space="preserve">
          <source>Note how this implementation of the move assignment operator duplicates logic of both the destructor and the move constructor. Are you familiar with the copy-and-swap idiom? It can also be applied to move semantics as the move-and-swap idiom:</source>
          <target state="translated">移動代入演算子のこの実装では、デストラクタと移動コンストラクタの両方のロジックが重複していることに注意してください。コピーとスワップのイディオムをご存知でしょうか?これは、移動とスワップのイディオムとして移動セマンティクスにも適用できます。</target>
        </trans-unit>
        <trans-unit id="bc1ed59cd37ede9518aedf02a407061ed06f096c" translate="yes" xml:space="preserve">
          <source>Note that after the third line, &lt;code&gt;a&lt;/code&gt; no longer owns a triangle. That's okay, because by &lt;em&gt;explicitly&lt;/em&gt; writing &lt;code&gt;std::move(a)&lt;/code&gt;, we made our intentions clear: &quot;Dear constructor, do whatever you want with &lt;code&gt;a&lt;/code&gt; in order to initialize &lt;code&gt;c&lt;/code&gt;; I don't care about &lt;code&gt;a&lt;/code&gt; anymore. Feel free to have your way with &lt;code&gt;a&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;三行目の後に、という注意&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もはや三角形を所有しています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それが原因で、大丈夫です&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;明示的に&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;書く&lt;/font&gt; &lt;code&gt;std::move(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我々は我々の意図は明らかにした：「親愛なるコンストラクタを、あなたがやりたい&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;初期化するために&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; ;私は気にしないでください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もう持ってお気軽に。とあなたの方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。」&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b545f2bda15018d01523f9ff1692f25b2b72840e" translate="yes" xml:space="preserve">
          <source>Note that even though &lt;code&gt;std::move(a)&lt;/code&gt; is an rvalue, its evaluation does &lt;em&gt;not&lt;/em&gt; create a temporary object. This conundrum forced the committee to introduce a third value category. Something that can be bound to an rvalue reference, even though it is not an rvalue in the traditional sense, is called an &lt;em&gt;xvalue&lt;/em&gt; (eXpiring value). The traditional rvalues were renamed to &lt;em&gt;prvalues&lt;/em&gt; (Pure rvalues).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;std::move(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は右辺値ですが、その評価では&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一時オブジェクトが作成され&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ない&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この難問により、委員会は3番目の価値カテゴリーを導入せざるを得なくなりました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それは伝統的な意味では右辺値ではないにもかかわらず、右辺値参照にバインドすることができるものを、と呼ばれて&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はxValue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（値を期限切れ）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;従来の右辺値は&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;prvalues&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（純粋な右辺値）に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;名前が変更され&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ました&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6197c8328d3615627bdcb1f1810f59a11b3231ca" translate="yes" xml:space="preserve">
          <source>Note that in both factory functions, the return type is a value, not an rvalue reference. Rvalue references are still references, and as always, you should never return a reference to an automatic object; the caller would end up with a dangling reference if you tricked the compiler into accepting your code, like this:</source>
          <target state="translated">どちらのファクトリー関数でも、戻り値の型は値であり、rvalue 参照ではないことに注意してください。このようにコンパイラを騙してコードを受け入れるようにした場合、呼び出し元は参照をぶら下げたままになってしまいます。</target>
        </trans-unit>
        <trans-unit id="895f41e9bd9293af7e0f16ad424d9f9981e26c97" translate="yes" xml:space="preserve">
          <source>Note that only xvalues are really new; the rest is just due to renaming and grouping.</source>
          <target state="translated">x値だけが本当に新しいもので、残りは名前の変更とグループ化によるものであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3432dccea5cbc5683d11346e5fcd0b1d26cea00a" translate="yes" xml:space="preserve">
          <source>Note that returning by rvalue reference is fine in this example, because &lt;code&gt;t&lt;/code&gt; does not denote an automatic object, but instead an object that was passed in by the caller.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この例では、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は自動オブジェクトを表すのではなく、呼び出し元から渡されたオブジェクトを表す&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ため、右辺値参照で返すのは問題あり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89ea05e38d59c5aed95819ce421844b145c2084c" translate="yes" xml:space="preserve">
          <source>Note that the copy assignment operator and the move assignment operator can be fused into a single, unified assignment operator, taking its argument by value:</source>
          <target state="translated">コピー代入演算子と移動代入演算子を融合させて、その引数を値として取る単一の統一代入演算子にすることができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="545ad832cdf421948e5760aa53c065f811afa6d0" translate="yes" xml:space="preserve">
          <source>Note that the letters &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; have a historic origin in the left-hand side and right-hand side of an assignment. This is no longer true in C++, because there are lvalues which cannot appear on the left-hand side of an assignment (like arrays or user-defined types without an assignment operator), and there are rvalues which can (all rvalues of class types with an assignment operator).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文字&lt;/font&gt;&lt;/font&gt; &lt;code&gt;l&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;には、割り当ての左側と右側に歴史的な起源がある&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことに注意してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、C ++ではもはや当てはまりません。これは、代入の左側に表示できない左辺値（配列または代入演算子のないユーザー定義型など）があり、右辺値（クラス型のすべての右辺値）があるためです。代入演算子を使用して）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eaab0e119523ba0a6a6a259204c53d3659b8a758" translate="yes" xml:space="preserve">
          <source>Note that we pass the parameter &lt;code&gt;that&lt;/code&gt;&lt;em&gt;by value&lt;/em&gt;, so &lt;code&gt;that&lt;/code&gt; has to be initialized just like any other string object. Exactly how is &lt;code&gt;that&lt;/code&gt; going to be initialized? In the olden days of &lt;a href=&quot;http://en.wikipedia.org/wiki/C++#Standardization&quot;&gt;C++98&lt;/a&gt;, the answer would have been &quot;by the copy constructor&quot;. In C++0x, the compiler chooses between the copy constructor and the move constructor based on whether the argument to the assignment operator is an lvalue or an rvalue.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;パラメータ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;value&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;渡す&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ため&lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他の文字列オブジェクトと同じように初期化する必要が&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あることに注意してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。正確にどのようにされて&lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、初期化するつもり？&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/C++#Standardization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の昔&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、答えは「コピーコンストラクター」でした。 C ++ 0xでは、コンパイラーは、代入演算子の引数が左辺値または右辺値のどちらであるかに基づいて、コピーコンストラクターと移動コンストラクターのどちらかを選択します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="292b4ec9384f8616eaa92d7632778a096d02a026" translate="yes" xml:space="preserve">
          <source>Now comes the interesting part, the move constructor:</source>
          <target state="translated">ここからが面白いところで、移動のコンストラクタです。</target>
        </trans-unit>
        <trans-unit id="9eeb4639b40950f86cdb1f7ee968470d998ea4aa" translate="yes" xml:space="preserve">
          <source>Now comes the key insight into move semantics. Note that only in the first line where we copy &lt;code&gt;x&lt;/code&gt; is this deep copy really necessary, because we might want to inspect &lt;code&gt;x&lt;/code&gt; later and would be very surprised if &lt;code&gt;x&lt;/code&gt; had changed somehow. Did you notice how I just said &lt;code&gt;x&lt;/code&gt; three times (four times if you include this sentence) and meant the &lt;em&gt;exact same object&lt;/em&gt; every time? We call expressions such as &lt;code&gt;x&lt;/code&gt; &quot;lvalues&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここで、移動のセマンティクスに関する重要な洞察が得られます。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;をコピーする最初の行でのみ、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このディープコピーが本当に必要であることに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意してください。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;後で&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を検査する必要があり、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が何らかの形で変更された&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合は非常に驚かれるからです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。私が&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 3回（この文章を含めると4回）言って、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;毎回&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;まったく同じオブジェクト&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を意味&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;していることに気づきまし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たか？&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などの式を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「lvalues」&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と呼びます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="931b9f3d55a132fec2e5e039741e883dded73c53" translate="yes" xml:space="preserve">
          <source>Now that &lt;code&gt;source&lt;/code&gt; is a variable of type &lt;code&gt;unique_ptr&lt;/code&gt;, it will be initialized by the move constructor; that is, the argument will be moved into the parameter. The argument is still required to be an rvalue, because the move constructor itself has an rvalue reference parameter. When control flow reaches the closing brace of &lt;code&gt;operator=&lt;/code&gt;, &lt;code&gt;source&lt;/code&gt; goes out of scope, releasing the old resource automatically.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これで、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;型の変数に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;なり、移動コンストラクターによって初期化されます。つまり、引数はパラメーターに移動されます。 moveコンストラクタ自体に右辺値参照パラメータがあるため、引数は右辺値である必要があります。制御フローが&lt;/font&gt;&lt;/font&gt; &lt;code&gt;operator=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;閉じ括弧に達すると&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はスコープ外になり、古いリソースを自動的に解放します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="298a83fc83958407292172112721d7fac6f19495" translate="yes" xml:space="preserve">
          <source>Now that you understand reference collapsing, here is how &lt;code&gt;std::move&lt;/code&gt; is implemented:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照の折りたたみを理解したところで、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実装&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法を次に示します&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c53f94e863e826764f4562c8d505588624c09e3e" translate="yes" xml:space="preserve">
          <source>Now, let's consider what a &lt;em&gt;copy constructor&lt;/em&gt; does.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここで、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コピーコンストラクタの&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;機能&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;について考えてみましょう&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf61830673a8f5c2707029863a04957daf0b7f26" translate="yes" xml:space="preserve">
          <source>Obviously, there must be some profound difference between the expression &lt;code&gt;a&lt;/code&gt; which denotes an &lt;code&gt;auto_ptr&lt;/code&gt; variable, and the expression &lt;code&gt;make_triangle()&lt;/code&gt; which denotes the call of a function that returns an &lt;code&gt;auto_ptr&lt;/code&gt; by value, thus creating a fresh temporary &lt;code&gt;auto_ptr&lt;/code&gt; object every time it is called. &lt;code&gt;a&lt;/code&gt; is an example of an &lt;em&gt;lvalue&lt;/em&gt;, whereas &lt;code&gt;make_triangle()&lt;/code&gt; is an example of an &lt;em&gt;rvalue&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;明らかに、&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;変数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を表す&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;値によって&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;を返す関数の呼び出しを表す&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;式&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;との間には、大きな違いがある&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はず&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。したがって、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;呼び出されるたびに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、新しい一時的な&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクト&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が作成されます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一例である&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;左辺値&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に対し、&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;の一例である&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f59b333eedae45f10bcefb5eb8e11c7862dbf00" translate="yes" xml:space="preserve">
          <source>Ok, but if I move an object, the source object becomes useless, no? Of course, but in certain situations that's very useful. The most evident one is when I call a function with an anonymous object (temporal, rvalue object, ..., you can call it with different names):</source>
          <target state="translated">でも、オブジェクトを移動させると、元のオブジェクトは役に立たなくなりますよね?もちろんですが、特定の状況では非常に便利です。最も明らかなのは、匿名のオブジェクト(一時的なもの、rvalueオブジェクト、...など、異なる名前で呼び出すことができます)で関数を呼び出すときです。</target>
        </trans-unit>
        <trans-unit id="ff03efad6b4f508d07644ba3ac921a54bad39daa" translate="yes" xml:space="preserve">
          <source>Other typical question: what is the difference between &lt;code&gt;A&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;const A&amp;amp;&amp;amp;&lt;/code&gt;? Of course, in the first case, you can modify the object and in the second not, but, practical meaning? In the second case, you can't modify it, so you have no ways to invalidate the object (except with a mutable flag or something like that), and there is no practical difference to a copy constructor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その他の典型的な質問：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const A&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;違いは何&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ですか？もちろん、最初のケースではオブジェクトを変更でき、2番目のケースでは変更できませんが、実際的な意味はありますか？ 2番目のケースでは、オブジェクトを変更できないため、オブジェクトを無効にする方法がなく（変更可能なフラグなどを使用する場合を除く）、コピーコンストラクターと実際的な違いはありません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70836291e05cb08b074706c1896b5e4d3e0d1003" translate="yes" xml:space="preserve">
          <source>Perhaps surprisingly, automatic objects (local variables that are not declared as &lt;code&gt;static&lt;/code&gt;) can also be &lt;em&gt;implicitly&lt;/em&gt; moved out of functions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;おそらく驚くべきことに、自動オブジェクト（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;static&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;として宣言されていないローカル変数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）も&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;暗黙的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に関数から移動&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;でき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="047060b19a709b1338cf8e5a234066acfcd19213" translate="yes" xml:space="preserve">
          <source>Returning an object from a method by default involves making a copy of the local object and its associated data in a location which is accessible to the caller (because the local object is not accessible to the caller and disappears when the method finishes).  When a built-in type is being returned, this operation is very fast, but if a large object is being returned, this could take a long time.  The move constructor allows the programmer to override this default behavior and instead &quot;reuse&quot; the heap data associated with the local object by pointing the object being returned to the caller to heap data associated with the local object.  Thus no copying is required.</source>
          <target state="translated">デフォルトでは、メソッドからオブジェクトを返すには、呼び出し元がアクセス可能な場所にローカル・オブジェクトとその関連データのコピーを作成する必要があります(ローカル・オブジェクトは呼び出し元がアクセスできず、メソッドが終了すると消えてしまうため)。組み込みの型が返される場合、この操作は非常に高速ですが、大きなオブジェクトが返される場合は、長い時間がかかる可能性があります。move コンストラクタを使用すると、プログラマはこのデフォルトの動作をオーバーライドして、呼び出し元に返されるオブジェクトをローカル・オブジェクトに関連付けられたヒープ・データにポイントすることで、ローカル・オブジェクトに関連付けられたヒープ・データを &quot;再利用 &quot;することができます。したがって、コピーは必要ありません。</target>
        </trans-unit>
        <trans-unit id="e5592cd0fb417300cbaac9ee976b933b1a98a51d" translate="yes" xml:space="preserve">
          <source>Rvalue references</source>
          <target state="translated">R値参照</target>
        </trans-unit>
        <trans-unit id="5dc3c807bd559ab077dd1e1206e50e03c15ccaf6" translate="yes" xml:space="preserve">
          <source>Rvalue references went through several versions. Since version 2.1, an rvalue reference &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; also binds to all value categories of a different type &lt;code&gt;Y&lt;/code&gt;, provided there is an implicit conversion from &lt;code&gt;Y&lt;/code&gt; to &lt;code&gt;X&lt;/code&gt;. In that case, a temporary of type &lt;code&gt;X&lt;/code&gt; is created, and the rvalue reference is bound to that temporary:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値参照はいくつかのバージョンを通過しました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;バージョン2.1以降&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt; &lt;code&gt;Y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;から&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;への&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;暗黙的な変換がある&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合、右辺値参照&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、異なるタイプ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Y&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべての値カテゴリにもバインドします&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その場合、タイプ&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一時&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;変数が作成され、右辺値参照がその一時変数にバインドされます。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="681732688880af87e8358c431edcf6c36bc387ab" translate="yes" xml:space="preserve">
          <source>Rvalue references went through several versions. Since version 3.0, C++11 declares two additional special member functions on demand: the move constructor and the move assignment operator. Note that neither VC10 nor VC11 conform to version 3.0 yet, so you will have to implement them yourself.</source>
          <target state="translated">Rvalue 参照にはいくつかのバージョンがあります。バージョン 3.0 以降、C++11 では、必要に応じて 2 つの特別なメンバ関数、すなわち移動コンストラクタと移動代入演算子が追加で宣言されています。VC10 も VC11 もバージョン 3.0 にはまだ準拠していないので、自分で実装する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ae0b0234229935b2ce05de8879beb6e5cb6cf659" translate="yes" xml:space="preserve">
          <source>Since an rvalue is going to die at the end of an expression, you can &lt;em&gt;steal its data&lt;/em&gt;. Instead of &lt;em&gt;copying&lt;/em&gt; it into another object, you &lt;em&gt;move&lt;/em&gt; its data into it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値は式の最後で死ぬので、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのデータ&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;盗む&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことができ&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;別のオブジェクト&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コピー&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代わりに、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのデータをそこに&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48e1e601d0414c91d7bb8d787fc5e6f1a4660de9" translate="yes" xml:space="preserve">
          <source>Since we chose to manage the memory ourselves, we need to follow the &lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29&quot;&gt;rule of three&lt;/a&gt;. I am going to defer writing the assignment operator and only implement the destructor and the copy constructor for now:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私たちは自分でメモリを管理することを選択したので&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、3つ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ルール&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に従う必要があります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここでは、代入演算子の作成を延期し、デストラクタとコピーコンストラクタのみを実装します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0099f828c7759a2abbdb4ba58fd52bd3abe97f90" translate="yes" xml:space="preserve">
          <source>So far, we have seen movement into local variables, and into function parameters. But moving is also possible in the opposite direction. If a function returns by value, some object at call site (probably a local variable or a temporary, but could be any kind of object) is initialized with the expression after the &lt;code&gt;return&lt;/code&gt; statement as an argument to the move constructor:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これまで、ローカル変数と関数パラメーターへの動きを見てきました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし、反対方向への移動も可能です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数が値によって戻る場合、呼び出しサイトの一部のオブジェクト（おそらくローカル変数または一時的ですが、あらゆる種類のオブジェクトである可能性があります）は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、移動コンストラクターへの引数として&lt;/font&gt;&lt;/font&gt; &lt;code&gt;return&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ステートメントの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;後の式で初期化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="034b89ff4264e6ea18c21f67aa398614ed9889ef" translate="yes" xml:space="preserve">
          <source>So if you say &lt;code&gt;a = b&lt;/code&gt;, the &lt;em&gt;copy constructor&lt;/em&gt; will initialize &lt;code&gt;that&lt;/code&gt; (because the expression &lt;code&gt;b&lt;/code&gt; is an lvalue), and the assignment operator swaps the contents with a freshly created, deep copy. That is the very definition of the copy and swap idiom -- make a copy, swap the contents with the copy, and then get rid of the copy by leaving the scope. Nothing new here.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a = b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と指定すると、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コピーコンストラクター&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;がそれを初期化&lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が左辺値であるため）、代入演算子が新しく作成されたディープコピーと内容を交換します。これが、コピーとスワップのイディオムのまさにその定義です。コピーを作成し、内容をコピーとスワップし、スコープを離れることによってコピーを削除します。ここには何も新しいものはありません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54d00ee61a37d56aa5dd7aa4758e0bd04233cb62" translate="yes" xml:space="preserve">
          <source>So the value is &lt;strong&gt;&lt;em&gt;moved&lt;/em&gt;&lt;/strong&gt; from the unnamed temporary returned from &lt;code&gt;f()&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; (while the data of &lt;code&gt;x&lt;/code&gt;, initialized to an empty &lt;code&gt;X&lt;/code&gt;, is moved into the temporary, which will get destroyed after the assignment).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;値がされるように&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から返される名前一時から&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に対する&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（のデータながら&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;空に初期化され、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、割り当て後に破棄されますれ、一時的に移動されます）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f7961a9153c9247dac8ea0516cb0ae78c84857c" translate="yes" xml:space="preserve">
          <source>So, if &lt;code&gt;T&lt;/code&gt; is a lvalue reference to &lt;code&gt;A&lt;/code&gt; (&lt;strong&gt;T&lt;/strong&gt; = A&amp;amp;), &lt;code&gt;a&lt;/code&gt; also (&lt;strong&gt;A&amp;amp;&lt;/strong&gt; &amp;amp;&amp;amp; =&amp;gt; A&amp;amp;). If &lt;code&gt;T&lt;/code&gt; is a rvalue reference to &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; also (A&amp;amp;&amp;amp; &amp;amp;&amp;amp; =&amp;gt; A&amp;amp;&amp;amp;). In both cases, &lt;code&gt;a&lt;/code&gt; is a named object in the actual scope, but &lt;code&gt;T&lt;/code&gt; contains the information of its &quot;reference type&quot; from the caller scope's point of view. This information (&lt;code&gt;T&lt;/code&gt;) is passed as template parameter to &lt;code&gt;forward&lt;/code&gt; and 'a' is moved or not according to the type of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;へ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;左辺値参照&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; = A＆）である場合、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;＆&amp;amp;&amp;amp; =&amp;gt; A＆）でもあります。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;へ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値参照である&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;も（A &amp;amp;&amp;amp; &amp;amp;&amp;amp; =&amp;gt; A &amp;amp;&amp;amp;）です。どちらの場合も、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は実際のスコープ内の名前付きオブジェクトですが、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;には呼び出し側のスコープの観点から見た「参照型」の情報が含まれています。この情報（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）は、テンプレートパラメータとして&lt;/font&gt;&lt;/font&gt; &lt;code&gt;forward&lt;/code&gt; に&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;渡され&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、 'a'は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のタイプに応じて移動され&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="093fc5e367c5e2bf6fc8ca5b593b0df072b3d2ce" translate="yes" xml:space="preserve">
          <source>So, your code is shorter (you don't need to do a &lt;code&gt;nullptr&lt;/code&gt; assignment for each dynamic member) and more general.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのため、コードは短く（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;各動的メンバーに&lt;/font&gt;&lt;/font&gt; &lt;code&gt;nullptr&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;割り当てる&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必要がない&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）、より一般的です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68b9a6a0be10d20ad14f2d271cf26db0796998be" translate="yes" xml:space="preserve">
          <source>Sometimes, we want to move from lvalues. That is, sometimes we want the compiler to treat an lvalue as if it were an rvalue, so it can invoke the move constructor, even though it could be potentially unsafe.
For this purpose, C++11 offers a standard library function template called &lt;code&gt;std::move&lt;/code&gt; inside the header &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;.
This name is a bit unfortunate, because &lt;code&gt;std::move&lt;/code&gt; simply casts an lvalue to an rvalue; it does &lt;em&gt;not&lt;/em&gt; move anything by itself. It merely &lt;em&gt;enables&lt;/em&gt; moving. Maybe it should have been named &lt;code&gt;std::cast_to_rvalue&lt;/code&gt; or &lt;code&gt;std::enable_move&lt;/code&gt;, but we are stuck with the name by now.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合によっては、左辺値から移動したいことがあります。つまり、安全ではない可能性があるとしても、コンパイラーが左辺値を右辺値であるかのように処理して、移動コンストラクターを呼び出すことができるようにする場合があります。この目的のために、C ++ 11は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、ヘッダー&lt;/font&gt; &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;内に&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と呼ばれる標準ライブラリー関数テンプレートを提供しています&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;単に左辺値を右辺値にキャストする&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ため、この名前は少し残念&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。それ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自体は何も動かし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ませ&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ん&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。それは単に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動を&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;にします。おそらく&lt;/font&gt; &lt;code&gt;std::cast_to_rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt; &lt;code&gt;std::enable_move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;という名前になっているはずですが&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、今ではその名前で行き詰まっています。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5301bb25f1b806784df96fdac43504d478adbc18" translate="yes" xml:space="preserve">
          <source>Sooner or later, you are going to write code like this:</source>
          <target state="translated">遅かれ早かれ、このようなコードを書くことになるでしょう。</target>
        </trans-unit>
        <trans-unit id="827e6674de363a70897b99e51fffefdb810a4c6e" translate="yes" xml:space="preserve">
          <source>Special member functions</source>
          <target state="translated">特別会員機能</target>
        </trans-unit>
        <trans-unit id="af929f44893f1dbb0ff36798043c5601a040d9c7" translate="yes" xml:space="preserve">
          <source>Stephan T. Lavavej took the time provide valuable feedback. Thank you very much, Stephan!</source>
          <target state="translated">Stephan T.Lavavej様より貴重なご意見をいただきました。ステファンさん、ありがとうございました。</target>
        </trans-unit>
        <trans-unit id="97edf0f249ffe0384959565a34426727579f471c" translate="yes" xml:space="preserve">
          <source>Suppose you have a function that returns a substantial object:</source>
          <target state="translated">実質的なオブジェクトを返す関数があるとします。</target>
        </trans-unit>
        <trans-unit id="76cdc8fdc1131d4b14a54894d4cef5413aad87ac" translate="yes" xml:space="preserve">
          <source>Swapping two large objects usually involves copying the first object to a temporary object, copying the second object to the first object, and copying the temporary object to the second object.  For a built-in type, this is very fast, but for large objects these three copies could take a large amount of time.  A &quot;move assignment&quot; allows the programmer to override the default copy behavior and instead swap references to the objects, which means that there is no copying at all and the swap operation is much faster.  The move assignment can be invoked by calling the std::move() method.</source>
          <target state="translated">2つのラージオブジェクトのスワップは通常、1つ目のオブジェクトを一時オブジェクトにコピーし、2つ目のオブジェクトを1つ目のオブジェクトにコピーし、一時オブジェクトを2つ目のオブジェクトにコピーします。ビルトイン型の場合、これは非常に高速ですが、大きなオブジェクトの場合、これらの3回のコピーには大量の時間がかかる可能性があります。移動代入」により、プログラマはデフォルトのコピー動作をオーバーライドし、代わりにオブジェクトへの参照をスワップすることができます。移動代入は、std::move()メソッドを呼び出すことで呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="f28b36c8ab1c06a2320bf78626f74f8e645b94e6" translate="yes" xml:space="preserve">
          <source>T&amp;amp;&amp;amp; is not an rvalue reference, but a forwarding reference. It also binds to lvalues, in which case &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; are both lvalue references.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T &amp;amp;&amp;amp;は右辺値参照ではなく、転送参照です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、左辺値にバインドします。この場合、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はどちらも左辺値参照です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25e5448ed70f909735a7a46f8300ed37a57706a9" translate="yes" xml:space="preserve">
          <source>That's the signature of a prototypical function that uses perfect forwarding, implemented in C++11 by means of &lt;code&gt;std::forward&lt;/code&gt;. This function exploits some rules of template instantiation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、C ++ 11で&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::forward&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;によって実装された、完全な転送を使用するプロトタイプ関数のシグネチャ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この関数は、テンプレートのインスタンス化のいくつかのルールを利用します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2aeb46f404b05b67c1d4b4e933f1b159f28adf0b" translate="yes" xml:space="preserve">
          <source>The C++98 standard library offers a smart pointer with unique ownership semantics called &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. In case you are unfamiliar with &lt;code&gt;auto_ptr&lt;/code&gt;, its purpose is to guarantee that a dynamically allocated object is always released, even in the face of exceptions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98標準ライブラリは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と呼ばれる独自の所有権セマンティクスを持つスマートポインターを提供します&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;慣れていない場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、その目的は、例外が発生した場合でも、動的に割り当てられたオブジェクトが常に解放されることを保証することです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c5273ddaf8d4d9bd2c708aae41ca02d986a560f" translate="yes" xml:space="preserve">
          <source>The above function uses &lt;em&gt;call by value&lt;/em&gt; which means that when this function is called an object must be &lt;em&gt;constructed&lt;/em&gt; to be used by the function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上記の関数は&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;値による呼び出しを&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;します。&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、この関数が呼び出されたときに、関数が&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;するオブジェクトを&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;構築&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必要があることを意味し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="21453336f2384057cccb4c69429d948c05e5271d" translate="yes" xml:space="preserve">
          <source>The arguments in lines 2 and 3 are not lvalues, but rvalues, because the underlying string objects have no names, so the client has no way to inspect them again at a later point in time.
rvalues denote temporary objects which are destroyed at the next semicolon (to be more precise: at the end of the full-expression that lexically contains the rvalue). This is important because during the initialization of &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, we could do whatever we wanted with the source string, and &lt;em&gt;the client couldn't tell a difference&lt;/em&gt;!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;行2と3の引数は左辺値ではなく右辺値です。これは、基礎となる文字列オブジェクトに名前がないため、クライアントが後でそれらを再度検査する方法がないためです。右辺値は、次のセミコロン（より正確には、右辺値を字句的に含む完全式の終わり）で破棄される一時オブジェクトを示します。これは重要です&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;および&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;初期化中に、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ソース文字列を使用して必要なことをすべて実行&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;でき、クライアントは違いを&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;認識&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;できなかったから&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e024a6d6f6f045a7e5fd3e2fd78c563a51190fec" translate="yes" xml:space="preserve">
          <source>The call of a function that returns an rvalue reference, such as &lt;code&gt;std::move&lt;/code&gt;, is an xvalue.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などの右辺値参照を返す関数の呼び出しは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;xvalueです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b626cb0884dddd9379630d99507ae7fe2ff2c15c" translate="yes" xml:space="preserve">
          <source>The constructor takes ownership of the object, and the destructor deletes it:</source>
          <target state="translated">コンストラクタはオブジェクトの所有権を取得し、デストラクタはオブジェクトを削除します。</target>
        </trans-unit>
        <trans-unit id="e74352db34fd6a5e34f47321ae6e9f914b303f6f" translate="yes" xml:space="preserve">
          <source>The copy constructor defines what it means to copy string objects. The parameter &lt;code&gt;const string&amp;amp; that&lt;/code&gt; binds to all expressions of type string which allows you to make copies in the following examples:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コピーコンストラクタは、文字列オブジェクトをコピーすることの意味を定義します。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;const string&amp;amp; that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;型のすべての式にバインドする&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;パラメータ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;const string＆&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用すると、次の例でコピーを作成できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="290f16723b4d755e1f94e621b760399ee06c5273" translate="yes" xml:space="preserve">
          <source>The copy constructor of &lt;code&gt;auto_ptr&lt;/code&gt; probably looks something like this (somewhat simplified):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のコピーコンストラクターは、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;おそらく次のようになります（やや簡略化されています）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f162420dc7014f9f7aea09dba5df626cfbba3e4" translate="yes" xml:space="preserve">
          <source>The dangerous thing about &lt;code&gt;auto_ptr&lt;/code&gt; is that what syntactically looks like a copy is actually a move. Trying to call a member function on a moved-from &lt;code&gt;auto_ptr&lt;/code&gt; will invoke undefined behavior, so you have to be very careful not to use an &lt;code&gt;auto_ptr&lt;/code&gt; after it has been moved from:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の危険なこと&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、構文的にコピーのように見えるものが実際には移動であるということです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;元の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; で&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メンバー関数を呼び出そうとすると、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;未定義の動作が呼び出されるため&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、移動&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;元の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用しないように十分注意する必要があります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5518e5be02f103564f3cd6dfbbdb856e00b6efc" translate="yes" xml:space="preserve">
          <source>The last missing piece is the move assignment operator. Its job is to release the old resource and acquire the new resource from its argument:</source>
          <target state="translated">最後の欠落した部分はmove assignment演算子です。この演算子の仕事は、古いリソースを解放し、その引数から新しいリソースを取得することです。</target>
        </trans-unit>
        <trans-unit id="e783ee3bf25d0cbf3bd7e4504e938db2d81a4f14" translate="yes" xml:space="preserve">
          <source>The move assignment operator transfers ownership of a managed resource into the current object, releasing the old resource.
  The move-and-swap idiom simplifies the implementation.</source>
          <target state="translated">移動割り当て演算子は、管理されているリソースの所有権を現在のオブジェクトに移し、古いリソースを解放します。move-and-swap というイディオムは実装を簡略化します。</target>
        </trans-unit>
        <trans-unit id="a92be27a40d64e9f0284a53eff6b28c4024e3a73" translate="yes" xml:space="preserve">
          <source>The move constructor transfers ownership of a managed resource into the current object.</source>
          <target state="translated">move コンストラクタは、管理されているリソースの所有権を現在のオブジェクトに転送します。</target>
        </trans-unit>
        <trans-unit id="369d03b7f7d3482f6aec3906bad55a6bc99dd045" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;a&lt;/code&gt; would be copied to the actual parameter of &lt;code&gt;other_function&lt;/code&gt;. If you want the object &lt;code&gt;a&lt;/code&gt; continues being treated as a temporary object, you should use the &lt;code&gt;std::move&lt;/code&gt; function:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクト&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際のパラメーターにコピーされます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクト&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;引き続き一時オブジェクトとして扱い&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たい場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用する必要があり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3f96d5d08d17f40270352611586edfa618dbb5ff" translate="yes" xml:space="preserve">
          <source>The second line fails to compile, because &lt;code&gt;a&lt;/code&gt; is an lvalue, but the parameter &lt;code&gt;unique_ptr&amp;amp;&amp;amp; source&lt;/code&gt; can only be bound to rvalues. This is exactly what we wanted; dangerous moves should never be implicit. The third line compiles just fine, because &lt;code&gt;make_triangle()&lt;/code&gt; is an rvalue. The move constructor will transfer ownership from the temporary to &lt;code&gt;c&lt;/code&gt;. Again, this is exactly what we wanted.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は左辺値な&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ので&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 2行目&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンパイルに失敗します&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が、パラメーター&lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&amp;amp;&amp;amp; source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は右辺&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;値に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のみバインドでき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。これがまさに私たちが欲しかったものです。危険な動きは決して暗示されるべきではありません。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は右辺値&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;であるため、3行目はうまくコンパイルされます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。 moveコンストラクターは、所有権を一時的なものから&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; に&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;転送し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。繰り返しますが、これはまさに私たちが望んでいたことです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a3730034e13e4628ec2934efc747b68c3fc3e13d" translate="yes" xml:space="preserve">
          <source>The solution is to manually enable the move:</source>
          <target state="translated">解決策は、手動で移動を有効にすることです。</target>
        </trans-unit>
        <trans-unit id="08aa002af0a7d7ef8a828f926264d37a71e32e78" translate="yes" xml:space="preserve">
          <source>The unusual thing about &lt;code&gt;auto_ptr&lt;/code&gt; is its &quot;copying&quot; behavior:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の変わった点&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、その「コピー」動作です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3032c490102dbbdc1a53ae3a1e6b530d8d4c02ba" translate="yes" xml:space="preserve">
          <source>These two new special member functions are only implicitly declared if none of the special member functions are declared manually. Also, if you declare your own move constructor or move assignment operator, neither the copy constructor nor the copy assignment operator will be declared implicitly.</source>
          <target state="translated">これら2つの新しい特殊メンバ関数は、いずれの特殊メンバ関数も手動で宣言されていない場合にのみ、暗黙的に宣言されます。また、独自の移動コンストラクタまたは移動代入演算子を宣言した場合、コピーコンストラクタもコピー代入演算子も暗黙的に宣言されません。</target>
        </trans-unit>
        <trans-unit id="83a00c1613c4181d37c495b96f0796b835f18525" translate="yes" xml:space="preserve">
          <source>This is accomplished with an &lt;code&gt;rvalue&lt;/code&gt; reference.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは&lt;/font&gt;&lt;/font&gt; &lt;code&gt;rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照で行われます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="31ccc28aaac9180efd97b0f2232c9474c45ded9f" translate="yes" xml:space="preserve">
          <source>This is especially important if (like perhaps the &lt;code&gt;Matrix&lt;/code&gt; example above), the object being copied allocates extra memory on the heap to store its internal representation. A copy constructor would have to either make a full copy of the internal representation, or use reference counting and copy-on-write semantics interally. A move constructor would leave the heap memory alone and just copy the pointer inside the &lt;code&gt;Matrix&lt;/code&gt; object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは（おそらく上記の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Matrix&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例のように）コピーされるオブジェクトがヒープに追加のメモリを割り当ててその内部表現を格納する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合に特に重要です&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コピーコンストラクターは、内部表現の完全なコピーを作成するか、参照カウントとコピーオンライトセマンティクスを内部で使用する必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動コンストラクタは、ヒープメモリをそのままにして、ポインタを&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Matrix&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクト&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内にコピーするだけ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="734c00e55f5d7bfea55f0c53e0033b51b7115120" translate="yes" xml:space="preserve">
          <source>This leads to the concept of an &quot;rvalue&quot; reference. They exist in C++11 only to detect if the received object is anonymous or not. I think you do already know that an &quot;lvalue&quot; is an assignable entity (the left part of the &lt;code&gt;=&lt;/code&gt; operator), so you need a named reference to an object to be capable to act as an lvalue. A rvalue is exactly the opposite, an object with no named references. Because of that, anonymous object and rvalue are synonyms. So:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、「右辺値」参照の概念につながります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それらはC ++ 11にのみ存在し、受信したオブジェクトが匿名かどうかを検出します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「lvalue」が割り当て可能なエンティティ（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;演算子の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;左側の部分）であることはすでに知っていると思います&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。したがって、lvalueとして機能するには、オブジェクトへの名前付き参照が必要です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値は正反対で、名前付き参照のないオブジェクトです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのため、匿名オブジェクトと右辺値は同義語です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そう：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2a9839394d8fd7fa5c503f67611a827e38511306" translate="yes" xml:space="preserve">
          <source>This move constructor does exactly what the &lt;code&gt;auto_ptr&lt;/code&gt; copy constructor did, but it can only be supplied with rvalues:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この移動コンストラクターは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コピーコンストラクターが行ったことと&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;まったく同じです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が、右辺値でのみ提供できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e308529a0760da4187efbb6031e853815d012f5" translate="yes" xml:space="preserve">
          <source>This way, the number of special member functions to implement drops from five to four. There is a tradeoff between exception-safety and efficiency here, but I am not an expert on this issue.</source>
          <target state="translated">この方法では、実装する特殊なメンバ関数の数が 5 つから 4 つに減ります。ここでは例外の安全性と効率性のトレードオフがありますが、私はこの問題の専門家ではありません。</target>
        </trans-unit>
        <trans-unit id="c835c096c791a7fe0c7b46b42e46e2033cbeb4bc" translate="yes" xml:space="preserve">
          <source>To illustrate the need for &lt;em&gt;move semantics&lt;/em&gt;, let's consider this example without move semantics:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動セマンティクス&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の必要性を説明するために、&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動セマンティクス&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;なしのこの例を考えてみましょう：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a7e9e734de9455aa1437dc73d5ab335d653aaac" translate="yes" xml:space="preserve">
          <source>To make strong exception guarantee possible, user-defined move constructors should not throw exceptions. In fact, standard containers typically rely on std::move_if_noexcept to choose between move and copy when container elements need to be relocated.
  If both copy and move constructors are provided, overload resolution selects the move constructor if the argument is an rvalue (either a prvalue such as a nameless temporary or an xvalue such as the result of std::move), and selects the copy constructor if the argument is an lvalue (named object or a function/operator returning lvalue reference). If only the copy constructor is provided, all argument categories select it (as long as it takes a reference to const, since rvalues can bind to const references), which makes copying the fallback for moving, when moving is unavailable.
  In many situations, move constructors are optimized out even if they would produce observable side-effects, see copy elision.
  A constructor is called a 'move constructor' when it takes an rvalue reference as a parameter. It is not obligated to move anything, the class is not required to have a resource to be moved and a 'move constructor' may not be able to move a resource as in the allowable (but maybe not sensible) case where the parameter is a const rvalue reference (const T&amp;amp;&amp;amp;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;強力な例外保証を可能にするために、ユーザー定義の移動コンストラクターは例外をスローしてはなりません。実際、標準のコンテナは通常、コンテナ要素を再配置する必要があるときに移動とコピーのどちらを選択するかをstd :: move_if_noexceptに依存しています。コピーコンストラクターと移動コンストラクターの両方が提供されている場合、引数が右辺値（名前のない一時変数などのprvalueまたはstd :: moveの結果などのxvalue）の場合、オーバーロードの解決によって移動コンストラクターが選択され、引数は左辺値（名前付きオブジェクト、または左辺値参照を返す関数/演算子）です。コピーコンストラクターのみが提供されている場合、すべての引数カテゴリーがそれを選択し（convalueへの参照が必要である限り、右辺値はconst参照にバインドできるため）、移動が利用できない場合に移動のフォールバックをコピーします。多くの場合、移動コンストラクターは、観察可能な副作用が生じる場合でも最適化されます。コピーの省略を参照してください。コンストラクターは、右辺値参照をパラメーターとして取る場合、「移動コンストラクター」と呼ばれます。何かを移動する義務はありません。クラスにリソースを移動する必要はありません。パラメータがaである許容される（ただし、賢明ではない）場合のように、「移動コンストラクタ」はリソースを移動できない場合があります。 const右辺値参照（const T &amp;amp;&amp;amp;）。パラメータがconst右辺値参照（const T &amp;amp;&amp;amp;）である許容可能な（ただし、理にかなわない）場合のように、リソースを移動できない場合があります。パラメータがconst右辺値参照（const T &amp;amp;&amp;amp;）である許容可能な（ただし、理にかなわない）場合のように、リソースを移動できない場合があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b31d2be34d67b295038676b6a78d3aa74806629a" translate="yes" xml:space="preserve">
          <source>To move an object means to transfer ownership of some resource it manages to another object.</source>
          <target state="translated">オブジェクトを移動させるとは、それが管理する何らかのリソースの所有権を別のオブジェクトに移すことを意味します。</target>
        </trans-unit>
        <trans-unit id="bbf1b3314c139a90af79519c70cc487a725f22d9" translate="yes" xml:space="preserve">
          <source>To summarize, the copy constructor makes a deep copy, because the source must remain untouched.
The move constructor, on the other hand, can just copy the pointer and then set the pointer in the source to null. It is okay to &quot;nullify&quot; the source object in this manner, because the client has no way of inspecting the object again.</source>
          <target state="translated">要約すると、ソースは手付かずのままにしておく必要があるため、コピー コンストラクタは深いコピーを行います。一方、move コンストラクタはポインタをコピーして、ソース内のポインタをヌルに設定するだけです。このようにしてソースオブジェクトを &quot;nullify &quot;しても構わないのですが、これはクライアントがオブジェクトを再度検査する方法がないからです。</target>
        </trans-unit>
        <trans-unit id="047b60f44c81098eb74095d0ced4e749b86ad68f" translate="yes" xml:space="preserve">
          <source>Turning expensive copies into cheap moves. See my first answer for an example. Note that if an object does not manage at least one external resource (either directly, or indirectly through its member objects), move semantics will not offer any advantages over copy semantics. In that case, copying an object and moving an object means the exact same thing:</source>
          <target state="translated">高価なコピーを安い手に変える 例については、私の最初の回答を参照してください。オブジェクトが少なくとも1つの外部リソースを管理していない場合(直接、またはメンバーオブジェクトを介して間接的に)、移動セマンティクスはコピーセマンティクスよりも何の利点も提供しないことに注意してください。その場合、オブジェクトをコピーすることとオブジェクトを移動することは全く同じことを意味します。</target>
        </trans-unit>
        <trans-unit id="de0430a56abae1a9c8cca4fd7a8b8906769e0636" translate="yes" xml:space="preserve">
          <source>Value categories</source>
          <target state="translated">価値のカテゴリー</target>
        </trans-unit>
        <trans-unit id="2aa8f4165ecd80aeeeeb890eaf78af1a8a3b401b" translate="yes" xml:space="preserve">
          <source>We now understand that moving from lvalues is potentially dangerous, but moving from rvalues is harmless. If C++ had language support to distinguish lvalue arguments from rvalue arguments, we could either completely forbid moving from lvalues, or at least make moving from lvalues &lt;em&gt;explicit&lt;/em&gt; at call site, so that we no longer move by accident.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;左辺値から移動することは潜在的に危険ですが、右辺値から移動することは無害であることを私たちは今理解しています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++がlvalue引数とrvalue引数を区別する言語サポートを持っていた場合、lvaluesからの移動を完全に禁止するか、少なくとも&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;呼び出しサイトで&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lvaluesからの移動を&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;明示的に&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;して、誤って移動しないようにすることができます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c91f5982e73d44e7f4a6ccace5726e523643802" translate="yes" xml:space="preserve">
          <source>What do these rules mean in practice?</source>
          <target state="translated">このルールは、実際にはどのような意味があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="99565c8cb484efe8d28c4076f67a25e83378c561" translate="yes" xml:space="preserve">
          <source>What have we done here? Instead of deeply copying the heap data, we have just copied the pointer and then set the original pointer to null (to prevent 'delete[]' from source object's destructor from releasing our 'just stolen data'). In effect, we have &quot;stolen&quot; the data that originally belonged to the source string. Again, the key insight is that under no circumstance could the client detect that the source had been modified. Since we don't really do a copy here, we call this constructor a &quot;move constructor&quot;. Its job is to move resources from one object to another instead of copying them.</source>
          <target state="translated">ここで何をしたのでしょうか?ヒープデータを深くコピーするのではなく、ポインタをコピーして、元のポインタをnullに設定しています(ソースオブジェクトのデストラクタからの'delete[]による「盗まれたばかりのデータ」の解放を防ぐためです)。事実上、元々ソース文字列に属していたデータを「盗んだ」ことになります。繰り返しになりますが、重要なのは、いかなる状況下でもクライアントはソースが変更されたことを検知できないということです。ここでは実際にはコピーを行わないので、このコンストラクタを「ムーブ・コンストラクタ」と呼びます。このコンストラクタの仕事は、リソースをコピーするのではなく、あるオブジェクトから別のオブジェクトに移動させることです。</target>
        </trans-unit>
        <trans-unit id="3334057bf5fdd1df4c8a56b5a8bb56d8d08ac48e" translate="yes" xml:space="preserve">
          <source>What is a move?</source>
          <target state="translated">移動とは何か?</target>
        </trans-unit>
        <trans-unit id="ff7bddf15a2315c6021f9e9d0f6b6bce8bcffd35" translate="yes" xml:space="preserve">
          <source>What is move semantics</source>
          <target state="translated">ムーブセマンティクスとは</target>
        </trans-unit>
        <trans-unit id="22b96be030691f90fe9b2e0240432d1d51dae570" translate="yes" xml:space="preserve">
          <source>When such copy/destroy pairs are expensive, it's typically because the object owns some heavyweight resource. For example, &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; may own a dynamically-allocated memory block containing an array of &lt;code&gt;string&lt;/code&gt; objects, each with its own dynamic memory.  Copying such an object is costly: you have to allocate new memory for each dynamically-allocated blocks in the source, and copy all the values across.  &lt;em&gt;Then&lt;/em&gt; you need deallocate all that memory you just copied.  However, &lt;em&gt;moving&lt;/em&gt; a large &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; means just copying a few pointers (that refer to the dynamic memory block) to the destination and zeroing them out in the source.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このようなコピー/破棄のペアが高価な場合、それは通常、オブジェクトが重いリソースを所有しているためです。たとえば、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、それぞれが独自の動的メモリを持つ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクトの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;配列を含む動的に割り当てられたメモリブロックを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有する場合があります。このようなオブジェクトのコピーはコストがかかります。ソース内の動的に割り当てられたブロックごとに新しいメモリを割り当て、すべての値をコピーする必要があります。 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次に、&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コピーしたメモリをすべて割り当て解除する必要があります。ただし、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大きな&lt;/font&gt; &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことは、（動的メモリブロックを参照する）いくつかのポインターを宛先にコピーし、ソースでそれらをゼロにすることを意味します。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9cd78414f15901d8e86a8d3f4a590968adf4da6" translate="yes" xml:space="preserve">
          <source>When the new object is created from the return value, the copy constructor is called to &lt;em&gt;copy&lt;/em&gt; the contents of the temporary object to the new object b. After the function completes, the temporary object used in the function goes out of scope and is destroyed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;戻り値から新しいオブジェクトが作成されると、コピーコンストラクターが呼び出され&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、一時オブジェクトの内容が新しいオブジェクト&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コピーさ&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;れ&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数が完了すると、関数で使用された一時オブジェクトはスコープ外になり、破棄されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="07a221a0bb57425e9405956022b30340ca656ba4" translate="yes" xml:space="preserve">
          <source>When would you want to do that? well std::vector is an example, say you created a temporary std::vector and you return it from a function say:</source>
          <target state="translated">どのような場合にそうしたいのでしょうか? std::vector が例として挙げられますが、一時的な std::vector を作成して、それを関数から返すとします。</target>
        </trans-unit>
        <trans-unit id="74ec9a380d335c03fb7b287be6ff753162c1a3a7" translate="yes" xml:space="preserve">
          <source>When you write code like this:</source>
          <target state="translated">こんな感じでコードを書くと</target>
        </trans-unit>
        <trans-unit id="221b238f8d5a91baf4778e7b3912f0b81807d155" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;move semantics&lt;/strong&gt; it's now possible to make most of this work less unpleasant by simply &lt;em&gt;moving&lt;/em&gt; the data rather than copying.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動セマンティクスを&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と、コピーするのではなくデータを&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移動&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;するだけで、この作業のほとんどを不快にしないようにすることができ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1e792bfe219381f99de1182972a3fef81354e659" translate="yes" xml:space="preserve">
          <source>With this line, &lt;code&gt;std::move&lt;/code&gt; will cast &lt;code&gt;a&lt;/code&gt; to an rvalue and &lt;code&gt;other_function&lt;/code&gt; will receive the object as a unnamed object. Of course, if &lt;code&gt;other_function&lt;/code&gt; has not specific overloading to work with unnamed objects, this distinction is not important.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この行では、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を右辺値に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;キャストし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はオブジェクトを名前のないオブジェクトとして受け取ります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もちろん、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; に&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;名前のないオブジェクトを処理するための特定のオーバーロードがない&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、この区別は重要ではありません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a502ae851780f1ddc7db29441700f146506ebb73" translate="yes" xml:space="preserve">
          <source>Xvalues</source>
          <target state="translated">Xvalues</target>
        </trans-unit>
        <trans-unit id="c39f86b271db60b23e48e49da3c4e77b7bf0f5df" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;parameter&lt;/code&gt; by value. For move-only types like &lt;code&gt;unique_ptr&lt;/code&gt;, it seems there is no established idiom yet. Personally, I prefer pass by value, as it causes less clutter in the interface.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を値で&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;渡すこともでき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ような移動のみのタイプの場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、確立されたイディオムはまだないようです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;個人的には、インターフェースでの混乱を少なくするため、値渡しを好みます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e2f4250ebd2eff63e7f150721d9b86649703b85e" translate="yes" xml:space="preserve">
          <source>You could argue that &lt;code&gt;parameter&lt;/code&gt; is not used anymore after the initialization of &lt;code&gt;member&lt;/code&gt;. Why is there no special rule to silently insert &lt;code&gt;std::move&lt;/code&gt; just as with return values? Probably because it would be too much burden on the compiler implementors. For example, what if the constructor body was in another translation unit? By contrast, the return value rule simply has to check the symbol tables to determine whether or not the identifier after the &lt;code&gt;return&lt;/code&gt; keyword denotes an automatic object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &lt;code&gt;member&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;の初期化後は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が使用されなくなった&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と主張することができ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;戻り値と同じように&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;を暗黙的に挿入する特別なルールがないのはなぜ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ですか？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;おそらくコンパイラの実装者にとって負担が大きすぎるためでしょう。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たとえば、コンストラクタ本体が別の翻訳単位にある場合はどうなりますか？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;対照的に、戻り値のルールでは、シンボルテーブルをチェックして、&lt;/font&gt; &lt;code&gt;return&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;キーワードの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;後の識別子が&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自動オブジェクトを表す&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;かどうかを判断するだけ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3ca8091ddd18805cfc713df7dd75868c9a95f47" translate="yes" xml:space="preserve">
          <source>You know what a copy semantics means right? it means you have types which are copyable, for user-defined types you define this either buy explicitly writing a copy constructor &amp;amp; assignment operator or the compiler generates them implicitly. This will do a copy.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コピーの意味が正しいことを知っていますか？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、コピー可能な型があることを意味します。ユーザー定義型の場合、これを定義するには、コピーコンストラクター＆代入演算子を明示的に記述するか、コンパイラーが暗黙的に生成します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これはコピーを行います。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e2f4bc4c9d48bda3c7ea5e8d13ceacb5e895f12" translate="yes" xml:space="preserve">
          <source>You might expect &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; to only bind to rvalues, because at first glance, it looks like an rvalue reference. As it turns out though, &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; also binds to lvalues:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一見すると右辺値参照のように見えるので、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が右辺値にのみバインドすることを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;期待するかもしれません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;結局のところ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は左辺値にもバインドします。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d33a97176f7badf8aeef43dbd922269578988791" translate="yes" xml:space="preserve">
          <source>You're going to have overhead from the copy constructor when the function returns, if (and it will in C++0x) std::vector has a move constructor instead of copying it can just set it's pointers and 'move' dynamically allocated memory to the new instance. It's kind of like transfer-of-ownership semantics with std::auto_ptr.</source>
          <target state="translated">もし std::vector がコピーの代わりに move コンストラクタを持っていれば(C++0x ではそうなります)、関数が戻ってきたときに copy コンストラクタのオーバーヘッドが発生します。これは std::auto_ptr の所有権移転のセマンティクスに似ています。</target>
        </trans-unit>
        <trans-unit id="e21276ab1166e0e62608292fa54445af12932da1" translate="yes" xml:space="preserve">
          <source>an &lt;em&gt;rvalue reference can be moved&lt;/em&gt; and an &lt;em&gt;lvalue&lt;/em&gt; cannot.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右辺値参照を移動させることができる&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;左辺値は&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;できません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="151db36d21b0e8f4a4f6c394902768f00fb00c34" translate="yes" xml:space="preserve">
          <source>then an ordinary C++ compiler will create a temporary object for the result of &lt;code&gt;multiply()&lt;/code&gt;, call the copy constructor to initialise &lt;code&gt;r&lt;/code&gt;, and then destruct the temporary return value. Move semantics in C++0x allow the &quot;move constructor&quot; to be called to initialise &lt;code&gt;r&lt;/code&gt; by copying its contents, and then discard the temporary value without having to destruct it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次に、通常のC ++コンパイラーは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;multiply()&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;結果の一時オブジェクトを作成し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、コピーコンストラクターを呼び出して&lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を初期化し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、一時的な戻り値を破棄します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 0xの移動セマンティクスでは、「移動コンストラクター」を呼び出して&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その内容をコピーすることにより&lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を初期化し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、一時的な値を破棄せずに破棄できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
