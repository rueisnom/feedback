<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/3106110">
    <body>
      <group id="3106110">
        <trans-unit id="df0fd2702057b417c35ac16135733ca9fa59293f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::move(some_lvalue)&lt;/code&gt; casts an lvalue to an rvalue, thus enabling a subsequent move.</source>
          <target state="translated">&lt;code&gt;std::move(some_lvalue)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lanza un valor l a un valor r, permitiendo as&amp;iacute; un movimiento posterior.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50f6f367eb9f6b3f8bc2138fd21d734104676605" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Move semantics&lt;/strong&gt; is about &lt;strong&gt;transferring resources rather than copying them&lt;/strong&gt; when nobody needs the source value anymore.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La sem&amp;aacute;ntica de movimiento&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se trata de &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;transferir recursos en lugar de copiarlos&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cuando ya nadie necesita el valor fuente.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6792b6f126f7677728171c0bfe42b4de3714768a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two&lt;/strong&gt; new objects have been constructed, one of which is a temporary object that's only used for the duration of the function.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Se&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; han construido &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;dos&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; nuevos objetos, uno de los cuales es un objeto temporal que solo se usa durante la duraci&amp;oacute;n de la funci&amp;oacute;n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a95152a9e43e530501f6b99af74270415868a62a" translate="yes" xml:space="preserve">
          <source>A named rvalue reference is an lvalue, just like any other variable.</source>
          <target state="translated">Una referencia de rvalor nombrada es un valor l,como cualquier otra variable.</target>
        </trans-unit>
        <trans-unit id="f040209caa6e8f4d4e43aa329b98ebb25520ebed" translate="yes" xml:space="preserve">
          <source>A useful example of a function with an &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; parameter is the &lt;em&gt;move constructor&lt;/em&gt;&lt;code&gt;X::X(X&amp;amp;&amp;amp; source)&lt;/code&gt;. Its purpose is to transfer ownership of the managed resource from the source into the current object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un ejemplo &amp;uacute;til de una funci&amp;oacute;n con un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;par&amp;aacute;metro &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es el &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;constructor de movimiento &lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;X::X(X&amp;amp;&amp;amp; source)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Su prop&amp;oacute;sito es transferir la propiedad del recurso administrado desde la fuente al objeto actual.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abef74394b5449ff6f5131eaf664d8e46d148d79" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;rvalue&lt;/code&gt; reference works pretty much like an &lt;code&gt;lvalue&lt;/code&gt; reference with one important difference:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;referencia &lt;/font&gt;&lt;/font&gt; &lt;code&gt;rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; funciona m&amp;aacute;s o menos como una &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;referencia &lt;/font&gt;&lt;/font&gt; &lt;code&gt;lvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con una diferencia importante:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1400246cab7166daac5095b766ba4438e047c79f" translate="yes" xml:space="preserve">
          <source>An rvalue is a temporary object, which is going to be destroyed at the end of the expression. In current C++, rvalues only bind to &lt;code&gt;const&lt;/code&gt; references. C++1x will allow non-&lt;code&gt;const&lt;/code&gt; rvalue references, spelled &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, which are references to an rvalue objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un valor r es un objeto temporal, que se destruir&amp;aacute; al final de la expresi&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En C ++ actual, los valores solo se unen a &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;referencias &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; antes&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 1x permitir&amp;aacute; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;referencias de valor &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; antes&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , deletreadas &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , que son referencias a objetos de valor r.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ec69c00d4b9b0c380efb9f8ecec0d4b04714fba" translate="yes" xml:space="preserve">
          <source>An rvalue of class type is an expression whose evaluation creates a temporary object.
  Under normal circumstances, no other expression inside the same scope denotes the same temporary object.</source>
          <target state="translated">Un valor de tipo clase es una expresión cuya evaluación crea un objeto temporal.En circunstancias normales,ninguna otra expresión dentro del mismo ámbito denota el mismo objeto temporal.</target>
        </trans-unit>
        <trans-unit id="3fe43eb5a17970d62352f3daf0ab3389b2294910" translate="yes" xml:space="preserve">
          <source>An rvalue reference &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; is a new kind of reference that only binds to rvalues.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una referencia de valor &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un nuevo tipo de referencia que solo se une a los valores.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b951ee76f644338afecca76aa03ce849f6e9a636" translate="yes" xml:space="preserve">
          <source>And what is &lt;strong&gt;perfect forwarding&lt;/strong&gt;? It is important to know that a &quot;rvalue reference&quot; is a reference to a named object in the &quot;caller's scope&quot;. But in the actual scope, a rvalue reference is a name to an object, so, it acts as a named object. If you pass an rvalue reference to another function, you are passing a named object, so, the object isn't received like a temporal object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Y qu&amp;eacute; es &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;el reenv&amp;iacute;o perfecto&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es importante saber que una &quot;referencia de valor&quot; es una referencia a un objeto nombrado en el &quot;alcance del llamante&quot;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero en el &amp;aacute;mbito real, una referencia rvalue es un nombre para un objeto, por lo tanto, act&amp;uacute;a como un objeto con nombre. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si pasa una referencia de valor r a otra funci&amp;oacute;n, est&amp;aacute; pasando un objeto con nombre, por lo tanto, el objeto no se recibe como un objeto temporal.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cdb7ef1ba819235b13a473fac62029ba510795b0" translate="yes" xml:space="preserve">
          <source>And yet, one of them invokes undefined behavior, whereas the other one does not. So what is the difference between the expressions &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;make_triangle()&lt;/code&gt;? Aren't they both of the same type? Indeed they are, but they have different &lt;em&gt;value categories&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y, sin embargo, uno de ellos invoca un comportamiento indefinido, mientras que el otro no. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces, &amp;iquest;cu&amp;aacute;l es la diferencia entre las expresiones &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;No son los dos del mismo tipo? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;De hecho lo son, pero tienen diferentes &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;categor&amp;iacute;as de valores&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0eeed3546c92bc7d030625e964a6a1e8f2f93dd1" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;move&lt;/code&gt; accepts any kind of parameter thanks to the forwarding reference &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, and it returns an rvalue reference. The &lt;code&gt;std::remove_reference&amp;lt;T&amp;gt;::type&lt;/code&gt; meta-function call is necessary because otherwise, for lvalues of type &lt;code&gt;X&lt;/code&gt;, the return type would be &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt;, which would collapse into &lt;code&gt;X&amp;amp;&lt;/code&gt;. Since &lt;code&gt;t&lt;/code&gt; is always an lvalue (remember that a named rvalue reference is an lvalue), but we want to bind &lt;code&gt;t&lt;/code&gt; to an rvalue reference, we have to explicitly cast &lt;code&gt;t&lt;/code&gt; to the correct return type.
The call of a function that returns an rvalue reference is itself an xvalue. Now you know where xvalues come from ;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Como puede ver, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; acepta cualquier tipo de par&amp;aacute;metro gracias a la referencia de reenv&amp;iacute;o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , y devuelve una referencia de valor. La &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::remove_reference&amp;lt;T&amp;gt;::type&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es necesaria porque de lo contrario, para valores de tipo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , el tipo de retorno ser&amp;iacute;a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , que colapsar&amp;iacute;a en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es siempre un valor de l (recuerde que una referencia de valor de r con nombre es un valor de l), pero queremos vincular &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a una referencia de valor de r, tenemos que convertir expl&amp;iacute;citamente &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; al tipo de retorno correcto. La llamada de una funci&amp;oacute;n que devuelve una referencia rvalue es en s&amp;iacute; misma un xvalue. Ahora ya sabes de d&amp;oacute;nde vienen los valores x;)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5a6f247186a6ec51d7763851bdd8e18f434a0b74" translate="yes" xml:space="preserve">
          <source>Basically, the compiler will complain that &lt;code&gt;parameter&lt;/code&gt; is an lvalue. If you look at its type, you see an rvalue reference, but an rvalue reference simply means &quot;a reference that is bound to an rvalue&quot;; it does &lt;em&gt;not&lt;/em&gt; mean that the reference itself is an rvalue! Indeed, &lt;code&gt;parameter&lt;/code&gt; is just an ordinary variable with a name. You can use &lt;code&gt;parameter&lt;/code&gt; as often as you like inside the body of the constructor, and it always denotes the same object. Implicitly moving from it would be dangerous, hence the language forbids it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B&amp;aacute;sicamente, el compilador se quejar&amp;aacute; de que el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un valor l. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si observa su tipo, ver&amp;aacute; una referencia de rvalue, pero una referencia de rvalue simplemente significa &quot;una referencia vinculada a un rvalue&quot;; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iexcl; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; significa que la referencia en s&amp;iacute; misma sea un valor! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;De hecho, el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es solo una variable ordinaria con un nombre. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede usar el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tantas veces como desee dentro del cuerpo del constructor, y siempre denota el mismo objeto. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Moverse impl&amp;iacute;citamente ser&amp;iacute;a peligroso, por lo tanto, el lenguaje lo proh&amp;iacute;be.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e378544bfb07451e6088433236851c65b1e84876" translate="yes" xml:space="preserve">
          <source>Because the function also &lt;em&gt;returns by value&lt;/em&gt;, another new object is constructed for the return value:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Como la funci&amp;oacute;n tambi&amp;eacute;n &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;regresa por valor&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , se construye otro nuevo objeto para el valor de retorno:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e819a9290ce3be37f7d22e748fce09e94c70c736" translate="yes" xml:space="preserve">
          <source>Both prvalues and xvalues are rvalues. Xvalues and lvalues are both &lt;em&gt;glvalues&lt;/em&gt; (Generalized lvalues). The relationships are easier to grasp with a diagram:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tanto los valores como los valores x son valores. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los valores X y los valores son ambos &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;valores&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (valores generalizados). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las relaciones son m&amp;aacute;s f&amp;aacute;ciles de comprender con un diagrama:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef1b8b9546c894e61fe1d619148e7bed5cc0fc49" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;auto_ptr&lt;/code&gt; is not &lt;em&gt;always&lt;/em&gt; dangerous. Factory functions are a perfectly fine use case for &lt;code&gt;auto_ptr&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;siempre es&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; peligroso. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las funciones de f&amp;aacute;brica son un caso de uso perfecto para &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e6a400bc51fb91373f9c57144a4bd019862c564" translate="yes" xml:space="preserve">
          <source>But if you say &lt;code&gt;a = x + y&lt;/code&gt;, the &lt;em&gt;move constructor&lt;/em&gt; will initialize &lt;code&gt;that&lt;/code&gt; (because the expression &lt;code&gt;x + y&lt;/code&gt; is an rvalue), so there is no deep copy involved, only an efficient move.
&lt;code&gt;that&lt;/code&gt; is still an independent object from the argument, but its construction was trivial,
since the heap data didn't have to be copied, just moved. It wasn't necessary to copy it because &lt;code&gt;x + y&lt;/code&gt; is an rvalue, and again, it is okay to move from string objects denoted by rvalues.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero si usted dice &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a = x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , el &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;movimiento constructor&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se inicializa &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (debido a la expresi&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un valor de lado derecho), as&amp;iacute; que no hay copia profunda implicados, solamente un movimiento eficiente. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; sigue siendo un objeto independiente de la discusi&amp;oacute;n, pero su construcci&amp;oacute;n fue trivial, ya que los datos del mont&amp;oacute;n no ten&amp;iacute;a que ser copiado, acaba de mudar. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;No fue necesario copiarlo porque &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x + y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un valor r, y nuevamente, est&amp;aacute; bien moverse de objetos de cadena denotados por valores.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="32822acac85aaeec4278db58d224f2fe9f3f352c" translate="yes" xml:space="preserve">
          <source>But, is that not dangerous? Of course, you could destruct a dynamic object twice (segmentation fault). So, to avoid that, you should &quot;invalidate&quot; the source pointers to avoid destructing them twice:</source>
          <target state="translated">Pero,¿no es eso peligroso? Por supuesto,se puede destruir un objeto dinámico dos veces (fallo de segmentación).Así que,para evitar eso,deberías &quot;invalidar&quot; los punteros de la fuente para evitar destruirlos dos veces:</target>
        </trans-unit>
        <trans-unit id="c8a8d115ca80240745b86fe8f011228ba83a9e3b" translate="yes" xml:space="preserve">
          <source>C++0x introduces a new mechanism called &quot;rvalue reference&quot; which, among other things,
allows us to detect rvalue arguments via function overloading. All we have to do is write a constructor with an rvalue reference parameter. Inside that constructor we can do &lt;em&gt;anything we want&lt;/em&gt; with the source, as long as we leave it in &lt;em&gt;some&lt;/em&gt; valid state:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 0x introduce un nuevo mecanismo llamado &quot;referencia de valor r&quot; que, entre otras cosas, nos permite detectar argumentos rvalue a trav&amp;eacute;s de la sobrecarga de funciones. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Todo lo que tenemos que hacer es escribir un constructor con un par&amp;aacute;metro de referencia rvalue. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dentro de ese constructor podemos hacer &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lo que queramos&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con la fuente, siempre que lo dejemos en &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;un&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; estado v&amp;aacute;lido:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd0492dc5e0b6d5d91433b74385064b17d458bf4" translate="yes" xml:space="preserve">
          <source>C++11's answer to this problem is &lt;em&gt;rvalue references&lt;/em&gt;. An rvalue reference is a new kind of reference that only binds to rvalues, and the syntax is &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt;. The good old reference &lt;code&gt;X&amp;amp;&lt;/code&gt; is now known as an &lt;em&gt;lvalue reference&lt;/em&gt;. (Note that &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a reference to a reference; there is no such thing in C++.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La respuesta de C ++ 11 a este problema son &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;las referencias de valor&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una referencia de valor r es un nuevo tipo de referencia que solo se une a los valores r, y la sintaxis es &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La buena referencia anterior &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ahora se conoce como una &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;referencia de valor&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Tenga en cuenta que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;una referencia a una referencia; no existe tal cosa en C ++).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="023a6a48d15ef2c95fc40e5be2aa59fe9b54efad" translate="yes" xml:space="preserve">
          <source>C++98 implicitly declares three special member functions on demand, that is, when they are needed somewhere: the copy constructor, the copy assignment operator and the destructor.</source>
          <target state="translated">C++98 declara implícitamente tres funciones especiales de los miembros a petición,es decir,cuando se necesitan en algún lugar:el constructor de copias,el operador de asignación de copias y el destructor.</target>
        </trans-unit>
        <trans-unit id="c779770f0201fc38c70bf3c75d9a6f84752c9e0a" translate="yes" xml:space="preserve">
          <source>C++98 rvalues are known as prvalues in C++11. Mentally replace all occurrences of &quot;rvalue&quot; in the preceding paragraphs with &quot;prvalue&quot;.</source>
          <target state="translated">Los valores r de C++98 se conocen como prvalores en C++11.Sustituya mentalmente todas las ocurrencias de &quot;rvalor&quot; en los párrafos anteriores por &quot;prvalor&quot;.</target>
        </trans-unit>
        <trans-unit id="132f3ce3182bbd08fe44f45ff771c82759cf58e2" translate="yes" xml:space="preserve">
          <source>Congratulations, you now understand the basics of move semantics! Let's continue by implementing the assignment operator. If you're unfamiliar with the &lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;copy and swap idiom&lt;/a&gt;, learn it and come back, because it's an awesome C++ idiom related to exception safety.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iexcl;Felicitaciones, ahora comprende los conceptos b&amp;aacute;sicos de la sem&amp;aacute;ntica de movimientos! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Continuemos implementando el operador de asignaci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si no est&amp;aacute; familiarizado con el idioma de &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;copiar e intercambiar&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , apr&amp;eacute;ndalo y regrese, porque es un idioma incre&amp;iacute;ble de C ++ relacionado con la seguridad de excepciones.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec6e7926adcc44088c147ea22db81f9c26b87174" translate="yes" xml:space="preserve">
          <source>Consider the following function template:</source>
          <target state="translated">Considere la siguiente plantilla de funciones:</target>
        </trans-unit>
        <trans-unit id="a22158725623f7c0e74173ef7dccec9292a51ae4" translate="yes" xml:space="preserve">
          <source>Copying an object means copying its &quot;static&quot; members and calling the &lt;code&gt;new&lt;/code&gt; operator for its dynamic objects. Right?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Copiar un objeto significa copiar sus miembros &quot;est&amp;aacute;ticos&quot; y llamar al &lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; operador por sus objetos din&amp;aacute;micos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Derecho?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4bd58a0d0236432df5def76d9e83073103fc10f" translate="yes" xml:space="preserve">
          <source>Dangerous and harmless moves</source>
          <target state="translated">Movimientos peligrosos e inofensivos</target>
        </trans-unit>
        <trans-unit id="8cdb90911daa2d1059f97197edc4cbc56200db7d" translate="yes" xml:space="preserve">
          <source>Depending on the class, maybe its a container with very much data, then that could represent much &lt;em&gt;time&lt;/em&gt; and &lt;em&gt;memory usage&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dependiendo de la clase, tal vez sea un contenedor con muchos datos, entonces eso podr&amp;iacute;a representar mucho &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tiempo&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;uso de memoria&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da91507e4d455dd873c3a8569cb70baddddfd087" translate="yes" xml:space="preserve">
          <source>Forwarding references (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf&quot;&gt;previously&lt;/a&gt; known as &lt;em&gt;Universal references&lt;/em&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Reenv&amp;iacute;o de referencias ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;anteriormente&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; conocidas como &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;referencias universales&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b55f1baad0eb4d648fab85d1a0b7b027bc44527" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/move_constructor&quot;&gt;cppreference.com&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Desde &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/move_constructor&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cppreference.com&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9831a9d72fc41bc7b1a34c6df1cc9330199f0d3" translate="yes" xml:space="preserve">
          <source>Here is how you explicitly move from an lvalue:</source>
          <target state="translated">Así es como explícitamente te mueves de un valor:</target>
        </trans-unit>
        <trans-unit id="ad658fc75be5325793f2c751d9cbdad9efe908d2" translate="yes" xml:space="preserve">
          <source>Here's a function that takes an object of type &lt;code&gt;T&lt;/code&gt; and returns an object of the same type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; hay una funci&amp;oacute;n que toma un objeto de tipo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y devuelve un objeto del mismo tipo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="472a84ed15750c08597c803026e48d9c509d8f33" translate="yes" xml:space="preserve">
          <source>How come the move constructor accepts the lvalue &lt;code&gt;result&lt;/code&gt; as an argument? The scope of &lt;code&gt;result&lt;/code&gt; is about to end, and it will be destroyed during stack unwinding. Nobody could possibly complain afterwards that &lt;code&gt;result&lt;/code&gt; had changed somehow; when control flow is back at the caller, &lt;code&gt;result&lt;/code&gt; does not exist anymore! For that reason, C++11 has a special rule that allows returning automatic objects from functions without having to write &lt;code&gt;std::move&lt;/code&gt;. In fact, you should &lt;em&gt;never&lt;/em&gt; use &lt;code&gt;std::move&lt;/code&gt; to move automatic objects out of functions, as this inhibits the &quot;named return value optimization&quot; (NRVO).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;C&amp;oacute;mo es que el constructor de movimientos acepta el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; ado&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lvalue &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;como argumento? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El alcance del &lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; ado&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; est&amp;aacute; a punto de finalizar, y se destruir&amp;aacute; durante el desbobinado de la pila. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nadie podr&amp;iacute;a quejarse despu&amp;eacute;s de que el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; ado&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; hubiera cambiado de alguna manera; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cuando el flujo de control vuelve a la persona que llama, &amp;iexcl;el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;result&lt;/code&gt; ado&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ya no existe! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por esa raz&amp;oacute;n, C ++ 11 tiene una regla especial que permite devolver objetos autom&amp;aacute;ticos de funciones sin tener que escribir &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;De hecho, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;nunca&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; debe &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;usar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para mover objetos autom&amp;aacute;ticos fuera de las funciones, ya que esto inhibe la &quot;optimizaci&amp;oacute;n del valor de retorno con nombre&quot; (NRVO).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b78fb8d2a72d70a2b646e5838f76a391fca0bd1" translate="yes" xml:space="preserve">
          <source>However, to &lt;strong&gt;move&lt;/strong&gt; an object (I repeat, in a practical point of view) implies only to copy the pointers of dynamic objects, and not to create new ones.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin embargo, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mover&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; un objeto (repito, desde un punto de vista pr&amp;aacute;ctico) implica solo copiar los punteros de los objetos din&amp;aacute;micos, y no crear nuevos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be9d897b4ed75e9712b0896110f82792f56d7b57" translate="yes" xml:space="preserve">
          <source>Huh, that's it? &quot;Where's the rvalue reference?&quot; you might ask. &quot;We don't need it here!&quot; is my answer :)</source>
          <target state="translated">¿Eh,eso es todo? &quot;¿Dónde está la referencia del valor?&quot;,podría preguntarse.&quot;¡No la necesitamos aquí!&quot; es mi respuesta.)</target>
        </trans-unit>
        <trans-unit id="dcad3bfb835bd226281cdb3832ed9fbd595b0efa" translate="yes" xml:space="preserve">
          <source>I find it easiest to understand move semantics with example code. Let's start with a very simple string class which only holds a pointer to a heap-allocated block of memory:</source>
          <target state="translated">Encuentro más fácil de entender la semántica de los movimientos con el código de ejemplo.Comencemos con una clase de cadena muy simple que sólo contiene un puntero a un bloque de memoria asignado a un montón:</target>
        </trans-unit>
        <trans-unit id="55918cb4dcbdcb99697ef67c5bfaed72dce39cdf" translate="yes" xml:space="preserve">
          <source>I hope this example got the main point across. There is a lot more to rvalue references and move semantics which I intentionally left out to keep it simple. If you want more details please see &lt;a href=&quot;https://stackoverflow.com/a/11540204/179917&quot;&gt;my supplementary answer&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Espero que este ejemplo haya entendido el punto principal. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hay mucho m&amp;aacute;s para valorar las referencias y mover la sem&amp;aacute;ntica que dej&amp;eacute; intencionalmente para simplificar. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si desea m&amp;aacute;s detalles, consulte &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/11540204/179917&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mi respuesta complementaria&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e26477129fa8f03bbac0d3249cb6cbea6421174" translate="yes" xml:space="preserve">
          <source>I just finished listening to the Software Engineering radio &lt;a href=&quot;http://www.se-radio.net/2010/04/episode-159-c-0x-with-scott-meyers/&quot;&gt;podcast interview with Scott Meyers&lt;/a&gt; regarding &lt;a href=&quot;http://en.wikipedia.org/wiki/C++11&quot;&gt;C++0x&lt;/a&gt;. Most of the new features made sense to me, and I am actually excited about C++0x now, with the exception of one. I still don't get &lt;em&gt;move semantics&lt;/em&gt;... What is it exactly?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Acabo de escuchar la &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.se-radio.net/2010/04/episode-159-c-0x-with-scott-meyers/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;entrevista de podcast de&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; radio de Ingenier&amp;iacute;a de Software &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;con Scott Meyers&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; sobre &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/C++11&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 0x&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La mayor&amp;iacute;a de las nuevas funciones ten&amp;iacute;an sentido para m&amp;iacute;, y ahora estoy realmente entusiasmado con C ++ 0x, con la excepci&amp;oacute;n de una. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Todav&amp;iacute;a no obtengo &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sem&amp;aacute;ntica de movimiento&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ... &amp;iquest;Qu&amp;eacute; es exactamente?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="adf922abf7820e8db1f54450dd73fbd3b62dfdc5" translate="yes" xml:space="preserve">
          <source>I'm writing this to make sure I understand it properly.</source>
          <target state="translated">Estoy escribiendo esto para asegurarme de que lo entiendo correctamente.</target>
        </trans-unit>
        <trans-unit id="ea09e01c3b05274835a4c830a79abe380ae9f1ce" translate="yes" xml:space="preserve">
          <source>If the argument is an rvalue of type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; is deduced to be &lt;code&gt;X&lt;/code&gt;, hence &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; means &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt;. This is what anyone would expect.
But if the argument is an lvalue of type &lt;code&gt;X&lt;/code&gt;, due to a special rule, &lt;code&gt;T&lt;/code&gt; is deduced to be &lt;code&gt;X&amp;amp;&lt;/code&gt;, hence &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; would mean something like &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt;. But since C++ still has no notion of references to references, the type &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; is &lt;em&gt;collapsed&lt;/em&gt; into &lt;code&gt;X&amp;amp;&lt;/code&gt;. This may sound confusing and useless at first, but reference collapsing is essential for &lt;em&gt;perfect forwarding&lt;/em&gt; (which will not be discussed here).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si el argumento es un valor de tipo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se deduce que es &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , por lo tanto, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; significa &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Esto es lo que cualquiera esperar&amp;iacute;a. Pero si el argumento es un valor de tipo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , debido a una regla especial, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se deduce que es &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , por lo tanto, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; significar&amp;iacute;a algo as&amp;iacute; como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Pero dado que C ++ todav&amp;iacute;a no tiene noci&amp;oacute;n de referencias a referencias, el tipo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;contrae&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Esto puede sonar confuso e in&amp;uacute;til al principio, pero el colapso de referencia es esencial para &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;un reenv&amp;iacute;o perfecto&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (que no se discutir&amp;aacute; aqu&amp;iacute;).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eaf342f5b650317d7bfa03afecf3ae79d590c46f" translate="yes" xml:space="preserve">
          <source>If we throw &lt;code&gt;const&lt;/code&gt; into the mix, we already have four different kinds of references. What kinds of expressions of type &lt;code&gt;X&lt;/code&gt; can they bind to?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si arrojamos &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const&lt;/code&gt; ante&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en la mezcla, ya tenemos cuatro tipos diferentes de referencias. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;A qu&amp;eacute; tipos de expresiones de tipo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; se&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; pueden unir?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ff4084df9c7bfd662c531429fd1f1577ffe7f6b" translate="yes" xml:space="preserve">
          <source>If you are really interested in a good, in-depth explanation of move semantics, I'd highly recommend reading the original paper on them, &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm&quot;&gt;&quot;A Proposal to Add Move Semantics Support to the C++ Language.&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si est&amp;aacute; realmente interesado en una buena explicaci&amp;oacute;n detallada de la sem&amp;aacute;ntica de movimiento, le recomiendo leer el documento original sobre ellos, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Una propuesta para agregar soporte de sem&amp;aacute;ntica de movimiento al lenguaje C ++&quot;.&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1199d462777552484944164f0bb197d84758ee45" translate="yes" xml:space="preserve">
          <source>If you want to constrain a function template to rvalues, you can combine &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/sfinae&quot;&gt;SFINAE&lt;/a&gt; with type traits:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si desea restringir una plantilla de funci&amp;oacute;n a valores, puede combinar &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/sfinae&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SFINAE&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con rasgos de tipo:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6da7cd499914cd7d580cba25f4db0148f6ddfea4" translate="yes" xml:space="preserve">
          <source>If you write a class without unmanaged resources, there is no need to declare any of the five special member functions yourself, and you will get correct copy semantics and move semantics for free. Otherwise, you will have to implement the special member functions yourself. Of course, if your class does not benefit from move semantics, there is no need to implement the special move operations.</source>
          <target state="translated">Si escribes una clase sin recursos no administrados,no hay necesidad de declarar ninguna de las cinco funciones especiales de los miembros por ti mismo,y obtendrás la semántica de copia correcta y moverás la semántica de forma gratuita.De lo contrario,tendrás que implementar las funciones especiales de miembro tú mismo.Por supuesto,si su clase no se beneficia de la semántica de movimiento,no hay necesidad de implementar las operaciones especiales de movimiento.</target>
        </trans-unit>
        <trans-unit id="937ed34b756d18c282b5b2e827b2ade63aff5ec5" translate="yes" xml:space="preserve">
          <source>If your object is complex and the destructor has other secondary effects, like calling to a library's function, calling to other global functions or whatever it is, perhaps is better to signal a movement with a flag:</source>
          <target state="translated">Si su objeto es complejo y el destructor tiene otros efectos secundarios,como llamar a la función de una biblioteca,llamar a otras funciones globales o lo que sea,quizás sea mejor señalar un movimiento con una bandera:</target>
        </trans-unit>
        <trans-unit id="7a9339c8c4d94e2f90667ec0345c001b70cea00e" translate="yes" xml:space="preserve">
          <source>Implementation of move</source>
          <target state="translated">Implementación del movimiento</target>
        </trans-unit>
        <trans-unit id="52c0adee2f966c6d6cae560ab2e2d18938668573" translate="yes" xml:space="preserve">
          <source>Implementing safe &quot;move-only&quot; types; that is, types for which copying does not make sense, but moving does.  Examples include locks, file handles, and smart pointers with unique ownership semantics. Note: This answer discusses &lt;code&gt;std::auto_ptr&lt;/code&gt;, a deprecated C++98 standard library template, which was replaced by &lt;code&gt;std::unique_ptr&lt;/code&gt; in C++11. Intermediate C++ programmers are probably at least somewhat familiar with &lt;code&gt;std::auto_ptr&lt;/code&gt;, and because of the &quot;move semantics&quot; it displays, it seems like a good starting point for discussing move semantics in C++11. YMMV.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Implementaci&amp;oacute;n de tipos seguros de &quot;solo movimiento&quot;; es decir, tipos para los que copiar no tiene sentido, pero mover s&amp;iacute;. Los ejemplos incluyen bloqueos, identificadores de archivos e indicadores inteligentes con una sem&amp;aacute;ntica de propiedad &amp;uacute;nica. Nota: Esta respuesta analiza &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , una plantilla de biblioteca est&amp;aacute;ndar C ++ 98 en desuso, que fue reemplazada por &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en C ++ 11. Los programadores intermedios de C ++ probablemente est&amp;eacute;n al menos algo familiarizados con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , y debido a la &quot;sem&amp;aacute;ntica de movimiento&quot; que muestra, parece un buen punto de partida para discutir la sem&amp;aacute;ntica de movimiento en C ++ 11. YMMV.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a454cb8b77503090cbd9a357441f356bcc77421b" translate="yes" xml:space="preserve">
          <source>Implicit conversions</source>
          <target state="translated">Conversiones implícitas</target>
        </trans-unit>
        <trans-unit id="bb86577e32db06fdf51943d408f139502900a7ec" translate="yes" xml:space="preserve">
          <source>In C++03, objects are often copied, only to be destroyed or assigned-over before any code uses the value again.  For example, when you return by value from a function&amp;mdash;unless RVO kicks in&amp;mdash;the value you're returning is copied to the caller's stack frame, and then it goes out of scope and is destroyed.  This is just one of many examples: see pass-by-value when the source object is a temporary, algorithms like &lt;code&gt;sort&lt;/code&gt; that just rearrange items, reallocation in &lt;code&gt;vector&lt;/code&gt; when its &lt;code&gt;capacity()&lt;/code&gt; is exceeded, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En C ++ 03, los objetos a menudo se copian, solo para ser destruidos o asignados antes de que cualquier c&amp;oacute;digo vuelva a usar el valor. Por ejemplo, cuando regresa por valor de una funci&amp;oacute;n, a menos que RVO entre en acci&amp;oacute;n, el valor que est&amp;aacute; devolviendo se copia en el marco de la pila de la persona que llama, y ​​luego se sale del alcance y se destruye. Este es solo uno de muchos ejemplos: vea el paso por valor cuando el objeto fuente es temporal, algoritmos como el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sort&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que simplemente reorganiza los elementos, la reasignaci&amp;oacute;n en el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cuando &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;se excede &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;su &lt;/font&gt;&lt;/font&gt; &lt;code&gt;capacity()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , etc.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3a5b25589cda5ecaab0c938846dc8a956cfda45" translate="yes" xml:space="preserve">
          <source>In C++11, &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; has been replaced by &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; which takes advantage of rvalue references. I will develop and discuss a simplified version of &lt;code&gt;unique_ptr&lt;/code&gt;. First, we encapsulate a raw pointer and overload the operators &lt;code&gt;-&amp;gt;&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, so our class feels like a pointer:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En C ++ 11, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ha sido reemplazado por &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que aprovecha las referencias de rvalue. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Desarrollar&amp;eacute; y discutir&amp;eacute; una versi&amp;oacute;n simplificada de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Primero, encapsulamos un puntero sin formato y sobrecargamos los operadores &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , por lo que nuestra clase se siente como un puntero:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c090c2258bd3627e3ec4d8b649121749fe3c3bd" translate="yes" xml:space="preserve">
          <source>In easy (practical) terms:</source>
          <target state="translated">En términos fáciles (prácticos):</target>
        </trans-unit>
        <trans-unit id="b398d9ad5637d0de4ed8f0bf75e5761b7e55916e" translate="yes" xml:space="preserve">
          <source>In languages which do not allow the creation of local objects (that is, objects on the stack) these types of problems do not occur as all objects are allocated on the heap and are always accessed by reference.</source>
          <target state="translated">En los idiomas que no permiten la creación de objetos locales (es decir,los objetos en la pila)este tipo de problemas no se producen,ya que todos los objetos están asignados en la pila y siempre se accede a ellos por referencia.</target>
        </trans-unit>
        <trans-unit id="27637ef20b376dcf19cbb5d2e6d093390e3f522d" translate="yes" xml:space="preserve">
          <source>In practice, you can forget about &lt;code&gt;const X&amp;amp;&amp;amp;&lt;/code&gt;. Being restricted to read from rvalues is not very useful.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En la pr&amp;aacute;ctica, puede olvidarse de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Estar restringido para leer valores no es muy &amp;uacute;til.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1103ccac7d3cbd997a56ab0386ee5fb290dec2d2" translate="yes" xml:space="preserve">
          <source>In that situation, an anonymous object is created, next copied to the function parameter, and afterwards deleted. So, here it is better to move the object, because you don't need the anonymous object and you can save time and memory.</source>
          <target state="translated">En esa situación,se crea un objeto anónimo,luego se copia en el parámetro de la función y después se borra.Por lo tanto,aquí es mejor mover el objeto,porque no se necesita el objeto anónimo y se puede ahorrar tiempo y memoria.</target>
        </trans-unit>
        <trans-unit id="43e85843d22aecda603952ad3f28eb8d579f2003" translate="yes" xml:space="preserve">
          <source>In the above code, with old compilers the result of &lt;code&gt;f()&lt;/code&gt; is &lt;strong&gt;&lt;em&gt;copied&lt;/em&gt;&lt;/strong&gt; into &lt;code&gt;x&lt;/code&gt; using &lt;code&gt;X&lt;/code&gt;'s copy constructor. If your compiler supports move semantics and &lt;code&gt;X&lt;/code&gt; has a move-constructor, then that is called instead. Since its &lt;code&gt;rhs&lt;/code&gt; argument is an &lt;em&gt;rvalue&lt;/em&gt;, we know it's not needed any longer and we can steal its value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En el c&amp;oacute;digo anterior, con los compiladores antiguos, el resultado de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;copia&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; utilizando &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;el constructor de copia de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; .&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si su compilador admite la sem&amp;aacute;ntica de movimiento y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tiene un constructor de movimiento, entonces se llama en su lugar. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Desde su &lt;/font&gt;&lt;/font&gt; &lt;code&gt;rhs&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; argumento es un &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;valor de lado derecho&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , sabemos que no se necesita m&amp;aacute;s tiempo y podemos robar su valor.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da927e9aca357b1650ec6103ca59d8bb2cb33301" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;&quot;hello world&quot;&lt;/code&gt; is an lvalue of type &lt;code&gt;const char[12]&lt;/code&gt;. Since there is an implicit conversion from &lt;code&gt;const char[12]&lt;/code&gt; through &lt;code&gt;const char*&lt;/code&gt; to &lt;code&gt;std::string&lt;/code&gt;, a temporary of type &lt;code&gt;std::string&lt;/code&gt; is created, and &lt;code&gt;r&lt;/code&gt; is bound to that temporary. This is one of the cases where the distinction between rvalues (expressions) and temporaries (objects) is a bit blurry.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En el ejemplo anterior, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;hello world&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un valor de tipo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char[12]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Como hay una conversi&amp;oacute;n impl&amp;iacute;cita de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char[12]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; trav&amp;eacute;s de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const char*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;se crea &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;un temporal de tipo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; est&amp;aacute; vinculado a ese temporal. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Este es uno de los casos en que la distinci&amp;oacute;n entre valores (expresiones) y temporales (objetos) es un poco borrosa.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc3e683553dc45c7f890c6646a6841181eb6dec4" translate="yes" xml:space="preserve">
          <source>In this case, when an object of type &lt;code&gt;A&lt;/code&gt; should be &quot;copied&quot;, the compiler creates a lvalue reference or a rvalue reference according to if the passed object is named or not. When not, your move-constructor is called and you know the object is temporal and you can move its dynamic objects instead of copying them, saving space and memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En este caso, cuando un objeto de tipo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; debe &quot;copiarse&quot;, el compilador crea una referencia de valor o una referencia de valor seg&amp;uacute;n si el objeto pasado se nombra o no. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cuando no, se llama a su constructor de movimiento y sabe que el objeto es temporal y puede mover sus objetos din&amp;aacute;micos en lugar de copiarlos, ahorrando espacio y memoria.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="d04bb2623f5288427463db7edef0eb602a9ed94a" translate="yes" xml:space="preserve">
          <source>Is that perfect forwarding? Not, but we are very close. Perfect forwarding is only useful to work with templates, with the purpose to say: if I need to pass an object to another function, I need that if I receive a named object, the object is passed as a named object, and when not, I want to pass it like a unnamed object:</source>
          <target state="translated">¿Es un reenvío perfecto? No,pero estamos muy cerca.El reenvío perfecto sólo es útil para trabajar con plantillas,con el propósito de decir:si necesito pasar un objeto a otra función,necesito que si recibo un objeto con nombre,el objeto se pase como un objeto con nombre,y cuando no,quiero pasarlo como un objeto sin nombre:</target>
        </trans-unit>
        <trans-unit id="697f3bc7df8e26b6f96ff8496435e846fe70c4d6" translate="yes" xml:space="preserve">
          <source>It is important to remember that &quot;static&quot; objects are always copied. There's no ways to &quot;move&quot; a static object (object in stack and not on heap). So, the distinction &quot;move&quot;/ &quot;copy&quot; when an object has no dynamic members (directly or indirectly) is irrelevant.</source>
          <target state="translated">Es importante recordar que los objetos &quot;estáticos&quot; siempre se copian.No hay forma de &quot;mover&quot; un objeto estático (objeto apilado y no en un montón).Por lo tanto,la distinción &quot;mover&quot; &quot;copiar&quot; cuando un objeto no tiene miembros dinámicos (directa o indirectamente)es irrelevante.</target>
        </trans-unit>
        <trans-unit id="e9d98f8e9d5357e09bdb4ad11e6dbd887aa316f7" translate="yes" xml:space="preserve">
          <source>It must first initialize the object, then copy all the relevant data from the old object to the new one.</source>
          <target state="translated">Primero debe inicializar el objeto y luego copiar todos los datos relevantes del objeto antiguo al nuevo.</target>
        </trans-unit>
        <trans-unit id="3203ece5d832b88a426ed868437b3f103470fad2" translate="yes" xml:space="preserve">
          <source>It's like copy semantics, but instead of having to duplicate all of the data you get to steal the data from the object being &quot;moved&quot; from.</source>
          <target state="translated">Es como la semántica de la copia,pero en lugar de tener que duplicar todos los datos que obtienes para robar los datos del objeto &quot;movido&quot;.</target>
        </trans-unit>
        <trans-unit id="90e6d34c95a16f345f4e07cab166d7088702a308" translate="yes" xml:space="preserve">
          <source>It's very accessible and easy to read and it makes an excellent case for the benefits that they offer.  There are other more recent and up to date papers about move semantics available on &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/&quot;&gt;the WG21 website&lt;/a&gt;, but this one is probably the most straightforward since it approaches things from a top-level view and doesn't get very much into the gritty language details.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es muy accesible y f&amp;aacute;cil de leer y es un excelente caso para los beneficios que ofrecen. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hay otros documentos m&amp;aacute;s recientes y actualizados sobre la sem&amp;aacute;ntica de movimientos disponibles en &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;el sitio web WG21&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pero este es probablemente el m&amp;aacute;s sencillo, ya que aborda las cosas desde una vista de nivel superior y no entra mucho en los detalles del lenguaje arenoso.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3214661671ef9aff8765af8c7d203ac41c5e3e99" translate="yes" xml:space="preserve">
          <source>Move assignment operators</source>
          <target state="translated">Mover los operadores de asignación</target>
        </trans-unit>
        <trans-unit id="76c87719ef4631d051ec31847319db90f2a38c3c" translate="yes" xml:space="preserve">
          <source>Move constructors</source>
          <target state="translated">Mueve a los constructores</target>
        </trans-unit>
        <trans-unit id="21df78e8312204ee0ae1344d1d1244c5ab2567b2" translate="yes" xml:space="preserve">
          <source>Move semantics allows an object, under certain conditions, to take ownership of some other object's external resources. This is important in two ways:</source>
          <target state="translated">La semántica del movimiento permite que un objeto,bajo ciertas condiciones,se apropie de los recursos externos de otro objeto.Esto es importante de dos maneras:</target>
        </trans-unit>
        <trans-unit id="ff2c5f0ff5c8b72e423fa0fe0eb25bf31e14356c" translate="yes" xml:space="preserve">
          <source>Move semantics are based on &lt;strong&gt;&lt;em&gt;rvalue references&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La sem&amp;aacute;ntica de movimiento se basa en &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;referencias de valor&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b1fd88c02c0af8c30b9a31838ee4311178338b21" translate="yes" xml:space="preserve">
          <source>Move semantics is basically a user-defined type with constructor that takes an r-value reference (new type of reference using &amp;amp;&amp;amp; (yes two ampersands)) which is non-const, this is called a move constructor, same goes for assignment operator. So what does a move constructor do, well instead of copying memory from it's source argument it 'moves' memory from the source to the destination.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La sem&amp;aacute;ntica de movimiento es b&amp;aacute;sicamente un tipo definido por el usuario con un constructor que toma una referencia de valor r (nuevo tipo de referencia usando &amp;amp;&amp;amp; (s&amp;iacute;, dos s&amp;iacute;mbolos)) que no es constante, esto se llama un constructor de movimiento, lo mismo ocurre con el operador de asignaci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces, &amp;iquest;qu&amp;eacute; hace un constructor de movimiento? Bueno, en lugar de copiar la memoria de su argumento de origen, 'mueve' la memoria del origen al destino.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60affa9a44a9bad8c292beedae93936057dc4f21" translate="yes" xml:space="preserve">
          <source>Move semantics were created to avoid the unnecessary copying of large objects.  Bjarne Stroustrup in his book &quot;The C++ Programming Language&quot; uses two examples where unnecessary copying occurs by default: one, the swapping of two large objects, and two, the returning of a large object from a method.</source>
          <target state="translated">La semántica del movimiento fue creada para evitar la copia innecesaria de objetos grandes.Bjarne Stroustrup en su libro &quot;The C++Programming Language&quot; utiliza dos ejemplos en los que la copia innecesaria se produce por defecto:uno,el intercambio de dos objetos grandes,y dos,el retorno de un objeto grande de un método.</target>
        </trans-unit>
        <trans-unit id="f19144fcd990c500b4ac693c567a9549f27dfd2c" translate="yes" xml:space="preserve">
          <source>Moving from lvalues</source>
          <target state="translated">Pasando de los valores</target>
        </trans-unit>
        <trans-unit id="d64e12206734f5c30656ba8ea9b5782042bd423a" translate="yes" xml:space="preserve">
          <source>Moving from lvalues such as &lt;code&gt;a&lt;/code&gt; is dangerous, because we could later try to call a member function via &lt;code&gt;a&lt;/code&gt;, invoking undefined behavior. On the other hand, moving from rvalues such as &lt;code&gt;make_triangle()&lt;/code&gt; is perfectly safe, because after the copy constructor has done its job, we cannot use the temporary again. There is no expression that denotes said temporary; if we simply write &lt;code&gt;make_triangle()&lt;/code&gt; again, we get a &lt;em&gt;different&lt;/em&gt; temporary. In fact, the moved-from temporary is already gone on the next line:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pasar de valores como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es peligroso, porque luego podr&amp;iacute;amos intentar llamar a una funci&amp;oacute;n miembro a trav&amp;eacute;s de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , invocando un comportamiento indefinido. Por otro lado, moverse de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; como &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;make_triangle ()&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es perfectamente seguro, porque despu&amp;eacute;s de que el constructor de copia haya hecho su trabajo, no podemos usar el temporal nuevamente. No hay expresi&amp;oacute;n que denote dicho temporal; si simplemente escribimos &lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; nuevamente, obtenemos un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;temporal &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;diferente&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . De hecho, el temporal de traslado ya se ha ido en la siguiente l&amp;iacute;nea:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a63742120d0d7b0e09c3bb18048c15fda0b0e774" translate="yes" xml:space="preserve">
          <source>Moving into members</source>
          <target state="translated">Moverse a los miembros</target>
        </trans-unit>
        <trans-unit id="55a56ac4401dd0eaa2dcf2e8a8396e846706642c" translate="yes" xml:space="preserve">
          <source>Moving out of functions</source>
          <target state="translated">Salir de las funciones</target>
        </trans-unit>
        <trans-unit id="2a77a62dac1e84715dce30b39e1eca21de49ebaa" translate="yes" xml:space="preserve">
          <source>Moving the data involves re-associating the data with the new object. And &lt;em&gt;no copy takes place&lt;/em&gt; at all.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mover los datos implica volver a asociar los datos con el nuevo objeto. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ninguna copia tiene lugar&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en absoluto.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="694f6377ae54f3d5a6a8d632f41c5ee6694d13aa" translate="yes" xml:space="preserve">
          <source>My first answer was an extremely simplified introduction to move semantics, and many details were left out on purpose to keep it simple.
However, there is a lot more to move semantics, and I thought it was time for a second answer to fill the gaps.
The first answer is already quite old, and it did not feel right to simply replace it with a completely different text. I think it still serves well as a first introduction. But if you want to dig deeper, read on :)</source>
          <target state="translated">Mi primera respuesta fue una introducción extremadamente simplificada para mover la semántica,y muchos detalles fueron dejados fuera a propósito para mantenerla simple.Sin embargo,hay mucho más para mover la semántica,y pensé que era hora de una segunda respuesta para llenar los huecos.La primera respuesta ya es bastante antigua,y no me pareció correcto simplemente reemplazarla con un texto completamente diferente.Creo que todavía sirve bien como una primera introducción.Pero si quieres profundizar más,sigue leyendo :)</target>
        </trans-unit>
        <trans-unit id="2273c40caec113ed4c70f21b9c59f72191a4ef03" translate="yes" xml:space="preserve">
          <source>Never return automatic objects by rvalue reference. Moving is exclusively performed by the move constructor, not by &lt;code&gt;std::move&lt;/code&gt;, and not by merely binding an rvalue to an rvalue reference.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nunca devuelva objetos autom&amp;aacute;ticos por referencia de valor. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El movimiento se realiza exclusivamente por el constructor de movimientos, no por &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , y no simplemente vinculando un rvalue a una referencia de rvalue.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c87b215e468265e84456567f5fd96732627b217" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;std::move&lt;/code&gt; to move automatic objects out of functions.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nunca use &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para mover objetos autom&amp;aacute;ticos fuera de las funciones.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5620a89fc44e99a7e64f46bd1660b0fe78ec31ff" translate="yes" xml:space="preserve">
          <source>Note how both examples follow the same syntactic pattern:</source>
          <target state="translated">Obsérvese cómo ambos ejemplos siguen el mismo patrón sintáctico:</target>
        </trans-unit>
        <trans-unit id="9ffaa4649e35625dc8efbe19265d4da4843b9b9e" translate="yes" xml:space="preserve">
          <source>Note how the initialization of &lt;code&gt;b&lt;/code&gt; with &lt;code&gt;a&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; copy the triangle, but instead transfers the ownership of the triangle from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;. We also say &quot;&lt;code&gt;a&lt;/code&gt; is &lt;em&gt;moved into&lt;/em&gt;&lt;code&gt;b&lt;/code&gt;&quot; or &quot;the triangle is &lt;em&gt;moved&lt;/em&gt; from &lt;code&gt;a&lt;/code&gt;&lt;em&gt;to&lt;/em&gt;&lt;code&gt;b&lt;/code&gt;&quot;. This may sound confusing, because the triangle itself always stays at the same place in memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nota c&amp;oacute;mo la inicializaci&amp;oacute;n de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; copiar el tri&amp;aacute;ngulo, sino que transfiere la propiedad del tri&amp;aacute;ngulo de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n decimos &quot; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mueve a &lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot; o &quot;el tri&amp;aacute;ngulo se &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mueve&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;a &lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto puede sonar confuso, porque el tri&amp;aacute;ngulo siempre permanece en el mismo lugar en la memoria.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4e30ddde6f9383ffb25516635c9c73988eaf920" translate="yes" xml:space="preserve">
          <source>Note how this implementation of the move assignment operator duplicates logic of both the destructor and the move constructor. Are you familiar with the copy-and-swap idiom? It can also be applied to move semantics as the move-and-swap idiom:</source>
          <target state="translated">Obsérvese cómo esta implementación del operador de asignación de movimientos duplica la lógica tanto del destructor como del constructor de movimientos.¿Está familiarizado con el lenguaje de copiar e intercambiar? También se puede aplicar a la semántica de los movimientos como el modismo de copiar e intercambiar:</target>
        </trans-unit>
        <trans-unit id="bc1ed59cd37ede9518aedf02a407061ed06f096c" translate="yes" xml:space="preserve">
          <source>Note that after the third line, &lt;code&gt;a&lt;/code&gt; no longer owns a triangle. That's okay, because by &lt;em&gt;explicitly&lt;/em&gt; writing &lt;code&gt;std::move(a)&lt;/code&gt;, we made our intentions clear: &quot;Dear constructor, do whatever you want with &lt;code&gt;a&lt;/code&gt; in order to initialize &lt;code&gt;c&lt;/code&gt;; I don't care about &lt;code&gt;a&lt;/code&gt; anymore. Feel free to have your way with &lt;code&gt;a&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tenga en cuenta que despu&amp;eacute;s de la tercera l&amp;iacute;nea, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ya no posee un tri&amp;aacute;ngulo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Est&amp;aacute; bien, porque al &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;escribir &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;expl&amp;iacute;citamente &lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;std::move(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , dejamos en claro nuestras intenciones: &quot;Estimado constructor, haz lo que quieras con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para inicializar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; ya no me importa &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Si&amp;eacute;ntete libre de tener tu camino con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b545f2bda15018d01523f9ff1692f25b2b72840e" translate="yes" xml:space="preserve">
          <source>Note that even though &lt;code&gt;std::move(a)&lt;/code&gt; is an rvalue, its evaluation does &lt;em&gt;not&lt;/em&gt; create a temporary object. This conundrum forced the committee to introduce a third value category. Something that can be bound to an rvalue reference, even though it is not an rvalue in the traditional sense, is called an &lt;em&gt;xvalue&lt;/em&gt; (eXpiring value). The traditional rvalues were renamed to &lt;em&gt;prvalues&lt;/em&gt; (Pure rvalues).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tenga en cuenta que aunque &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un valor r, su evaluaci&amp;oacute;n &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; crea un objeto temporal. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Este enigma oblig&amp;oacute; al comit&amp;eacute; a introducir una tercera categor&amp;iacute;a de valor. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algo que puede estar vinculado a una referencia de valor de r, aunque no sea un valor de r en el sentido tradicional, se denomina &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;xvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (valor de eXpiring). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los valores tradicionales se renombraron a &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;valores&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ( &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;valores&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; puros).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6197c8328d3615627bdcb1f1810f59a11b3231ca" translate="yes" xml:space="preserve">
          <source>Note that in both factory functions, the return type is a value, not an rvalue reference. Rvalue references are still references, and as always, you should never return a reference to an automatic object; the caller would end up with a dangling reference if you tricked the compiler into accepting your code, like this:</source>
          <target state="translated">Tenga en cuenta que en ambas funciones de fábrica,el tipo de retorno es un valor,no una referencia de valor.Las referencias de valores siguen siendo referencias,y como siempre,nunca debes devolver una referencia a un objeto automático;el llamador terminaría con una referencia colgante si engañaras al compilador para que aceptara tu código,así:</target>
        </trans-unit>
        <trans-unit id="895f41e9bd9293af7e0f16ad424d9f9981e26c97" translate="yes" xml:space="preserve">
          <source>Note that only xvalues are really new; the rest is just due to renaming and grouping.</source>
          <target state="translated">Tenga en cuenta que sólo los valores x son realmente nuevos;el resto es sólo debido al renombramiento y la agrupación.</target>
        </trans-unit>
        <trans-unit id="3432dccea5cbc5683d11346e5fcd0b1d26cea00a" translate="yes" xml:space="preserve">
          <source>Note that returning by rvalue reference is fine in this example, because &lt;code&gt;t&lt;/code&gt; does not denote an automatic object, but instead an object that was passed in by the caller.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tenga en cuenta que regresar por referencia de valor r est&amp;aacute; bien en este ejemplo, porque &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no denota un objeto autom&amp;aacute;tico, sino un objeto que fue pasado por el llamador.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89ea05e38d59c5aed95819ce421844b145c2084c" translate="yes" xml:space="preserve">
          <source>Note that the copy assignment operator and the move assignment operator can be fused into a single, unified assignment operator, taking its argument by value:</source>
          <target state="translated">Tenga en cuenta que el operador de asignación de copia y el operador de asignación de movimiento pueden fusionarse en un único operador de asignación unificado,tomando su argumento por valor:</target>
        </trans-unit>
        <trans-unit id="545ad832cdf421948e5760aa53c065f811afa6d0" translate="yes" xml:space="preserve">
          <source>Note that the letters &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; have a historic origin in the left-hand side and right-hand side of an assignment. This is no longer true in C++, because there are lvalues which cannot appear on the left-hand side of an assignment (like arrays or user-defined types without an assignment operator), and there are rvalues which can (all rvalues of class types with an assignment operator).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tenga en cuenta que las letras &lt;/font&gt;&lt;/font&gt; &lt;code&gt;l&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tienen un origen hist&amp;oacute;rico en el lado izquierdo y derecho de una tarea. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto ya no es cierto en C ++, porque hay valores que no pueden aparecer en el lado izquierdo de una asignaci&amp;oacute;n (como matrices o tipos definidos por el usuario sin un operador de asignaci&amp;oacute;n), y hay valores que pueden (todos los valores de los tipos de clase con un operador de asignaci&amp;oacute;n).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eaab0e119523ba0a6a6a259204c53d3659b8a758" translate="yes" xml:space="preserve">
          <source>Note that we pass the parameter &lt;code&gt;that&lt;/code&gt;&lt;em&gt;by value&lt;/em&gt;, so &lt;code&gt;that&lt;/code&gt; has to be initialized just like any other string object. Exactly how is &lt;code&gt;that&lt;/code&gt; going to be initialized? In the olden days of &lt;a href=&quot;http://en.wikipedia.org/wiki/C++#Standardization&quot;&gt;C++98&lt;/a&gt;, the answer would have been &quot;by the copy constructor&quot;. In C++0x, the compiler chooses between the copy constructor and the move constructor based on whether the argument to the assignment operator is an lvalue or an rvalue.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tenga en cuenta que se pasa el par&amp;aacute;metro &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;por su valor&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , por lo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tiene que ser inicializado al igual que cualquier otro objeto de cadena. Exactamente c&amp;oacute;mo se &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; va a ser inicializado? En los viejos tiempos de &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/C++#Standardization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 98&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , la respuesta habr&amp;iacute;a sido &quot;por el constructor de la copia&quot;. En C ++ 0x, el compilador elige entre el constructor de copia y el constructor de movimiento en funci&amp;oacute;n de si el argumento para el operador de asignaci&amp;oacute;n es un valor l o un valor r.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="292b4ec9384f8616eaa92d7632778a096d02a026" translate="yes" xml:space="preserve">
          <source>Now comes the interesting part, the move constructor:</source>
          <target state="translated">Ahora viene la parte interesante,el constructor de la mudanza:</target>
        </trans-unit>
        <trans-unit id="9eeb4639b40950f86cdb1f7ee968470d998ea4aa" translate="yes" xml:space="preserve">
          <source>Now comes the key insight into move semantics. Note that only in the first line where we copy &lt;code&gt;x&lt;/code&gt; is this deep copy really necessary, because we might want to inspect &lt;code&gt;x&lt;/code&gt; later and would be very surprised if &lt;code&gt;x&lt;/code&gt; had changed somehow. Did you notice how I just said &lt;code&gt;x&lt;/code&gt; three times (four times if you include this sentence) and meant the &lt;em&gt;exact same object&lt;/em&gt; every time? We call expressions such as &lt;code&gt;x&lt;/code&gt; &quot;lvalues&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora viene la idea clave de la sem&amp;aacute;ntica del movimiento. Tenga en cuenta que solo en la primera l&amp;iacute;nea donde copiamos &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es realmente necesaria esta copia profunda, porque podr&amp;iacute;amos querer inspeccionar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; m&amp;aacute;s tarde y nos sorprender&amp;iacute;a mucho si &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; hubiera cambiado de alguna manera. &amp;iquest;Te diste cuenta de c&amp;oacute;mo acabo de decir &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tres veces (cuatro veces si incluyes esta oraci&amp;oacute;n) y quise decir &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;exactamente el mismo objeto&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cada vez? Llamamos expresiones como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;valores&quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="931b9f3d55a132fec2e5e039741e883dded73c53" translate="yes" xml:space="preserve">
          <source>Now that &lt;code&gt;source&lt;/code&gt; is a variable of type &lt;code&gt;unique_ptr&lt;/code&gt;, it will be initialized by the move constructor; that is, the argument will be moved into the parameter. The argument is still required to be an rvalue, because the move constructor itself has an rvalue reference parameter. When control flow reaches the closing brace of &lt;code&gt;operator=&lt;/code&gt;, &lt;code&gt;source&lt;/code&gt; goes out of scope, releasing the old resource automatically.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora que la &lt;/font&gt;&lt;/font&gt; &lt;code&gt;source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es una variable de tipo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , ser&amp;aacute; inicializada por el constructor de movimiento; es decir, el argumento se mover&amp;aacute; al par&amp;aacute;metro. Todav&amp;iacute;a se requiere que el argumento sea un valor r, porque el propio constructor de movimiento tiene un par&amp;aacute;metro de referencia rvalue. Cuando el flujo de control alcanza la llave de cierre de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;operator=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , la &lt;/font&gt;&lt;/font&gt; &lt;code&gt;source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; sale del alcance y libera el recurso antiguo autom&amp;aacute;ticamente.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="298a83fc83958407292172112721d7fac6f19495" translate="yes" xml:space="preserve">
          <source>Now that you understand reference collapsing, here is how &lt;code&gt;std::move&lt;/code&gt; is implemented:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora que comprende el colapso de referencias, as&amp;iacute; es como &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;se implementa &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c53f94e863e826764f4562c8d505588624c09e3e" translate="yes" xml:space="preserve">
          <source>Now, let's consider what a &lt;em&gt;copy constructor&lt;/em&gt; does.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora, consideremos lo que hace un &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;constructor de copias&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf61830673a8f5c2707029863a04957daf0b7f26" translate="yes" xml:space="preserve">
          <source>Obviously, there must be some profound difference between the expression &lt;code&gt;a&lt;/code&gt; which denotes an &lt;code&gt;auto_ptr&lt;/code&gt; variable, and the expression &lt;code&gt;make_triangle()&lt;/code&gt; which denotes the call of a function that returns an &lt;code&gt;auto_ptr&lt;/code&gt; by value, thus creating a fresh temporary &lt;code&gt;auto_ptr&lt;/code&gt; object every time it is called. &lt;code&gt;a&lt;/code&gt; is an example of an &lt;em&gt;lvalue&lt;/em&gt;, whereas &lt;code&gt;make_triangle()&lt;/code&gt; is an example of an &lt;em&gt;rvalue&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Obviamente, debe haber una profunda diferencia entre la expresi&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que denota una &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;variable &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y la expresi&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que denota la llamada de una funci&amp;oacute;n que devuelve un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; por valor, creando as&amp;iacute; un nuevo &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;objeto &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;temporal &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cada vez que se llama . &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un ejemplo de un &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , mientras que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un ejemplo de un &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f59b333eedae45f10bcefb5eb8e11c7862dbf00" translate="yes" xml:space="preserve">
          <source>Ok, but if I move an object, the source object becomes useless, no? Of course, but in certain situations that's very useful. The most evident one is when I call a function with an anonymous object (temporal, rvalue object, ..., you can call it with different names):</source>
          <target state="translated">Vale,pero si muevo un objeto,el objeto fuente se vuelve inútil,¿no? Por supuesto,pero en ciertas situaciones eso es muy útil.La más evidente es cuando llamo a una función con un objeto anónimo (temporal,objeto de valor,...,puedes llamarlo con diferentes nombres):</target>
        </trans-unit>
        <trans-unit id="ff03efad6b4f508d07644ba3ac921a54bad39daa" translate="yes" xml:space="preserve">
          <source>Other typical question: what is the difference between &lt;code&gt;A&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;const A&amp;amp;&amp;amp;&lt;/code&gt;? Of course, in the first case, you can modify the object and in the second not, but, practical meaning? In the second case, you can't modify it, so you have no ways to invalidate the object (except with a mutable flag or something like that), and there is no practical difference to a copy constructor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otra pregunta t&amp;iacute;pica: &amp;iquest;cu&amp;aacute;l es la diferencia entre &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const A&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? Por supuesto, en el primer caso, puede modificar el objeto y en el segundo no, pero &amp;iquest;significado pr&amp;aacute;ctico? En el segundo caso, no puede modificarlo, por lo que no tiene formas de invalidar el objeto (excepto con una bandera mutable o algo as&amp;iacute;), y no hay una diferencia pr&amp;aacute;ctica para un constructor de copias.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70836291e05cb08b074706c1896b5e4d3e0d1003" translate="yes" xml:space="preserve">
          <source>Perhaps surprisingly, automatic objects (local variables that are not declared as &lt;code&gt;static&lt;/code&gt;) can also be &lt;em&gt;implicitly&lt;/em&gt; moved out of functions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Quiz&amp;aacute;s sorprendentemente, los objetos autom&amp;aacute;ticos (variables locales que no se declaran como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;static&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) tambi&amp;eacute;n se pueden &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mover &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;impl&amp;iacute;citamente&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; fuera de las funciones:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="047060b19a709b1338cf8e5a234066acfcd19213" translate="yes" xml:space="preserve">
          <source>Returning an object from a method by default involves making a copy of the local object and its associated data in a location which is accessible to the caller (because the local object is not accessible to the caller and disappears when the method finishes).  When a built-in type is being returned, this operation is very fast, but if a large object is being returned, this could take a long time.  The move constructor allows the programmer to override this default behavior and instead &quot;reuse&quot; the heap data associated with the local object by pointing the object being returned to the caller to heap data associated with the local object.  Thus no copying is required.</source>
          <target state="translated">Devolver un objeto de un método por defecto implica hacer una copia del objeto local y sus datos asociados en un lugar que sea accesible para la persona que llama (porque el objeto local no es accesible para la persona que llama y desaparece cuando el método termina).Cuando se devuelve un tipo incorporado,esta operación es muy rápida,pero si se devuelve un objeto grande,esto puede llevar mucho tiempo.El constructor de movimiento permite al programador anular este comportamiento por defecto y en su lugar &quot;reutilizar&quot; los datos de pila asociados al objeto local apuntando el objeto que se devuelve al llamante a los datos de pila asociados al objeto local.Por lo tanto,no es necesario copiar.</target>
        </trans-unit>
        <trans-unit id="e5592cd0fb417300cbaac9ee976b933b1a98a51d" translate="yes" xml:space="preserve">
          <source>Rvalue references</source>
          <target state="translated">Referencias de valores</target>
        </trans-unit>
        <trans-unit id="5dc3c807bd559ab077dd1e1206e50e03c15ccaf6" translate="yes" xml:space="preserve">
          <source>Rvalue references went through several versions. Since version 2.1, an rvalue reference &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; also binds to all value categories of a different type &lt;code&gt;Y&lt;/code&gt;, provided there is an implicit conversion from &lt;code&gt;Y&lt;/code&gt; to &lt;code&gt;X&lt;/code&gt;. In that case, a temporary of type &lt;code&gt;X&lt;/code&gt; is created, and the rvalue reference is bound to that temporary:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las referencias de Rvalue pasaron por varias versiones. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Desde la versi&amp;oacute;n 2.1, una referencia rvalue &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tambi&amp;eacute;n se une a todas las categor&amp;iacute;as de valores de un tipo diferente &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , siempre que exista una conversi&amp;oacute;n impl&amp;iacute;cita de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En ese caso, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;se crea &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;un temporal de tipo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y la referencia rvalue est&amp;aacute; vinculada a ese temporal:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="681732688880af87e8358c431edcf6c36bc387ab" translate="yes" xml:space="preserve">
          <source>Rvalue references went through several versions. Since version 3.0, C++11 declares two additional special member functions on demand: the move constructor and the move assignment operator. Note that neither VC10 nor VC11 conform to version 3.0 yet, so you will have to implement them yourself.</source>
          <target state="translated">Las referencias de valor pasaron por varias versiones.Desde la versión 3.0,C++11 declara dos funciones adicionales de miembros especiales a petición:el constructor de mudanzas y el operador de asignación de mudanzas.Tenga en cuenta que ni VC10 ni VC11 se ajustan aún a la versión 3.0,por lo que tendrá que implementarlas usted mismo.</target>
        </trans-unit>
        <trans-unit id="ae0b0234229935b2ce05de8879beb6e5cb6cf659" translate="yes" xml:space="preserve">
          <source>Since an rvalue is going to die at the end of an expression, you can &lt;em&gt;steal its data&lt;/em&gt;. Instead of &lt;em&gt;copying&lt;/em&gt; it into another object, you &lt;em&gt;move&lt;/em&gt; its data into it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dado que un valor r va a morir al final de una expresi&amp;oacute;n, puede &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;robar sus datos&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En lugar de &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;copiarlo&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en otro objeto, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mueve&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; sus datos a &amp;eacute;l.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48e1e601d0414c91d7bb8d787fc5e6f1a4660de9" translate="yes" xml:space="preserve">
          <source>Since we chose to manage the memory ourselves, we need to follow the &lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29&quot;&gt;rule of three&lt;/a&gt;. I am going to defer writing the assignment operator and only implement the destructor and the copy constructor for now:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Como elegimos administrar la memoria nosotros mismos, debemos seguir la &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;regla de tres&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Voy a aplazar la escritura del operador de asignaci&amp;oacute;n y solo implementar&amp;eacute; el destructor y el constructor de copia por ahora:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0099f828c7759a2abbdb4ba58fd52bd3abe97f90" translate="yes" xml:space="preserve">
          <source>So far, we have seen movement into local variables, and into function parameters. But moving is also possible in the opposite direction. If a function returns by value, some object at call site (probably a local variable or a temporary, but could be any kind of object) is initialized with the expression after the &lt;code&gt;return&lt;/code&gt; statement as an argument to the move constructor:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hasta ahora, hemos visto movimientos en variables locales y en par&amp;aacute;metros de funci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero moverse tambi&amp;eacute;n es posible en la direcci&amp;oacute;n opuesta. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si una funci&amp;oacute;n regresa por valor, alg&amp;uacute;n objeto en el sitio de la llamada (probablemente una variable local o temporal, pero podr&amp;iacute;a ser cualquier tipo de objeto) se inicializa con la expresi&amp;oacute;n despu&amp;eacute;s de la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;declaraci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;return&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; como argumento para el constructor de movimiento:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="034b89ff4264e6ea18c21f67aa398614ed9889ef" translate="yes" xml:space="preserve">
          <source>So if you say &lt;code&gt;a = b&lt;/code&gt;, the &lt;em&gt;copy constructor&lt;/em&gt; will initialize &lt;code&gt;that&lt;/code&gt; (because the expression &lt;code&gt;b&lt;/code&gt; is an lvalue), and the assignment operator swaps the contents with a freshly created, deep copy. That is the very definition of the copy and swap idiom -- make a copy, swap the contents with the copy, and then get rid of the copy by leaving the scope. Nothing new here.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces, si dice &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a = b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , el &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;constructor de&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; la &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;copia&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; inicializar&amp;aacute; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (porque la expresi&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un valor l), y el operador de asignaci&amp;oacute;n intercambia el contenido con una copia profunda reci&amp;eacute;n creada. Esa es la definici&amp;oacute;n misma del idioma de copiar e intercambiar: hacer una copia, intercambiar el contenido con la copia y luego deshacerse de la copia dejando el alcance. Nada nuevo aqu&amp;iacute;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54d00ee61a37d56aa5dd7aa4758e0bd04233cb62" translate="yes" xml:space="preserve">
          <source>So the value is &lt;strong&gt;&lt;em&gt;moved&lt;/em&gt;&lt;/strong&gt; from the unnamed temporary returned from &lt;code&gt;f()&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; (while the data of &lt;code&gt;x&lt;/code&gt;, initialized to an empty &lt;code&gt;X&lt;/code&gt;, is moved into the temporary, which will get destroyed after the assignment).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto, el valor se &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mueve&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; del temporal sin nombre devuelto de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (mientras que los datos de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , inicializados en una &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; vac&amp;iacute;a &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, se mueven al temporal, que se destruir&amp;aacute; despu&amp;eacute;s de la asignaci&amp;oacute;n).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f7961a9153c9247dac8ea0516cb0ae78c84857c" translate="yes" xml:space="preserve">
          <source>So, if &lt;code&gt;T&lt;/code&gt; is a lvalue reference to &lt;code&gt;A&lt;/code&gt; (&lt;strong&gt;T&lt;/strong&gt; = A&amp;amp;), &lt;code&gt;a&lt;/code&gt; also (&lt;strong&gt;A&amp;amp;&lt;/strong&gt; &amp;amp;&amp;amp; =&amp;gt; A&amp;amp;). If &lt;code&gt;T&lt;/code&gt; is a rvalue reference to &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; also (A&amp;amp;&amp;amp; &amp;amp;&amp;amp; =&amp;gt; A&amp;amp;&amp;amp;). In both cases, &lt;code&gt;a&lt;/code&gt; is a named object in the actual scope, but &lt;code&gt;T&lt;/code&gt; contains the information of its &quot;reference type&quot; from the caller scope's point of view. This information (&lt;code&gt;T&lt;/code&gt;) is passed as template parameter to &lt;code&gt;forward&lt;/code&gt; and 'a' is moved or not according to the type of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces, si &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es una referencia de valor de &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;l&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ( &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; = A &amp;amp;), &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tambi&amp;eacute;n ( &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A &amp;amp;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;amp;&amp;amp; =&amp;gt; A &amp;amp;). Si &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es una referencia de valor r a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tambi&amp;eacute;n (A &amp;amp;&amp;amp; &amp;amp;&amp;amp; =&amp;gt; A &amp;amp;&amp;amp;). En ambos casos, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un objeto con nombre en el alcance real, pero &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; contiene la informaci&amp;oacute;n de su &quot;tipo de referencia&quot; desde el punto de vista del alcance de la persona que llama. Esta informaci&amp;oacute;n ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) se pasa como par&amp;aacute;metro de plantilla a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;forward&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y 'a' es movido o no de acuerdo con el tipo de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="093fc5e367c5e2bf6fc8ca5b593b0df072b3d2ce" translate="yes" xml:space="preserve">
          <source>So, your code is shorter (you don't need to do a &lt;code&gt;nullptr&lt;/code&gt; assignment for each dynamic member) and more general.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces, su c&amp;oacute;digo es m&amp;aacute;s corto (no necesita hacer una &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;asignaci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nullptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para cada miembro din&amp;aacute;mico) y m&amp;aacute;s general.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68b9a6a0be10d20ad14f2d271cf26db0796998be" translate="yes" xml:space="preserve">
          <source>Sometimes, we want to move from lvalues. That is, sometimes we want the compiler to treat an lvalue as if it were an rvalue, so it can invoke the move constructor, even though it could be potentially unsafe.
For this purpose, C++11 offers a standard library function template called &lt;code&gt;std::move&lt;/code&gt; inside the header &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;.
This name is a bit unfortunate, because &lt;code&gt;std::move&lt;/code&gt; simply casts an lvalue to an rvalue; it does &lt;em&gt;not&lt;/em&gt; move anything by itself. It merely &lt;em&gt;enables&lt;/em&gt; moving. Maybe it should have been named &lt;code&gt;std::cast_to_rvalue&lt;/code&gt; or &lt;code&gt;std::enable_move&lt;/code&gt;, but we are stuck with the name by now.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A veces, queremos pasar de los valores. Es decir, a veces queremos que el compilador trate un valor l como si fuera un valor r, por lo que puede invocar al constructor de movimiento, aunque podr&amp;iacute;a ser potencialmente inseguro. Para este prop&amp;oacute;sito, C ++ 11 ofrece una plantilla de funci&amp;oacute;n de biblioteca est&amp;aacute;ndar llamada &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; dentro del encabezado &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Este nombre es un poco desafortunado, porque &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; simplemente convierte un valor en un valor; s&amp;iacute; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se mueve nada por s&amp;iacute; misma. Simplemente &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;permite&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; moverse. Tal vez deber&amp;iacute;a haberse llamado &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::cast_to_rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::enable_move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pero ahora estamos atrapados con el nombre.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5301bb25f1b806784df96fdac43504d478adbc18" translate="yes" xml:space="preserve">
          <source>Sooner or later, you are going to write code like this:</source>
          <target state="translated">Tarde o temprano,vas a escribir un código como este:</target>
        </trans-unit>
        <trans-unit id="827e6674de363a70897b99e51fffefdb810a4c6e" translate="yes" xml:space="preserve">
          <source>Special member functions</source>
          <target state="translated">Funciones especiales de los miembros</target>
        </trans-unit>
        <trans-unit id="af929f44893f1dbb0ff36798043c5601a040d9c7" translate="yes" xml:space="preserve">
          <source>Stephan T. Lavavej took the time provide valuable feedback. Thank you very much, Stephan!</source>
          <target state="translated">Stephan T.Lavavej se tomó el tiempo para darnos su valiosa opinión.¡Muchas gracias,Stephan!</target>
        </trans-unit>
        <trans-unit id="97edf0f249ffe0384959565a34426727579f471c" translate="yes" xml:space="preserve">
          <source>Suppose you have a function that returns a substantial object:</source>
          <target state="translated">Supongamos que tienes una función que devuelve un objeto sustancial:</target>
        </trans-unit>
        <trans-unit id="76cdc8fdc1131d4b14a54894d4cef5413aad87ac" translate="yes" xml:space="preserve">
          <source>Swapping two large objects usually involves copying the first object to a temporary object, copying the second object to the first object, and copying the temporary object to the second object.  For a built-in type, this is very fast, but for large objects these three copies could take a large amount of time.  A &quot;move assignment&quot; allows the programmer to override the default copy behavior and instead swap references to the objects, which means that there is no copying at all and the swap operation is much faster.  The move assignment can be invoked by calling the std::move() method.</source>
          <target state="translated">El intercambio de dos objetos grandes suele implicar la copia del primer objeto a un objeto temporal,la copia del segundo objeto al primer objeto y la copia del objeto temporal al segundo objeto.Para un tipo incorporado,esto es muy rápido,pero para los objetos grandes estas tres copias podrían tomar una gran cantidad de tiempo.Una &quot;asignación de movimiento&quot; permite al programador anular el comportamiento de copia por defecto y en su lugar intercambiar referencias a los objetos,lo que significa que no hay copia en absoluto y la operación de intercambio es mucho más rápida.La asignación de movimiento puede ser invocada llamando al método std::move().</target>
        </trans-unit>
        <trans-unit id="f28b36c8ab1c06a2320bf78626f74f8e645b94e6" translate="yes" xml:space="preserve">
          <source>T&amp;amp;&amp;amp; is not an rvalue reference, but a forwarding reference. It also binds to lvalues, in which case &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; are both lvalue references.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;T&amp;amp;&amp;amp; no es una referencia de valor, sino una referencia de reenv&amp;iacute;o. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n se une a los valores, en cuyo caso &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; son referencias de valor.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25e5448ed70f909735a7a46f8300ed37a57706a9" translate="yes" xml:space="preserve">
          <source>That's the signature of a prototypical function that uses perfect forwarding, implemented in C++11 by means of &lt;code&gt;std::forward&lt;/code&gt;. This function exploits some rules of template instantiation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esa es la firma de una funci&amp;oacute;n protot&amp;iacute;pica que utiliza el reenv&amp;iacute;o perfecto, implementado en C ++ 11 por medio de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::forward&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta funci&amp;oacute;n explota algunas reglas de creaci&amp;oacute;n de instancias de plantilla:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2aeb46f404b05b67c1d4b4e933f1b159f28adf0b" translate="yes" xml:space="preserve">
          <source>The C++98 standard library offers a smart pointer with unique ownership semantics called &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. In case you are unfamiliar with &lt;code&gt;auto_ptr&lt;/code&gt;, its purpose is to guarantee that a dynamically allocated object is always released, even in the face of exceptions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La biblioteca est&amp;aacute;ndar C ++ 98 ofrece un puntero inteligente con una sem&amp;aacute;ntica de propiedad &amp;uacute;nica llamada &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En caso de que no est&amp;eacute; familiarizado con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , su prop&amp;oacute;sito es garantizar que siempre se libere un objeto asignado din&amp;aacute;micamente, incluso ante excepciones:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c5273ddaf8d4d9bd2c708aae41ca02d986a560f" translate="yes" xml:space="preserve">
          <source>The above function uses &lt;em&gt;call by value&lt;/em&gt; which means that when this function is called an object must be &lt;em&gt;constructed&lt;/em&gt; to be used by the function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La funci&amp;oacute;n anterior utiliza la &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;llamada por valor, lo&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que significa que cuando se llama a esta funci&amp;oacute;n, se debe &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;construir&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; un objeto &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;para ser utilizado por la funci&amp;oacute;n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="21453336f2384057cccb4c69429d948c05e5271d" translate="yes" xml:space="preserve">
          <source>The arguments in lines 2 and 3 are not lvalues, but rvalues, because the underlying string objects have no names, so the client has no way to inspect them again at a later point in time.
rvalues denote temporary objects which are destroyed at the next semicolon (to be more precise: at the end of the full-expression that lexically contains the rvalue). This is important because during the initialization of &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, we could do whatever we wanted with the source string, and &lt;em&gt;the client couldn't tell a difference&lt;/em&gt;!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los argumentos en las l&amp;iacute;neas 2 y 3 no son valores, sino valores, porque los objetos de cadena subyacentes no tienen nombres, por lo que el cliente no tiene forma de inspeccionarlos nuevamente en un momento posterior. Los valores r denotan objetos temporales que se destruyen en el siguiente punto y coma (para ser m&amp;aacute;s precisos: al final de la expresi&amp;oacute;n completa que contiene l&amp;eacute;xicamente el valor r). Esto es importante debido a que durante la inicializaci&amp;oacute;n de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pod&amp;iacute;amos hacer lo que quisi&amp;eacute;ramos con la cadena de origen, y &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;el cliente no puede decir una diferencia&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; !&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e024a6d6f6f045a7e5fd3e2fd78c563a51190fec" translate="yes" xml:space="preserve">
          <source>The call of a function that returns an rvalue reference, such as &lt;code&gt;std::move&lt;/code&gt;, is an xvalue.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La llamada de una funci&amp;oacute;n que devuelve una referencia rvalue, como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , es un xvalue.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b626cb0884dddd9379630d99507ae7fe2ff2c15c" translate="yes" xml:space="preserve">
          <source>The constructor takes ownership of the object, and the destructor deletes it:</source>
          <target state="translated">El constructor toma posesión del objeto y el destructor lo borra:</target>
        </trans-unit>
        <trans-unit id="e74352db34fd6a5e34f47321ae6e9f914b303f6f" translate="yes" xml:space="preserve">
          <source>The copy constructor defines what it means to copy string objects. The parameter &lt;code&gt;const string&amp;amp; that&lt;/code&gt; binds to all expressions of type string which allows you to make copies in the following examples:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El constructor de copia define lo que significa copiar objetos de cadena. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El par&amp;aacute;metro &lt;/font&gt;&lt;/font&gt; &lt;code&gt;const string&amp;amp; that&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; une a todas las expresiones de tipo string que le permite hacer copias en los siguientes ejemplos:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="290f16723b4d755e1f94e621b760399ee06c5273" translate="yes" xml:space="preserve">
          <source>The copy constructor of &lt;code&gt;auto_ptr&lt;/code&gt; probably looks something like this (somewhat simplified):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El constructor de copia de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; probablemente se parece a esto (algo simplificado):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f162420dc7014f9f7aea09dba5df626cfbba3e4" translate="yes" xml:space="preserve">
          <source>The dangerous thing about &lt;code&gt;auto_ptr&lt;/code&gt; is that what syntactically looks like a copy is actually a move. Trying to call a member function on a moved-from &lt;code&gt;auto_ptr&lt;/code&gt; will invoke undefined behavior, so you have to be very careful not to use an &lt;code&gt;auto_ptr&lt;/code&gt; after it has been moved from:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lo peligroso de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es que lo que parece sint&amp;aacute;cticamente una copia es en realidad un movimiento. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Intentar llamar a una funci&amp;oacute;n miembro en un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; movido &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;invocar&amp;aacute; un comportamiento indefinido, por lo que debe tener mucho cuidado de no usar un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; despu&amp;eacute;s de que se haya movido de:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5518e5be02f103564f3cd6dfbbdb856e00b6efc" translate="yes" xml:space="preserve">
          <source>The last missing piece is the move assignment operator. Its job is to release the old resource and acquire the new resource from its argument:</source>
          <target state="translated">La última pieza que falta es el operador de asignación de movimientos.Su trabajo es liberar el viejo recurso y adquirir el nuevo recurso de su argumento:</target>
        </trans-unit>
        <trans-unit id="e783ee3bf25d0cbf3bd7e4504e938db2d81a4f14" translate="yes" xml:space="preserve">
          <source>The move assignment operator transfers ownership of a managed resource into the current object, releasing the old resource.
  The move-and-swap idiom simplifies the implementation.</source>
          <target state="translated">El operador de asignación de movimientos transfiere la propiedad de un recurso gestionado al objeto actual,liberando el recurso antiguo.El modismo de mover e intercambiar simplifica la implementación.</target>
        </trans-unit>
        <trans-unit id="a92be27a40d64e9f0284a53eff6b28c4024e3a73" translate="yes" xml:space="preserve">
          <source>The move constructor transfers ownership of a managed resource into the current object.</source>
          <target state="translated">El constructor de la mudanza transfiere la propiedad de un recurso administrado al objeto actual.</target>
        </trans-unit>
        <trans-unit id="369d03b7f7d3482f6aec3906bad55a6bc99dd045" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;a&lt;/code&gt; would be copied to the actual parameter of &lt;code&gt;other_function&lt;/code&gt;. If you want the object &lt;code&gt;a&lt;/code&gt; continues being treated as a temporary object, you should use the &lt;code&gt;std::move&lt;/code&gt; function:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El objeto &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se copiar&amp;aacute; al par&amp;aacute;metro real de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si desea que el objeto &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; contin&amp;uacute;e siendo tratado como un objeto temporal, debe usar la funci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3f96d5d08d17f40270352611586edfa618dbb5ff" translate="yes" xml:space="preserve">
          <source>The second line fails to compile, because &lt;code&gt;a&lt;/code&gt; is an lvalue, but the parameter &lt;code&gt;unique_ptr&amp;amp;&amp;amp; source&lt;/code&gt; can only be bound to rvalues. This is exactly what we wanted; dangerous moves should never be implicit. The third line compiles just fine, because &lt;code&gt;make_triangle()&lt;/code&gt; is an rvalue. The move constructor will transfer ownership from the temporary to &lt;code&gt;c&lt;/code&gt;. Again, this is exactly what we wanted.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La segunda l&amp;iacute;nea no puede compilarse, porque &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un valor l, pero el par&amp;aacute;metro &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&amp;amp;&amp;amp; source&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; solo puede vincularse a valores. Esto es exactamente lo que quer&amp;iacute;amos; movimientos peligrosos nunca deben ser impl&amp;iacute;citos. La tercera l&amp;iacute;nea se compila muy bien, porque &lt;/font&gt;&lt;/font&gt; &lt;code&gt;make_triangle()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un valor r. El constructor de movimiento transferir&amp;aacute; la propiedad de lo temporal a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . De nuevo, esto es exactamente lo que quer&amp;iacute;amos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a3730034e13e4628ec2934efc747b68c3fc3e13d" translate="yes" xml:space="preserve">
          <source>The solution is to manually enable the move:</source>
          <target state="translated">La solución es habilitar manualmente el movimiento:</target>
        </trans-unit>
        <trans-unit id="08aa002af0a7d7ef8a828f926264d37a71e32e78" translate="yes" xml:space="preserve">
          <source>The unusual thing about &lt;code&gt;auto_ptr&lt;/code&gt; is its &quot;copying&quot; behavior:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lo inusual de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es su comportamiento de &quot;copia&quot;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3032c490102dbbdc1a53ae3a1e6b530d8d4c02ba" translate="yes" xml:space="preserve">
          <source>These two new special member functions are only implicitly declared if none of the special member functions are declared manually. Also, if you declare your own move constructor or move assignment operator, neither the copy constructor nor the copy assignment operator will be declared implicitly.</source>
          <target state="translated">Estas dos nuevas funciones de los miembros especiales sólo se declaran implícitamente si ninguna de las funciones de los miembros especiales se declara manualmente.Además,si usted declara su propio constructor de mudanzas u operador de asignación de mudanzas,ni el constructor de copias ni el operador de asignación de copias serán declarados implícitamente.</target>
        </trans-unit>
        <trans-unit id="83a00c1613c4181d37c495b96f0796b835f18525" translate="yes" xml:space="preserve">
          <source>This is accomplished with an &lt;code&gt;rvalue&lt;/code&gt; reference.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto se logra con un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;rvalue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de referencia.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="31ccc28aaac9180efd97b0f2232c9474c45ded9f" translate="yes" xml:space="preserve">
          <source>This is especially important if (like perhaps the &lt;code&gt;Matrix&lt;/code&gt; example above), the object being copied allocates extra memory on the heap to store its internal representation. A copy constructor would have to either make a full copy of the internal representation, or use reference counting and copy-on-write semantics interally. A move constructor would leave the heap memory alone and just copy the pointer inside the &lt;code&gt;Matrix&lt;/code&gt; object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto es especialmente importante si (como quiz&amp;aacute;s el &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ejemplo de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Matrix&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; anterior), el objeto que se copia asigna memoria adicional en el mont&amp;oacute;n para almacenar su representaci&amp;oacute;n interna. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un constructor de copias tendr&amp;iacute;a que hacer una copia completa de la representaci&amp;oacute;n interna, o usar el conteo de referencias y la sem&amp;aacute;ntica de copia en escritura de manera interna. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un constructor de movimientos dejar&amp;iacute;a sola la memoria de almacenamiento din&amp;aacute;mico y simplemente copiar&amp;iacute;a el puntero dentro del &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;objeto &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Matrix&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="734c00e55f5d7bfea55f0c53e0033b51b7115120" translate="yes" xml:space="preserve">
          <source>This leads to the concept of an &quot;rvalue&quot; reference. They exist in C++11 only to detect if the received object is anonymous or not. I think you do already know that an &quot;lvalue&quot; is an assignable entity (the left part of the &lt;code&gt;=&lt;/code&gt; operator), so you need a named reference to an object to be capable to act as an lvalue. A rvalue is exactly the opposite, an object with no named references. Because of that, anonymous object and rvalue are synonyms. So:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto lleva al concepto de una referencia de &quot;valor&quot;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Existen en C ++ 11 solo para detectar si el objeto recibido es an&amp;oacute;nimo o no. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Creo que ya sabe que un &quot;lvalue&quot; es una entidad asignable (la parte izquierda del &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;operador &lt;/font&gt;&lt;/font&gt; &lt;code&gt;=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), por lo que necesita una referencia con nombre a un objeto para poder actuar como un lvalue. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un valor r es exactamente lo contrario, un objeto sin referencias nombradas. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por eso, objeto an&amp;oacute;nimo y rvalue son sin&amp;oacute;nimos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2a9839394d8fd7fa5c503f67611a827e38511306" translate="yes" xml:space="preserve">
          <source>This move constructor does exactly what the &lt;code&gt;auto_ptr&lt;/code&gt; copy constructor did, but it can only be supplied with rvalues:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Este constructor de movimientos hace exactamente lo que &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;hizo el constructor de copia &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pero solo se puede suministrar con valores:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e308529a0760da4187efbb6031e853815d012f5" translate="yes" xml:space="preserve">
          <source>This way, the number of special member functions to implement drops from five to four. There is a tradeoff between exception-safety and efficiency here, but I am not an expert on this issue.</source>
          <target state="translated">De esta manera,el número de funciones especiales de los miembros para implementar bajan de cinco a cuatro.Hay un equilibrio entre la seguridad de la excepción y la eficiencia aquí,pero no soy un experto en este tema.</target>
        </trans-unit>
        <trans-unit id="c835c096c791a7fe0c7b46b42e46e2033cbeb4bc" translate="yes" xml:space="preserve">
          <source>To illustrate the need for &lt;em&gt;move semantics&lt;/em&gt;, let's consider this example without move semantics:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para ilustrar la necesidad de &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sem&amp;aacute;ntica de movimiento&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , consideremos este ejemplo sin sem&amp;aacute;ntica de movimiento:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a7e9e734de9455aa1437dc73d5ab335d653aaac" translate="yes" xml:space="preserve">
          <source>To make strong exception guarantee possible, user-defined move constructors should not throw exceptions. In fact, standard containers typically rely on std::move_if_noexcept to choose between move and copy when container elements need to be relocated.
  If both copy and move constructors are provided, overload resolution selects the move constructor if the argument is an rvalue (either a prvalue such as a nameless temporary or an xvalue such as the result of std::move), and selects the copy constructor if the argument is an lvalue (named object or a function/operator returning lvalue reference). If only the copy constructor is provided, all argument categories select it (as long as it takes a reference to const, since rvalues can bind to const references), which makes copying the fallback for moving, when moving is unavailable.
  In many situations, move constructors are optimized out even if they would produce observable side-effects, see copy elision.
  A constructor is called a 'move constructor' when it takes an rvalue reference as a parameter. It is not obligated to move anything, the class is not required to have a resource to be moved and a 'move constructor' may not be able to move a resource as in the allowable (but maybe not sensible) case where the parameter is a const rvalue reference (const T&amp;amp;&amp;amp;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para hacer posible una fuerte garant&amp;iacute;a de excepci&amp;oacute;n, los constructores de movimiento definidos por el usuario no deber&amp;iacute;an lanzar excepciones. De hecho, los contenedores est&amp;aacute;ndar generalmente se basan en std :: move_if_noexcept para elegir entre mover y copiar cuando los elementos del contenedor necesitan ser reubicados. Si se proporcionan constructores de copia y movimiento, la resoluci&amp;oacute;n de sobrecarga selecciona el constructor de movimiento si el argumento es un valor r (un valor pr tal como un temporal sin nombre o un valor x como el resultado de std :: move), y selecciona el constructor de copia si El argumento es un lvalue (objeto nombrado o una funci&amp;oacute;n / operador que devuelve la referencia de lvalue). Si solo se proporciona el constructor de copia, todas las categor&amp;iacute;as de argumentos lo seleccionan (siempre que tome una referencia a const, ya que los valores pueden unirse a las referencias de const), lo que hace que copiar el respaldo para mover, cuando mover no est&amp;eacute; disponible.En muchas situaciones, los constructores de movimientos se optimizan incluso si produjeran efectos secundarios observables, ver copia de elisi&amp;oacute;n. Un constructor se llama 'constructor de movimiento' cuando toma una referencia de valor como par&amp;aacute;metro. No est&amp;aacute; obligado a mover nada, no se requiere que la clase tenga un recurso para mover y un 'constructor de movimiento' puede no ser capaz de mover un recurso como en el caso permitido (pero quiz&amp;aacute;s no sensible) donde el par&amp;aacute;metro es un const rvalue reference (const T &amp;amp;&amp;amp;).es posible que no pueda mover un recurso como en el caso permitido (pero quiz&amp;aacute;s no sensible) donde el par&amp;aacute;metro es una referencia de valor constante (const T &amp;amp;&amp;amp;).es posible que no pueda mover un recurso como en el caso permitido (pero quiz&amp;aacute;s no sensible) donde el par&amp;aacute;metro es una referencia de valor constante (const T &amp;amp;&amp;amp;).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b31d2be34d67b295038676b6a78d3aa74806629a" translate="yes" xml:space="preserve">
          <source>To move an object means to transfer ownership of some resource it manages to another object.</source>
          <target state="translated">Mover un objeto significa transferir la propiedad de algún recurso que administra a otro objeto.</target>
        </trans-unit>
        <trans-unit id="bbf1b3314c139a90af79519c70cc487a725f22d9" translate="yes" xml:space="preserve">
          <source>To summarize, the copy constructor makes a deep copy, because the source must remain untouched.
The move constructor, on the other hand, can just copy the pointer and then set the pointer in the source to null. It is okay to &quot;nullify&quot; the source object in this manner, because the client has no way of inspecting the object again.</source>
          <target state="translated">En resumen,el constructor de la copia hace una copia profunda,porque la fuente debe permanecer intacta.El constructor de movimientos,por otro lado,puede simplemente copiar el puntero y luego poner el puntero de la fuente en nulo.Está bien &quot;anular&quot; el objeto fuente de esta manera,porque el cliente no tiene forma de inspeccionar el objeto de nuevo.</target>
        </trans-unit>
        <trans-unit id="047b60f44c81098eb74095d0ced4e749b86ad68f" translate="yes" xml:space="preserve">
          <source>Turning expensive copies into cheap moves. See my first answer for an example. Note that if an object does not manage at least one external resource (either directly, or indirectly through its member objects), move semantics will not offer any advantages over copy semantics. In that case, copying an object and moving an object means the exact same thing:</source>
          <target state="translated">Convirtiendo copias caras en movimientos baratos.Vean mi primera respuesta para un ejemplo.Tenga en cuenta que si un objeto no gestiona al menos un recurso externo (ya sea directamente o indirectamente a través de sus objetos miembros),la semántica de los movimientos no ofrecerá ninguna ventaja sobre la semántica de las copias.En ese caso,copiar un objeto y mover un objeto significa exactamente lo mismo:</target>
        </trans-unit>
        <trans-unit id="de0430a56abae1a9c8cca4fd7a8b8906769e0636" translate="yes" xml:space="preserve">
          <source>Value categories</source>
          <target state="translated">Categorías de valor</target>
        </trans-unit>
        <trans-unit id="2aa8f4165ecd80aeeeeb890eaf78af1a8a3b401b" translate="yes" xml:space="preserve">
          <source>We now understand that moving from lvalues is potentially dangerous, but moving from rvalues is harmless. If C++ had language support to distinguish lvalue arguments from rvalue arguments, we could either completely forbid moving from lvalues, or at least make moving from lvalues &lt;em&gt;explicit&lt;/em&gt; at call site, so that we no longer move by accident.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora entendemos que moverse de los valores es potencialmente peligroso, pero moverse de los valores es inofensivo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si C ++ tuviera soporte de lenguaje para distinguir los argumentos de lvalue de los argumentos de rvalue, podr&amp;iacute;amos prohibir completamente el traslado de los valores, o al menos hacer que el desplazamiento de los valores sea &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;expl&amp;iacute;cito&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en el sitio de la llamada, de modo que ya no nos &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;muevamos &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;por accidente.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c91f5982e73d44e7f4a6ccace5726e523643802" translate="yes" xml:space="preserve">
          <source>What do these rules mean in practice?</source>
          <target state="translated">¿Qué significan estas reglas en la práctica?</target>
        </trans-unit>
        <trans-unit id="99565c8cb484efe8d28c4076f67a25e83378c561" translate="yes" xml:space="preserve">
          <source>What have we done here? Instead of deeply copying the heap data, we have just copied the pointer and then set the original pointer to null (to prevent 'delete[]' from source object's destructor from releasing our 'just stolen data'). In effect, we have &quot;stolen&quot; the data that originally belonged to the source string. Again, the key insight is that under no circumstance could the client detect that the source had been modified. Since we don't really do a copy here, we call this constructor a &quot;move constructor&quot;. Its job is to move resources from one object to another instead of copying them.</source>
          <target state="translated">¿Qué hemos hecho aquí? En lugar de copiar profundamente los datos del montón,hemos copiado el puntero y luego hemos puesto el puntero original en nulo (para evitar que &quot;delete[]&quot; del destructor del objeto fuente libere nuestros &quot;datos recién robados&quot;).En efecto,hemos &quot;robado&quot; los datos que originalmente pertenecían a la cadena de la fuente.Una vez más,la clave es que bajo ninguna circunstancia el cliente pudo detectar que la fuente había sido modificada.Como no hacemos una copia aquí,llamamos a este constructor un &quot;constructor de movimiento&quot;.Su trabajo es mover recursos de un objeto a otro en lugar de copiarlos.</target>
        </trans-unit>
        <trans-unit id="3334057bf5fdd1df4c8a56b5a8bb56d8d08ac48e" translate="yes" xml:space="preserve">
          <source>What is a move?</source>
          <target state="translated">¿Qué es una mudanza?</target>
        </trans-unit>
        <trans-unit id="ff7bddf15a2315c6021f9e9d0f6b6bce8bcffd35" translate="yes" xml:space="preserve">
          <source>What is move semantics</source>
          <target state="translated">¿Qué es la semántica del movimiento</target>
        </trans-unit>
        <trans-unit id="22b96be030691f90fe9b2e0240432d1d51dae570" translate="yes" xml:space="preserve">
          <source>When such copy/destroy pairs are expensive, it's typically because the object owns some heavyweight resource. For example, &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; may own a dynamically-allocated memory block containing an array of &lt;code&gt;string&lt;/code&gt; objects, each with its own dynamic memory.  Copying such an object is costly: you have to allocate new memory for each dynamically-allocated blocks in the source, and copy all the values across.  &lt;em&gt;Then&lt;/em&gt; you need deallocate all that memory you just copied.  However, &lt;em&gt;moving&lt;/em&gt; a large &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; means just copying a few pointers (that refer to the dynamic memory block) to the destination and zeroing them out in the source.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cuando tales pares de copia / destrucci&amp;oacute;n son caros, generalmente se debe a que el objeto posee alg&amp;uacute;n recurso pesado. Por ejemplo, el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; puede poseer un bloque de memoria asignado din&amp;aacute;micamente que contiene una matriz de &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;objetos &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , cada uno con su propia memoria din&amp;aacute;mica. Copiar un objeto de este tipo es costoso: debe asignar nueva memoria para cada bloque asignado din&amp;aacute;micamente en el origen y copiar todos los valores. &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; necesitas desasignar toda esa memoria que acabas de copiar. Sin embargo, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mover&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; grande &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;lt;cadena&amp;gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; significa simplemente copiar algunos punteros (que se refieren al bloque de memoria din&amp;aacute;mica) al destino y ponerlos a cero en la fuente.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9cd78414f15901d8e86a8d3f4a590968adf4da6" translate="yes" xml:space="preserve">
          <source>When the new object is created from the return value, the copy constructor is called to &lt;em&gt;copy&lt;/em&gt; the contents of the temporary object to the new object b. After the function completes, the temporary object used in the function goes out of scope and is destroyed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cuando se crea el nuevo objeto a partir del valor de retorno, se llama al constructor de &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;copia&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;copiar&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; el contenido del objeto temporal en el nuevo objeto b. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una vez que se completa la funci&amp;oacute;n, el objeto temporal utilizado en la funci&amp;oacute;n queda fuera de alcance y se destruye.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="07a221a0bb57425e9405956022b30340ca656ba4" translate="yes" xml:space="preserve">
          <source>When would you want to do that? well std::vector is an example, say you created a temporary std::vector and you return it from a function say:</source>
          <target state="translated">¿Cuándo querrías hacer eso? Bueno std::vector es un ejemplo,digamos que creaste un std::vector temporal y lo devuelves desde una función digamos:</target>
        </trans-unit>
        <trans-unit id="74ec9a380d335c03fb7b287be6ff753162c1a3a7" translate="yes" xml:space="preserve">
          <source>When you write code like this:</source>
          <target state="translated">Cuando escribes un código como este:</target>
        </trans-unit>
        <trans-unit id="221b238f8d5a91baf4778e7b3912f0b81807d155" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;move semantics&lt;/strong&gt; it's now possible to make most of this work less unpleasant by simply &lt;em&gt;moving&lt;/em&gt; the data rather than copying.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Con la &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sem&amp;aacute;ntica de movimiento&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ahora es posible hacer que la mayor&amp;iacute;a de este trabajo sea menos desagradable simplemente &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;moviendo&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; los datos en lugar de copiarlos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1e792bfe219381f99de1182972a3fef81354e659" translate="yes" xml:space="preserve">
          <source>With this line, &lt;code&gt;std::move&lt;/code&gt; will cast &lt;code&gt;a&lt;/code&gt; to an rvalue and &lt;code&gt;other_function&lt;/code&gt; will receive the object as a unnamed object. Of course, if &lt;code&gt;other_function&lt;/code&gt; has not specific overloading to work with unnamed objects, this distinction is not important.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Con esta l&amp;iacute;nea, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; echar&amp;aacute; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a un valor de lado derecho y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; recibir&amp;aacute; el objeto como un objeto no identificado. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por supuesto, si &lt;/font&gt;&lt;/font&gt; &lt;code&gt;other_function&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no tiene una sobrecarga espec&amp;iacute;fica para trabajar con objetos sin nombre, esta distinci&amp;oacute;n no es importante.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a502ae851780f1ddc7db29441700f146506ebb73" translate="yes" xml:space="preserve">
          <source>Xvalues</source>
          <target state="translated">Xvalues</target>
        </trans-unit>
        <trans-unit id="c39f86b271db60b23e48e49da3c4e77b7bf0f5df" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;parameter&lt;/code&gt; by value. For move-only types like &lt;code&gt;unique_ptr&lt;/code&gt;, it seems there is no established idiom yet. Personally, I prefer pass by value, as it causes less clutter in the interface.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n puede pasar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; por valor. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para los tipos de solo movimiento como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , parece que todav&amp;iacute;a no hay un idioma establecido. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Personalmente, prefiero pasar por valor, ya que causa menos desorden en la interfaz.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e2f4250ebd2eff63e7f150721d9b86649703b85e" translate="yes" xml:space="preserve">
          <source>You could argue that &lt;code&gt;parameter&lt;/code&gt; is not used anymore after the initialization of &lt;code&gt;member&lt;/code&gt;. Why is there no special rule to silently insert &lt;code&gt;std::move&lt;/code&gt; just as with return values? Probably because it would be too much burden on the compiler implementors. For example, what if the constructor body was in another translation unit? By contrast, the return value rule simply has to check the symbol tables to determine whether or not the identifier after the &lt;code&gt;return&lt;/code&gt; keyword denotes an automatic object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Podr&amp;iacute;a argumentar que el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;parameter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ya no se usa despu&amp;eacute;s de la inicializaci&amp;oacute;n del &lt;/font&gt;&lt;/font&gt; &lt;code&gt;member&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Por qu&amp;eacute; no hay una regla especial para insertar silenciosamente &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::move&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; como con los valores de retorno? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Probablemente porque ser&amp;iacute;a una carga excesiva para los implementadores del compilador. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por ejemplo, &amp;iquest;qu&amp;eacute; pasa si el cuerpo del constructor estaba en otra unidad de traducci&amp;oacute;n? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por el contrario, la regla del valor de retorno simplemente tiene que verificar las tablas de s&amp;iacute;mbolos para determinar si el identificador despu&amp;eacute;s de la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;palabra clave de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;return&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; denota un objeto autom&amp;aacute;tico.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3ca8091ddd18805cfc713df7dd75868c9a95f47" translate="yes" xml:space="preserve">
          <source>You know what a copy semantics means right? it means you have types which are copyable, for user-defined types you define this either buy explicitly writing a copy constructor &amp;amp; assignment operator or the compiler generates them implicitly. This will do a copy.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sabes lo que significa una sem&amp;aacute;ntica de copia, &amp;iquest;verdad? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;significa que tiene tipos que se pueden copiar, para los tipos definidos por el usuario, usted define esto ya sea comprando expl&amp;iacute;citamente escribiendo un constructor de copia y un operador de asignaci&amp;oacute;n o el compilador los genera impl&amp;iacute;citamente. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto har&amp;aacute; una copia.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e2f4bc4c9d48bda3c7ea5e8d13ceacb5e895f12" translate="yes" xml:space="preserve">
          <source>You might expect &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; to only bind to rvalues, because at first glance, it looks like an rvalue reference. As it turns out though, &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; also binds to lvalues:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede esperar que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; solo se una a los valores, porque a primera vista, parece una referencia de valor. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin embargo, resulta que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tambi&amp;eacute;n se une a los valores:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d33a97176f7badf8aeef43dbd922269578988791" translate="yes" xml:space="preserve">
          <source>You're going to have overhead from the copy constructor when the function returns, if (and it will in C++0x) std::vector has a move constructor instead of copying it can just set it's pointers and 'move' dynamically allocated memory to the new instance. It's kind of like transfer-of-ownership semantics with std::auto_ptr.</source>
          <target state="translated">Vas a tener una sobrecarga del constructor de la copia cuando la función regrese,si (y lo hará en C++0x)std::vector tiene un constructor de movimientos en lugar de copiarlo puede simplemente establecer sus punteros y 'mover' la memoria asignada dinámicamente a la nueva instancia.Es algo así como la semántica de la transferencia de propiedad con std::auto_ptr.</target>
        </trans-unit>
        <trans-unit id="e21276ab1166e0e62608292fa54445af12932da1" translate="yes" xml:space="preserve">
          <source>an &lt;em&gt;rvalue reference can be moved&lt;/em&gt; and an &lt;em&gt;lvalue&lt;/em&gt; cannot.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;una &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;referencia de rvalue se puede mover&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y un &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lvalue&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="151db36d21b0e8f4a4f6c394902768f00fb00c34" translate="yes" xml:space="preserve">
          <source>then an ordinary C++ compiler will create a temporary object for the result of &lt;code&gt;multiply()&lt;/code&gt;, call the copy constructor to initialise &lt;code&gt;r&lt;/code&gt;, and then destruct the temporary return value. Move semantics in C++0x allow the &quot;move constructor&quot; to be called to initialise &lt;code&gt;r&lt;/code&gt; by copying its contents, and then discard the temporary value without having to destruct it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;entonces un compilador de C ++ ordinario crear&amp;aacute; un objeto temporal para el resultado de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;multiply()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , llamar&amp;aacute; al constructor de la copia para inicializar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , y luego destruir&amp;aacute; el valor de retorno temporal. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La sem&amp;aacute;ntica de movimiento en C ++ 0x permite que se llame al &quot;constructor de movimiento&quot; para inicializar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; copiando su contenido y luego descartar el valor temporal sin tener que destruirlo.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
