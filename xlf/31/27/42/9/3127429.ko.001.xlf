<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/3127429">
    <body>
      <group id="3127429">
        <trans-unit id="1f8742c489830fbb68ca2ba261bc508b53df7499" translate="yes" xml:space="preserve">
          <source>&quot;this&quot; is all about scope. Every function has its own scope, and since everything in JS is an object, even a function can store some values into itself using &quot;this&quot;. OOP 101 teaches that &quot;this&quot; is only applicable to &lt;em&gt;instances&lt;/em&gt; of an object. Therefore, every-time a function executes, a new &quot;instance&quot; of that function has a new meaning of &quot;this&quot;.</source>
          <target state="translated">&quot;이것은&quot;범위에 관한 것입니다. 모든 함수에는 고유 한 범위가 있으며 JS의 모든 것이 객체이므로 &quot;this&quot;를 사용하여 함수에 값을 저장할 수도 있습니다. OOP 101은 &quot;this&quot;는 객체의 &lt;em&gt;인스턴스&lt;/em&gt; 에만 적용 할 수 있다고 가르칩니다. 따라서 함수가 실행될 때마다 해당 함수의 새로운 &quot;인스턴스&quot;는 &quot;this&quot;라는 새로운 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b087ac216caabb7017868b37aca9a9d6e2dc3acd" translate="yes" xml:space="preserve">
          <source>&quot;this&quot; keyword is always dependant on the context of invocation. They are mentioned below.</source>
          <target state="translated">&quot;this&quot;키워드는 항상 호출 컨텍스트에 따라 다릅니다. 아래에 언급되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3a3f86fe5a29d3e243308285b4b562e5ee68cee" translate="yes" xml:space="preserve">
          <source>&amp;hellip;by a direct call to &lt;code&gt;eval()&lt;/code&gt;
ThisBinding is left unchanged; it is the same value as the ThisBinding of the calling execution context (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;&amp;sect;10.4.2&lt;/a&gt; (2)(a)).</source>
          <target state="translated">&amp;hellip; &lt;code&gt;eval()&lt;/code&gt; 을 직접 호출하여이 바인딩은 변경되지 않습니다. 호출 실행 컨텍스트의 ThisBinding과 동일한 값입니다 ( &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;&amp;sect;10.4.2&lt;/a&gt; (2) (a)).</target>
        </trans-unit>
        <trans-unit id="9cc3cef106ffb16fe471cb3389ab7a4426b808f0" translate="yes" xml:space="preserve">
          <source>&amp;hellip;if not by a direct call to &lt;code&gt;eval()&lt;/code&gt;</source>
          <target state="translated">&amp;hellip; &lt;code&gt;eval()&lt;/code&gt; 을 직접 호출하지 않으면</target>
        </trans-unit>
        <trans-unit id="51102ac175310aed1bea1f10200498ad1af008e5" translate="yes" xml:space="preserve">
          <source>&amp;sect;15.1.2.1.1 defines what a direct call to &lt;code&gt;eval()&lt;/code&gt; is. Basically, &lt;code&gt;eval(...)&lt;/code&gt; is a direct call whereas something like &lt;code&gt;(0, eval)(...)&lt;/code&gt; or &lt;code&gt;var indirectEval = eval; indirectEval(...);&lt;/code&gt; is an indirect call to &lt;code&gt;eval()&lt;/code&gt;. See &lt;a href=&quot;https://stackoverflow.com/a/9107491/196844&quot;&gt;chuckj's answer&lt;/a&gt; to &lt;a href=&quot;https://stackoverflow.com/q/9107240/196844&quot;&gt;(1, eval)('this') vs eval('this') in JavaScript?&lt;/a&gt; and &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/#indirect-eval-call&quot;&gt;Dmitry Soshnikov&amp;rsquo;s ECMA-262-5 in detail. Chapter 2. Strict Mode.&lt;/a&gt; for when you might use an indirect &lt;code&gt;eval()&lt;/code&gt; call.</source>
          <target state="translated">&amp;sect;15.1.2.1.1은 &lt;code&gt;eval()&lt;/code&gt; 대한 직접 호출이 무엇인지 정의합니다. 기본적으로 &lt;code&gt;eval(...)&lt;/code&gt; 은 직접 호출이지만 &lt;code&gt;(0, eval)(...)&lt;/code&gt; 또는 &lt;code&gt;var indirectEval = eval; indirectEval(...);&lt;/code&gt; indirectEval (...); &lt;code&gt;eval()&lt;/code&gt; 대한 간접 호출입니다. &lt;a href=&quot;https://stackoverflow.com/a/9107491/196844&quot;&gt;JavaScript에서&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/q/9107240/196844&quot;&gt;(1, eval) ( 'this') vs eval ( 'this')에&lt;/a&gt; 대한 chuckj의 답변 을 참조하십시오 . 및 &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/#indirect-eval-call&quot;&gt;Dmitry Soshnikov의 ECMA-262-5에 대해 자세히 설명합니다.&lt;/a&gt; 2 장. 엄격한 모드. 간접 &lt;code&gt;eval()&lt;/code&gt; 호출을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d811f7b2b609ced44226e1cc0f2cc624eac9c4ae" translate="yes" xml:space="preserve">
          <source>1. Initial global execution context</source>
          <target state="translated">1. 초기 글로벌 실행 컨텍스트</target>
        </trans-unit>
        <trans-unit id="a1fa3b35a9272755e31354f7d5e59caf11fa3cf1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://bjorn.tipling.com/all-this&quot;&gt;Here&lt;/a&gt; is one good source of &lt;code&gt;this&lt;/code&gt; in &lt;code&gt;JavaScript&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://bjorn.tipling.com/all-this&quot;&gt;다음&lt;/a&gt; 은 &lt;code&gt;JavaScript&lt;/code&gt; 에서 좋은 소스 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="b49c71fe77018d6aeff02cd966c9eb2f2def9fd9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;Arrow functions&lt;/a&gt; (introduced in ECMA6) alter the scope of &lt;code&gt;this&lt;/code&gt;. See the existing canonical question, &lt;a href=&quot;https://stackoverflow.com/questions/34361379/arrow-function-vs-function-declaration-expressions-are-they-equivalent-exch&quot;&gt;Arrow function vs function declaration / expressions: Are they equivalent / exchangeable?&lt;/a&gt; for more information. But in short:</source>
          <target state="translated">ECMA6에 도입 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;화살표 기능&lt;/a&gt; 은 &lt;code&gt;this&lt;/code&gt; 의 범위를 변경합니다. 기존의 표준 질문 인 &lt;a href=&quot;https://stackoverflow.com/questions/34361379/arrow-function-vs-function-declaration-expressions-are-they-equivalent-exch&quot;&gt;화살표 함수 대 함수 선언 / 표현을&lt;/a&gt; 참조하십시오 . 자세한 내용은. 그러나 간단히 말해서 :</target>
        </trans-unit>
        <trans-unit id="7f751a15d113e0f9a8416dec1351c576d0282769" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-11.1.1&quot;&gt;&amp;sect;11.1.1&lt;/a&gt; The &lt;code&gt;this&lt;/code&gt; keyword</source>
          <target state="translated">&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-11.1.1&quot;&gt;&amp;sect;11.1.1&lt;/a&gt; &lt;code&gt;this&lt;/code&gt; 키워드</target>
        </trans-unit>
        <trans-unit id="424e6d7255bde2010b643c058d5b8f1d62241294" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;apply&lt;/code&gt; is almost the same as &lt;code&gt;call&lt;/code&gt; accept that it takes only two parameters: &lt;code&gt;thisArg&lt;/code&gt; and an array which contains the arguments to be passed to the function. So the above &lt;code&gt;call&lt;/code&gt; call can be translated to &lt;code&gt;apply&lt;/code&gt; like this:</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 는 &lt;code&gt;call&lt;/code&gt; accept와 거의 동일합니다. &lt;code&gt;thisArg&lt;/code&gt; 와 함수에 전달할 인수가 포함 된 배열. 따라서 위의 &lt;code&gt;call&lt;/code&gt; 는 다음과 같이 &lt;code&gt;apply&lt;/code&gt; 되도록 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="382d7e3908485b3ab834fd0e20e7a2a1529aef8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bind&lt;/code&gt; is a brother of &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;.  It is also a method inherited by all functions from the global &lt;code&gt;Function&lt;/code&gt; constructor in Javascript. The difference between &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;call&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; is that both &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; will actually invoke the function. &lt;code&gt;bind&lt;/code&gt;, on the other hand, returns a new function with the &lt;code&gt;thisArg&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt; pre-set. Let's take an example to better understand this:</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; 는 &lt;code&gt;call&lt;/code&gt; 의 형제이며 &lt;code&gt;apply&lt;/code&gt; 합니다. 또한 Javascript의 전역 &lt;code&gt;Function&lt;/code&gt; 생성자에서 모든 함수로 상속되는 메소드입니다. &lt;code&gt;bind&lt;/code&gt; 와 &lt;code&gt;call&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; 의 차이점은 &lt;code&gt;call&lt;/code&gt; 과 &lt;code&gt;apply&lt;/code&gt; 모두 실제로 함수를 호출한다는 것입니다. 반면, &lt;code&gt;bind&lt;/code&gt; 는 &lt;code&gt;thisArg&lt;/code&gt; 및 &lt;code&gt;arguments&lt;/code&gt; 사전 설정된 새 함수를 반환합니다. 이것을 더 잘 이해하기 위해 예를 들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="d372c94fc4d01f36f32e9424821af8fae90a6d1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;obj.foo()&lt;/code&gt; translates to &lt;code&gt;const temp = obj.foo; temp.call(obj);&lt;/code&gt; which means the arrow operator inside &lt;code&gt;foo&lt;/code&gt; will bind &lt;code&gt;obj&lt;/code&gt; to a new invisible function and return that new invisible function which is assigned to &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;b()&lt;/code&gt; will work as it always has as &lt;code&gt;b.call(window)&lt;/code&gt; or &lt;code&gt;b.call(undefined)&lt;/code&gt; calling the new invisible function that &lt;code&gt;foo&lt;/code&gt; created. That invisible function ignores the &lt;code&gt;this&lt;/code&gt; passed into it and  passes &lt;code&gt;obj&lt;/code&gt; as objectForThis` to the arrow function.</source>
          <target state="translated">&lt;code&gt;obj.foo()&lt;/code&gt; 는 &lt;code&gt;const temp = obj.foo; temp.call(obj);&lt;/code&gt; 변환됩니다 . temp.call (obj); 즉, &lt;code&gt;foo&lt;/code&gt; 안의 화살표 연산자는 &lt;code&gt;obj&lt;/code&gt; 를 새로운 보이지 않는 함수에 바인딩하고 &lt;code&gt;b&lt;/code&gt; 에 할당 된 새로운 보이지 않는 함수를 반환합니다. &lt;code&gt;b()&lt;/code&gt; 는 항상 &lt;code&gt;foo&lt;/code&gt; 가 만든 새로운 보이지 않는 함수를 호출하는 &lt;code&gt;b.call(window)&lt;/code&gt; 또는 &lt;code&gt;b.call(undefined)&lt;/code&gt; 같이 작동합니다. 보이지 않는 함수는 전달 된 &lt;code&gt;this&lt;/code&gt; 를 무시하고 &lt;code&gt;obj&lt;/code&gt; 를 objectForThis`로 화살표 함수에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="cc4f263a38b1f6aedd93045cde762a01d7dc5a49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;obj&lt;/code&gt; &amp;mdash; When calling a function on an object, ThisBinding is set to the object.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; &amp;mdash; 객체에서 함수를 호출 할 때 ThisBinding이 객체로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="107d6e7f7fb924b5dc3445b4c08dd5f9aaa0aaa7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; can be used to refer to the object being created</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 생성되는 객체를 참조하는데 사용될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c811f8b7269bca9f651630faab87a3c3f3e35ac4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; helps to get the current object (a.k.a. execution context) we work with. If you understand in which object the current function is getting executed, you can understand easily what current &lt;code&gt;this&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 우리가 작업하는 현재 객체 (일명 실행 컨텍스트)를 얻는 데 도움 이 됩니다. 현재 함수가 어떤 객체에서 실행되는지 이해하면 현재의 기능을 쉽게 이해할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b4aeb36a0b116d9deb56aa0b8774cb04edd881be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; in JavaScript always refers to the 'owner' of the function that is &lt;strong&gt;being executed&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; JavaScript에서 항상 &lt;strong&gt;실행중인&lt;/strong&gt; 함수의 '소유자'를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7c3f84f931c948a2cb7f1e59f0d6dfa830ab07b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; is one of the misunderstood concept in JavaScript because it behaves little differently from place to place. Simply, &lt;code&gt;this&lt;/code&gt; refers to the &lt;strong&gt;&quot;owner&quot; of the function we are currently executing&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; JavaScript에서 오해의 여지가있는 개념 중 하나입니다. 간단히 말해서 &lt;strong&gt;현재 실행중인 함수&lt;/strong&gt; 의 &lt;strong&gt;&quot;소유자&quot;를&lt;/strong&gt; 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="13e02a751d5916a050a8b3dc4252bc2caca654cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; would refer to the element object. But be careful, a lot of people make this mistake.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 요소 객체를 참조합니다. 그러나 많은 사람들이이 실수를 저지르는 것을 조심하십시오.</target>
        </trans-unit>
        <trans-unit id="f5240944b8f27af27e4b000a78873eeedbe95583" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;&lt;strong&gt;is not assigned a value&lt;/strong&gt; until an object invokes the function where it is defined. In the global scope, all global variables and functions are defined on the &lt;code&gt;window&lt;/code&gt; object. Therefore, &lt;code&gt;this&lt;/code&gt; in a global function refers to (and has the value of) the global &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">객체가 정의 된 함수를 호출 할 때까지 &lt;strong&gt;값&lt;/strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;strong&gt;할당되지 않습니다&lt;/strong&gt; . 전역 범위에서 모든 전역 변수와 함수는 &lt;code&gt;window&lt;/code&gt; 개체에 정의됩니다. 따라서 전역 함수에서 &lt;code&gt;this&lt;/code&gt; 전역 &lt;code&gt;window&lt;/code&gt; 개체를 참조하고 그 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2017743fc4e80e00beebfb42e3038d8fb7f5b026" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window&lt;/code&gt; &amp;mdash; The marked line is evaluated in the initial global execution context.</source>
          <target state="translated">&lt;code&gt;window&lt;/code&gt; &amp;mdash; 표시된 행은 초기 전역 실행 컨텍스트에서 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="f4be438a760254b14a91ab09c03d45c80ef71f1b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Few places where &lt;code&gt;this&lt;/code&gt; can be differentiated&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;차별화 할 수있는 곳은 거의 없습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09380dc0b6ee6bdf73de503a58ea18d71700e94d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I recommend to better try this in &lt;a href=&quot;http://jsfiddle.net/Mahesha999/xKtzC/8/embedded/html,js,result&quot;&gt;JSFiddle&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://jsfiddle.net/Mahesha999/xKtzC/8/embedded/html,js,result&quot;&gt;JSFiddle&lt;/a&gt; 에서 더 잘 시도하는 것이 좋습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="89af8ce5b9c6ddaddba039f802cac788a61fd49a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Since this thread has bumped up, I have compiled few points for readers new to &lt;code&gt;this&lt;/code&gt; topic.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 글타래가 부딪 쳤으므로이 주제를 처음 접하는 독자들을 위해 몇 가지 요점을 정리했습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf09c380c346a11478b95850016d50cc8b3825f2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;To reveal the answers, mouse over the light yellow boxes.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;답을 나타내려면 밝은 노란색 상자 위로 마우스를 이동하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ff1f9889e4b9c65093673c35d707361ce7a29d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. When used in global context&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. 글로벌 맥락에서 사용될 때&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1cb747759f0fbb0bff69036f9d6d60f4aa3fa28d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. When used inside object method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. 객체 메소드 내부에서 사용될 때&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a912f1682aefdda6a1d36527df19cad6af2400d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. When invoking context-less function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3. 문맥없는 기능을 호출 할 때&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc4963b484aa9c5ab6a24d462de6d79d10013299" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. When used inside constructor function&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;4. 생성자 함수 안에서 사용될 때&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1151d51ab92181c7cb05dad8e085d7369e1d980f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5. When used inside function defined on prototype chain&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5. 프로토 타입 체인에 정의 된 함수 내부에서 사용될 때&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1836a9a4449c1ab65274d2b92c93146cbd04cfc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;6. Inside call(), apply() and bind() functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;6. 내부 call (), apply () 및 bind () 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5eb140bea3b13dba943d1a806bc843988b98056" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;7. &lt;code&gt;this&lt;/code&gt; inside event handlers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;7. 이벤트 핸들러 내부&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9d21ab1911b874d328796c84c4b427f924e6226" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;8. &lt;code&gt;this&lt;/code&gt; in ES6 arrow function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;8. ES6 화살표 기능에서&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="718494e8c6739afd0ac4b8944ca72f98a1b42d96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;fun.apply(obj1 [, argsArray])&lt;/code&gt;&lt;/strong&gt; Sets &lt;code&gt;obj1&lt;/code&gt; as the value of &lt;code&gt;this&lt;/code&gt; inside &lt;code&gt;fun()&lt;/code&gt; and calls &lt;code&gt;fun()&lt;/code&gt; passing elements of &lt;code&gt;argsArray&lt;/code&gt; as its arguments.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;fun.apply(obj1 [, argsArray])&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;obj1&lt;/code&gt; 을 &lt;code&gt;fun()&lt;/code&gt; 내부의 값으로 설정하고 &lt;code&gt;argsArray&lt;/code&gt; 의 요소를 인수로 전달하여 fun () 을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="9efe54b50d151a789da3c3d7e3f5f9c6142683ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;fun.bind(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])&lt;/code&gt;&lt;/strong&gt; - Returns the reference to the function &lt;code&gt;fun&lt;/code&gt; with &lt;code&gt;this&lt;/code&gt; inside fun bound to &lt;code&gt;obj1&lt;/code&gt; and parameters of &lt;code&gt;fun&lt;/code&gt; bound to the   parameters specified &lt;code&gt;arg1, arg2, arg3,...&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;fun.bind(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])&lt;/code&gt; &lt;/strong&gt; - &lt;code&gt;obj1&lt;/code&gt; 에 바인딩 된 fun 내부와 &lt;code&gt;fun&lt;/code&gt; a 매개 변수에 지정된 fun 매개 변수를 사용하여 fun 함수에 대한 참조를 반환합니다 &lt;code&gt;arg1, arg2, arg3,...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2fa93f1be283db9398b00d14dcb4562d31a96a58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;fun.call(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])&lt;/code&gt;&lt;/strong&gt; - Sets &lt;code&gt;obj1&lt;/code&gt; as the value of &lt;code&gt;this&lt;/code&gt; inside &lt;code&gt;fun()&lt;/code&gt; and calls &lt;code&gt;fun()&lt;/code&gt; passing &lt;code&gt;arg1, arg2, arg3, ...&lt;/code&gt; as its arguments.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;fun.call(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])&lt;/code&gt; &lt;/strong&gt; - &lt;code&gt;obj1&lt;/code&gt; 을 &lt;code&gt;fun()&lt;/code&gt; 내부의 값으로 설정하고 &lt;code&gt;arg1, arg2, arg3, ...&lt;/code&gt; 그 주장으로.</target>
        </trans-unit>
        <trans-unit id="418f0b4779a9d1418d184d2b02d0207c370e9e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;References:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;References:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="78d38ee0591e57aa045e4c0f056e77a623a22b30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM event this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DOM 이벤트는이&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0611618ab4bef86d4217dc74878abb5876ef1d1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Everything else is syntactic sugar for &lt;code&gt;functionObject.call&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다른 모든 것은 &lt;code&gt;functionObject.call&lt;/code&gt; 의 구문 설탕입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="085e18e665d8e1d81d0ca5c6a9023f7d3da54da0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FUNCTION IS CALLED EXPLICITLY USING CALL AND APPLY METHODS.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;통화 및 적용 방법을 사용하여 기능이 명시 적으로 호출됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d75456f909e4fd7563b46975c382623f3dc3c8e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FUNCTION IS CALLED WITH NEW KEYWORD&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;새로운 키워드로 기능 호출&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1325e530872f52dae1b1e7bc729151d7fd17b95d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For event handlers:&lt;/strong&gt; inline event handlers, such as &lt;code&gt;&amp;lt;element onclick=&quot;foo&quot;&amp;gt;&lt;/code&gt;, override any other handlers attached earlier and before, so be careful and it's better to stay off of inline event delegation at all.
And thanks to Zara Alaverdyan who inspired me to this list of examples through a dissenting debate :)</source>
          <target state="translated">&lt;strong&gt;이벤트 핸들러 :&lt;/strong&gt; &lt;code&gt;&amp;lt;element onclick=&quot;foo&quot;&amp;gt;&lt;/code&gt; 와 같은 인라인 이벤트 핸들러는 이전 및 이전에 연결된 다른 핸들러를 대체하므로 인라인 이벤트 위임에서 벗어나는 것이 좋습니다. 그리고 반대 토론을 통해이 예제 목록에 영감을 준 Zara Alaverdyan 덕분에 :)</target>
        </trans-unit>
        <trans-unit id="894baeb26ee211c848adbf141fef8ea332f2d512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global Context&lt;/strong&gt; (i.e. Outside all functions):</source>
          <target state="translated">&lt;strong&gt;글로벌 컨텍스트&lt;/strong&gt; (즉, 모든 기능 외부) :</target>
        </trans-unit>
        <trans-unit id="168e0b60ab24edf5659b7603a5e6761ba4b78bc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global&lt;/strong&gt; (i.e. Outside all functions)</source>
          <target state="translated">&lt;strong&gt;글로벌&lt;/strong&gt; (즉, 모든 기능 외부)</target>
        </trans-unit>
        <trans-unit id="a9b296c5fddc1bb4ff71359ff1b16bcabd27c0ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HTML this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTML이&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="917118becd0e6d67a05db3eed2df871405cda7a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IF FUNCTION IS CALLED WITH OBJECT IMPLICITLY THEN THIS WILL BE BOUND TO THAT OBJECT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기능이 부정확하게 개체에 호출 된 경우 해당 개체에 적용됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ba8db8e3f1fc0f64367058719c6e34521b6988c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IN STRICT MODE THIS WILL BE UNDEFINED&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;엄격한 모드에서는이 정의되지 않습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d0ea3429b59410b8f4d00a4cc84074280bda9ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside &quot;Bound Function&quot; Call&lt;/strong&gt; (i.e. a function that &lt;strong&gt;has been bound&lt;/strong&gt; by calling &lt;strong&gt;&lt;em&gt;functionName.bind&lt;/em&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;&quot;바운드 함수&quot;호출 내부&lt;/strong&gt; (즉, functionName.bind를 호출하여 &lt;strong&gt;바인딩&lt;/strong&gt; 된 &lt;strong&gt;&lt;em&gt;함수&lt;/em&gt;&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="173ec8ce03dcc96425b564f955f3e8db1cca03ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside &quot;Bound Function&quot; Call&lt;/strong&gt; (i.e. a function that has been bound by calling &lt;strong&gt;&lt;em&gt;functionName.bind&lt;/em&gt;&lt;/strong&gt;):</source>
          <target state="translated">&lt;strong&gt;&quot;바운드 함수&quot;호출 내부&lt;/strong&gt; (즉, functionName.bind를 호출하여 바인딩 된 &lt;strong&gt;&lt;em&gt;함수&lt;/em&gt;&lt;/strong&gt; ) :</target>
        </trans-unit>
        <trans-unit id="3e875249daa0473a8fdf23ad502cdf3367b1cde8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Direct &quot;Non Bound Function&quot; Call&lt;/strong&gt; (i.e. a function that has &lt;strong&gt;not been&lt;/strong&gt; bound by calling &lt;strong&gt;&lt;em&gt;functionName.bind&lt;/em&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;직접 &quot;바인드되지 않은 함수&quot;호출 내부&lt;/strong&gt; (즉, functionName.bind를 호출하여 바인드 &lt;strong&gt;되지 않은&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;함수&lt;/em&gt;&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="8c57485accd3f8de730dc301d4b4402bc9d5ff6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Direct &quot;Non Bound Function&quot; Call&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;직접 &quot;비 바운드 기능&quot;호출 내부&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="20b6606bfe8a1a339672457b5987c0bbe9801b32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Indirect &quot;Non Bound Function&quot; Call&lt;/strong&gt; through &lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;functionName.apply&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;내부 간접 &quot;비 바운드 함수&quot;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; 및 &lt;strong&gt;&lt;em&gt;functionName.apply를&lt;/em&gt;&lt;/strong&gt; 통한 &lt;strong&gt;호출&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f6bbd439250c2f70bd753a9c1867ff4ae0334cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Indirect &quot;Non Bound Function&quot; Call&lt;/strong&gt; through &lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;functionName.apply&lt;/em&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;내부 간접 &quot;비 바운드 함수&quot;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; 및 &lt;strong&gt;&lt;em&gt;functionName.apply를&lt;/em&gt;&lt;/strong&gt; 통해 &lt;strong&gt;호출&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;합니다&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b687e55bef18e96403dcec84a064997fff961ba4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Inline DOM event handler&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;인라인 DOM 이벤트 핸들러 내부&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b733413aa17352a3e9b6ca5623c81d22f47452b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Inline DOM event handler&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;인라인 DOM 이벤트 핸들러 내부&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="266e0d16f0275a7b45db6e40b0e84253044c47e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Trying it all with functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기능으로 모든 것을 시도&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b798c488f44ac56ef97819e55be72d13bc6ae204" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WHEN FUNCTION IS CALLED WITHOUT ANY CONTEXT THEN THIS WILL BE BOUND TO GLOBAL OBJECT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;컨텍스트없이 함수를 호출하면 글로벌 오브젝트에 바인드됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ff4d1e2e595c31a6b0764e1ad94e2fa48fffb37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;While Object Creation through &quot;new&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&quot;신규&quot;를 통한 객체 생성&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8198d31ce2fb4af76a276cd2353f3b893b2b3c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;While Object Creation through &quot;new&quot;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&quot;신규&quot;를 통한 객체 생성&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="bd0054da704663fa349cd05f6dec86874b0a5b98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;eval this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이것을 평가&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b6e7cb5e761aba02987ecc24374a500c50b2f3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;function this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d575ef4572a4d0f70d88145f3266940c01dbe092" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;global this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 글로벌&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf73e6df87566417c40b38e407048179eb72abf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery에&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="267215baf52fd6931b04140eff3d560dfdf04823" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;object this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이의를 제기하다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6993e186af398b71572f7532218e7b60a53b53e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;prototype this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;프로토 타입&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f609ef0b01e29c7688ac86f84c3b2fd9542bc770" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;this &amp;amp; Object Prototypes&lt;/strong&gt;, by Kyle Simpson. &amp;copy; 2014 Getify Solutions.</source>
          <target state="translated">Kyle &lt;strong&gt;&amp;amp;&lt;/strong&gt; Simpson의 &lt;strong&gt;this &amp;amp; Object Prototypes&lt;/strong&gt; &amp;copy; 2014 Getify 솔루션.</target>
        </trans-unit>
        <trans-unit id="d68567ba0092c29c333f4067dcc1219804e03507" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;with this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이것으로&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bb486259298102ba39377e4ed03a0fb81bf8790" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;&lt;code&gt;apply&lt;/code&gt; is another function similar to &lt;code&gt;call&lt;/code&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; &lt;code&gt;apply&lt;/code&gt; 는 &lt;code&gt;call&lt;/code&gt; 과 비슷한 다른 함수입니다.</target>
        </trans-unit>
        <trans-unit id="521d8887a5ef2e61310029a52ca75b452424b493" translate="yes" xml:space="preserve">
          <source>A bound function is a function whose &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; value has been
fixed. The following code demonstrated how &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; works in case
of bound function</source>
          <target state="translated">바운드 함수는 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 값이 수정 된 함수입니다. 다음 코드는 바운드 함수의 경우 &lt;strong&gt;&quot;this&quot;의&lt;/strong&gt; 작동 방식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ef2db31f656b33473e747f5be7b06a3421bd96e7" translate="yes" xml:space="preserve">
          <source>A little bit info about &lt;strong&gt;this&lt;/strong&gt; keyword</source>
          <target state="translated">&lt;strong&gt;이&lt;/strong&gt; 키워드에 대한 약간의 정보</target>
        </trans-unit>
        <trans-unit id="bba748cf8bf63af49cb69595a0f4e85a54d40178" translate="yes" xml:space="preserve">
          <source>Above &lt;code&gt;f1&lt;/code&gt; is made a method of global object. Thus we can also call it on &lt;code&gt;window&lt;/code&gt; object as follows:</source>
          <target state="translated">위의 &lt;code&gt;f1&lt;/code&gt; 은 전역 객체의 방법입니다. 따라서 다음과 같이 &lt;code&gt;window&lt;/code&gt; 객체에서 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b753f43e6cc93cab6d731a784a044886d520b74f" translate="yes" xml:space="preserve">
          <source>Above I have put the word immediate in double quotes. It is to make the point that if you nest the object inside another object, then &lt;code&gt;this&lt;/code&gt; is bound to the immediate parent.</source>
          <target state="translated">위의 단어를 즉시 큰 따옴표로 묶었습니다. 객체를 다른 객체 안에 중첩하면 &lt;code&gt;this&lt;/code&gt; 바로 상위에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="d0e03fe81743bbdb1803208b752058307d77c7c9" translate="yes" xml:space="preserve">
          <source>Above we added members to objects using object literal notation. We can add members to functions by using &lt;code&gt;this&lt;/code&gt;. to specify them.</source>
          <target state="translated">위에서 객체 리터럴 표기법을 사용하여 객체에 멤버를 추가했습니다. &lt;code&gt;this&lt;/code&gt; 를 사용하여 함수에 멤버를 추가 할 수 있습니다. 그들을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="378cd99eed8979a93e73069d633b7546f12e1467" translate="yes" xml:space="preserve">
          <source>Above we create 3 variables with same name 'val'. One in global context, one inside obj and the other inside innerMethod of obj. JavaScript resolves identifiers within a particular context by going up the scope chain from local go global.</source>
          <target state="translated">위의 이름은 'val'인 3 개의 변수를 만듭니다. 하나는 전역 컨텍스트에서 하나는 obj 내부이고 다른 하나는 obj의 innerMethod 내부입니다. JavaScript는 로컬 Go Global에서 범위 체인으로 올라가 특정 컨텍스트 내에서 식별자를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="4fbc9235f1c80f74cce8e944e82472b1cf3e26c7" translate="yes" xml:space="preserve">
          <source>Again these all are just syntactic sugar for</source>
          <target state="translated">다시 이것들은 모두 단지 구문 설탕입니다</target>
        </trans-unit>
        <trans-unit id="44f5606c7c264327eaf36478d243b0e4ee2e66c7" translate="yes" xml:space="preserve">
          <source>All functions inherit from the global &lt;code&gt;Function&lt;/code&gt;, and two of its many methods are &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;, and both can be used to manipulate the value of &lt;code&gt;this&lt;/code&gt; in the function on which they are called.</source>
          <target state="translated">모든 함수는 전역 &lt;code&gt;Function&lt;/code&gt; 에서 상속되며, 많은 메소드 중 두 가지가 &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; 이며, 둘 다 호출 되는 함수 &lt;code&gt;this&lt;/code&gt; 값을 조작하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65bb256adbc34f0e662f2e6886cf45e5da2fe2e0" translate="yes" xml:space="preserve">
          <source>All these methods are defined on &lt;code&gt;Function.prototype&lt;/code&gt;.</source>
          <target state="translated">이러한 모든 메소드는 &lt;code&gt;Function.prototype&lt;/code&gt; 에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f3251d2eefcb2ea293e403dfdf0b701c95967f7" translate="yes" xml:space="preserve">
          <source>Also in an object literal approach, we can explicitly add members to already defined object using dot operator. This gets added to the specific instance only. However I have added variable to the function prototype so that it gets reflected in all instances of the function.</source>
          <target state="translated">또한 객체 리터럴 방식에서는 점 연산자를 사용하여 이미 정의 된 객체에 멤버를 명시 적으로 추가 할 수 있습니다. 이것은 특정 인스턴스에만 추가됩니다. 그러나 함수 프로토 타입에 변수를 추가하여 함수의 모든 인스턴스에 반영되도록했습니다.</target>
        </trans-unit>
        <trans-unit id="42a17cccb4a20658564c0ef8e45cbac226648a85" translate="yes" xml:space="preserve">
          <source>Also note that neither of these three functions do any change to the original function. &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; would return the value from freshly constructed functions while &lt;code&gt;bind&lt;/code&gt; will return the freshly constructed function itself, ready to be called.</source>
          <target state="translated">또한이 세 기능 중 어느 것도 원래 기능을 변경하지 않습니다. &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; 는 새로 작성된 함수에서 값을 리턴하는 반면 &lt;code&gt;bind&lt;/code&gt; 는 새로 작성된 함수 자체를 리턴하여 호출 할 준비를합니다.</target>
        </trans-unit>
        <trans-unit id="96bacdecd2f20c6e4133c59029163b3a5024cc7a" translate="yes" xml:space="preserve">
          <source>Angus Croll - &lt;a href=&quot;http://goo.gl/Z2RacU&quot;&gt;http://goo.gl/Z2RacU&lt;/a&gt;</source>
          <target state="translated">앵거스 크롤-http://goo.gl/Z2RacU</target>
        </trans-unit>
        <trans-unit id="fc6d0b4a3431a2895e9d69a29dd7c9026e676f98" translate="yes" xml:space="preserve">
          <source>Arrow functions</source>
          <target state="translated">화살표 기능</target>
        </trans-unit>
        <trans-unit id="0c6f0eb1c1ab36699d24af9b8c41dcdfa8f179e2" translate="yes" xml:space="preserve">
          <source>Arrow functions don't have their own &lt;code&gt;this&lt;/code&gt;.... binding.
  Instead, those identifiers are resolved in the lexical scope like any
  other variable. That means that inside an arrow function, &lt;code&gt;this&lt;/code&gt;...refer(s) to the values of &lt;code&gt;this&lt;/code&gt; in the environment
  the arrow function is defined in.</source>
          <target state="translated">화살표 함수에는이 고유 한 바인딩 &lt;code&gt;this&lt;/code&gt; 없습니다. 대신, 이러한 식별자는 다른 변수와 같이 어휘 범위에서 분석됩니다. 이것은 화살표 함수 안에서 화살표 함수가 정의 된 환경에서 &lt;code&gt;this&lt;/code&gt; 의 값을 의미한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b50c4e79c0e3f7852862c14187e6ddd0825a3bd5" translate="yes" xml:space="preserve">
          <source>Arrow functions, the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator are syntactic sugar for bind</source>
          <target state="translated">화살표 함수, &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자는 바인드의 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="203d51646bb4fd08eace6d614d8c939e2e57a916" translate="yes" xml:space="preserve">
          <source>As given in the code above, &lt;strong&gt;&quot;this&quot; value for any &quot;Bound Function&quot;
CANNOT be altered through call/apply&lt;/strong&gt;. Also, if the &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;
parameter is  not explicitly passed to bind, &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt;
(and hence the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; ) is set to &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; in Non
strict mode and &lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; in strict mode.  One more thing.
Binding an already bound function does not change the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;.
It remains set as the value set by first bind function.</source>
          <target state="translated">위 코드에서 주어진 것처럼, &lt;strong&gt;&quot;바운드 함수&quot;에 대한 &quot;this&quot;값은 call / apply를 통해 변경할 수 없습니다&lt;/strong&gt; . 또한 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 매개 변수가 바인드하도록 명시 적으로 전달되지 않으면 &lt;strong&gt;&quot;현재 오브젝트&quot;&lt;/strong&gt; (따라서 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 값)는 엄격하지 않은 모드에서 &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; 로 설정되고 엄격 모드에서는 &lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; 로 설정됩니다. 하나 더. 이미 바인딩 된 함수를 바인딩해도 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 값은 변경되지 않습니다. 첫 번째 바인드 기능에 의해 설정된 값으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d5edefb33540455ad04404ac360e751fa53a32fc" translate="yes" xml:space="preserve">
          <source>Below I tried out all the things that we did with Object and &lt;code&gt;this&lt;/code&gt; above, but by first creating function instead of directly writing an object.</source>
          <target state="translated">아래에서 나는 Object와 &lt;code&gt;this&lt;/code&gt; 했던 모든 것을 시도했지만, 직접 객체를 작성하는 대신 함수를 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="1304a85574c9a47bfc387cb1181284252d8be183" translate="yes" xml:space="preserve">
          <source>Binding and already bound function does not change the value of &quot;this&quot;. It remains set as the value set by first bind function.</source>
          <target state="translated">바인딩 및 이미 바인딩 된 함수는 &quot;this&quot;의 값을 변경하지 않습니다. 첫 번째 바인드 기능에 의해 설정된 값으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="21140ee58286bc8b79afc046971cefc9d15813d9" translate="yes" xml:space="preserve">
          <source>But as of ES6 conceptually you can even translate that into</source>
          <target state="translated">그러나 ES6부터 개념적으로는</target>
        </trans-unit>
        <trans-unit id="65a473e0027f5ed69ce186b407bc8fdb48bdca1e" translate="yes" xml:space="preserve">
          <source>By default, and what confuses most beginners, when a listener is called after an event is raised on a DOM element, the &lt;em&gt;this&lt;/em&gt; value of the function is the DOM element.</source>
          <target state="translated">기본적으로 대부분의 초보자를 혼란스럽게 만드는 요소는 DOM 요소에서 이벤트가 발생한 후 리스너가 호출 될 때 함수 &lt;em&gt;의이&lt;/em&gt; 값은 DOM 요소입니다.</target>
        </trans-unit>
        <trans-unit id="d6d441b4209195e14353f9a1f6054d514dd9abbd" translate="yes" xml:space="preserve">
          <source>By now the difference between &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;bind&lt;/code&gt; must have become apparent. &lt;code&gt;apply&lt;/code&gt; allows to specify the arguments to function as array-like object i.e. an object with a numeric &lt;code&gt;length&lt;/code&gt; property and corresponding non-negative integer properties. Whereas &lt;code&gt;call&lt;/code&gt; allows to specify the arguments to the function directly. Both &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;call&lt;/code&gt; immediately invokes the function in the specified context and with the specified arguments. On the other hand, &lt;code&gt;bind&lt;/code&gt; simply returns the function bound to the specified &lt;code&gt;this&lt;/code&gt; value and the arguments. We can capture the reference to this returned function by assigning it to a variable and later we can call it any time.</source>
          <target state="translated">이제 &lt;code&gt;apply&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; 및 &lt;code&gt;bind&lt;/code&gt; 의 차이점이 분명해졌습니다. &lt;code&gt;apply&lt;/code&gt; 를 사용하면 인수가 배열과 같은 객체, 즉 숫자 &lt;code&gt;length&lt;/code&gt; 속성과 해당하는 음이 아닌 정수 속성을 가진 객체로 작동하도록 지정할 수 있습니다. 반면에 &lt;code&gt;call&lt;/code&gt; 은 함수에 대한 인수를 직접 지정할 수 있습니다. &lt;code&gt;apply&lt;/code&gt; 및 &lt;code&gt;call&lt;/code&gt; 모두 지정된 컨텍스트에서 지정된 인수로 함수를 즉시 호출합니다. 반면에 &lt;code&gt;bind&lt;/code&gt; 는 단순히 지정된 &lt;code&gt;this&lt;/code&gt; 값과 인수에 바인딩 된 함수를 반환합니다. 이 반환 된 함수에 대한 참조를 변수에 지정하여 나중에 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4ff7db3d2943e81347a74ac6f68ad3f64995792" translate="yes" xml:space="preserve">
          <source>Calling a function on an object</source>
          <target state="translated">객체에서 함수 호출</target>
        </trans-unit>
        <trans-unit id="8967949e0052bf4fec471f1e862bcdb2f857d888" translate="yes" xml:space="preserve">
          <source>Calling a method of a object</source>
          <target state="translated">객체의 메소드 호출</target>
        </trans-unit>
        <trans-unit id="2a0f01b7dbab312f469277a939897da668bb1530" translate="yes" xml:space="preserve">
          <source>Calling functions on Functions: &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;</source>
          <target state="translated">함수에서 함수 &lt;code&gt;call&lt;/code&gt; : 호출 및 &lt;code&gt;apply&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a2d9c2f761f313e12a3f59af3ad126c32d5b68b" translate="yes" xml:space="preserve">
          <source>Calling the function with the &lt;code&gt;new&lt;/code&gt; keyword would immediately initialize an &lt;code&gt;Object&lt;/code&gt; of type &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 키워드로 함수를 호출하면 &lt;code&gt;Person&lt;/code&gt; 유형의 &lt;code&gt;Object&lt;/code&gt; 가 즉시 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="8c59fcda4559bb7741c9e317275c16e64acbc60a" translate="yes" xml:space="preserve">
          <source>Consider a constructor function in Javascript:</source>
          <target state="translated">Javascript에서 생성자 함수를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="908dded501f1eb025abaae1e462f1b9398ed9b15" translate="yes" xml:space="preserve">
          <source>Consider the following function:</source>
          <target state="translated">다음 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="88d43b78335fb71e23d3a8324b00ba1dcbae38f4" translate="yes" xml:space="preserve">
          <source>Considering a more commonly practical scenario:</source>
          <target state="translated">보다 일반적으로 실용적인 시나리오를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e15054647d5d4825673bec78e395e8f11fd5d1bd" translate="yes" xml:space="preserve">
          <source>Copying &lt;code&gt;this&lt;/code&gt; to solve nested-scope issues.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 복사하여 중첩 범위 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="04b00eef3c0f84d63c5bf373bc4fbfa1f1f1f418" translate="yes" xml:space="preserve">
          <source>Daniel, awesome explanation! A couple of words on this and good list of &lt;code&gt;this&lt;/code&gt; execution context pointer in case of event handlers.</source>
          <target state="translated">대니얼, 대단한 설명! 이벤트 핸들러의 &lt;code&gt;this&lt;/code&gt; 실행 컨텍스트 포인터 의이 목록과 좋은 목록에 대한 몇 단어.</target>
        </trans-unit>
        <trans-unit id="df12cce3f2c22b0cfea79b58f42e474a2d9806ee" translate="yes" xml:space="preserve">
          <source>Defined in &lt;a href=&quot;https://leanpub.com/understandinges6/read&quot;&gt;ECMA Script 6&lt;/a&gt;, arrow-functions adopt the &lt;code&gt;this&lt;/code&gt; binding from the
enclosing (function or global) scope.</source>
          <target state="translated">&lt;a href=&quot;https://leanpub.com/understandinges6/read&quot;&gt;ECMA Script 6에&lt;/a&gt; 정의 된 화살표 기능은 둘러싸는 (기능 또는 전역) 범위 &lt;code&gt;this&lt;/code&gt; 바인딩을 채택합니다.</target>
        </trans-unit>
        <trans-unit id="128f370e01dcc41eacea0f41d2c828ef2ac1d087" translate="yes" xml:space="preserve">
          <source>Entering eval code</source>
          <target state="translated">평가 코드 입력</target>
        </trans-unit>
        <trans-unit id="2ee3bc84b3cdd8c94c92611d8db5e0176f368f84" translate="yes" xml:space="preserve">
          <source>Entering function code</source>
          <target state="translated">기능 코드 입력</target>
        </trans-unit>
        <trans-unit id="6d5f131f63e2b46f200e419e32d757a476bff5fb" translate="yes" xml:space="preserve">
          <source>Even if you add function explicitly to the object as a method, it still follows above rules, that is &lt;code&gt;this&lt;/code&gt; still points to the immediate parent object.</source>
          <target state="translated">메소드를 객체에 명시 적으로 함수를 추가하더라도 여전히 위의 규칙을 따릅니다. 즉, 이는 바로 상위 부모 객체를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="5bd2dbf0b8d00773801e52b8a0a2d5c918eeff2f" translate="yes" xml:space="preserve">
          <source>Every &lt;em&gt;execution context&lt;/em&gt; in javascript has a &lt;em&gt;this&lt;/em&gt; parameter that is set by:</source>
          <target state="translated">자바 스크립트의 모든 &lt;em&gt;실행 컨텍스트&lt;/em&gt; 에는 다음에 의해 설정된 &lt;em&gt;this&lt;/em&gt; 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="05376964e6969860e3233532567e5c90c576ce63" translate="yes" xml:space="preserve">
          <source>Example constructor:</source>
          <target state="translated">생성자 예제 :</target>
        </trans-unit>
        <trans-unit id="4e8e909da4d8e05122cc933de6fde902781e02f1" translate="yes" xml:space="preserve">
          <source>Example event listeners:</source>
          <target state="translated">이벤트 리스너 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="27a003083ab2583d3a2ad4eed814443aff4033fd" translate="yes" xml:space="preserve">
          <source>Except in the case of DOM event handlers or when a &lt;code&gt;thisArg&lt;/code&gt; is provided (see further down), both in node and in a browser using &lt;code&gt;this&lt;/code&gt; in a function that is not called with &lt;code&gt;new&lt;/code&gt; references the global scope&amp;hellip;</source>
          <target state="translated">DOM 이벤트 핸들러의 경우 또는 &lt;code&gt;thisArg&lt;/code&gt; 가 제공되는 경우 (추가 참조)를 제외하고 노드와 브라우저 모두에서 &lt;code&gt;new&lt;/code&gt; 참조와 함께 호출되지 않은 함수에서 전역 범위를 사용합니다&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="ee189376deeee0556de246c1ff07244efeae84a9" translate="yes" xml:space="preserve">
          <source>Extra stuff, copy this</source>
          <target state="translated">추가 물건, 이것을 복사</target>
        </trans-unit>
        <trans-unit id="a79ebf936a8f65b125ea48abc5225b5dc6cabb06" translate="yes" xml:space="preserve">
          <source>Following the translation to use &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;obj.bar()&lt;/code&gt; becomes &lt;code&gt;const temp = obj.bar; temp.call(obj);&lt;/code&gt;. When we enter the &lt;code&gt;bar&lt;/code&gt; function we call &lt;code&gt;foo&lt;/code&gt; but we explicitly passed in another object for objectForThis so when we arrive at foo &lt;code&gt;this&lt;/code&gt; is that inner object.</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 을 사용하도록 변환 한 후 &lt;code&gt;obj.bar()&lt;/code&gt; 는 &lt;code&gt;const temp = obj.bar; temp.call(obj);&lt;/code&gt; temp.call (obj); . &lt;code&gt;bar&lt;/code&gt; 함수를 입력하면 &lt;code&gt;foo&lt;/code&gt; 를 호출하지만 objectForThis에 대한 다른 객체를 명시 적으로 전달 했으므로 foo에 도달하면 &lt;code&gt;this&lt;/code&gt; 내부 객체입니다.</target>
        </trans-unit>
        <trans-unit id="987a7929690e08340ed411e619558b9514d1934d" translate="yes" xml:space="preserve">
          <source>For an arrow function (special case of context transparency) ask yourself:</source>
          <target state="translated">화살표 기능 (컨텍스트 투명도의 특수한 경우)에 대해서는 다음과 같이 자문하십시오.</target>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">함수 호출</target>
        </trans-unit>
        <trans-unit id="845fc2d1f33b0159fa8601b6b79fdc1e053598bf" translate="yes" xml:space="preserve">
          <source>Functions you create become function objects. They automatically get a special &lt;code&gt;prototype&lt;/code&gt; property, which is something you can assign values to. When you create an instance by calling your function with &lt;code&gt;new&lt;/code&gt; you get access to the values you assigned to the &lt;code&gt;prototype&lt;/code&gt; property. You access those values using &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">생성 한 함수는 함수 객체가됩니다. 자동으로 특별한 &lt;code&gt;prototype&lt;/code&gt; 속성을 얻습니다.이 속성은 값을 할당 할 수 있습니다. &lt;code&gt;new&lt;/code&gt; 로 함수를 호출하여 인스턴스를 만들면 &lt;code&gt;prototype&lt;/code&gt; 속성에 할당 한 값에 액세스 할 수 있습니다. &lt;code&gt;this&lt;/code&gt; 를 사용하여 해당 값에 액세스 합니다 .</target>
        </trans-unit>
        <trans-unit id="469e0788e79d852a9a805ea846c580f27362cc2a" translate="yes" xml:space="preserve">
          <source>Gentle explanation of 'this' keyword in JavaScript</source>
          <target state="translated">JavaScript에서 'this'키워드에 대한 부드러운 설명</target>
        </trans-unit>
        <trans-unit id="14a9ca90c670d793e8de8f4b937b4808ca9a99f8" translate="yes" xml:space="preserve">
          <source>He gives code examples, explanations, and solutions, which I thought was very helpful.</source>
          <target state="translated">그는 코드 예제, 설명 및 솔루션을 제공하며 매우 유용하다고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="542541ad020f39c0dd65066d67e5d1be86126656" translate="yes" xml:space="preserve">
          <source>Here is the summary:</source>
          <target state="translated">요약은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d75950e5613f2d50e01a7e225b9725bf0505513" translate="yes" xml:space="preserve">
          <source>How do we manipulate &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;?</source>
          <target state="translated">전화로 어떻게 조작하고 &lt;code&gt;apply&lt;/code&gt; 합니까?</target>
        </trans-unit>
        <trans-unit id="509b1a748402f9fa1f52f877d915151ea7eacf7c" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;this&lt;/code&gt; work and when should it be used?</source>
          <target state="translated">어떻게 작동하며 언제 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="c59a24b0ebdaf81d21086f1154af537b99a98f5d" translate="yes" xml:space="preserve">
          <source>How does the “this” keyword work</source>
          <target state="translated">&amp;ldquo;this&amp;rdquo;키워드는 어떻게 작동합니까</target>
        </trans-unit>
        <trans-unit id="8f5642913527f63ddc8d0489b7f04d5dca4b4e15" translate="yes" xml:space="preserve">
          <source>How does this work? Well, let's see what happens when we use the &lt;code&gt;new&lt;/code&gt; keyword.</source>
          <target state="translated">어떻게 작동합니까? &lt;code&gt;new&lt;/code&gt; 키워드를 사용할 때 어떤 일이 발생하는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="25cd4eb543ab592a2c8fdba2a85b8eac25657436" translate="yes" xml:space="preserve">
          <source>How is the function &lt;em&gt;invoked&lt;/em&gt;?</source>
          <target state="translated">함수는 어떻게 &lt;em&gt;호출&lt;/em&gt; 됩니까?</target>
        </trans-unit>
        <trans-unit id="6f351646cb35f88a1be59388fbb15c6a9a0a2c91" translate="yes" xml:space="preserve">
          <source>How is the value of &lt;code&gt;this&lt;/code&gt; determined?</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 의 가치는 어떻게 결정됩니까?</target>
        </trans-unit>
        <trans-unit id="2e8b8683e60bc5d1aab340b438427ac67cec8ead" translate="yes" xml:space="preserve">
          <source>How the function is called (including as an object method, use of &lt;em&gt;call&lt;/em&gt; and &lt;em&gt;apply&lt;/em&gt;, use of &lt;em&gt;new&lt;/em&gt;)</source>
          <target state="translated">함수 호출 방법 (오브젝트 메소드, &lt;em&gt;호출&lt;/em&gt; 및 &lt;em&gt;적용&lt;/em&gt; 사용, &lt;em&gt;new&lt;/em&gt; 사용 포함)</target>
        </trans-unit>
        <trans-unit id="41df7a9ac498fb8701396ea8333d73de768c8a4f" translate="yes" xml:space="preserve">
          <source>However use of &lt;code&gt;this&lt;/code&gt; indirectly through the other function called inside the event handling function or event property resolves to the global object &lt;code&gt;window&lt;/code&gt;.</source>
          <target state="translated">그러나 이벤트 처리 함수 또는 이벤트 속성 내에서 호출 된 다른 함수를 통해 간접적으로이를 사용하면 전역 개체 &lt;code&gt;window&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b57106c514445ec802e1cd473722a5a17ec00810" translate="yes" xml:space="preserve">
          <source>However, invoking it explicitly using window object shall result in
the following</source>
          <target state="translated">그러나 window 객체를 사용하여 명시 적으로 호출하면 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f29f3dcc991cc0d0219d93627781059b44927c91" translate="yes" xml:space="preserve">
          <source>I have a different take on &lt;code&gt;this&lt;/code&gt; from the other answers that I hope is helpful.</source>
          <target state="translated">나는 도움이되기를 희망하는 다른 답변과 다른 것을 취합니다.</target>
        </trans-unit>
        <trans-unit id="12126d6f03dcab3e8bc1580e1ffa7e034bb107bc" translate="yes" xml:space="preserve">
          <source>I have noticed that there doesn't appear to be a clear explanation of what the &lt;code&gt;this&lt;/code&gt; keyword is and how it is correctly (and incorrectly) used in JavaScript on the Stack Overflow site.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 키워드가 무엇인지, 그리고 키워드가 스택 오버플로 사이트의 JavaScript에서 올바르게 사용되고 잘못 사용되는 방법에 대한 명확한 설명이없는 것으로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="1460f7d950fc7da3126879c166cd50e7e5efc4dc" translate="yes" xml:space="preserve">
          <source>I have witnessed some very strange behaviour with it and have failed to understand why it has occurred.</source>
          <target state="translated">나는 그것으로 매우 이상한 행동을 목격했고 그것이 왜 발생했는지 이해하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="5a8ffb9e545c5cf5851a2f18d53651ef1e65e1af" translate="yes" xml:space="preserve">
          <source>I recommend reading &lt;a href=&quot;https://mikewest.org&quot;&gt;Mike West&lt;/a&gt;'s article &lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;Scope in JavaScript&lt;/a&gt; (&lt;a href=&quot;http://web.archive.org/web/20110725013125/http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;mirror&lt;/a&gt;) first. It is an excellent, friendly introduction to the concepts of &lt;code&gt;this&lt;/code&gt; and scope chains in JavaScript.</source>
          <target state="translated">&lt;a href=&quot;https://mikewest.org&quot;&gt;Mike West&lt;/a&gt; 의 기사 &lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;Scope in JavaScript&lt;/a&gt; ( &lt;a href=&quot;http://web.archive.org/web/20110725013125/http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;mirror&lt;/a&gt; )를 먼저 읽는 것이 좋습니다. JavaScript의 개념과 범위 체인에 대한 개념을 훌륭하고 친절하게 소개합니다.</target>
        </trans-unit>
        <trans-unit id="2f8031248cc83596d7bde88186a31b74ce913e61" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Object&lt;/code&gt; contains a property which holds a &lt;code&gt;Function&lt;/code&gt;, the property is called a method. This method, when called, will always have it's &lt;code&gt;this&lt;/code&gt; variable set to the &lt;code&gt;Object&lt;/code&gt; it is associated with. This is true for both strict and non-strict modes.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 에 &lt;code&gt;Function&lt;/code&gt; 을 보유한 속성이 포함 된 경우이 속성을 메서드라고합니다. 이 메소드는 호출 될 때 항상 &lt;code&gt;this&lt;/code&gt; 변수가 연관된 &lt;code&gt;Object&lt;/code&gt; 설정되도록합니다. 이는 엄격 및 비 엄격 모드 모두에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="f9f88fafad52186ab62424ffeb6795041b66ab36" translate="yes" xml:space="preserve">
          <source>If no explicit owner is defined, then the top most owner, the window object, is referenced.</source>
          <target state="translated">명시 적 소유자가 정의되어 있지 않으면 최상위 소유자 인 창 개체가 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="abea008c9ccdd3ff813706bd9d78b13581e069ae" translate="yes" xml:space="preserve">
          <source>If the event handler is inline, &lt;code&gt;this&lt;/code&gt; refers to global object</source>
          <target state="translated">이벤트 핸들러가 인라인 인 경우 글로벌 오브젝트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f545568898aa3f9f5ee670cd77b9d433d0a46089" translate="yes" xml:space="preserve">
          <source>If the function is called with NEW keyword then THIS will be bound to the newly created object.</source>
          <target state="translated">함수가 NEW 키워드로 호출되면 THIS는 새로 작성된 오브젝트에 바인드됩니다.</target>
        </trans-unit>
        <trans-unit id="6ee87374d289abdd7ecf8ddb47adfb37ca1d1d0e" translate="yes" xml:space="preserve">
          <source>If the method is on an object's prototype chain, &lt;code&gt;this&lt;/code&gt; inside such method refers to the object the method was called on, as if the method is defined on the object.</source>
          <target state="translated">메소드가 오브젝트의 프로토 타입 체인에있는 경우 해당 메소드 내부에서 메소드가 오브젝트에 정의 된 것처럼 메소드가 호출 된 오브젝트를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="0f184b072ae7cca9bec0b9152d5ee281a0952b2c" translate="yes" xml:space="preserve">
          <source>If we miss &lt;code&gt;new&lt;/code&gt; keyword, &lt;code&gt;whatIsThis&lt;/code&gt; referes to the most global context it can find(&lt;code&gt;window&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 키워드를 &lt;code&gt;whatIsThis&lt;/code&gt; 는 찾을 수있는 가장 글로벌 한 컨텍스트를 나타냅니다 ( &lt;code&gt;window&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="08b356112172b63c41e869c9033bb2d83cf69377" translate="yes" xml:space="preserve">
          <source>If you are wondering how a JavaScript library manipulates the value of &lt;code&gt;this&lt;/code&gt;, the library is simply using one of the built-in JavaScript functions accepting a &lt;code&gt;thisArg&lt;/code&gt;. You, too, can write your own function taking a callback function and &lt;code&gt;thisArg&lt;/code&gt;:</source>
          <target state="translated">JavaScript 라이브러리가 &lt;code&gt;this&lt;/code&gt; 의 값을 조작하는 방법이 궁금하다면 라이브러리는 &lt;code&gt;thisArg&lt;/code&gt; 를 허용하는 내장 JavaScript 함수 중 하나를 사용하는 것입니다. 콜백 함수와 &lt;code&gt;thisArg&lt;/code&gt; 를 사용 하여 자신의 함수를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a05e4a50ca55b0ab68c8d4be4da417b51bf22da0" translate="yes" xml:space="preserve">
          <source>If you call a function with &lt;code&gt;new&lt;/code&gt; the &lt;code&gt;this&lt;/code&gt; will be a new context, it will not reference the global &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 로 함수를 호출하면 &lt;code&gt;this&lt;/code&gt; 새로운 컨텍스트가되고 전역 &lt;code&gt;this&lt;/code&gt; 를 참조하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02cbcf4e964a2153e423ad418b22f8c3fd0762a2" translate="yes" xml:space="preserve">
          <source>If you just call a function then &lt;code&gt;this&lt;/code&gt; is the &quot;global object&quot; which in the browser is the window</source>
          <target state="translated">방금 함수를 호출하면 브라우저에서 창이 &quot;글로벌 객체&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d0e810fa1822dca8618162a82abee010cf8edbef" translate="yes" xml:space="preserve">
          <source>If you run this same piece of code in an environment like node.js, &lt;code&gt;this&lt;/code&gt; would refer to the global variable in your app.</source>
          <target state="translated">node.js와 같은 환경에서 동일한 코드를 실행하면 앱의 전역 변수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d3d6688717298c61d86ba4872a3543c0973adcae" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;use strict;&lt;/code&gt;, in which case &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">당신이 사용하는 &lt;code&gt;use strict;&lt;/code&gt; 이 경우 &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4534c020e272fd844f4a0447a32701b45e3c9a14" translate="yes" xml:space="preserve">
          <source>In &quot;Non Strict Mode&quot;, Calling/Invoking this function directly through   &lt;strong&gt;&quot;UserDefinedFunction()&quot;&lt;/strong&gt; will automatically call/invoke
it as &lt;strong&gt;&quot;window.UserDefinedFunction()&quot;&lt;/strong&gt; making &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; as the
&lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; (and hence the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) within &lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt;.Invoking this function in &quot;Non Strict Mode&quot; will result in the following</source>
          <target state="translated">&quot;Non Strict Mode&quot;에서 &lt;strong&gt;&quot;UserDefinedFunction ()&quot;&lt;/strong&gt; 을 통해이 함수를 직접 호출 / 호출하면 &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; 를 &lt;strong&gt;&quot;현재 오브젝트&quot;&lt;/strong&gt; ( &lt;strong&gt;&quot;&lt;/strong&gt; 값 &lt;strong&gt;&quot;&lt;/strong&gt; &lt;strong&gt;)&lt;/strong&gt; 로 &lt;strong&gt;&quot;window.UserDefinedFunction ()&quot;&lt;/strong&gt; 으로 자동 호출 / 호출됩니다. &quot;Non Strict Mode&quot;에서이 함수를 호출하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a86f46ab5fd04ce187322c9dacbc63583d2300ac" translate="yes" xml:space="preserve">
          <source>In &quot;Strict Mode&quot;, Calling/Invoking the function directly through
&lt;strong&gt;&quot;UserDefinedFunction()&quot;&lt;/strong&gt; will &lt;strong&gt;&quot;NOT&quot;&lt;/strong&gt; automatically call/invoke it as &lt;strong&gt;&quot;window.UserDefinedFunction()&quot;&lt;/strong&gt;.Hence the &lt;strong&gt;&quot;current
object&quot;&lt;/strong&gt; (and the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) within
&lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt; shall be &lt;strong&gt;undefined&lt;/strong&gt;. Invoking this function in &quot;Strict Mode&quot; will result in the following</source>
          <target state="translated">&quot;Strict Mode&quot;에서 &lt;strong&gt;&quot;UserDefinedFunction ()&quot;을&lt;/strong&gt; 통해 함수를 직접 호출 / 호출하면 &lt;strong&gt;&quot;NOT&quot;가&lt;/strong&gt; 자동으로 &lt;strong&gt;&quot;window.UserDefinedFunction ()&quot;&lt;/strong&gt; 으로 호출 / 호출됩니다. 따라서 &lt;strong&gt;&quot;현재 객체&quot;&lt;/strong&gt; (및 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 의 값) &lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt; 내에서 &lt;strong&gt;정의되지&lt;/strong&gt; 않아야합니다. &quot;엄격 모드&quot;에서이 기능을 호출하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="324ac6a318b326d5cd6ec138a5535c67787f43fe" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;node&lt;/code&gt; executing from a script, &lt;code&gt;this&lt;/code&gt; at the global scope starts as an empty object. It is not the same as &lt;code&gt;global&lt;/code&gt;</source>
          <target state="translated">스크립트에서 실행되는 &lt;code&gt;node&lt;/code&gt; 의 전역 범위에서 &lt;code&gt;this&lt;/code&gt; 빈 개체로 시작됩니다. &lt;code&gt;global&lt;/code&gt; 과 동일하지 않습니다</target>
        </trans-unit>
        <trans-unit id="e86f9b9c713dc09a44f881bdef02363ebb098cc7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;node&lt;/code&gt; using the repl, &lt;code&gt;this&lt;/code&gt; is the top namespace. You can refer to it as &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">repl을 사용하는 &lt;code&gt;node&lt;/code&gt; 에서 &lt;code&gt;this&lt;/code&gt; 최상위 네임 스페이스입니다. &lt;code&gt;global&lt;/code&gt; 이라고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffab00b98bc67260544caac0fccb102e726b7819" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;Client/Browser&lt;/strong&gt;&lt;code&gt;this&lt;/code&gt; keyword is a global object which is &lt;code&gt;window&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Client / Browser&lt;/strong&gt; &lt;code&gt;this&lt;/code&gt; 키워드는 &lt;code&gt;window&lt;/code&gt; 인 전역 객체입니다.</target>
        </trans-unit>
        <trans-unit id="1f8bea0a49922aa0e3476e6f13ff485166460709" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;Server/Node/Javascript runtime&lt;/strong&gt;&lt;code&gt;this&lt;/code&gt; keyword is also a global object which is &lt;code&gt;module.exports&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;서버 / 노드 / 자바 스크립트 런타임&lt;/strong&gt; &lt;code&gt;this&lt;/code&gt; 키워드는 또한 &lt;code&gt;module.exports&lt;/code&gt; 인 전역 객체입니다.</target>
        </trans-unit>
        <trans-unit id="4079e8901c7bbc5e93844e5cba0c225cbd71f87b" translate="yes" xml:space="preserve">
          <source>In Global Context &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; always refers to the &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; object</source>
          <target state="translated">글로벌 컨텍스트에서 &lt;strong&gt;&quot;this&quot;는&lt;/strong&gt; 항상 &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; 개체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2878a1d2151511dedfc3b49078b6bb8743b5e514" translate="yes" xml:space="preserve">
          <source>In JavaScript there are operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;. There is also the dot operator which is &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">JavaScript에는 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; 및 &lt;code&gt;*&lt;/code&gt; 와 같은 연산자가 있습니다. 도트 연산자도 있습니다 &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6efa6728b16de4e8625617c966cac872299fcc61" translate="yes" xml:space="preserve">
          <source>In a browser, at the global scope, &lt;code&gt;this&lt;/code&gt; is the &lt;code&gt;window&lt;/code&gt;object</source>
          <target state="translated">브라우저의 전역 범위에서 &lt;code&gt;this&lt;/code&gt; &lt;code&gt;window&lt;/code&gt; 개체입니다.</target>
        </trans-unit>
        <trans-unit id="471827f41377d6ddd619a309af3ab2d6e951cd2c" translate="yes" xml:space="preserve">
          <source>In an HTML DOM event handler, &lt;code&gt;this&lt;/code&gt; is always a reference to the DOM element the event was attached to</source>
          <target state="translated">HTML DOM 이벤트 핸들러에서 &lt;code&gt;this&lt;/code&gt; 항상 이벤트가 연결된 DOM 요소에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="f43a8566d5e8782dd6106131e8e134eb235d04cf" translate="yes" xml:space="preserve">
          <source>In an arrow function, &lt;code&gt;this&lt;/code&gt; will behave like common variables: it will be inherited from its lexical scope. The function's &lt;code&gt;this&lt;/code&gt;, where the arrow function is defined, will be the arrow function's &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">화살표 함수에서 &lt;code&gt;this&lt;/code&gt; 일반적인 변수처럼 작동합니다. 어휘 범위에서 상속됩니다. 화살표 함수가 정의 된 함수의 &lt;code&gt;this&lt;/code&gt; 는 화살표 함수의 this 입니다.</target>
        </trans-unit>
        <trans-unit id="e0ed578783f6c0844fb69401e88c46b1d4c812d5" translate="yes" xml:space="preserve">
          <source>In both cases, this is set to window.</source>
          <target state="translated">두 경우 모두 창으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3c2d641383f797d7802108f589e4b9aefd246bdb" translate="yes" xml:space="preserve">
          <source>In event listeners the value of &lt;code&gt;this&lt;/code&gt;  refers to the DOM element on which the event was called.</source>
          <target state="translated">이벤트 리스너 &lt;code&gt;this&lt;/code&gt; 값은 이벤트가 호출 된 DOM 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="21221c02e3ea6b186925dee47bb0aff97b3c7622" translate="yes" xml:space="preserve">
          <source>In other words &lt;code&gt;bar.foo()&lt;/code&gt; translates into &lt;code&gt;const temp = bar.foo; temp.call(bar);&lt;/code&gt;</source>
          <target state="translated">즉 &lt;code&gt;bar.foo()&lt;/code&gt; 는 &lt;code&gt;const temp = bar.foo; temp.call(bar);&lt;/code&gt; 로 변환됩니다 . temp.call (bar);</target>
        </trans-unit>
        <trans-unit id="e583468a15187c915f71a5317544c6b871de6462" translate="yes" xml:space="preserve">
          <source>In other words,</source>
          <target state="translated">다시 말해,</target>
        </trans-unit>
        <trans-unit id="27d6a458ca3d5e041f95d454ee2e6dbc62b5e228" translate="yes" xml:space="preserve">
          <source>In pseudoclassical terms, the way many lectures teach the 'this' keyword is as an object instantiated by a class or object constructor. Each time a new object is constructed from a class, imagine that under the hood a local instance of a 'this' object is created and returned. I remember it taught like this:</source>
          <target state="translated">유사 고전 용어로, 많은 강의에서 'this'키워드를 가르치는 방식은 클래스 또는 객체 생성자가 인스턴스화 한 객체입니다. 클래스에서 새 객체를 만들 때마다 'this'객체의 로컬 인스턴스가 만들어지고 반환된다고 상상해보십시오. 나는 이것이 이렇게 가르쳤다는 것을 기억한다.</target>
        </trans-unit>
        <trans-unit id="cd2387ea5c279e482429632a93ee4100a845238a" translate="yes" xml:space="preserve">
          <source>In the above code, we see that the value of &lt;code&gt;this&lt;/code&gt; changed with the nested scope, but we wanted the value of &lt;code&gt;this&lt;/code&gt; from the original scope. So we 'copied' &lt;code&gt;this&lt;/code&gt; to &lt;code&gt;that&lt;/code&gt; and used the copy instead of &lt;code&gt;this&lt;/code&gt;. Clever, eh?</source>
          <target state="translated">위의 코드 &lt;code&gt;this&lt;/code&gt; 값 이 중첩 범위로 변경되었음을 알 수 있지만 원래 범위 &lt;code&gt;this&lt;/code&gt; 값을 원했습니다. 그래서 우리는 &lt;code&gt;this&lt;/code&gt; 에 '복사'했고 &lt;code&gt;this&lt;/code&gt; 대신에 사본을 사용 했습니다 . 영리한가?</target>
        </trans-unit>
        <trans-unit id="43224f60c133b11951481d44412c4fce99a0226f" translate="yes" xml:space="preserve">
          <source>In the above example we see that when &lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt; was
invoked through &lt;strong&gt;o1&lt;/strong&gt;, &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; takes value of &lt;strong&gt;o1&lt;/strong&gt; and the
value of its properties &lt;strong&gt;&quot;a&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;b&quot;&lt;/strong&gt; get displayed. The value
of &lt;strong&gt;&quot;c&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;d&quot;&lt;/strong&gt; were shown as &lt;strong&gt;undefined&lt;/strong&gt; as &lt;strong&gt;o1&lt;/strong&gt; does
not define these properties</source>
          <target state="translated">위의 예제에서 &lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt; 이 &lt;strong&gt;o1을&lt;/strong&gt; 통해 호출되면 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 는 &lt;strong&gt;o1&lt;/strong&gt; 의 값을 가져오고 해당 속성 &lt;strong&gt;&quot;a&quot;&lt;/strong&gt; 및 &lt;strong&gt;&quot;b&quot;의 값&lt;/strong&gt; 이 표시됩니다. &lt;strong&gt;o1&lt;/strong&gt; 이 이러한 특성을 정의하지 않으므로 &lt;strong&gt;&quot;c&quot;&lt;/strong&gt; 및 &lt;strong&gt;&quot;d&quot;&lt;/strong&gt; 값이 &lt;strong&gt;정의되지 않은&lt;/strong&gt; 것으로 표시되었습니다.</target>
        </trans-unit>
        <trans-unit id="96cc1a99aaa4e2084ab88b3ca40dccb578c47d7d" translate="yes" xml:space="preserve">
          <source>In the above this will be bound to 'myCar' object</source>
          <target state="translated">위의 'myCar'객체에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="c83013fb1cd27e083ad60085d21979e56ba40fe5" translate="yes" xml:space="preserve">
          <source>In the case of the &lt;code&gt;Array.prototype&lt;/code&gt; functions, the given &lt;code&gt;callbackfn&lt;/code&gt; is called in an execution context where ThisBinding is set to &lt;code&gt;thisArg&lt;/code&gt; if supplied; otherwise, to the global object.</source>
          <target state="translated">&lt;code&gt;Array.prototype&lt;/code&gt; 함수의 경우 제공된 바인딩이 제공된 경우이 바인딩이 &lt;code&gt;thisArg&lt;/code&gt; 로 설정된 실행 컨텍스트에서 호출됩니다. 그렇지 않으면 전역 객체에.</target>
        </trans-unit>
        <trans-unit id="c033f7496c40486ad987d93a68b83caa6838c09d" translate="yes" xml:space="preserve">
          <source>In the case of the &lt;code&gt;Function.prototype&lt;/code&gt; functions, they are called on a function object, but rather than setting ThisBinding to the function object, ThisBinding is set to the &lt;code&gt;thisArg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Function.prototype&lt;/code&gt; 함수의 경우 함수 객체에서 호출되지만 ThisBinding을 함수 객체로 설정하지 않고 ThisBinding이 &lt;code&gt;thisArg&lt;/code&gt; 로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aaeae9315cfc2930a15076b4cb90e923ca76ddd7" translate="yes" xml:space="preserve">
          <source>In the first example, the font color of the button shall be set to
white when it is clicked.</source>
          <target state="translated">첫 번째 예에서 버튼의 글꼴 색상은 클릭 할 때 흰색으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2e598c3cda0bdc325d8abb172c4e83c3b44ff6a8" translate="yes" xml:space="preserve">
          <source>In the following cases, we would see how to manipulate the value of &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">다음과 같은 경우에는 &lt;code&gt;this&lt;/code&gt; 값을 조작하는 방법을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="430cd67bcc3100745a24d8b9fbad17bfca3af311" translate="yes" xml:space="preserve">
          <source>In the latter case, you merely reference the function, not hand it over to the element. Therefore, &lt;code&gt;this&lt;/code&gt; will refer to the window object.</source>
          <target state="translated">후자의 경우, 함수를 요소에 넘기는 것이 아니라 함수를 참조 할뿐입니다. 따라서 &lt;code&gt;this&lt;/code&gt; 창 개체를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="1dd405f2048b51f3afad5fd52c3f9bfc8120d1ae" translate="yes" xml:space="preserve">
          <source>In the second example when the &lt;strong&gt;&quot;div&quot;&lt;/strong&gt; element is clicked it shall
call the &lt;strong&gt;OnDivClick&lt;/strong&gt; function with its second parameter
referencing the clicked div element. However the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;
within OnDivClick &lt;strong&gt;SHALL NOT&lt;/strong&gt; reference the clicked &lt;strong&gt;div&lt;/strong&gt;
element. It shall be set as the &lt;strong&gt;&quot;window object&quot;&lt;/strong&gt; or
&lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; in &lt;strong&gt;Non strict&lt;/strong&gt; and &lt;strong&gt;Strict Modes&lt;/strong&gt; respectively (if &lt;strong&gt;OnDivClick&lt;/strong&gt; is an &lt;strong&gt;unbound function&lt;/strong&gt;) or set to a predefined
Bound value (if &lt;strong&gt;OnDivClick&lt;/strong&gt; is a &lt;strong&gt;bound function&lt;/strong&gt;)</source>
          <target state="translated">두 번째 예제에서 &lt;strong&gt;&quot;div&quot;&lt;/strong&gt; 요소를 클릭하면 클릭 한 div 요소를 참조하는 두 번째 매개 변수와 함께 &lt;strong&gt;OnDivClick&lt;/strong&gt; 함수를 호출해야합니다. 그러나 OnDivClick 내의 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 값은 클릭 된 &lt;strong&gt;div&lt;/strong&gt; 요소를 참조 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . &lt;strong&gt;엄격&lt;/strong&gt; &lt;strong&gt;하지&lt;/strong&gt; &lt;strong&gt;않은&lt;/strong&gt; &lt;strong&gt;모드&lt;/strong&gt; 와 &lt;strong&gt;엄격한 모드에서&lt;/strong&gt; 각각 &lt;strong&gt;&quot;창 개체&quot;&lt;/strong&gt; 또는 &lt;strong&gt;&quot;정의되지 않음&quot;&lt;/strong&gt; 으로 설정되거나 ( &lt;strong&gt;OnDivClick&lt;/strong&gt; 이 &lt;strong&gt;언 바운드 함수 인 경우&lt;/strong&gt; ) 미리 정의 된 경계 값으로 설정되어야합니다 ( &lt;strong&gt;OnDivClick&lt;/strong&gt; 이 &lt;strong&gt;바인딩 된 함수 인 경우&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="81ed2e6a494f7f2dc46f5d18d6632785957e98bc" translate="yes" xml:space="preserve">
          <source>In this case, THIS will be bound to the object which is explicitly passed to the function.</source>
          <target state="translated">이 경우 THIS는 명시 적으로 함수에 전달되는 객체에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="0df985536051bb82097890e1a0953285b688bcea" translate="yes" xml:space="preserve">
          <source>In this example, the JavaScript interpreter enters function code, but because &lt;code&gt;myFun&lt;/code&gt;/&lt;code&gt;obj.myMethod&lt;/code&gt; is not called on an object, ThisBinding is set to &lt;code&gt;window&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 JavaScript 인터프리터는 함수 코드를 입력하지만 객체에서 myFun / &lt;code&gt;obj.myMethod&lt;/code&gt; 가 호출되지 않으므로 ThisBinding이 &lt;code&gt;window&lt;/code&gt; 로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2bb2e91de5338b6aa278265043941f191287a902" translate="yes" xml:space="preserve">
          <source>In two words, &lt;code&gt;this&lt;/code&gt; in JavaScript points the object from whom (or from whose execution context) the current function was run and it's always read-only, you can't set it anyway (such an attempt will end up with 'Invalid left-hand side in assignment' message.</source>
          <target state="translated">즉, JavaScript에서 &lt;code&gt;this&lt;/code&gt; 현재 함수가 실행 된 (또는 실행 컨텍스트에서) 객체를 가리키며 항상 읽기 전용이므로 어쨌든 설정할 수 없습니다 (이러한 시도는 'Invalid left- 과제 '메시지의 손 쪽.</target>
        </trans-unit>
        <trans-unit id="934e0a8e43701b41d397444e208dc6649f33774f" translate="yes" xml:space="preserve">
          <source>Index:</source>
          <target state="translated">Index:</target>
        </trans-unit>
        <trans-unit id="8659b0f0077283eb99e2d1bd963b7db35f13f69b" translate="yes" xml:space="preserve">
          <source>Inside HTML attributes in which you can put JavaScript, &lt;code&gt;this&lt;/code&gt; is a reference to the element.</source>
          <target state="translated">JavaScript를 넣을 수있는 HTML 속성 내에서 이는 요소에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="9e308c1af402a51e3c742eaeb80b4ffd7fa67c95" translate="yes" xml:space="preserve">
          <source>Inside a Direct  &quot;Non Bound Function&quot; Call, &lt;strong&gt;the object that
invoked the function call becomes the &quot;current object&quot;&lt;/strong&gt; (and hence
the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;). If a function is called without a explicit &lt;strong&gt;current object&lt;/strong&gt;, the &lt;strong&gt;current object&lt;/strong&gt; is either the &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; object (For Non Strict Mode) or &lt;strong&gt;undefined&lt;/strong&gt; (For Strict Mode)  . Any function (or variable) defined in
&lt;strong&gt;Global Context&lt;/strong&gt; automatically becomes a property of the &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; object.For e.g Suppose function is defined in Global Context as</source>
          <target state="translated">직접 &quot;바인딩되지 않은 함수&quot; &lt;strong&gt;호출 내에서 함수 호출을 호출 한 객체는 &quot;현재 객체&quot;&lt;/strong&gt; (따라서 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 값)가됩니다. 명시 적 &lt;strong&gt;현재 객체&lt;/strong&gt; 없이 함수를 호출하면 &lt;strong&gt;현재 객체&lt;/strong&gt; 는 &lt;strong&gt;&quot;창&quot;&lt;/strong&gt; 객체 (비 엄격 모드의 경우) 또는 &lt;strong&gt;정의되지 않은&lt;/strong&gt; (엄격한 모드의 경우)입니다. &lt;strong&gt;전역 컨텍스트에&lt;/strong&gt; 정의 된 모든 함수 (또는 변수)는 자동으로 &lt;strong&gt;&quot;창&quot;&lt;/strong&gt; 객체의 속성이됩니다. 예를 들어 함수가 전역 컨텍스트에 다음과 같이 정의되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e90ac117b0316d7973d69a03502107870607096b" translate="yes" xml:space="preserve">
          <source>Inside a constructor function, the &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; (and hence the value of 
&lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) references the object that is currently being created
through &lt;strong&gt;&quot;new&quot;&lt;/strong&gt; irrespective of the bind status of the function. However
if the constructor is a bound function it shall get called with 
predefined set of arguments as set for the bound function.</source>
          <target state="translated">생성자 함수 내에서 &lt;strong&gt;&quot;현재 객체&quot;&lt;/strong&gt; (따라서 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 값)는 함수의 바인드 상태에 관계없이 &lt;strong&gt;&quot;new&quot;를&lt;/strong&gt; 통해 현재 생성중인 객체를 참조합니다. 그러나 생성자가 바운드 함수 인 경우 바운드 함수에 대해 설정된 미리 정의 된 인수 집합으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="07896e58b529f3fb8b5b73a6120efa70bb3ab536" translate="yes" xml:space="preserve">
          <source>Irrespective of the context in which it is used, &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; always references the &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; in Javascript. However, what the &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; is  differs according to &lt;strong&gt;context&lt;/strong&gt;. The &lt;strong&gt;context&lt;/strong&gt; may be exactly &lt;strong&gt;1 of the 6&lt;/strong&gt; following:</source>
          <target state="translated">사용되는 컨텍스트와 상관없이 &lt;strong&gt;&quot;this&quot;는&lt;/strong&gt; 항상 Javascript의 &lt;strong&gt;&quot;현재 오브젝트&quot;&lt;/strong&gt; 를 참조합니다. 그러나 &lt;strong&gt;&quot;현재 객체&quot;&lt;/strong&gt; 가 무엇인지는 &lt;strong&gt;context&lt;/strong&gt; 에 따라 다릅니다. &lt;strong&gt;컨텍스트&lt;/strong&gt; 는 다음 &lt;strong&gt;6 개 중&lt;/strong&gt; 정확히 &lt;strong&gt;1&lt;/strong&gt; &lt;strong&gt;개일&lt;/strong&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ddbde6677e66a2eef6ce94f5856c81e48273985" translate="yes" xml:space="preserve">
          <source>It is difficult to get a good grasp of JS, or write more than anything trivial in it, if you don't understand it thoroughly. You cannot just afford to take a quick dip :) I think the best way to get started with JS is to first watch these video lectures by Douglas Crockford - &lt;a href=&quot;http://yuiblog.com/crockford/&quot;&gt;http://yuiblog.com/crockford/&lt;/a&gt;, which covers this and that, and everything else about JS.</source>
          <target state="translated">JS를 잘 이해하지 못하면 JS를 잘 이해하거나 사소한 것 이상을 쓰는 것이 어렵습니다. JS를 시작하는 가장 좋은 방법은 Douglas Crockford ( &lt;a href=&quot;http://yuiblog.com/crockford/&quot;&gt;http://yuiblog.com/crockford/)의&lt;/a&gt; 비디오 강의를 먼저 보는 것입니다. JS에 관한 다른 모든 것.</target>
        </trans-unit>
        <trans-unit id="7126c04f305ed904207b61e181769dea029be5b6" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to assign &lt;em&gt;arrays&lt;/em&gt; or &lt;em&gt;objects&lt;/em&gt; on the &lt;code&gt;prototype&lt;/code&gt;. If you want instances to each have their own arrays, create them in the function, not the prototype.</source>
          <target state="translated">&lt;code&gt;prototype&lt;/code&gt; 에 &lt;em&gt;배열&lt;/em&gt; 이나 &lt;em&gt;객체&lt;/em&gt; 를 할당하는 것은 일반적으로 실수입니다. 인스턴스마다 고유 한 배열을 가지려면 프로토 타입이 아닌 함수에서 인스턴스를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="992dc5d399c1eb9c5819d08e8cdc27405e9a0bff" translate="yes" xml:space="preserve">
          <source>JQuery proxy is another way you can use to make sure this in a function will be the value you desire. (Check &lt;a href=&quot;https://stackoverflow.com/q/4986329/340046&quot;&gt;Understanding $.proxy()&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/q/3349380/340046&quot;&gt;jQuery.proxy() usage&lt;/a&gt;)</source>
          <target state="translated">JQuery 프록시는 함수에서이를 원하는 값으로 만드는 데 사용할 수있는 또 다른 방법입니다. ( &lt;a href=&quot;https://stackoverflow.com/q/4986329/340046&quot;&gt;$ .proxy ()&lt;/a&gt; , &lt;a href=&quot;https://stackoverflow.com/q/3349380/340046&quot;&gt;jQuery.proxy () 사용법&lt;/a&gt; 이해 확인)</target>
        </trans-unit>
        <trans-unit id="be6b0ab456696ba8d67592a42d2412b774842021" translate="yes" xml:space="preserve">
          <source>Javascript's &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">자바 스크립트는 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2453951365a295c5909c9ed643507672357709f3" translate="yes" xml:space="preserve">
          <source>Just for fun, test your understanding with some examples</source>
          <target state="translated">재미를 위해 몇 가지 예를 통해 이해를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="894c85eb8e48c996ee7525b62829676432dc120f" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;bind&lt;/code&gt;, a new invisible function is created that calls the given function with a bound value for &lt;code&gt;objectForThis&lt;/code&gt; but unlike &lt;code&gt;bind&lt;/code&gt; the object to be bound is implicit. It's whatever &lt;code&gt;this&lt;/code&gt; happens to be when the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is used.</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; 와 마찬가지로 &lt;code&gt;objectForThis&lt;/code&gt; 에 대한 바인딩 된 값으로 지정된 함수를 호출하는 새로운 보이지 않는 함수가 만들어 지지만 &lt;code&gt;bind&lt;/code&gt; 할 객체와는 달리 바인딩 되는 것은 암시 적입니다. &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자를 사용할 때 발생하는 모든 &lt;code&gt;this&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fcbd5d2a27f1bec48bd69a467c70b7017b49d1da" translate="yes" xml:space="preserve">
          <source>Keep in mind &lt;code&gt;exports&lt;/code&gt; is just a reference to &lt;code&gt;module.exports&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;exports&lt;/code&gt; 는 &lt;code&gt;module.exports&lt;/code&gt; 대한 참조 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="5fa70764a0750c44aea026597b2b0bb54778bd69" translate="yes" xml:space="preserve">
          <source>Let us look at another example. Please look at the following code</source>
          <target state="translated">다른 예를 봅시다. 다음 코드를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="674fee26bf2169d5b7390a8d6cb04650d870ce43" translate="yes" xml:space="preserve">
          <source>Let's log &lt;code&gt;this&lt;/code&gt; keyword to the console in global scope without any more code but</source>
          <target state="translated">더 이상 코드없이이 키워드를 전역 범위의 콘솔에 기록하겠습니다</target>
        </trans-unit>
        <trans-unit id="347a6545cb2fdbde1b257137e4557d5c3e7376d9" translate="yes" xml:space="preserve">
          <source>Lexically for arrow functions (they adopt the &lt;em&gt;this&lt;/em&gt; of their outer execution context)</source>
          <target state="translated">어휘 기능을 위해 어휘 적으로 (외부 실행 컨텍스트를 채택 함)</target>
        </trans-unit>
        <trans-unit id="4b794c51b008429d9440459755a0aea70b021d1b" translate="yes" xml:space="preserve">
          <source>Most people get confused when they try to use &quot;this&quot; inside of anonymous closure functions like:</source>
          <target state="translated">대부분의 사람들은 다음과 같은 익명 클로저 함수 내에서 &quot;this&quot;를 사용하려고 할 때 혼란스러워합니다.</target>
        </trans-unit>
        <trans-unit id="24a1c5ba7f20054e6cc97447ca4ff99819209a36" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; can override the value of &lt;code&gt;this&lt;/code&gt; set by dot method invocation we discussed in the second bullet.
Simple enough :)</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; 는 두 번째 글 머리표에서 설명한 도트 메소드 호출 &lt;code&gt;this&lt;/code&gt; 세트의 값을 대체 할 수 있습니다. 충분히 간단하다 :)</target>
        </trans-unit>
        <trans-unit id="d5fda3afa616c2908147257d1b4538bffe1f96f3" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;functionObject.bind&lt;/code&gt; did not exist we could make our own like this</source>
          <target state="translated">&lt;code&gt;functionObject.bind&lt;/code&gt; 가 존재하지 않으면 다음과 같이 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd156fe39e6cb3e81a3dc10a1d0665f3a2485dfd" translate="yes" xml:space="preserve">
          <source>Note that if a method is stored (or rather, copied) in another variable, the reference to &lt;code&gt;this&lt;/code&gt; is no longer preserved in the new variable. For example:</source>
          <target state="translated">메소드가 다른 변수에 저장되는 경우 (또는 복사되는 경우) &lt;code&gt;this&lt;/code&gt; 참조는 더 이상 새 변수에 유지되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="767a361d58ea1665f1185636ce54e8f7e4d5a7b8" translate="yes" xml:space="preserve">
          <source>Note that if you use strict mode then &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">엄격 모드를 사용하면 &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="235f4aca4b6e147c89ad215706ae8a6e2deabb75" translate="yes" xml:space="preserve">
          <source>Note that it doesn't matter how the function was created (mostly...). All of these will produce the same results</source>
          <target state="translated">함수가 어떻게 생성되었는지는 중요하지 않습니다 (주로 ...). 이 모든 것이 동일한 결과를 낳을 것입니다</target>
        </trans-unit>
        <trans-unit id="2b700c221638ceb27ecd2fe681cd4c26833c39cf" translate="yes" xml:space="preserve">
          <source>Note that the official ECMAScript spec nowhere states that such types of functions are actual &lt;code&gt;constructor&lt;/code&gt; functions. They are just normal functions, and &lt;code&gt;new&lt;/code&gt; can be used on any function. It's just that we use them as such, and so we call them as such only.</source>
          <target state="translated">공식 ECMAScript 사양에는 이러한 유형의 함수가 실제 &lt;code&gt;constructor&lt;/code&gt; 함수라고 명시되어 있지 않습니다. 그것들은 단지 정상적인 기능이며, 어떤 기능에도 &lt;code&gt;new&lt;/code&gt; 기능을 사용할 수 있습니다. 단지 우리가 그것들을 그대로 사용하기 때문에 단지 그렇게 부르는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd960096fd51dca1613866611c29d9d73d149c0d" translate="yes" xml:space="preserve">
          <source>Note that we are running this in the normal mode, i.e. strict mode is not used.</source>
          <target state="translated">우리는 이것을 일반 모드에서 실행하고 있습니다. 즉, 엄격 모드는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81c5b121bb3b104b797c415c59fc9f82cf7e31ea" translate="yes" xml:space="preserve">
          <source>Now if we run this in strict mode by adding the statement &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; to the beginning of the function declaration, &lt;code&gt;this&lt;/code&gt; would no longer refer to the global variable in either of the environments. This is done to avoid confusions in strict mode. &lt;code&gt;this&lt;/code&gt; would, in this case just log &lt;code&gt;undefined&lt;/code&gt;, because that is what it is, it is not defined.</source>
          <target state="translated">이제 &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 문을 추가하여 엄격 모드에서 이것을 실행하면 ; 함수 선언의 시작 부분에서 &lt;code&gt;this&lt;/code&gt; 더 이상 어느 환경에서나 전역 변수를 참조하지 않습니다. 엄격 모드에서 혼동을 피하기 위해 수행됩니다. &lt;code&gt;this&lt;/code&gt; 이 경우 &lt;code&gt;undefined&lt;/code&gt; 것이기 때문에 undefined를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="bdb993d7f3927fbada79fbc0cdf43dcb01f54dc1" translate="yes" xml:space="preserve">
          <source>Now. Let's imagine we make a function that explicitly sets &lt;code&gt;this&lt;/code&gt; before calling another function and then call it with the &lt;code&gt;.&lt;/code&gt; (dot) operator</source>
          <target state="translated">지금. 다른 함수를 호출하기 전에 &lt;code&gt;this&lt;/code&gt; 명시 적으로 설정 한 다음를 사용하여 호출하는 함수를 상상해 봅시다 &lt;code&gt;.&lt;/code&gt; (점) 연산자</target>
        </trans-unit>
        <trans-unit id="f7c9c2091cfaff21dd7fae4ea95609c87cb2899e" translate="yes" xml:space="preserve">
          <source>Object literal notation creates an instance of object which we can use immediately. With function we may need to first create its instance using &lt;code&gt;new&lt;/code&gt; operator.</source>
          <target state="translated">객체 리터럴 표기법은 즉시 사용할 수있는 객체 인스턴스를 만듭니다. 함수를 사용하면 먼저 &lt;code&gt;new&lt;/code&gt; 연산자를 사용하여 인스턴스를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="25ff51b9b77d4e3cd4a459c2231b84b262b58dee" translate="yes" xml:space="preserve">
          <source>Once you start getting used to &lt;code&gt;this&lt;/code&gt;, the rules are actually pretty simple. The &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1&quot;&gt;ECMAScript 5.1 Standard&lt;/a&gt; defines &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 익숙해지기 시작하면 규칙은 실제로 매우 간단합니다. &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1&quot;&gt;ECMAScript 5.1 표준&lt;/a&gt; 은 &lt;code&gt;this&lt;/code&gt; 정의 합니다 .</target>
        </trans-unit>
        <trans-unit id="ba28d64a842cc863e8fd947ef8b2d2761787ca76" translate="yes" xml:space="preserve">
          <source>One other wrinkle is the prototype chain. When you use &lt;code&gt;a.b&lt;/code&gt; JavaScript first looks on the object referenced directly by &lt;code&gt;a&lt;/code&gt; for the property &lt;code&gt;b&lt;/code&gt;. If &lt;code&gt;b&lt;/code&gt; is not found on the object then JavaScript will look in the object's prototype to find &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">또 다른 주름은 프로토 타입 체인입니다. &lt;code&gt;a.b&lt;/code&gt; JavaScript를 사용하면 먼저 &lt;code&gt;b&lt;/code&gt; 속성에서 b가 직접 참조하는 객체를 찾습니다. 객체에서 &lt;code&gt;b&lt;/code&gt; 가 발견되지 않으면 JavaScript는 객체의 프로토 타입에서 &lt;code&gt;b&lt;/code&gt; 를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="519ab8586252702931098aa46525bc513da1698f" translate="yes" xml:space="preserve">
          <source>One way to look at JavaScript is to see that there are only 1 way to call a function&lt;sup&gt;1&lt;/sup&gt;. It is</source>
          <target state="translated">JavaScript를 보는 한 가지 방법은 함수 &lt;sup&gt;1&lt;/sup&gt; 을 호출하는 단 하나의 방법 만 있음을 보는 것입니다. 그것은</target>
        </trans-unit>
        <trans-unit id="e6cc1f21389aeed3c994d1fb9ea99f0e63bb1e99" translate="yes" xml:space="preserve">
          <source>Outside all functions (i.e. in global context) the &lt;strong&gt;&quot;current
object&quot;&lt;/strong&gt; (and hence the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) is always the
&lt;strong&gt;&quot;window&quot;&lt;/strong&gt; object for browsers.</source>
          <target state="translated">모든 기능 외부 (즉, 전역 컨텍스트)에서 &lt;strong&gt;&quot;현재 객체&quot;&lt;/strong&gt; (따라서 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 값)는 항상 브라우저의 &lt;strong&gt;&quot;창&quot;&lt;/strong&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="458f4f8a250f5217e985cebc8035a133a4cc6496" translate="yes" xml:space="preserve">
          <source>Please look at the following HTML Snippet</source>
          <target state="translated">다음 HTML 스 니펫을보십시오</target>
        </trans-unit>
        <trans-unit id="c23e76e8d97b29eedd68eb763eb4329893b8b3a7" translate="yes" xml:space="preserve">
          <source>Presenting.... &lt;code&gt;bind&lt;/code&gt;!</source>
          <target state="translated">발표 .... &lt;code&gt;bind&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="5dff48a80d21897b1a7b4ec4d3e064bd791cf0a7" translate="yes" xml:space="preserve">
          <source>Pretty straightforward, eh?</source>
          <target state="translated">아주 간단합니까?</target>
        </trans-unit>
        <trans-unit id="d68dbd2ff1e0f0c272d49f9c85bec5340d93f7ba" translate="yes" xml:space="preserve">
          <source>Probably the most detailed and comprehensive article on &lt;code&gt;this&lt;/code&gt; is the following:</source>
          <target state="translated">아마도 가장 상세하고 포괄적 인 기사는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aec57670cb741243fb4b52dc59dfa257130956b6" translate="yes" xml:space="preserve">
          <source>See the difference between the three? It is subtle, but they are used differently. Like &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;bind&lt;/code&gt; will also over-ride the value of &lt;code&gt;this&lt;/code&gt; set by dot-method invocation.</source>
          <target state="translated">세 가지의 차이점을 보시겠습니까? 미묘하지만 다르게 사용됩니다. &lt;code&gt;call&lt;/code&gt; 및 &lt;code&gt;apply&lt;/code&gt; 와 마찬가지로 &lt;code&gt;bind&lt;/code&gt; 는 도트 메소드 호출 &lt;code&gt;this&lt;/code&gt; 세트의 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="d6a6db24764ce1a8198a5fb69df54904ebb96362" translate="yes" xml:space="preserve">
          <source>See the following code:</source>
          <target state="translated">다음 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="044b35bd261da09f7c8b736e9469b64b95b16433" translate="yes" xml:space="preserve">
          <source>Similarly when &lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt; was invoked through &lt;strong&gt;o2&lt;/strong&gt;,
&lt;strong&gt;&quot;this&quot;&lt;/strong&gt; takes value of &lt;strong&gt;o2&lt;/strong&gt; and the value of its properties &lt;strong&gt;&quot;c&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;d&quot;&lt;/strong&gt; get displayed.The value of &lt;strong&gt;&quot;a&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;b&quot;&lt;/strong&gt; were shown as &lt;strong&gt;undefined&lt;/strong&gt; as &lt;strong&gt;o2&lt;/strong&gt; does not define these properties.</source>
          <target state="translated">마찬가지로 &lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt; 이 &lt;strong&gt;o2를&lt;/strong&gt; 통해 호출 된 경우 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 는 &lt;strong&gt;o2&lt;/strong&gt; 의 값을 가져오고 해당 속성 &lt;strong&gt;&quot;c&quot;&lt;/strong&gt; 및 &lt;strong&gt;&quot;d&quot;의&lt;/strong&gt; 값이 표시됩니다. &lt;strong&gt;&quot;a&quot;&lt;/strong&gt; 및 &lt;strong&gt;&quot;b&quot;의&lt;/strong&gt; 값은 &lt;strong&gt;o2&lt;/strong&gt; 와 달리 &lt;strong&gt;정의되지 않은&lt;/strong&gt; 것으로 표시됩니다. 이러한 속성을 정의하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4681c4e7dfd2de2b681bc6a9a880fb39de0fc724" translate="yes" xml:space="preserve">
          <source>Similarly, when you use &lt;code&gt;this&lt;/code&gt; directly inside the event property (like &lt;code&gt;&amp;lt;button onclick=&quot;...this...&quot; &amp;gt;&lt;/code&gt;) of the element, it refers to the element.</source>
          <target state="translated">마찬가지로 요소의 이벤트 속성 (예 : &lt;code&gt;&amp;lt;button onclick=&quot;...this...&quot; &amp;gt;&lt;/code&gt; ) 내에서 직접 사용하는 경우 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fc5642eed954e43be8c2b08ea6204f5beae34cb6" translate="yes" xml:space="preserve">
          <source>Simple answer:</source>
          <target state="translated">간단한 답변 :</target>
        </trans-unit>
        <trans-unit id="cd0c21407e549024fd8ebade4d9db293fa35da67" translate="yes" xml:space="preserve">
          <source>Simple function invocation</source>
          <target state="translated">간단한 함수 호출</target>
        </trans-unit>
        <trans-unit id="d7af4d79d12ac932a60b3bcbb4551442c40a1a19" translate="yes" xml:space="preserve">
          <source>So here, inside each(), &quot;this&quot; doesn't hold the &quot;value&quot; that you expect it to (from</source>
          <target state="translated">여기에서 each () 안에서 &quot;this&quot;는 &quot;value&quot;를 기대하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2dedd77da3beb2baf299eed38237e8b9cb499c92" translate="yes" xml:space="preserve">
          <source>So if I did</source>
          <target state="translated">내가 한 경우</target>
        </trans-unit>
        <trans-unit id="f9ad9f9ed5dfd5b4e3d833b6c8840ad972fab14b" translate="yes" xml:space="preserve">
          <source>So the Semantic of &quot;this&quot; is different from the traditional OOP languages. And it causes problems:
1. when a function is passed to another variable (most likely, a callback); and 2. when a closure is invoked from a member method of a class.</source>
          <target state="translated">&quot;this&quot;의 의미는 전통적인 OOP 언어와 다릅니다. 그리고 그것은 문제를 일으킨다 : 1. 함수가 다른 변수 (대부분 콜백)에 전달 될 때; 그리고 2. 클래스의 멤버 메소드에서 클로저가 호출 될 때.</target>
        </trans-unit>
        <trans-unit id="40cd6970e0b84898911ea5a78a1e7dfb515b5bcf" translate="yes" xml:space="preserve">
          <source>So the above code will log &lt;code&gt;{myObj: &quot;is cool&quot;}, [1, 2, 3]&lt;/code&gt; in the console. Pretty nice way to change the value of &lt;code&gt;this&lt;/code&gt; in any function.</source>
          <target state="translated">따라서 위 코드는 콘솔에 &lt;code&gt;{myObj: &quot;is cool&quot;}, [1, 2, 3]&lt;/code&gt; 을 기록합니다. 모든 기능 &lt;code&gt;this&lt;/code&gt; 값을 변경하는 아주 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="522ff2123214afbd475283a209499ed36291eb73" translate="yes" xml:space="preserve">
          <source>So yeah, since &lt;code&gt;function&lt;/code&gt;s are also &lt;code&gt;Objects&lt;/code&gt; (and in-fact first class variables in Javascript), even functions have methods which are... well, functions themselves.</source>
          <target state="translated">그렇습니다. &lt;code&gt;function&lt;/code&gt; 는 &lt;code&gt;Objects&lt;/code&gt; (그리고 실제로는 JavaScript의 첫 번째 클래스 변수)이기 때문에 함수조차도 함수 자체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f3b2a9afffa56a30d094f3e24ed8cf50303768c" translate="yes" xml:space="preserve">
          <source>So, everything else can be described by how it translates into &lt;code&gt;functionObject.call&lt;/code&gt;.</source>
          <target state="translated">따라서 다른 모든 것은 &lt;code&gt;functionObject.call&lt;/code&gt; 로 변환하는 방법으로 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="790a624bffefadda17b70c21c4b01c0c58df0ee7" translate="yes" xml:space="preserve">
          <source>So, just like the rules above</source>
          <target state="translated">위의 규칙과 마찬가지로</target>
        </trans-unit>
        <trans-unit id="914ff3d89be46de1e5d463f23bd9e8ec17bc3b6b" translate="yes" xml:space="preserve">
          <source>So, that's the same behavior as:</source>
          <target state="translated">따라서 다음과 같은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="3752107636af96b291a982ec3e8aba9fd5bc3976" translate="yes" xml:space="preserve">
          <source>Sometimes, you don't like the fact that &lt;code&gt;this&lt;/code&gt; changes with scope, especially nested scope. Take a look at the following example.</source>
          <target state="translated">때로는 범위, 특히 중첩 범위에 따라 변경되는 사실 &lt;code&gt;this&lt;/code&gt; 마음에 들지 않습니다. 다음 예를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="3dcb878280db0a0ee997fedf6a06a9e25d983362" translate="yes" xml:space="preserve">
          <source>Summary &lt;code&gt;this&lt;/code&gt; Javascript:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 자바 스크립트를 요약 하면 :</target>
        </trans-unit>
        <trans-unit id="870ae78c66193024be4337db8b9c61bdcf897d92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.&lt;/code&gt; operator when used with a function on the right and an object on the left effectively means &quot;pass object as &lt;code&gt;this&lt;/code&gt; to function.</source>
          <target state="translated">&lt;code&gt;.&lt;/code&gt; 오른쪽에있는 함수와 왼쪽에있는 개체와 함께 사용되는 연산자는 &quot;기능에 따라 개체를 전달합니다&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5dc19a793d0ce3f7b84a548e2b6a4dbb98f0fbaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 키워드</target>
        </trans-unit>
        <trans-unit id="5c7d3a19cb8b6bc930a3cf143fd794ae8cdebd95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; keyword behaves differently in JavaScript compared to other languages. In Object Oriented languages, the &lt;code&gt;this&lt;/code&gt; keyword refers to the current instance of the class. In JavaScript the value of &lt;code&gt;this&lt;/code&gt; is determined by the invocation context of function (&lt;em&gt;&lt;code&gt;context.function()&lt;/code&gt;&lt;/em&gt;) and where it is called.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 키워드는 JavaScript에서 다른 언어와 다르게 작동합니다. 객체 지향 언어에서 &lt;code&gt;this&lt;/code&gt; 키워드는 클래스의 현재 인스턴스를 나타냅니다. JavaScript &lt;code&gt;this&lt;/code&gt; 값은 함수의 호출 컨텍스트 ( &lt;em&gt; &lt;code&gt;context.function()&lt;/code&gt; &lt;/em&gt; ) 및 호출되는 위치에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="8118d827d29ceed5b5f484813a32a7dbdecf8a1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; keyword evaluates to the value of the ThisBinding of the current execution context</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 키워드는 현재 실행 컨텍스트의 ThisBinding 값으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="21236dd5251fb6c854cd82db5d7b667a4cfa5baa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; keyword is &lt;a href=&quot;http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/#When_this_is_most_misunderstood_and_becomes_tricky&quot;&gt;most misunderstood&lt;/a&gt; when: 1) we borrow a method that uses &lt;code&gt;this&lt;/code&gt;, 2) we assign a method that uses &lt;code&gt;this&lt;/code&gt; to a variable, 3) a function that uses &lt;code&gt;this&lt;/code&gt; is passed as a callback function, and 4) &lt;code&gt;this&lt;/code&gt; is used inside a closure &amp;mdash; an inner function. &lt;sup&gt;(2)&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 키워드는 다음과 같은 경우에 &lt;a href=&quot;http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/#When_this_is_most_misunderstood_and_becomes_tricky&quot;&gt;가장 잘 이해되지&lt;/a&gt; 않습니다 .1) &lt;code&gt;this&lt;/code&gt; 사용하는 메소드를 빌려 간다 .2) &lt;code&gt;this&lt;/code&gt; 사용하는 메소드를 변수에 할당한다. 클로저 내부에서 사용 &amp;ndash; 내부 함수. &lt;sup&gt;(2)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0273a69ad15752e42d17d46c263b491390395350" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;this&lt;/em&gt; reference ALWAYS refers to (and holds the value of) an
  object&amp;mdash;a singular object&amp;mdash;and it is usually used inside a function or a
  method, although it can be used outside a function in the global
  scope. Note that when we use strict mode, this holds the value of
  undefined in global functions and in anonymous functions that are not
  bound to any object.</source>
          <target state="translated">&lt;em&gt;이&lt;/em&gt; 참조는 항상 객체 (단일 객체)를 참조하며 그 값을 유지하며 일반적으로 전역 범위에서 함수 외부에서 사용할 수 있지만 함수 나 메소드 내부에서 사용됩니다. 엄격 모드를 사용하면 전역 함수와 객체에 바인딩되지 않은 익명 함수에서 undefined 값이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0bfa8fcb62a7f1e00d91e50841a62afe63da5f55" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; in above examples refer to &quot;button&quot; element and the
&quot;div&quot; element respectively.</source>
          <target state="translated">위 예제에서 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 는 각각 &quot;button&quot;요소와 &quot;div&quot;요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f95de8ec5b813d1517bdbcb77f6c0c1a7fb9c6c1" translate="yes" xml:space="preserve">
          <source>The above code clearly shows that the &quot;this&quot; value for any &quot;NON
Bound Function&quot; can be altered through &lt;strong&gt;call/apply&lt;/strong&gt;. Also,if the
&lt;strong&gt;&quot;this&quot;&lt;/strong&gt; parameter is  not explicitly passed to &lt;strong&gt;call/apply&lt;/strong&gt;, &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; (and hence the value of &quot;this&quot;) is set to &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; in Non strict mode and &lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; in strict mode.</source>
          <target state="translated">위의 코드는 &quot;NON Bound Function&quot;의 &quot;this&quot;값이 &lt;strong&gt;call / apply를&lt;/strong&gt; 통해 변경 될 수 있음을 분명히 보여줍니다. 또한 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 매개 변수가 명시 적으로 &lt;strong&gt;call / apply에&lt;/strong&gt; 전달되지 않으면 &lt;strong&gt;&quot;현재 오브젝트&quot;&lt;/strong&gt; (따라서 &quot;this&quot;값)는 엄격하지 않은 모드에서 &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; 로 설정되고 엄격 모드에서는 &lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; 로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c6c331ad3ba8cbd437f9af0ab0775ebb81b757f7" translate="yes" xml:space="preserve">
          <source>The code above translates to</source>
          <target state="translated">위의 코드는</target>
        </trans-unit>
        <trans-unit id="48a4deba793f1321a1d058e028490a18d81f4854" translate="yes" xml:space="preserve">
          <source>The constructor of this &lt;code&gt;Object&lt;/code&gt; has its constructor set to &lt;code&gt;Person&lt;/code&gt;. Also, note that &lt;code&gt;typeof awal&lt;/code&gt; would return &lt;code&gt;Object&lt;/code&gt; only.</source>
          <target state="translated">이 &lt;code&gt;Object&lt;/code&gt; 의 생성자에는 생성자가 &lt;code&gt;Person&lt;/code&gt; 으로 설정되어 있습니다. 또한 &lt;code&gt;typeof awal&lt;/code&gt; 은 &lt;code&gt;Object&lt;/code&gt; 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="598e31c8f2d3b5ebb3d9a975927bac31dd78c17d" translate="yes" xml:space="preserve">
          <source>The following describes each of this contexts one by one:</source>
          <target state="translated">다음은이 컨텍스트 각각을 하나씩 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5ffc86b9fbcb86bd5ce90c80ade9aac7f6674126" translate="yes" xml:space="preserve">
          <source>The following summarizes the entire article</source>
          <target state="translated">다음은 전체 기사를 요약 한 것입니다</target>
        </trans-unit>
        <trans-unit id="b9c4aa48554b8690755f430230adc7aead0e4875" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;Person&lt;/code&gt; itself is now invoked; &lt;code&gt;this&lt;/code&gt; being a reference to the newly constructed object &lt;code&gt;awal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Person&lt;/code&gt; 함수 자체가 이제 호출됩니다. &lt;code&gt;this&lt;/code&gt; 새롭게 구성된 객체 &lt;code&gt;awal&lt;/code&gt; 에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="d26b585e0f11b2474001731ad046d99b221862ac" translate="yes" xml:space="preserve">
          <source>The idea behind &lt;code&gt;this&lt;/code&gt; is to understand that the function invocation types have the significant importance on setting &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="translated">이에 대한 아이디어는 함수 호출 유형 &lt;code&gt;this&lt;/code&gt; 값을 설정하는 데 매우 중요하다는 것을 이해하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd9df2dd9475c12d7d70a035ffbc3060e8d9dccf" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;myFun.call(obj);&lt;/code&gt; is invoking the special built-in function &lt;code&gt;Function.prototype.call()&lt;/code&gt;, which accepts &lt;code&gt;thisArg&lt;/code&gt; as the first argument.</source>
          <target state="translated">줄 &lt;code&gt;myFun.call(obj);&lt;/code&gt; 는 내장 함수 특수 함수 &lt;code&gt;Function.prototype.call()&lt;/code&gt; 호출하여 &lt;code&gt;thisArg&lt;/code&gt; 를 첫 번째 인수로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="205b8665ab9d83e5add811cf8bd2f784d1caf68a" translate="yes" xml:space="preserve">
          <source>The reason for writing &quot;in most other cases&quot; is because there are eight ECMAScript 5 built-in functions that allow ThisBinding to be specified in the arguments list. These special functions take a so-called &lt;code&gt;thisArg&lt;/code&gt; which becomes the ThisBinding when calling the function (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.3&quot;&gt;&amp;sect;10.4.3&lt;/a&gt;).</source>
          <target state="translated">&quot;대부분의 다른 경우&quot;를 작성하는 이유는 인수 목록에 ThisBinding을 지정할 수있는 ECMAScript 5 내장 함수가 8 개 있기 때문입니다. 이러한 특수 함수는 소위 &lt;code&gt;thisArg&lt;/code&gt; 를 사용하여 함수를 호출 할 때 ThisBinding이됩니다 ( &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.3&quot;&gt;&amp;sect;10.4.3&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a1d54f980faedf5c96fee5c403683ca230e1320f" translate="yes" xml:space="preserve">
          <source>The same above behavior is achieved when we attach the function to the event handler using Microsoft's Event Registration model method &lt;code&gt;attachEvent&lt;/code&gt;. Instead of assigning the function to the event handler (and the thus making the function method of the element), it calls the function on the event (effectively calling it in global context).</source>
          <target state="translated">Microsoft의 이벤트 등록 모델 메소드 인 &lt;code&gt;attachEvent&lt;/code&gt; 를 사용하여 함수를 이벤트 핸들러에 첨부하면 위와 동일한 동작이 수행됩니다. 함수를 이벤트 핸들러에 할당하는 대신 (요소의 함수 메소드를 작성하는) 대신 이벤트에서 함수를 호출합니다 (글로벌 컨텍스트에서 효과적으로 호출).</target>
        </trans-unit>
        <trans-unit id="f835f6ede39f09721b6b3a08a6766f6a816b4a55" translate="yes" xml:space="preserve">
          <source>The value of &quot;this&quot; depends on the &quot;context&quot; in which the function is executed. The context can be any object or the global object, i.e., window.</source>
          <target state="translated">&quot;this&quot;의 값은 함수가 실행되는 &quot;컨텍스트&quot;에 따라 다릅니다. 콘텍스트는 임의의 객체 또는 글로벌 객체, 즉 윈도우 일 수있다.</target>
        </trans-unit>
        <trans-unit id="8f71afcd2f8c39c35d17ede8ea64967e5b3dabc9" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;this&lt;/code&gt; is determined by &lt;strong&gt;how the function is invoked not, where it was created!&lt;/strong&gt;</source>
          <target state="translated">이것의 값은 &lt;strong&gt;함수가 어떻게 호출되는지, 어디서 생성&lt;/strong&gt; 되었는지에 의해 결정됩니다 &lt;strong&gt;!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85a035ea25fb197d75ddcfad6ad7ecc47bbf83df" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; is fixed for a Bound function and cannot be
overriden by &lt;strong&gt;call&lt;/strong&gt; and &lt;strong&gt;apply&lt;/strong&gt; methods of the function.</source>
          <target state="translated">&lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 값은 바운드 함수에 대해 고정되어 있으며 함수의 &lt;strong&gt;호출&lt;/strong&gt; 및 &lt;strong&gt;적용&lt;/strong&gt; 메소드로 대체 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="732a7262b87dd35272a2fefa011c384eaf4c1806" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; within a Non Bound function can be overriden by
&lt;strong&gt;call&lt;/strong&gt; and &lt;strong&gt;apply&lt;/strong&gt; methods of the function.</source>
          <target state="translated">비 바인드 함수 내의 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 값은 함수의 &lt;strong&gt;호출&lt;/strong&gt; 및 &lt;strong&gt;적용&lt;/strong&gt; 메소드로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="986983b3bc829dee13e4af0f6cd58cc64ea6a541" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; within a Non Bound function is the reference to object in context of which the function is invoked (&lt;strong&gt;&quot;current object&quot;&lt;/strong&gt;)</source>
          <target state="translated">비 바운드 함수 내 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 값은 함수가 호출 된 컨텍스트에서 오브젝트에 대한 참조입니다 ( &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="94e5e1e54d6e891723770f7f55f8c8aa368f150f" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; within a constructor is the object that is being
created and initialized</source>
          <target state="translated">생성자 내 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 값은 작성 및 초기화되는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="5ff56d075173f67c99015d872ca5e48d81c42ed8" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; within an inline DOM event handler is reference
to the element for which the event handler is given.</source>
          <target state="translated">인라인 DOM 이벤트 핸들러 내의 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 값은 이벤트 핸들러가 제공되는 요소에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="23a806a2918ae62d9efe5b8e4d50db0d562119c4" translate="yes" xml:space="preserve">
          <source>There are Four Scenarios where &lt;em&gt;this&lt;/em&gt; can be confusing:</source>
          <target state="translated">혼동 될 수있는 네 가지 시나리오가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e38bf69ca4f13895c35d97268be9b7f0be29ccd7" translate="yes" xml:space="preserve">
          <source>There are different ways to do this. If you have called native methods in Javascript like &lt;code&gt;forEach&lt;/code&gt; and &lt;code&gt;slice&lt;/code&gt;, you should already know that the &lt;code&gt;this&lt;/code&gt; variable in that case refers to the &lt;code&gt;Object&lt;/code&gt; on which you called that function (Note that in javascript, just about everything is an &lt;code&gt;Object&lt;/code&gt;, including &lt;code&gt;Array&lt;/code&gt;s and &lt;code&gt;Function&lt;/code&gt;s). Take the following code for example.</source>
          <target state="translated">이를 수행하는 다른 방법이 있습니다. &lt;code&gt;forEach&lt;/code&gt; 및 &lt;code&gt;slice&lt;/code&gt; 와 같은 Javascript에서 원시 메소드를 호출 한 경우, &lt;code&gt;this&lt;/code&gt; 변수는 해당 함수를 호출 한 &lt;code&gt;Object&lt;/code&gt; 를 참조한다는 것을 이미 알고 있어야합니다 (자바 스크립트에서는 &lt;code&gt;Array&lt;/code&gt; 를 포함하여 거의 모든 것이 &lt;code&gt;Object&lt;/code&gt; 입니다 . 및 &lt;code&gt;Function&lt;/code&gt; ). 예를 들어 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="279973f865726145d86bc2b948936a3c5ea84f1b" translate="yes" xml:space="preserve">
          <source>There are various ways to define an object's prototype, the most common in 2019 is the &lt;code&gt;class&lt;/code&gt; keyword. For the purposes of &lt;code&gt;this&lt;/code&gt; though it doesn't matter. What matters is that as it looks in object &lt;code&gt;a&lt;/code&gt; for property &lt;code&gt;b&lt;/code&gt; if it finds property &lt;code&gt;b&lt;/code&gt; on the object or in it's prototype chain if &lt;code&gt;b&lt;/code&gt; ends up being a function then the same rules as above apply. The function &lt;code&gt;b&lt;/code&gt; references will be called using the &lt;code&gt;call&lt;/code&gt; method and passing &lt;code&gt;a&lt;/code&gt; as objectForThis as shown a the top of this answer.</source>
          <target state="translated">객체의 프로토 타입을 정의하는 다양한 방법이 있으며 2019 년에 가장 일반적으로 사용되는 것은 &lt;code&gt;class&lt;/code&gt; 키워드입니다. 이 목적을 위해 그것은 중요하지 않습니다. 중요한 것은 객체 &lt;code&gt;a&lt;/code&gt; 속성 &lt;code&gt;b&lt;/code&gt; 를 객체 에서 찾은 경우 객체 &lt;code&gt;b&lt;/code&gt; 에서 속성 b 를 찾거나 프로토 타입 체인에서 &lt;code&gt;b&lt;/code&gt; 가 함수 인 경우 위와 동일한 규칙이 적용된다는 것입니다. 함수 &lt;code&gt;b&lt;/code&gt; 참조는 &lt;code&gt;call&lt;/code&gt; 메소드를 사용하여이 응답의 맨 위에 표시된 것처럼 objectForThis로 &lt;code&gt;a&lt;/code&gt; 를 전달 합니다 .</target>
        </trans-unit>
        <trans-unit id="4b176e3b91607484833f86d66ef5e37c3e87f616" translate="yes" xml:space="preserve">
          <source>There is a lot of confusion regarding how &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; keyword is interpreted in JavaScript. Hopefully this article will lay all those to rest once and for all. And a lot more. Please read the entire article carefully. Be forewarned that this article is long.</source>
          <target state="translated">JavaScript에서 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 키워드가 해석되는 방식과 관련하여 많은 혼란 &lt;strong&gt;이&lt;/strong&gt; 있습니다. 이 기사가 모든 사람들이 한 번에 휴식을 취하기를 바랍니다. 그리고 훨씬 더. 전체 기사를주의 깊게 읽으십시오. 이 기사는 길다.</target>
        </trans-unit>
        <trans-unit id="9bf2606f55ac02610bfeca5231ecaa8045e7e025" translate="yes" xml:space="preserve">
          <source>There is always some value supplied for &lt;code&gt;objectForThis&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;objectForThis&lt;/code&gt; 에 항상 제공된 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f5b72ee2e27b15caab5b155ad2ccf879983f917" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special case I didn&amp;rsquo;t yet mention. When constructing a new object via the &lt;code&gt;new&lt;/code&gt; operator, the JavaScript interpreter creates a new, empty object, sets some internal properties, and then calls the constructor function on the new object. Thus, when a function is called in a constructor context, the value of &lt;code&gt;this&lt;/code&gt; is the new object that the interpreter created:</source>
          <target state="translated">내가 아직 언급하지 않은 특별한 경우가 있습니다. &lt;code&gt;new&lt;/code&gt; 연산자를 통해 새 객체를 만들 때 JavaScript 인터프리터는 비어있는 새 객체를 만들고 내부 속성을 설정 한 다음 새 객체에서 생성자 함수를 호출합니다. 따라서 생성자 컨텍스트에서 함수가 호출 될 때이 값은 인터프리터가 만든 새 객체입니다.</target>
        </trans-unit>
        <trans-unit id="2d3a18e72bf0f045f8f3de4d4504d75c62e5dcda" translate="yes" xml:space="preserve">
          <source>These methods allows to write a function once and invoke it in different context. In other words, they allows to specify the value of &lt;code&gt;this&lt;/code&gt; which will be used while the function is being executed. They also take any parameters to be passed to the original function when it is invoked.</source>
          <target state="translated">이 메소드를 사용하면 함수를 한 번 작성하고 다른 컨텍스트에서 호출 할 수 있습니다. 즉, 함수가 실행되는 동안 사용될 값을 지정할 수 있습니다. 또한 호출 될 때 원래 함수로 전달되는 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4ade0a7126aef80885995d3c6e7d2a3b5b9a749a" translate="yes" xml:space="preserve">
          <source>These special built-in functions are:</source>
          <target state="translated">이러한 특수 내장 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85527d5006265cfde99894b7c55c9fb14d1c3dc8" translate="yes" xml:space="preserve">
          <source>This is a typical example of using &lt;code&gt;call&lt;/code&gt;. It basically takes the first parameter and sets &lt;code&gt;this&lt;/code&gt; in the function &lt;code&gt;foo&lt;/code&gt; as a reference to &lt;code&gt;thisArg&lt;/code&gt;.  All other parameters passed to &lt;code&gt;call&lt;/code&gt; is passed to the function &lt;code&gt;foo&lt;/code&gt; as arguments.</source>
          <target state="translated">이것은 &lt;code&gt;call&lt;/code&gt; 사용의 전형적인 예입니다. 기본적으로 첫 번째 매개 변수를 사용하여 &lt;code&gt;this&lt;/code&gt; 함수에서 &lt;code&gt;thisArg&lt;/code&gt; 에 대한 참조로 이것을 설정 합니다 . &lt;code&gt;call&lt;/code&gt; 에 전달 된 다른 모든 매개 변수는 인수로 함수 &lt;code&gt;foo&lt;/code&gt; 에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="29ed5f10284269291bb711c4ff11d342e2767871" translate="yes" xml:space="preserve">
          <source>This is different from Python, in which accessing a method (&lt;code&gt;obj.myMethod&lt;/code&gt;) creates a &lt;a href=&quot;http://docs.python.org/3/library/stdtypes.html#methods&quot;&gt;bound method object&lt;/a&gt;.</source>
          <target state="translated">이는 메소드 ( &lt;code&gt;obj.myMethod&lt;/code&gt; )에 액세스하여 &lt;a href=&quot;http://docs.python.org/3/library/stdtypes.html#methods&quot;&gt;바인딩 된 메소드 객체를&lt;/a&gt; 작성하는 Python과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a132674b519e683c1c771b823eb5a1e2de6af493" translate="yes" xml:space="preserve">
          <source>This is the best explanation I've seen: &lt;a href=&quot;http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/&quot;&gt;Understand JavaScripts &lt;em&gt;this&lt;/em&gt; with Clarity&lt;/a&gt;</source>
          <target state="translated">이것이 내가 본 가장 좋은 설명 &lt;a href=&quot;http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/&quot;&gt;입니다. Clarity로 JavaScript 이해하기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b0808c58b0591e7278bd423057d577254441336b" translate="yes" xml:space="preserve">
          <source>This is the case for JavaScript code that is evaluated at the top-level, e.g. when directly inside a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 내부에있을 때와 같이 최상위 수준에서 평가되는 JavaScript 코드의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="802391aac07cdb035195e6978ec32a12d3125ef9" translate="yes" xml:space="preserve">
          <source>This is what both &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;=&amp;gt;&lt;/code&gt; functions effectively do. They are more syntactic sugar. They effectively build a new invisible function exactly like &lt;code&gt;bar&lt;/code&gt; above that explicitly sets &lt;code&gt;this&lt;/code&gt; before it calls whatever function is specified. In the case of bind &lt;code&gt;this&lt;/code&gt; is set to whatever you pass to &lt;code&gt;bind&lt;/code&gt;.</source>
          <target state="translated">이것이 &lt;code&gt;bind&lt;/code&gt; 와 &lt;code&gt;=&amp;gt;&lt;/code&gt; 함수가 효과적으로하는 것입니다. 그들은 더 구문 설탕입니다. 그들은 명시 된 &lt;code&gt;bar&lt;/code&gt; 같이 정확하게 보이지 않는 새로운 함수를 효과적으로 작성하여 지정된 함수를 호출하기 전에 이것을 명시 적으로 설정합니다. 바인드의 경우 &lt;code&gt;this&lt;/code&gt; &lt;code&gt;bind&lt;/code&gt; 전달하는 모든 것으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3f377690fefdec48899ec0d15066da36044d96e2" translate="yes" xml:space="preserve">
          <source>This mindset is correct when dealing with &lt;code&gt;this&lt;/code&gt; and will save you from headache.</source>
          <target state="translated">이 사고 방식은이 문제를 처리 할 때 정확하며 두통을 예방합니다.</target>
        </trans-unit>
        <trans-unit id="fe922a11381e67c113153def83bf53886fc17c59" translate="yes" xml:space="preserve">
          <source>This new &lt;code&gt;Object&lt;/code&gt; would be assigned the prototype of &lt;code&gt;Person.prototype&lt;/code&gt;. This means that any method or property in the &lt;code&gt;Person&lt;/code&gt; prototype would be available to all instances of &lt;code&gt;Person&lt;/code&gt;, including &lt;code&gt;awal&lt;/code&gt;.</source>
          <target state="translated">이 새로운 &lt;code&gt;Object&lt;/code&gt; 에는 &lt;code&gt;Person.prototype&lt;/code&gt; 의 프로토 타입이 할당됩니다. 즉, &lt;code&gt;Person&lt;/code&gt; 프로토 타입의 모든 메소드 또는 속성은 &lt;code&gt;awal&lt;/code&gt; 을 포함하여 &lt;code&gt;Person&lt;/code&gt; 의 모든 인스턴스에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8390b31573bde1e5e11596eda14bd9837b0066dd" translate="yes" xml:space="preserve">
          <source>This occurs when calling a function. If a function is called on an object, such as in &lt;code&gt;obj.myMethod()&lt;/code&gt; or the equivalent &lt;code&gt;obj[&quot;myMethod&quot;]()&lt;/code&gt;, then ThisBinding is set to the object (&lt;code&gt;obj&lt;/code&gt; in the example; &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-13.2.1&quot;&gt;&amp;sect;13.2.1&lt;/a&gt;). In most other cases, ThisBinding is set to the global object (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.3&quot;&gt;&amp;sect;10.4.3&lt;/a&gt;).</source>
          <target state="translated">함수를 호출 할 때 발생합니다. &lt;code&gt;obj.myMethod()&lt;/code&gt; 또는 이와 동등한 &lt;code&gt;obj[&quot;myMethod&quot;]()&lt;/code&gt; 와 같이 객체에서 함수가 호출되면 ThisBinding이 객체로 설정됩니다 (예제에서 &lt;code&gt;obj&lt;/code&gt; ; &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-13.2.1&quot;&gt;&amp;sect;13.2.1&lt;/a&gt; ). 대부분의 경우이 바인딩은 전역 객체 ( &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.3&quot;&gt;&amp;sect;10.4.3&lt;/a&gt; )로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="31e21fd5682329c65723d9fdb2afb15437924824" translate="yes" xml:space="preserve">
          <source>This one was tricky. When evaluating the eval code, &lt;code&gt;this&lt;/code&gt; is &lt;code&gt;obj&lt;/code&gt;. However, in the eval code, &lt;code&gt;myFun&lt;/code&gt; is not called on an object, so ThisBinding is set to &lt;code&gt;window&lt;/code&gt; for the call.</source>
          <target state="translated">이건 까다로웠다. 평가 코드를 평가할 때 &lt;code&gt;this&lt;/code&gt; &lt;code&gt;obj&lt;/code&gt; 입니다. 그러나 평가 코드에서는 &lt;code&gt;myFun&lt;/code&gt; 이 객체에서 호출되지 않으므로 ThisBinding이 호출 &lt;code&gt;window&lt;/code&gt; 으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="906f21f1345827c9f5f29e264d69b70a0a4c77a2" translate="yes" xml:space="preserve">
          <source>ThisBinding is set to the global object &lt;em&gt;as if&lt;/em&gt; executing in the initial global execution context (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;&amp;sect;10.4.2&lt;/a&gt; (1)).</source>
          <target state="translated">이 바인딩은 초기 전역 실행 컨텍스트에서 실행되는 &lt;em&gt;것처럼&lt;/em&gt; 전역 개체 &lt;em&gt;로&lt;/em&gt; 설정됩니다 ( &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;&amp;sect;10.4.2&lt;/a&gt; (1)).</target>
        </trans-unit>
        <trans-unit id="05a9ff5b30e366baba755d7af02bdee90564da08" translate="yes" xml:space="preserve">
          <source>ThisBinding is something that the JavaScript interpreter maintains as it evaluates JavaScript code, like a special CPU register which holds a reference to an object. The interpreter updates the ThisBinding whenever establishing an execution context in one of only three different cases:</source>
          <target state="translated">ThisBinding은 객체에 대한 참조를 보유하는 특수 CPU 레지스터와 같이 JavaScript 코드를 평가할 때 JavaScript 인터프리터가 유지 관리하는 것입니다. 인터프리터는 세 가지 경우 중 하나에서 실행 컨텍스트를 설정할 때마다 ThisBinding을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="99dd9cee0f0141c71707204de7a8eb68227dcb58" translate="yes" xml:space="preserve">
          <source>Those are the rules for plain JavaScript. When you begin using JavaScript libraries (e.g. jQuery), you may find that certain library functions manipulate the value of &lt;code&gt;this&lt;/code&gt;. The developers of those JavaScript libraries do this because it tends to support the most common use cases, and users of the library typically find this behavior to be more convenient. When passing callback functions referencing &lt;code&gt;this&lt;/code&gt; to library functions, you should refer to the documentation for any guarantees about what the value of &lt;code&gt;this&lt;/code&gt; is when the function is called.</source>
          <target state="translated">이것들은 일반 JavaScript의 규칙입니다. JavaScript 라이브러리 (예 : jQuery)를 사용하기 시작하면 특정 라이브러리 함수가 &lt;code&gt;this&lt;/code&gt; 의 값을 조작한다는 것을 알 수 있습니다. JavaScript 라이브러리의 개발자는 가장 일반적인 사용 사례를 지원하는 경향이 있기 때문에이 작업을 수행하며 라이브러리 사용자는 일반적으로이 동작이 더 편리하다는 것을 알게됩니다. &lt;code&gt;this&lt;/code&gt; 참조하는 콜백 함수를 라이브러리 함수로 전달할 때 함수가 호출 될 때의 값에 대한 보증은 설명서를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2e075f690095f8a07098f5032ffef152a676d5a" translate="yes" xml:space="preserve">
          <source>Try it out; you'll begin to like this pattern of programming</source>
          <target state="translated">사용해보십시오. 이 프로그래밍 패턴을 좋아하기 시작합니다</target>
        </trans-unit>
        <trans-unit id="b31340518b4d3450382a16fe42d7b550a535da55" translate="yes" xml:space="preserve">
          <source>Unless you &lt;code&gt;bind&lt;/code&gt; the context</source>
          <target state="translated">컨텍스트를 &lt;code&gt;bind&lt;/code&gt; 하지 않는 한</target>
        </trans-unit>
        <trans-unit id="44c1de29d488c2efbb55dbbf89180707d408e09f" translate="yes" xml:space="preserve">
          <source>Use of &lt;em&gt;bind&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;바인드&lt;/em&gt; 사용</target>
        </trans-unit>
        <trans-unit id="130803684886f32a73870ec3182481aa18a857a0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;bind&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; 사용.</target>
        </trans-unit>
        <trans-unit id="c9f1a654f7867f9709c86fb54556d6b1085312f6" translate="yes" xml:space="preserve">
          <source>Usually the value of &lt;code&gt;this&lt;/code&gt; is determined by the Object which is left of the dot. (&lt;code&gt;window&lt;/code&gt; in global space)</source>
          <target state="translated">일반적 &lt;code&gt;this&lt;/code&gt; 값은 점의 왼쪽에있는 Object에 의해 결정됩니다. (글로벌 공간의 &lt;code&gt;window&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3fe0e54dcbb7644fba3d3f361c514bd846e8caf6" translate="yes" xml:space="preserve">
          <source>We can try above points with functions too. However there are some differences.</source>
          <target state="translated">함수로 위의 포인트를 시험해 볼 수도 있습니다. 그러나 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="02ee79a3f4e52fa8dc6015c8800e56de11fbd2ff" translate="yes" xml:space="preserve">
          <source>We use this similar to the way we use pronouns in natural languages like English:  &amp;ldquo;John is running fast because &lt;strong&gt;&lt;em&gt;he&lt;/em&gt;&lt;/strong&gt; is trying to catch the train.&amp;rdquo; Instead we could have written &amp;ldquo;&amp;hellip; &lt;strong&gt;&lt;em&gt;John&lt;/em&gt;&lt;/strong&gt; is trying to catch the train&amp;rdquo;.</source>
          <target state="translated">우리는 영어와 같은 자연 언어로 대명사를 사용하는 것과 유사한 방식으로이 단어를 사용합니다.&amp;ldquo;요한은 기차를 타려고하기 때문에 빨리 달리고 있습니다.&amp;rdquo; 대신에 우리는&amp;ldquo;&amp;hellip; &lt;strong&gt;&lt;em&gt;요한&lt;/em&gt;&lt;/strong&gt; 이 기차를 타려고 노력하고 있습니다&amp;rdquo;라고 쓸 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="59c84c3a56d40f1298569aad07647b4063c6d313" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;var that = this&lt;/code&gt; means in JavaScript</source>
          <target state="translated">&lt;code&gt;var that = this&lt;/code&gt; JavaScript에서 의미 하는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d6960afa81986e4b8866c2cd069e74c4a085e98a" translate="yes" xml:space="preserve">
          <source>What holds the future</source>
          <target state="translated">미래를 잡는 것</target>
        </trans-unit>
        <trans-unit id="8522002fd86f4ae1d009f9373919bcfac6e5aa3c" translate="yes" xml:space="preserve">
          <source>What if we call the function as a method with Object-dot notation?</source>
          <target state="translated">객체 점 표기법을 사용하여 함수를 함수로 호출하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="e90a818f0c0f181348f3ffa33436750e9c56414d" translate="yes" xml:space="preserve">
          <source>What if we use the &lt;code&gt;new&lt;/code&gt; keyword?</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 키워드를 사용하면 어떻게 되나요?</target>
        </trans-unit>
        <trans-unit id="0b741f1c36a30a2f39adb4807b11baf832686d62" translate="yes" xml:space="preserve">
          <source>What is held in &lt;code&gt;this&lt;/code&gt; by default?</source>
          <target state="translated">기본적으로 무엇이 유지됩니까?</target>
        </trans-unit>
        <trans-unit id="f31de30789ea80d6b68979bdfc23922eb652ecfe" translate="yes" xml:space="preserve">
          <source>What is the value of &lt;code&gt;this&lt;/code&gt; at the marked line when &lt;code&gt;obj.staticFunction()&lt;/code&gt; is executed? Why?</source>
          <target state="translated">&lt;code&gt;obj.staticFunction()&lt;/code&gt; 이 실행될 때 표시된 줄의 값은 무엇입니까? 왜?</target>
        </trans-unit>
        <trans-unit id="19602fe263ba02a9e70190487cdbb1f5d8295602" translate="yes" xml:space="preserve">
          <source>What is the value of &lt;code&gt;this&lt;/code&gt; at the marked line? Why?</source>
          <target state="translated">표시된 줄에서 &lt;code&gt;this&lt;/code&gt; 의 가치는 무엇입니까? 왜?</target>
        </trans-unit>
        <trans-unit id="10b02218e944261b661613e959beb9dc45a0a0c1" translate="yes" xml:space="preserve">
          <source>What value has &lt;code&gt;this&lt;/code&gt; where the arrow function is &lt;em&gt;defined&lt;/em&gt;?</source>
          <target state="translated">화살표 기능이 &lt;em&gt;정의 된&lt;/em&gt; 위치에 어떤 값이 있습니까?</target>
        </trans-unit>
        <trans-unit id="e78621a0c74b5518e2c62eeba51b08b351f0dc5e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use strict&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; in global and in anonymous functions that are not bound to any object holds a value of &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;use strict&lt;/code&gt; 하면 객체에 바인딩되지 않은 전역 함수 및 익명 함수에서 &lt;code&gt;undefined&lt;/code&gt; 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7834bcbc1ad278f4ac5802fab1061efa51a8ede7" translate="yes" xml:space="preserve">
          <source>When a &lt;strong&gt;&quot;Non Bound Function&quot;&lt;/strong&gt; is called through
&lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;functionName.apply&lt;/em&gt;&lt;/strong&gt;, the &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; (and hence the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) is set to the value of
&lt;strong&gt;&quot;this&quot;&lt;/strong&gt; parameter (first parameter) passed to &lt;strong&gt;call/apply&lt;/strong&gt;. The following code demonstrates the same.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; 또는 &lt;strong&gt;&lt;em&gt;functionName.apply를&lt;/em&gt;&lt;/strong&gt; 통해 &lt;strong&gt;&quot;Non Bound Function&quot;&lt;/strong&gt; 을 호출하면 &lt;strong&gt;&quot;현재 객체&quot;&lt;/strong&gt; (따라서 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 값)가 &lt;strong&gt;호출에&lt;/strong&gt; 전달 된 &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; 매개 변수 (첫 번째 매개 변수)의 값으로 설정됩니다. &lt;strong&gt;/ 적용&lt;/strong&gt; 다음 코드는 동일하게 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="51ee7e3f1872cc53a0ea74134a7dcd791782c6b5" translate="yes" xml:space="preserve">
          <source>When a method which relies on &lt;em&gt;this&lt;/em&gt; is assigned to a variable across contexts, in which case &lt;em&gt;this&lt;/em&gt; references another object than originally intended.</source>
          <target state="translated">&lt;em&gt;이것에&lt;/em&gt; 의존하는 메소드가 컨텍스트를 가로 질러 변수에 할당 될 때, 이것은 원래 의도 된 것 이외의 다른 오브젝트를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="c21e1c0cd6eaa7a56b15d8a8d9f7696b5ea3ba0b" translate="yes" xml:space="preserve">
          <source>When adding event handler through JavaScript, &lt;code&gt;this&lt;/code&gt; refers to DOM element that generated the event.</source>
          <target state="translated">JavaScript를 통해 이벤트 핸들러를 추가 할 때 이벤트를 생성 한 DOM 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f9cdfe0773a82ce634e71531211148636519905c" translate="yes" xml:space="preserve">
          <source>When evaluating code in the initial global execution context, ThisBinding is set to the global object, &lt;code&gt;window&lt;/code&gt; (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.1.1&quot;&gt;&amp;sect;10.4.1.1&lt;/a&gt;).</source>
          <target state="translated">초기 전역 실행 컨텍스트에서 코드를 평가할 때 ThisBinding은 전역 개체 &lt;code&gt;window&lt;/code&gt; ( &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.1.1&quot;&gt;&amp;sect;10.4.1.1&lt;/a&gt; )으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a6a1241496a32c546213391c9684a37c3f770157" translate="yes" xml:space="preserve">
          <source>When having troubles identifying &lt;code&gt;this&lt;/code&gt;, &lt;strong&gt;do not&lt;/strong&gt; ask yourself:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 식별하는 데 문제가있는 경우 스스로에게 묻지 &lt;strong&gt;마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="21c5f0557070fcbb938fbc68a83481429de1ab57" translate="yes" xml:space="preserve">
          <source>When in function is called with the &lt;code&gt;new&lt;/code&gt; keyword the value of &lt;code&gt;this&lt;/code&gt; refers to the newly created object</source>
          <target state="translated">함수에서 &lt;code&gt;new&lt;/code&gt; 키워드를 사용하여 호출 할 때이 값은 새로 작성된 오브젝트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="72b6f37ac72430df1d8593cb30420726f4ef738c" translate="yes" xml:space="preserve">
          <source>When line1 is executed, JavaScript establishes an execution context (EC) for the function call, setting &lt;code&gt;this&lt;/code&gt; to the &lt;strong&gt;object referenced by whatever came before the last &quot;.&quot;&lt;/strong&gt;. so in the last line you can understand that &lt;code&gt;a()&lt;/code&gt; was executed in the global context which is the &lt;code&gt;window&lt;/code&gt;.</source>
          <target state="translated">line1이 실행될 때 JavaScript는 함수 호출에 대한 실행 컨텍스트 (EC)를 설정하고 &lt;code&gt;this&lt;/code&gt; &lt;strong&gt;마지막 &quot;.&quot;이전에 참조 된 객체로&lt;/strong&gt; 설정 합니다 &lt;strong&gt;.&lt;/strong&gt; . 마지막 줄에서 &lt;code&gt;a()&lt;/code&gt; 가 전역 컨텍스트 인 &lt;code&gt;window&lt;/code&gt; 인 것을 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d92af4bea245247c6b438883984c33bed622ea0a" translate="yes" xml:space="preserve">
          <source>When new &lt;code&gt;Person()&lt;/code&gt; is executed, a completely new object is created. &lt;code&gt;Person&lt;/code&gt; is called and its &lt;code&gt;this&lt;/code&gt; is set to reference that new object.</source>
          <target state="translated">new &lt;code&gt;Person()&lt;/code&gt; 이 실행되면 완전히 새로운 객체가 생성됩니다. &lt;code&gt;Person&lt;/code&gt; 이 호출되고 해당 새 오브젝트를 참조하도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="306c3e489768ae032ad521b39781632f59757922" translate="yes" xml:space="preserve">
          <source>When running in a browser, the value of &lt;code&gt;this&lt;/code&gt; would be logged as &lt;code&gt;window&lt;/code&gt;. This is because &lt;code&gt;window&lt;/code&gt; is the global variable in a web browser's scope.</source>
          <target state="translated">브라우저에서 실행할 때이 값은 &lt;code&gt;window&lt;/code&gt; 로 기록됩니다. 이는 &lt;code&gt;window&lt;/code&gt; 가 웹 브라우저 범위의 전역 변수이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c446d142725f86e5cae11afca3f3dc6b1b2b729d" translate="yes" xml:space="preserve">
          <source>When the function is used as a constructor (that is when it is called with &lt;code&gt;new&lt;/code&gt; keyword), &lt;code&gt;this&lt;/code&gt; inside function body points to the new object being constructed.</source>
          <target state="translated">함수가 생성자로 사용되면 (즉, &lt;code&gt;new&lt;/code&gt; 키워드로 호출 될 때) &lt;code&gt;this&lt;/code&gt; 내부 함수 본문은 생성되는 새 객체를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="9363e1921613ca1efc56fe00d3f9bed0e7ff0634" translate="yes" xml:space="preserve">
          <source>When using &lt;em&gt;this&lt;/em&gt; along with the bind, apply, and call methods.</source>
          <target state="translated">&lt;em&gt;이것을&lt;/em&gt; 바인드, 적용 및 호출 메소드와 함께 사용할 때.</target>
        </trans-unit>
        <trans-unit id="3f06c3fcab4e5f6d63f2ca2b14de2f0e5c884eca" translate="yes" xml:space="preserve">
          <source>When we pass a method (that uses &lt;em&gt;this&lt;/em&gt;) as an argument to be used as a callback function.</source>
          <target state="translated">콜백 함수로 사용될 인자로 메소드 ( &lt;em&gt;this&lt;/em&gt; 를 사용 &lt;em&gt;하는&lt;/em&gt; )를 전달할 때.</target>
        </trans-unit>
        <trans-unit id="90f8c4932f81072077b5e29262c1cb9a5e197bac" translate="yes" xml:space="preserve">
          <source>When we use an inner function (a closure). It is important to take note that closures cannot access the outer function&amp;rsquo;s &lt;em&gt;this&lt;/em&gt; variable by using the this keyword because the this variable is accessible only by the function itself, not by inner functions.</source>
          <target state="translated">내부 함수 (클로즈)를 사용할 때. 클로저는 this 키워드를 사용하여 외부 함수 &lt;em&gt;의이&lt;/em&gt; 변수에 액세스 할 수 없다는 점에 유의해야합니다.이 변수는 내부 함수가 아닌 함수 자체만으로 액세스 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="53aef58f636acbf9068698d4996ade0921bbfa2d" translate="yes" xml:space="preserve">
          <source>When you assign function directly to event handlers of an element, use of &lt;code&gt;this&lt;/code&gt; directly inside event handling function refers to the corresponding element. Such direct function assignment can be done using &lt;code&gt;addeventListener&lt;/code&gt; method or through the traditional event registration methods like &lt;code&gt;onclick&lt;/code&gt;.</source>
          <target state="translated">함수를 요소의 이벤트 핸들러에 직접 지정하는 경우 이벤트 처리 함수에서 직접 사용하면 해당 요소를 참조합니다. 이러한 직접 함수 할당은 &lt;code&gt;addeventListener&lt;/code&gt; 메소드를 사용하거나 &lt;code&gt;onclick&lt;/code&gt; 과 같은 기존의 이벤트 등록 메소드를 통해 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baae7a28429ffc8ffa19c066579bec164fbe4c42" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;this&lt;/code&gt; in global context, it is bound to global object (&lt;code&gt;window&lt;/code&gt; in browser)</source>
          <target state="translated">전역 컨텍스트에서 이것을 사용 &lt;code&gt;this&lt;/code&gt; 전역 객체 (브라우저의 &lt;code&gt;window&lt;/code&gt; 에 바인딩됩니다</target>
        </trans-unit>
        <trans-unit id="2cd00de08c1b80d16d90bbb50289443efdf1c856" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;this&lt;/code&gt; inside a function defined in the global context, &lt;code&gt;this&lt;/code&gt; is still bound to global object since the function is actually made a method of global context.</source>
          <target state="translated">전역 컨텍스트에 정의 된 함수 내에서 &lt;code&gt;this&lt;/code&gt; 사용하면 함수가 실제로 전역 컨텍스트의 메소드로 작성되므로 글로벌 오브젝트에 바인드됩니다.</target>
        </trans-unit>
        <trans-unit id="8d179ffca69128a51c69505a9563d82ba3e8c1a4" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;this&lt;/code&gt; inside function that is invoked without any context (i.e. not on any object), it is bound to the global object (&lt;code&gt;window&lt;/code&gt; in browser)(even if the function is defined inside the object) .</source>
          <target state="translated">컨텍스트없이 (즉, 오브젝트에서) 호출되지 않은 &lt;code&gt;this&lt;/code&gt; 내부 함수를 사용하면 글로벌 오브젝트 (브라우저의 &lt;code&gt;window&lt;/code&gt; 에 바인딩됩니다 (함수가 오브젝트 내부에 정의 된 경우에도).</target>
        </trans-unit>
        <trans-unit id="7909d383b2cdb2682dbc516d4d07f2a0250ff82b" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;this&lt;/code&gt; keyword inside an object method, &lt;code&gt;this&lt;/code&gt; is bound to the &quot;immediate&quot; enclosing object.</source>
          <target state="translated">객체 키워드 내 &lt;code&gt;this&lt;/code&gt; 키워드를 사용하면 &quot;즉시&quot;둘러싸는 객체에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="83b1b8689f73a2750a7952c4091b19bcec3490d7" translate="yes" xml:space="preserve">
          <source>Whenever a function is invoked, it is invoked in context of an
object (&lt;strong&gt;&quot;current object&quot;&lt;/strong&gt;). If the &lt;strong&gt;current object&lt;/strong&gt; is not explicitly provided,
the &lt;strong&gt;current object&lt;/strong&gt;  is the &lt;strong&gt;&quot;window object&quot;&lt;/strong&gt; in &lt;strong&gt;NON Strict
Mode&lt;/strong&gt; and &lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; in Strict Mode by default.</source>
          <target state="translated">함수가 호출 될 때마다 객체 ( &lt;strong&gt;&quot;현재 객체&quot;&lt;/strong&gt; )의 컨텍스트에서 호출됩니다. &lt;strong&gt;현재 개체&lt;/strong&gt; 가 명시 적으로 제공되지 않으면 &lt;strong&gt;현재 개체&lt;/strong&gt; 는 &lt;strong&gt;NON Strict Mode&lt;/strong&gt; 의 &lt;strong&gt;&quot;window object&quot;&lt;/strong&gt; 이고 기본적으로 Strict Mode의 &lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c1e2d9b7e33f4aae1fb2ee3c05579c089c455131" translate="yes" xml:space="preserve">
          <source>Where is &lt;em&gt;&lt;code&gt;this&lt;/code&gt; taken from&lt;/em&gt;?</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;this&lt;/code&gt; &lt;/em&gt; 어디 &lt;em&gt;에서 가져온 것&lt;/em&gt; 입니까?</target>
        </trans-unit>
        <trans-unit id="9b9fe2edee77fa966a9bca11a2314adc27b17dde" translate="yes" xml:space="preserve">
          <source>Whether the code is in strict or non-strict mode</source>
          <target state="translated">코드가 엄격 또는 비 엄격 모드인지 여부</target>
        </trans-unit>
        <trans-unit id="c67697bc299f31a4867d9e3ec63fd31a1acb34d6" translate="yes" xml:space="preserve">
          <source>Whether the code was invoked using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; 을&lt;/a&gt; 사용하여 코드를 호출했는지 여부</target>
        </trans-unit>
        <trans-unit id="95b195c331d5df50ce3d94202285a5aa9dff77e9" translate="yes" xml:space="preserve">
          <source>While arrow-functions provide an alternative to using &lt;code&gt;bind()&lt;/code&gt;, it&amp;rsquo;s important to note that they essentially are disabling the traditional &lt;code&gt;this&lt;/code&gt; mechanism in favor of more widely understood lexical scoping. &lt;sup&gt;(1)&lt;/sup&gt;</source>
          <target state="translated">화살표 함수는 &lt;code&gt;bind()&lt;/code&gt; 사용에 대한 대안을 제공하지만, 더 널리 이해되는 어휘 범위 지정을 위해 기존 &lt;code&gt;this&lt;/code&gt; 메커니즘을 사용하지 않도록 설정하는 것이 중요합니다. &lt;sup&gt;(1)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1ed94bc080271febddcf89764199947c7c3fdafb" translate="yes" xml:space="preserve">
          <source>Whould &lt;a href=&quot;http://www.quirksmode.org/js/this.html&quot;&gt;this&lt;/a&gt; help? (Most confusion of 'this' in javascript is coming from the fact that it generally is not linked to your object, but to the current executing scope -- that might not be exactly how it works but is always feels like that to me -- see the article for a complete explanation)</source>
          <target state="translated">&lt;a href=&quot;http://www.quirksmode.org/js/this.html&quot;&gt;이&lt;/a&gt; 도움을 누가? (자바 스크립트에서 'this'의 대부분의 혼란은 일반적으로 객체와 연결되어 있지 않지만 현재 실행 범위와 관련이 있다는 사실에서 비롯됩니다. 정확히 작동하는 방식은 아니지만 항상 나에게 그런 느낌입니다. 자세한 설명은 기사 참조)</target>
        </trans-unit>
        <trans-unit id="b4fb795b23dbff94bf4305a128bec5ae7d7ea74e" translate="yes" xml:space="preserve">
          <source>With Constructor</source>
          <target state="translated">생성자</target>
        </trans-unit>
        <trans-unit id="3b1aa9ad3adbb8fddf6c31fef8a04fbd8c6ce154" translate="yes" xml:space="preserve">
          <source>With event handlers</source>
          <target state="translated">이벤트 처리기</target>
        </trans-unit>
        <trans-unit id="15ce445da4009f96d02170197211759e9e416399" translate="yes" xml:space="preserve">
          <source>You can also manipulate the context using &lt;code&gt;.apply()&lt;/code&gt;&lt;code&gt;.call()&lt;/code&gt; and &lt;code&gt;.bind()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.apply()&lt;/code&gt; &lt;code&gt;.call()&lt;/code&gt; 및 &lt;code&gt;.bind()&lt;/code&gt; 사용하여 컨텍스트를 조작 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4c81bc669883bad79d12946f0cdcef3cb41ac57" translate="yes" xml:space="preserve">
          <source>You can manipulate the value of &lt;code&gt;this&lt;/code&gt; with the functions: &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;bind&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; , &lt;code&gt;apply&lt;/code&gt; , &lt;code&gt;bind&lt;/code&gt; 함수를 사용 &lt;code&gt;this&lt;/code&gt; 값을 조작 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9aafe015410fc61c26eb7b85e5f45fd78ded6a07" translate="yes" xml:space="preserve">
          <source>You can set the value of &lt;em&gt;this&lt;/em&gt; using &lt;code&gt;func.call&lt;/code&gt;, &lt;code&gt;func.apply&lt;/code&gt; or &lt;code&gt;func.bind&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func.call&lt;/code&gt; , &lt;code&gt;func.apply&lt;/code&gt; 또는 &lt;code&gt;func.bind&lt;/code&gt; 를 사용 하여이 값을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bc00565d4384be2eef6cc38bfd42c85cf8d0315" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;eval&lt;/code&gt; to access &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; 을 사용하여 &lt;code&gt;this&lt;/code&gt; 에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cca5c93685569cae1cf0ccae89b950fa2dccdaf8" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;this&lt;/code&gt; in any function on an object to refer to other properties on that object. This is not the same as an instance created with &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">객체의 모든 함수 &lt;code&gt;this&lt;/code&gt; 객체를 사용하여 해당 객체의 다른 속성을 참조 할 수 있습니다. 이것은 &lt;code&gt;new&lt;/code&gt; 로 만든 인스턴스와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b4d5df9ef1b310c884c8d57fbfb242857d89270e" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;with&lt;/code&gt; to add &lt;code&gt;this&lt;/code&gt; to the current scope to read and write to values on &lt;code&gt;this&lt;/code&gt; without referring to &lt;code&gt;this&lt;/code&gt; explicitly.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 를 사용 하여 &lt;code&gt;this&lt;/code&gt; 현재 범위에 추가하여 &lt;code&gt;this&lt;/code&gt; 명시 적으로 참조하지 않고도 &lt;code&gt;this&lt;/code&gt; 에 대한 값을 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54e27d188f0d38ee9602bf7437198a4746e2a173" translate="yes" xml:space="preserve">
          <source>above it). So, to get over this (no pun intended) problem, a developer could:</source>
          <target state="translated">그 위에). 따라서이 문제를 극복하기 위해 개발자는 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="9515c8375c0b70748ad0886b201ac47811d74397" translate="yes" xml:space="preserve">
          <source>and then we could call it like this</source>
          <target state="translated">그리고 우리는 이것을 이렇게 부를 수 있습니다</target>
        </trans-unit>
        <trans-unit id="226abeaecd5ff1c4ed49f5e280892fe18bd8990d" translate="yes" xml:space="preserve">
          <source>but &lt;strong&gt;do&lt;/strong&gt; ask yourself:</source>
          <target state="translated">그러나 스스로에게 물어보십시오 :</target>
        </trans-unit>
        <trans-unit id="841108c86e9fbb4edafbf1fc269ca06fbd9c2aa7" translate="yes" xml:space="preserve">
          <source>is the same as</source>
          <target state="translated">와 같다</target>
        </trans-unit>
        <trans-unit id="52bf064bbb0874e1615c452b86946146a06f7150" translate="yes" xml:space="preserve">
          <source>it becomes the property of the window object, as if you have defined
it as</source>
          <target state="translated">다음과 같이 정의한 것처럼 창 객체의 속성이됩니다.</target>
        </trans-unit>
        <trans-unit id="030861400725df2cccdbd01f8186798d77f7e41a" translate="yes" xml:space="preserve">
          <source>jQuery makes this trivial to change with jQuery.proxy.</source>
          <target state="translated">jQuery는 jQuery.proxy로이 사소한 변경을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f36f025d3a5f8c92288a34e977b81bdd71e6227d" translate="yes" xml:space="preserve">
          <source>javascriptissexy.com - &lt;a href=&quot;http://goo.gl/pvl0GX&quot;&gt;http://goo.gl/pvl0GX&lt;/a&gt;</source>
          <target state="translated">javascriptissexy.com- &lt;a href=&quot;http://goo.gl/pvl0GX&quot;&gt;http&lt;/a&gt; : //goo.gl/pvl0GX</target>
        </trans-unit>
        <trans-unit id="4049836cfbefc8188779c17bb3962e791ecad445" translate="yes" xml:space="preserve">
          <source>the jQuery will in many places have &lt;code&gt;this&lt;/code&gt; refer to a DOM element.</source>
          <target state="translated">jQuery는 여러 곳에서 DOM 요소를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="3be4a57468f0408033e4ea27c9512e741f1fbc8b" translate="yes" xml:space="preserve">
          <source>this use for Scope just like this</source>
          <target state="translated">이처럼 범위에 대한 사용</target>
        </trans-unit>
        <trans-unit id="0be011b10726d85ae6873c3f4ffc235cfde3ceb9" translate="yes" xml:space="preserve">
          <source>value of txt1 and txt is same
in Above example 
$(this)=$('#tbleName tbody tr') is Same</source>
          <target state="translated">위의 예에서 txt1과 txt의 값은 동일합니다 $ (this) = $ ( '# tbleName tbody tr') is Same</target>
        </trans-unit>
        <trans-unit id="a40cac89bb894a88e8ef678122403134449a72d5" translate="yes" xml:space="preserve">
          <source>was effectively translated into</source>
          <target state="translated">효과적으로 번역되었다</target>
        </trans-unit>
        <trans-unit id="eee2fd622722c8b192547f36dd5b9891b7a1ad1e" translate="yes" xml:space="preserve">
          <source>which means</source>
          <target state="translated">그 의미는</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
