<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/3127429">
    <body>
      <group id="3127429">
        <trans-unit id="1f8742c489830fbb68ca2ba261bc508b53df7499" translate="yes" xml:space="preserve">
          <source>&quot;this&quot; is all about scope. Every function has its own scope, and since everything in JS is an object, even a function can store some values into itself using &quot;this&quot;. OOP 101 teaches that &quot;this&quot; is only applicable to &lt;em&gt;instances&lt;/em&gt; of an object. Therefore, every-time a function executes, a new &quot;instance&quot; of that function has a new meaning of &quot;this&quot;.</source>
          <target state="translated">「これ」はすべてスコープに関するものです。 すべての関数には独自のスコープがあり、JSのすべてがオブジェクトであるため、関数でも「this」を使用していくつかの値をそれ自体に格納できます。 OOP 101は、「this」はオブジェクトの&lt;em&gt;インスタンス&lt;/em&gt;にのみ適用できることを教えています。 したがって、関数が実行されるたびに、その関数の新しい「インスタンス」は「this」という新しい意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="b087ac216caabb7017868b37aca9a9d6e2dc3acd" translate="yes" xml:space="preserve">
          <source>&quot;this&quot; keyword is always dependant on the context of invocation. They are mentioned below.</source>
          <target state="translated">&quot;this&quot; キーワードは常に呼び出しのコンテキストに依存します。それらを以下に示します。</target>
        </trans-unit>
        <trans-unit id="f3a3f86fe5a29d3e243308285b4b562e5ee68cee" translate="yes" xml:space="preserve">
          <source>&amp;hellip;by a direct call to &lt;code&gt;eval()&lt;/code&gt;
ThisBinding is left unchanged; it is the same value as the ThisBinding of the calling execution context (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;&amp;sect;10.4.2&lt;/a&gt; (2)(a)).</source>
          <target state="translated">&amp;hellip; &lt;code&gt;eval()&lt;/code&gt; への直接呼び出しによってThisBindingは変更されません。 これは、呼び出し実行コンテキストのThisBindingと同じ値です（ &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;&amp;sect;10.4.2&lt;/a&gt; （2）（a））。</target>
        </trans-unit>
        <trans-unit id="9cc3cef106ffb16fe471cb3389ab7a4426b808f0" translate="yes" xml:space="preserve">
          <source>&amp;hellip;if not by a direct call to &lt;code&gt;eval()&lt;/code&gt;</source>
          <target state="translated">&amp;hellip; &lt;code&gt;eval()&lt;/code&gt; を直接呼び出さない場合</target>
        </trans-unit>
        <trans-unit id="51102ac175310aed1bea1f10200498ad1af008e5" translate="yes" xml:space="preserve">
          <source>&amp;sect;15.1.2.1.1 defines what a direct call to &lt;code&gt;eval()&lt;/code&gt; is. Basically, &lt;code&gt;eval(...)&lt;/code&gt; is a direct call whereas something like &lt;code&gt;(0, eval)(...)&lt;/code&gt; or &lt;code&gt;var indirectEval = eval; indirectEval(...);&lt;/code&gt; is an indirect call to &lt;code&gt;eval()&lt;/code&gt;. See &lt;a href=&quot;https://stackoverflow.com/a/9107491/196844&quot;&gt;chuckj's answer&lt;/a&gt; to &lt;a href=&quot;https://stackoverflow.com/q/9107240/196844&quot;&gt;(1, eval)('this') vs eval('this') in JavaScript?&lt;/a&gt; and &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/#indirect-eval-call&quot;&gt;Dmitry Soshnikov&amp;rsquo;s ECMA-262-5 in detail. Chapter 2. Strict Mode.&lt;/a&gt; for when you might use an indirect &lt;code&gt;eval()&lt;/code&gt; call.</source>
          <target state="translated">&amp;sect;15.1.2.1.1は、 &lt;code&gt;eval()&lt;/code&gt; への直接呼び出しが何であるかを定義しています。 基本的に、 &lt;code&gt;eval(...)&lt;/code&gt; は直接呼び出しですが、 &lt;code&gt;(0, eval)(...)&lt;/code&gt; または &lt;code&gt;var indirectEval = eval; indirectEval(...);&lt;/code&gt; indirectEval（...）; &lt;code&gt;eval()&lt;/code&gt; への間接呼び出しです。 &lt;a href=&quot;https://stackoverflow.com/a/9107491/196844&quot;&gt;JavaScriptでの&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/q/9107240/196844&quot;&gt;（1、eval）（ 'this'）とeval（ 'this'）の&lt;/a&gt; チャックjの答えを参照してください。 &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/#indirect-eval-call&quot;&gt;Dmitry SoshnikovのECMA-262-5の詳細。&lt;/a&gt; 第2章厳格モード。 間接 &lt;code&gt;eval()&lt;/code&gt; 呼び出しを使用する可能性がある場合。</target>
        </trans-unit>
        <trans-unit id="d811f7b2b609ced44226e1cc0f2cc624eac9c4ae" translate="yes" xml:space="preserve">
          <source>1. Initial global execution context</source>
          <target state="translated">1.初期グローバル実行コンテキスト</target>
        </trans-unit>
        <trans-unit id="a1fa3b35a9272755e31354f7d5e59caf11fa3cf1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://bjorn.tipling.com/all-this&quot;&gt;Here&lt;/a&gt; is one good source of &lt;code&gt;this&lt;/code&gt; in &lt;code&gt;JavaScript&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; が &lt;code&gt;JavaScript&lt;/code&gt; の良い情報源の1つです。</target>
        </trans-unit>
        <trans-unit id="b49c71fe77018d6aeff02cd966c9eb2f2def9fd9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;Arrow functions&lt;/a&gt; (introduced in ECMA6) alter the scope of &lt;code&gt;this&lt;/code&gt;. See the existing canonical question, &lt;a href=&quot;https://stackoverflow.com/questions/34361379/arrow-function-vs-function-declaration-expressions-are-they-equivalent-exch&quot;&gt;Arrow function vs function declaration / expressions: Are they equivalent / exchangeable?&lt;/a&gt; for more information. But in short:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;アロー関数&lt;/a&gt; （ECMA6で導入）は、thisのスコープを変更します。 既存の標準的な質問、 &lt;a href=&quot;https://stackoverflow.com/questions/34361379/arrow-function-vs-function-declaration-expressions-are-they-equivalent-exch&quot;&gt;矢印関数vs関数宣言/式を&lt;/a&gt;参照してください：それらは同等/交換可能ですか？ 詳細については。 しかし、要するに：</target>
        </trans-unit>
        <trans-unit id="7f751a15d113e0f9a8416dec1351c576d0282769" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-11.1.1&quot;&gt;&amp;sect;11.1.1&lt;/a&gt; The &lt;code&gt;this&lt;/code&gt; keyword</source>
          <target state="translated">&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-11.1.1&quot;&gt;&amp;sect;11.1.1this&lt;/a&gt;キーワード</target>
        </trans-unit>
        <trans-unit id="424e6d7255bde2010b643c058d5b8f1d62241294" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;apply&lt;/code&gt; is almost the same as &lt;code&gt;call&lt;/code&gt; accept that it takes only two parameters: &lt;code&gt;thisArg&lt;/code&gt; and an array which contains the arguments to be passed to the function. So the above &lt;code&gt;call&lt;/code&gt; call can be translated to &lt;code&gt;apply&lt;/code&gt; like this:</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; は、2つのパラメーター（ &lt;code&gt;thisArg&lt;/code&gt; と、関数に渡される引数を含む配列）のみをとるという点で、 &lt;code&gt;call&lt;/code&gt; acceptとほぼ同じです。 したがって、上記の &lt;code&gt;call&lt;/code&gt; は次のように &lt;code&gt;apply&lt;/code&gt; ように変換できます。</target>
        </trans-unit>
        <trans-unit id="382d7e3908485b3ab834fd0e20e7a2a1529aef8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bind&lt;/code&gt; is a brother of &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;.  It is also a method inherited by all functions from the global &lt;code&gt;Function&lt;/code&gt; constructor in Javascript. The difference between &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;call&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; is that both &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; will actually invoke the function. &lt;code&gt;bind&lt;/code&gt;, on the other hand, returns a new function with the &lt;code&gt;thisArg&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt; pre-set. Let's take an example to better understand this:</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; は &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; の兄弟です。 これは、Javascriptのグローバル &lt;code&gt;Function&lt;/code&gt; コンストラクターからすべての関数によって継承されるメソッドでもあります。 &lt;code&gt;bind&lt;/code&gt; と &lt;code&gt;call&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; の違いは、 &lt;code&gt;call&lt;/code&gt; と &lt;code&gt;apply&lt;/code&gt; の両方が実際に関数を呼び出すことです。 一方、 &lt;code&gt;bind&lt;/code&gt; は、 &lt;code&gt;thisArg&lt;/code&gt; と &lt;code&gt;arguments&lt;/code&gt; 事前設定された新しい関数を返します。 これをよりよく理解するために例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="d372c94fc4d01f36f32e9424821af8fae90a6d1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;obj.foo()&lt;/code&gt; translates to &lt;code&gt;const temp = obj.foo; temp.call(obj);&lt;/code&gt; which means the arrow operator inside &lt;code&gt;foo&lt;/code&gt; will bind &lt;code&gt;obj&lt;/code&gt; to a new invisible function and return that new invisible function which is assigned to &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;b()&lt;/code&gt; will work as it always has as &lt;code&gt;b.call(window)&lt;/code&gt; or &lt;code&gt;b.call(undefined)&lt;/code&gt; calling the new invisible function that &lt;code&gt;foo&lt;/code&gt; created. That invisible function ignores the &lt;code&gt;this&lt;/code&gt; passed into it and  passes &lt;code&gt;obj&lt;/code&gt; as objectForThis` to the arrow function.</source>
          <target state="translated">&lt;code&gt;obj.foo()&lt;/code&gt; は、 &lt;code&gt;const temp = obj.foo; temp.call(obj);&lt;/code&gt; 変換されます。 temp.call（obj）; これは、 &lt;code&gt;foo&lt;/code&gt; 内の矢印演算子が &lt;code&gt;obj&lt;/code&gt; を新しい非表示の関数にバインドし、 &lt;code&gt;b&lt;/code&gt; に割り当てられているその新しい非表示の関数を返すことを意味します。 &lt;code&gt;b()&lt;/code&gt; は、 &lt;code&gt;foo&lt;/code&gt; が作成した新しい非表示の関数を呼び出す &lt;code&gt;b.call(window)&lt;/code&gt; または &lt;code&gt;b.call(undefined)&lt;/code&gt; と同じように機能します。 この非表示の関数は、渡された &lt;code&gt;this&lt;/code&gt; を無視し、 &lt;code&gt;obj&lt;/code&gt; をobjectForThis`として矢印関数に渡します。</target>
        </trans-unit>
        <trans-unit id="cc4f263a38b1f6aedd93045cde762a01d7dc5a49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;obj&lt;/code&gt; &amp;mdash; When calling a function on an object, ThisBinding is set to the object.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; &amp;mdash;オブジェクトの関数を呼び出すと、ThisBindingがオブジェクトに設定されます。</target>
        </trans-unit>
        <trans-unit id="107d6e7f7fb924b5dc3445b4c08dd5f9aaa0aaa7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; can be used to refer to the object being created</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; は、作成されるオブジェクトを参照するために使用できます</target>
        </trans-unit>
        <trans-unit id="c811f8b7269bca9f651630faab87a3c3f3e35ac4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; helps to get the current object (a.k.a. execution context) we work with. If you understand in which object the current function is getting executed, you can understand easily what current &lt;code&gt;this&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; は、現在のオブジェクト（別名実行コンテキスト）を取得するのに役立ちます。 現在の関数が実行されているオブジェクトを理解していれば、これが現在どのようなオブジェクトであるかを簡単に理解できます。</target>
        </trans-unit>
        <trans-unit id="b4aeb36a0b116d9deb56aa0b8774cb04edd881be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; in JavaScript always refers to the 'owner' of the function that is &lt;strong&gt;being executed&lt;/strong&gt;.</source>
          <target state="translated">JavaScriptの &lt;code&gt;this&lt;/code&gt; は常に、 &lt;strong&gt;実行されている&lt;/strong&gt;関数の「所有者」を指します。</target>
        </trans-unit>
        <trans-unit id="7c3f84f931c948a2cb7f1e59f0d6dfa830ab07b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; is one of the misunderstood concept in JavaScript because it behaves little differently from place to place. Simply, &lt;code&gt;this&lt;/code&gt; refers to the &lt;strong&gt;&quot;owner&quot; of the function we are currently executing&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; はJavaScriptで誤解されている概念の1つです。 これは、場所によって動作がほとんど異なるためです。 簡単に言うと、 &lt;code&gt;this&lt;/code&gt; &lt;strong&gt;は現在実行している関数の「所有者」を&lt;/strong&gt;指します。</target>
        </trans-unit>
        <trans-unit id="13e02a751d5916a050a8b3dc4252bc2caca654cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; would refer to the element object. But be careful, a lot of people make this mistake.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; は要素オブジェクトを参照します。 しかし、注意してください。多くの人がこの間違いを犯します。</target>
        </trans-unit>
        <trans-unit id="f5240944b8f27af27e4b000a78873eeedbe95583" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;&lt;strong&gt;is not assigned a value&lt;/strong&gt; until an object invokes the function where it is defined. In the global scope, all global variables and functions are defined on the &lt;code&gt;window&lt;/code&gt; object. Therefore, &lt;code&gt;this&lt;/code&gt; in a global function refers to (and has the value of) the global &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">オブジェクトが定義されている関数をオブジェクトが呼び出すまで、 &lt;strong&gt;値は割り当てられません&lt;/strong&gt; 。 グローバルスコープでは、すべてのグローバル変数と関数は &lt;code&gt;window&lt;/code&gt; オブジェクトで定義されます。 したがって、 &lt;code&gt;this&lt;/code&gt; はグローバル関数で、グローバル &lt;code&gt;window&lt;/code&gt; オブジェクトを参照し、その値を持っています。</target>
        </trans-unit>
        <trans-unit id="2017743fc4e80e00beebfb42e3038d8fb7f5b026" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window&lt;/code&gt; &amp;mdash; The marked line is evaluated in the initial global execution context.</source>
          <target state="translated">&lt;code&gt;window&lt;/code&gt; &amp;mdash;マークされた行は、初期グローバル実行コンテキストで評価されます。</target>
        </trans-unit>
        <trans-unit id="f4be438a760254b14a91ab09c03d45c80ef71f1b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Few places where &lt;code&gt;this&lt;/code&gt; can be differentiated&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;this&lt;/code&gt; を区別できる場所はほとんどありません&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09380dc0b6ee6bdf73de503a58ea18d71700e94d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I recommend to better try this in &lt;a href=&quot;http://jsfiddle.net/Mahesha999/xKtzC/8/embedded/html,js,result&quot;&gt;JSFiddle&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://jsfiddle.net/Mahesha999/xKtzC/8/embedded/html,js,result&quot;&gt;JSFiddleで&lt;/a&gt;これを試すことをお勧めします。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="89af8ce5b9c6ddaddba039f802cac788a61fd49a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Since this thread has bumped up, I have compiled few points for readers new to &lt;code&gt;this&lt;/code&gt; topic.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;このスレッドが増えたので、 &lt;code&gt;this&lt;/code&gt; トピックを初めて読む読者のためにいくつかのポイントをまとめました。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf09c380c346a11478b95850016d50cc8b3825f2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;To reveal the answers, mouse over the light yellow boxes.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;答えを明らかにするには、淡黄色のボックスの上にマウスを置きます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ff1f9889e4b9c65093673c35d707361ce7a29d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. When used in global context&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.グローバルコンテキストで使用する場合&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1cb747759f0fbb0bff69036f9d6d60f4aa3fa28d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. When used inside object method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.オブジェクトメソッド内で使用する場合&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a912f1682aefdda6a1d36527df19cad6af2400d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. When invoking context-less function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.コンテキストレス関数を呼び出すとき&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc4963b484aa9c5ab6a24d462de6d79d10013299" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. When used inside constructor function&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;4.コンストラクター関数内で使用する場合&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="1151d51ab92181c7cb05dad8e085d7369e1d980f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5. When used inside function defined on prototype chain&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5.プロトタイプチェーンで定義された関数内で使用する場合&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1836a9a4449c1ab65274d2b92c93146cbd04cfc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;6. Inside call(), apply() and bind() functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;6. call（）、apply（）およびbind（）関数の内部&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5eb140bea3b13dba943d1a806bc843988b98056" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;7. &lt;code&gt;this&lt;/code&gt; inside event handlers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;7. &lt;code&gt;this&lt;/code&gt; 内部イベントハンドラ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9d21ab1911b874d328796c84c4b427f924e6226" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;8. &lt;code&gt;this&lt;/code&gt; in ES6 arrow function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;8. &lt;code&gt;this&lt;/code&gt; はES6の矢印関数で&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="718494e8c6739afd0ac4b8944ca72f98a1b42d96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;fun.apply(obj1 [, argsArray])&lt;/code&gt;&lt;/strong&gt; Sets &lt;code&gt;obj1&lt;/code&gt; as the value of &lt;code&gt;this&lt;/code&gt; inside &lt;code&gt;fun()&lt;/code&gt; and calls &lt;code&gt;fun()&lt;/code&gt; passing elements of &lt;code&gt;argsArray&lt;/code&gt; as its arguments.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;fun.apply(obj1 [, argsArray])&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;obj1&lt;/code&gt; を &lt;code&gt;this&lt;/code&gt; 内部 &lt;code&gt;fun()&lt;/code&gt; の値として設定し&lt;strong&gt;、argsArrayの&lt;/strong&gt;要素を引数として渡して &lt;code&gt;fun()&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="9efe54b50d151a789da3c3d7e3f5f9c6142683ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;fun.bind(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])&lt;/code&gt;&lt;/strong&gt; - Returns the reference to the function &lt;code&gt;fun&lt;/code&gt; with &lt;code&gt;this&lt;/code&gt; inside fun bound to &lt;code&gt;obj1&lt;/code&gt; and parameters of &lt;code&gt;fun&lt;/code&gt; bound to the   parameters specified &lt;code&gt;arg1, arg2, arg3,...&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;fun.bind(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])&lt;/code&gt; &lt;/strong&gt; - &lt;code&gt;this&lt;/code&gt; 内部funが &lt;code&gt;obj1&lt;/code&gt; にバインドされた関数 &lt;code&gt;fun&lt;/code&gt; への参照と、指定されたパラメーター &lt;code&gt;arg1, arg2, arg3,...&lt;/code&gt; バインドされた &lt;code&gt;fun&lt;/code&gt; のパラメーターを返しますarg2、arg3、...</target>
        </trans-unit>
        <trans-unit id="2fa93f1be283db9398b00d14dcb4562d31a96a58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;fun.call(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])&lt;/code&gt;&lt;/strong&gt; - Sets &lt;code&gt;obj1&lt;/code&gt; as the value of &lt;code&gt;this&lt;/code&gt; inside &lt;code&gt;fun()&lt;/code&gt; and calls &lt;code&gt;fun()&lt;/code&gt; passing &lt;code&gt;arg1, arg2, arg3, ...&lt;/code&gt; as its arguments.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;fun.call(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])&lt;/code&gt; &lt;/strong&gt; - &lt;code&gt;obj1&lt;/code&gt; を &lt;code&gt;this&lt;/code&gt; 内部 &lt;code&gt;fun()&lt;/code&gt; の値として設定し、 &lt;code&gt;arg1, arg2, arg3, ...&lt;/code&gt; を渡して &lt;code&gt;fun()&lt;/code&gt; を呼び出します。 。その引数として。</target>
        </trans-unit>
        <trans-unit id="418f0b4779a9d1418d184d2b02d0207c370e9e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;References:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;References:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="78d38ee0591e57aa045e4c0f056e77a623a22b30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM event this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DOMイベントこれ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0611618ab4bef86d4217dc74878abb5876ef1d1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Everything else is syntactic sugar for &lt;code&gt;functionObject.call&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;その他はすべて &lt;code&gt;functionObject.call&lt;/code&gt; の構文糖衣です&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="085e18e665d8e1d81d0ca5c6a9023f7d3da54da0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FUNCTION IS CALLED EXPLICITLY USING CALL AND APPLY METHODS.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;関数は、呼び出しと適用の方法を使用して明示的に呼び出されます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d75456f909e4fd7563b46975c382623f3dc3c8e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FUNCTION IS CALLED WITH NEW KEYWORD&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;関数は新しいキーワードで呼び出されます&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1325e530872f52dae1b1e7bc729151d7fd17b95d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For event handlers:&lt;/strong&gt; inline event handlers, such as &lt;code&gt;&amp;lt;element onclick=&quot;foo&quot;&amp;gt;&lt;/code&gt;, override any other handlers attached earlier and before, so be careful and it's better to stay off of inline event delegation at all.
And thanks to Zara Alaverdyan who inspired me to this list of examples through a dissenting debate :)</source>
          <target state="translated">&lt;strong&gt;イベントハンドラーの場合：&lt;/strong&gt; &lt;code&gt;&amp;lt;element onclick=&quot;foo&quot;&amp;gt;&lt;/code&gt; などのインラインイベントハンドラーは、以前にアタッチされた他のハンドラーをオーバーライドするため、注意してください。インラインイベントの委任は避けてください。 そして、反対論争を通じてこの例のリストに私をインスピレーションを与えてくれたZara Alaverdyanに感謝します:)</target>
        </trans-unit>
        <trans-unit id="894baeb26ee211c848adbf141fef8ea332f2d512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global Context&lt;/strong&gt; (i.e. Outside all functions):</source>
          <target state="translated">&lt;strong&gt;グローバルコンテキスト&lt;/strong&gt; （つまり、すべての関数の外）：</target>
        </trans-unit>
        <trans-unit id="168e0b60ab24edf5659b7603a5e6761ba4b78bc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global&lt;/strong&gt; (i.e. Outside all functions)</source>
          <target state="translated">&lt;strong&gt;グローバル&lt;/strong&gt; （つまり、すべての機能の外側）</target>
        </trans-unit>
        <trans-unit id="a9b296c5fddc1bb4ff71359ff1b16bcabd27c0ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HTML this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTMLこれ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="917118becd0e6d67a05db3eed2df871405cda7a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IF FUNCTION IS CALLED WITH OBJECT IMPLICITLY THEN THIS WILL BE BOUND TO THAT OBJECT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;関数がオブジェクトで暗黙的に呼び出された場合、これはそのオブジェクトに束縛されます&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ba8db8e3f1fc0f64367058719c6e34521b6988c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IN STRICT MODE THIS WILL BE UNDEFINED&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;厳密モードでは、これは未定義になります&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d0ea3429b59410b8f4d00a4cc84074280bda9ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside &quot;Bound Function&quot; Call&lt;/strong&gt; (i.e. a function that &lt;strong&gt;has been bound&lt;/strong&gt; by calling &lt;strong&gt;&lt;em&gt;functionName.bind&lt;/em&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;「バインドされた関数」呼び出しの内部&lt;/strong&gt; （つまり、functionName.bindの呼び出しによって&lt;strong&gt;バインド&lt;/strong&gt;された&lt;strong&gt;&lt;em&gt;関数&lt;/em&gt;&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="173ec8ce03dcc96425b564f955f3e8db1cca03ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside &quot;Bound Function&quot; Call&lt;/strong&gt; (i.e. a function that has been bound by calling &lt;strong&gt;&lt;em&gt;functionName.bind&lt;/em&gt;&lt;/strong&gt;):</source>
          <target state="translated">&lt;strong&gt;「バインドされた関数」呼び出しの内部&lt;/strong&gt; （つまり、functionName.bindを呼び出す&lt;strong&gt;&lt;em&gt;こと&lt;/em&gt;&lt;/strong&gt;によってバインドされた&lt;strong&gt;&lt;em&gt;関数&lt;/em&gt;&lt;/strong&gt; ）：</target>
        </trans-unit>
        <trans-unit id="3e875249daa0473a8fdf23ad502cdf3367b1cde8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Direct &quot;Non Bound Function&quot; Call&lt;/strong&gt; (i.e. a function that has &lt;strong&gt;not been&lt;/strong&gt; bound by calling &lt;strong&gt;&lt;em&gt;functionName.bind&lt;/em&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;内部の「非バインド関数」呼び出し&lt;/strong&gt; （つまり、functionName.bindの呼び出しによってバインドされて&lt;strong&gt;いない&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;関数&lt;/em&gt;&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="8c57485accd3f8de730dc301d4b4402bc9d5ff6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Direct &quot;Non Bound Function&quot; Call&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;内部の「非バインド関数」呼び出し&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="20b6606bfe8a1a339672457b5987c0bbe9801b32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Indirect &quot;Non Bound Function&quot; Call&lt;/strong&gt; through &lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;functionName.apply&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt;および&lt;strong&gt;&lt;em&gt;functionName.apply&lt;/em&gt;&lt;/strong&gt;による&lt;strong&gt;間接的な「非バインド関数」呼び出し&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f6bbd439250c2f70bd753a9c1867ff4ae0334cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Indirect &quot;Non Bound Function&quot; Call&lt;/strong&gt; through &lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;functionName.apply&lt;/em&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt;および&lt;strong&gt;&lt;em&gt;functionName.applyを&lt;/em&gt;&lt;/strong&gt;介した&lt;strong&gt;間接的な「非バインド関数」呼び出し&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="b687e55bef18e96403dcec84a064997fff961ba4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Inline DOM event handler&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;インラインDOMイベントハンドラー内&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b733413aa17352a3e9b6ca5623c81d22f47452b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Inline DOM event handler&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;インラインDOMイベントハンドラー内&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="266e0d16f0275a7b45db6e40b0e84253044c47e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Trying it all with functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;関数ですべてを試す&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b798c488f44ac56ef97819e55be72d13bc6ae204" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WHEN FUNCTION IS CALLED WITHOUT ANY CONTEXT THEN THIS WILL BE BOUND TO GLOBAL OBJECT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;関数がコンテキストなしで呼び出され、グローバルオブジェクトに束縛される場合&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ff4d1e2e595c31a6b0764e1ad94e2fa48fffb37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;While Object Creation through &quot;new&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;「新しい」によるオブジェクトの作成中&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8198d31ce2fb4af76a276cd2353f3b893b2b3c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;While Object Creation through &quot;new&quot;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;「新規」によるオブジェクトの作成中&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="bd0054da704663fa349cd05f6dec86874b0a5b98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;eval this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これを評価&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b6e7cb5e761aba02987ecc24374a500c50b2f3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;function this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これを機能させる&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d575ef4572a4d0f70d88145f3266940c01dbe092" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;global this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;グローバルこれ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf73e6df87566417c40b38e407048179eb72abf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery this&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="267215baf52fd6931b04140eff3d560dfdf04823" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;object this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これに反対&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6993e186af398b71572f7532218e7b60a53b53e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;prototype this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これのプロトタイプ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f609ef0b01e29c7688ac86f84c3b2fd9542bc770" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;this &amp;amp; Object Prototypes&lt;/strong&gt;, by Kyle Simpson. &amp;copy; 2014 Getify Solutions.</source>
          <target state="translated">&lt;strong&gt;this＆Object Prototypes&lt;/strong&gt; 、Kyle Simpson作。 &amp;copy;2014 Getify Solutions。</target>
        </trans-unit>
        <trans-unit id="d68567ba0092c29c333f4067dcc1219804e03507" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;with this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これとともに&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bb486259298102ba39377e4ed03a0fb81bf8790" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;&lt;code&gt;apply&lt;/code&gt; is another function similar to &lt;code&gt;call&lt;/code&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; &lt;code&gt;apply&lt;/code&gt; は、 &lt;code&gt;call&lt;/code&gt; に似た別の関数です</target>
        </trans-unit>
        <trans-unit id="521d8887a5ef2e61310029a52ca75b452424b493" translate="yes" xml:space="preserve">
          <source>A bound function is a function whose &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; value has been
fixed. The following code demonstrated how &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; works in case
of bound function</source>
          <target state="translated">バインドされた関数は、 &lt;strong&gt;「this」&lt;/strong&gt;値が修正された関数です。 次のコードは、バインドされた関数の場合に&lt;strong&gt;「this」が&lt;/strong&gt;どのように機能するかを示しています</target>
        </trans-unit>
        <trans-unit id="ef2db31f656b33473e747f5be7b06a3421bd96e7" translate="yes" xml:space="preserve">
          <source>A little bit info about &lt;strong&gt;this&lt;/strong&gt; keyword</source>
          <target state="translated">&lt;strong&gt;この&lt;/strong&gt;キーワードについて少し情報</target>
        </trans-unit>
        <trans-unit id="bba748cf8bf63af49cb69595a0f4e85a54d40178" translate="yes" xml:space="preserve">
          <source>Above &lt;code&gt;f1&lt;/code&gt; is made a method of global object. Thus we can also call it on &lt;code&gt;window&lt;/code&gt; object as follows:</source>
          <target state="translated">上記の &lt;code&gt;f1&lt;/code&gt; はグローバルオブジェクトのメソッドにしています。 したがって、次のように &lt;code&gt;window&lt;/code&gt; オブジェクトで呼び出すこともできます。</target>
        </trans-unit>
        <trans-unit id="b753f43e6cc93cab6d731a784a044886d520b74f" translate="yes" xml:space="preserve">
          <source>Above I have put the word immediate in double quotes. It is to make the point that if you nest the object inside another object, then &lt;code&gt;this&lt;/code&gt; is bound to the immediate parent.</source>
          <target state="translated">上記では、即時という単語を二重引用符で囲んでいます。 これは、オブジェクトを別のオブジェクト内にネストすると、 &lt;code&gt;this&lt;/code&gt; が直接の親にバインドされることを強調するためです。</target>
        </trans-unit>
        <trans-unit id="d0e03fe81743bbdb1803208b752058307d77c7c9" translate="yes" xml:space="preserve">
          <source>Above we added members to objects using object literal notation. We can add members to functions by using &lt;code&gt;this&lt;/code&gt;. to specify them.</source>
          <target state="translated">上記では、オブジェクトリテラル表記を使用してオブジェクトにメンバーを追加しました。 &lt;code&gt;this&lt;/code&gt; を使用して関数にメンバーを追加できます。 それらを指定します。</target>
        </trans-unit>
        <trans-unit id="378cd99eed8979a93e73069d633b7546f12e1467" translate="yes" xml:space="preserve">
          <source>Above we create 3 variables with same name 'val'. One in global context, one inside obj and the other inside innerMethod of obj. JavaScript resolves identifiers within a particular context by going up the scope chain from local go global.</source>
          <target state="translated">上記の例では、同じ名前のvalを持つ変数を3つ作成しています。1つはグローバルコンテキスト内、1つはobj内、もう1つはobjのinnerMethod内に作成しています。JavaScriptは、特定のコンテキスト内の識別子を、ローカルからグローバルへとスコープチェーンを上って解決します。</target>
        </trans-unit>
        <trans-unit id="4fbc9235f1c80f74cce8e944e82472b1cf3e26c7" translate="yes" xml:space="preserve">
          <source>Again these all are just syntactic sugar for</source>
          <target state="translated">繰り返しになりますが、これらはすべて構文的には</target>
        </trans-unit>
        <trans-unit id="44f5606c7c264327eaf36478d243b0e4ee2e66c7" translate="yes" xml:space="preserve">
          <source>All functions inherit from the global &lt;code&gt;Function&lt;/code&gt;, and two of its many methods are &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;, and both can be used to manipulate the value of &lt;code&gt;this&lt;/code&gt; in the function on which they are called.</source>
          <target state="translated">すべての関数はグローバル &lt;code&gt;Function&lt;/code&gt; を継承し、その多くのメソッドのうち2つは &lt;code&gt;call&lt;/code&gt; および &lt;code&gt;apply&lt;/code&gt; であり、両方を使用して、それらが呼び出される関数で &lt;code&gt;this&lt;/code&gt; の値を操作できます。</target>
        </trans-unit>
        <trans-unit id="65bb256adbc34f0e662f2e6886cf45e5da2fe2e0" translate="yes" xml:space="preserve">
          <source>All these methods are defined on &lt;code&gt;Function.prototype&lt;/code&gt;.</source>
          <target state="translated">これらのメソッドはすべて &lt;code&gt;Function.prototype&lt;/code&gt; で定義されています。</target>
        </trans-unit>
        <trans-unit id="2f3251d2eefcb2ea293e403dfdf0b701c95967f7" translate="yes" xml:space="preserve">
          <source>Also in an object literal approach, we can explicitly add members to already defined object using dot operator. This gets added to the specific instance only. However I have added variable to the function prototype so that it gets reflected in all instances of the function.</source>
          <target state="translated">また、オブジェクトリテラルのアプローチでは、すでに定義されているオブジェクトにドット演算子を使って明示的にメンバーを追加することができます。これは特定のインスタンスにのみ追加されます。しかし、私は関数のプロトタイプに変数を追加して、関数のすべてのインスタンスに反映されるようにしています。</target>
        </trans-unit>
        <trans-unit id="42a17cccb4a20658564c0ef8e45cbac226648a85" translate="yes" xml:space="preserve">
          <source>Also note that neither of these three functions do any change to the original function. &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; would return the value from freshly constructed functions while &lt;code&gt;bind&lt;/code&gt; will return the freshly constructed function itself, ready to be called.</source>
          <target state="translated">また、これらの3つの関数はどちらも元の関数を変更しないことに注意してください。 &lt;code&gt;call&lt;/code&gt; および &lt;code&gt;apply&lt;/code&gt; は、新しく作成された関数から値を返しますが、 &lt;code&gt;bind&lt;/code&gt; は、新しく作成された関数自体を返し、すぐに呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="96bacdecd2f20c6e4133c59029163b3a5024cc7a" translate="yes" xml:space="preserve">
          <source>Angus Croll - &lt;a href=&quot;http://goo.gl/Z2RacU&quot;&gt;http://goo.gl/Z2RacU&lt;/a&gt;</source>
          <target state="translated">アンガスクロール-http: &lt;a href=&quot;http://goo.gl/Z2RacU&quot;&gt;//goo.gl/Z2RacU&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc6d0b4a3431a2895e9d69a29dd7c9026e676f98" translate="yes" xml:space="preserve">
          <source>Arrow functions</source>
          <target state="translated">矢印関数</target>
        </trans-unit>
        <trans-unit id="0c6f0eb1c1ab36699d24af9b8c41dcdfa8f179e2" translate="yes" xml:space="preserve">
          <source>Arrow functions don't have their own &lt;code&gt;this&lt;/code&gt;.... binding.
  Instead, those identifiers are resolved in the lexical scope like any
  other variable. That means that inside an arrow function, &lt;code&gt;this&lt;/code&gt;...refer(s) to the values of &lt;code&gt;this&lt;/code&gt; in the environment
  the arrow function is defined in.</source>
          <target state="translated">アロー関数には独自の &lt;code&gt;this&lt;/code&gt; ....バインディングがありません。 代わりに、これらの識別子は他の変数と同様に字句スコープで解決されます。 つまり、矢印関数の内部では、 &lt;code&gt;this&lt;/code&gt; は、矢印関数が定義されている環境での &lt;code&gt;this&lt;/code&gt; の値を参照します。</target>
        </trans-unit>
        <trans-unit id="b50c4e79c0e3f7852862c14187e6ddd0825a3bd5" translate="yes" xml:space="preserve">
          <source>Arrow functions, the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator are syntactic sugar for bind</source>
          <target state="translated">矢印関数、 &lt;code&gt;=&amp;gt;&lt;/code&gt; 演算子はバインドの構文糖</target>
        </trans-unit>
        <trans-unit id="203d51646bb4fd08eace6d614d8c939e2e57a916" translate="yes" xml:space="preserve">
          <source>As given in the code above, &lt;strong&gt;&quot;this&quot; value for any &quot;Bound Function&quot;
CANNOT be altered through call/apply&lt;/strong&gt;. Also, if the &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;
parameter is  not explicitly passed to bind, &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt;
(and hence the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; ) is set to &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; in Non
strict mode and &lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; in strict mode.  One more thing.
Binding an already bound function does not change the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;.
It remains set as the value set by first bind function.</source>
          <target state="translated">上記のコードにあるように、 &lt;strong&gt;「バインドされた関数」の「this」値は、call / applyを介して変更できません&lt;/strong&gt; 。 また、 &lt;strong&gt;「this」&lt;/strong&gt;パラメーターが明示的にバインドに渡されない場合、 &lt;strong&gt;「現在のオブジェクト」&lt;/strong&gt; （したがって&lt;strong&gt;「this」の&lt;/strong&gt;値）は、非厳密モードでは&lt;strong&gt;「ウィンドウ」に&lt;/strong&gt; 、厳密モードでは&lt;strong&gt;「未定義」&lt;/strong&gt;に設定されます。 もう一つ。 すでにバインドされている関数をバインドしても、 &lt;strong&gt;「this」の&lt;/strong&gt;値は変更されません。 最初のバインド機能によって設定された値として設定されたままになります。</target>
        </trans-unit>
        <trans-unit id="d5edefb33540455ad04404ac360e751fa53a32fc" translate="yes" xml:space="preserve">
          <source>Below I tried out all the things that we did with Object and &lt;code&gt;this&lt;/code&gt; above, but by first creating function instead of directly writing an object.</source>
          <target state="translated">以下では、Objectと上記で行ったすべてのことを試しましたが、オブジェクトを直接書き込む代わりに、最初に関数を作成しました。</target>
        </trans-unit>
        <trans-unit id="1304a85574c9a47bfc387cb1181284252d8be183" translate="yes" xml:space="preserve">
          <source>Binding and already bound function does not change the value of &quot;this&quot;. It remains set as the value set by first bind function.</source>
          <target state="translated">バインド関数と既にバインドされている関数は、&quot;this &quot;の値を変更しません。最初のバインド関数で設定した値のままです。</target>
        </trans-unit>
        <trans-unit id="21140ee58286bc8b79afc046971cefc9d15813d9" translate="yes" xml:space="preserve">
          <source>But as of ES6 conceptually you can even translate that into</source>
          <target state="translated">しかし、ES6では概念的にはこれを</target>
        </trans-unit>
        <trans-unit id="65a473e0027f5ed69ce186b407bc8fdb48bdca1e" translate="yes" xml:space="preserve">
          <source>By default, and what confuses most beginners, when a listener is called after an event is raised on a DOM element, the &lt;em&gt;this&lt;/em&gt; value of the function is the DOM element.</source>
          <target state="translated">デフォルトで、ほとんどの初心者を混乱させるものとして、DOM要素でイベントが発生した後にリスナーが呼び出される場合、関数の&lt;em&gt;この&lt;/em&gt;値はDOM要素です。</target>
        </trans-unit>
        <trans-unit id="d6d441b4209195e14353f9a1f6054d514dd9abbd" translate="yes" xml:space="preserve">
          <source>By now the difference between &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;bind&lt;/code&gt; must have become apparent. &lt;code&gt;apply&lt;/code&gt; allows to specify the arguments to function as array-like object i.e. an object with a numeric &lt;code&gt;length&lt;/code&gt; property and corresponding non-negative integer properties. Whereas &lt;code&gt;call&lt;/code&gt; allows to specify the arguments to the function directly. Both &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;call&lt;/code&gt; immediately invokes the function in the specified context and with the specified arguments. On the other hand, &lt;code&gt;bind&lt;/code&gt; simply returns the function bound to the specified &lt;code&gt;this&lt;/code&gt; value and the arguments. We can capture the reference to this returned function by assigning it to a variable and later we can call it any time.</source>
          <target state="translated">今では、 &lt;code&gt;apply&lt;/code&gt; 、 &lt;code&gt;call&lt;/code&gt; 、 &lt;code&gt;bind&lt;/code&gt; の違いが明らかになっているはずです。 &lt;code&gt;apply&lt;/code&gt; は、配列のようなオブジェクトとして機能する引数を指定できます。つまり、数値の &lt;code&gt;length&lt;/code&gt; プロパティと対応する負でない整数プロパティを持つオブジェクトです。 一方、 &lt;code&gt;call&lt;/code&gt; は、関数の引数を直接指定できます。 &lt;code&gt;apply&lt;/code&gt; と &lt;code&gt;call&lt;/code&gt; はどちらも、指定されたコンテキストで、指定された引数を使用して関数をすぐに呼び出します。 一方、 &lt;code&gt;bind&lt;/code&gt; は指定された &lt;code&gt;this&lt;/code&gt; 値と引数にバインドされた関数を返すだけです。 この返された関数への参照を変数に割り当てることでキャプチャでき、後でいつでも呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="f4ff7db3d2943e81347a74ac6f68ad3f64995792" translate="yes" xml:space="preserve">
          <source>Calling a function on an object</source>
          <target state="translated">オブジェクトに対する関数の呼び出し</target>
        </trans-unit>
        <trans-unit id="8967949e0052bf4fec471f1e862bcdb2f857d888" translate="yes" xml:space="preserve">
          <source>Calling a method of a object</source>
          <target state="translated">オブジェクトのメソッドを呼び出す</target>
        </trans-unit>
        <trans-unit id="2a0f01b7dbab312f469277a939897da668bb1530" translate="yes" xml:space="preserve">
          <source>Calling functions on Functions: &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;</source>
          <target state="translated">関数の &lt;code&gt;call&lt;/code&gt; 関数： 呼び出しと &lt;code&gt;apply&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a2d9c2f761f313e12a3f59af3ad126c32d5b68b" translate="yes" xml:space="preserve">
          <source>Calling the function with the &lt;code&gt;new&lt;/code&gt; keyword would immediately initialize an &lt;code&gt;Object&lt;/code&gt; of type &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; キーワードを指定して関数を呼び出すと、タイプ &lt;code&gt;Person&lt;/code&gt; の &lt;code&gt;Object&lt;/code&gt; がすぐに初期化されます。</target>
        </trans-unit>
        <trans-unit id="8c59fcda4559bb7741c9e317275c16e64acbc60a" translate="yes" xml:space="preserve">
          <source>Consider a constructor function in Javascript:</source>
          <target state="translated">Javascriptのコンストラクタ関数を考えてみます。</target>
        </trans-unit>
        <trans-unit id="908dded501f1eb025abaae1e462f1b9398ed9b15" translate="yes" xml:space="preserve">
          <source>Consider the following function:</source>
          <target state="translated">次のような関数を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="88d43b78335fb71e23d3a8324b00ba1dcbae38f4" translate="yes" xml:space="preserve">
          <source>Considering a more commonly practical scenario:</source>
          <target state="translated">より一般的な実用的なシナリオを考える</target>
        </trans-unit>
        <trans-unit id="e15054647d5d4825673bec78e395e8f11fd5d1bd" translate="yes" xml:space="preserve">
          <source>Copying &lt;code&gt;this&lt;/code&gt; to solve nested-scope issues.</source>
          <target state="translated">ネストされたスコープの問題を解決するために &lt;code&gt;this&lt;/code&gt; をコピーします。</target>
        </trans-unit>
        <trans-unit id="04b00eef3c0f84d63c5bf373bc4fbfa1f1f1f418" translate="yes" xml:space="preserve">
          <source>Daniel, awesome explanation! A couple of words on this and good list of &lt;code&gt;this&lt;/code&gt; execution context pointer in case of event handlers.</source>
          <target state="translated">ダニエル、素晴らしい説明！ イベントハンドラーの場合の、 &lt;code&gt;this&lt;/code&gt; 実行コンテキストポインターのこのリストおよび適切なリストに関するいくつかの単語。</target>
        </trans-unit>
        <trans-unit id="df12cce3f2c22b0cfea79b58f42e474a2d9806ee" translate="yes" xml:space="preserve">
          <source>Defined in &lt;a href=&quot;https://leanpub.com/understandinges6/read&quot;&gt;ECMA Script 6&lt;/a&gt;, arrow-functions adopt the &lt;code&gt;this&lt;/code&gt; binding from the
enclosing (function or global) scope.</source>
          <target state="translated">&lt;a href=&quot;https://leanpub.com/understandinges6/read&quot;&gt;ECMAスクリプト6&lt;/a&gt;で定義されている矢印関数は、囲み（関数またはグローバル）スコープから &lt;code&gt;this&lt;/code&gt; バインディングを採用します。</target>
        </trans-unit>
        <trans-unit id="128f370e01dcc41eacea0f41d2c828ef2ac1d087" translate="yes" xml:space="preserve">
          <source>Entering eval code</source>
          <target state="translated">evalコードの入力</target>
        </trans-unit>
        <trans-unit id="2ee3bc84b3cdd8c94c92611d8db5e0176f368f84" translate="yes" xml:space="preserve">
          <source>Entering function code</source>
          <target state="translated">関数コードの入力</target>
        </trans-unit>
        <trans-unit id="6d5f131f63e2b46f200e419e32d757a476bff5fb" translate="yes" xml:space="preserve">
          <source>Even if you add function explicitly to the object as a method, it still follows above rules, that is &lt;code&gt;this&lt;/code&gt; still points to the immediate parent object.</source>
          <target state="translated">メソッドとしてオブジェクトに関数を明示的に追加した場合でも、上記のルールに従います。つまり、 &lt;code&gt;this&lt;/code&gt; まだ直接の親オブジェクトを指しています。</target>
        </trans-unit>
        <trans-unit id="5bd2dbf0b8d00773801e52b8a0a2d5c918eeff2f" translate="yes" xml:space="preserve">
          <source>Every &lt;em&gt;execution context&lt;/em&gt; in javascript has a &lt;em&gt;this&lt;/em&gt; parameter that is set by:</source>
          <target state="translated">JavaScriptのすべての&lt;em&gt;実行コンテキスト&lt;/em&gt;には、次の&lt;em&gt;ように&lt;/em&gt;設定される&lt;em&gt;this&lt;/em&gt;パラメータがあります。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="05376964e6969860e3233532567e5c90c576ce63" translate="yes" xml:space="preserve">
          <source>Example constructor:</source>
          <target state="translated">コンストラクタの例です。</target>
        </trans-unit>
        <trans-unit id="4e8e909da4d8e05122cc933de6fde902781e02f1" translate="yes" xml:space="preserve">
          <source>Example event listeners:</source>
          <target state="translated">イベントリスナーの例。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="27a003083ab2583d3a2ad4eed814443aff4033fd" translate="yes" xml:space="preserve">
          <source>Except in the case of DOM event handlers or when a &lt;code&gt;thisArg&lt;/code&gt; is provided (see further down), both in node and in a browser using &lt;code&gt;this&lt;/code&gt; in a function that is not called with &lt;code&gt;new&lt;/code&gt; references the global scope&amp;hellip;</source>
          <target state="translated">DOMイベントハンドラーの場合、または &lt;code&gt;thisArg&lt;/code&gt; が提供されている場合（下を参照）を除き、ノードとブラウザーの両方で、 &lt;code&gt;new&lt;/code&gt; 参照で呼び出されない関数で &lt;code&gt;this&lt;/code&gt; を使用してグローバルスコープ&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="ee189376deeee0556de246c1ff07244efeae84a9" translate="yes" xml:space="preserve">
          <source>Extra stuff, copy this</source>
          <target state="translated">余分なもの、これをコピーします。</target>
        </trans-unit>
        <trans-unit id="a79ebf936a8f65b125ea48abc5225b5dc6cabb06" translate="yes" xml:space="preserve">
          <source>Following the translation to use &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;obj.bar()&lt;/code&gt; becomes &lt;code&gt;const temp = obj.bar; temp.call(obj);&lt;/code&gt;. When we enter the &lt;code&gt;bar&lt;/code&gt; function we call &lt;code&gt;foo&lt;/code&gt; but we explicitly passed in another object for objectForThis so when we arrive at foo &lt;code&gt;this&lt;/code&gt; is that inner object.</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; を使用するように変換すると 、 &lt;code&gt;obj.bar()&lt;/code&gt; は &lt;code&gt;const temp = obj.bar; temp.call(obj);&lt;/code&gt; temp.call（obj）; 。 &lt;code&gt;bar&lt;/code&gt; 関数に入るときに &lt;code&gt;foo&lt;/code&gt; を呼び出しますが、objectForThisの別のオブジェクトを明示的に渡したため、fooに到達すると、 &lt;code&gt;this&lt;/code&gt; がその内部オブジェクトになります。</target>
        </trans-unit>
        <trans-unit id="987a7929690e08340ed411e619558b9514d1934d" translate="yes" xml:space="preserve">
          <source>For an arrow function (special case of context transparency) ask yourself:</source>
          <target state="translated">矢印関数(コンテキスト透過の特殊な場合)については、自問自答してみてください。</target>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">関数呼び出し</target>
        </trans-unit>
        <trans-unit id="845fc2d1f33b0159fa8601b6b79fdc1e053598bf" translate="yes" xml:space="preserve">
          <source>Functions you create become function objects. They automatically get a special &lt;code&gt;prototype&lt;/code&gt; property, which is something you can assign values to. When you create an instance by calling your function with &lt;code&gt;new&lt;/code&gt; you get access to the values you assigned to the &lt;code&gt;prototype&lt;/code&gt; property. You access those values using &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">作成した関数は関数オブジェクトになります。 これらは自動的に特別な &lt;code&gt;prototype&lt;/code&gt; プロパティを取得します。これは、値を割り当てることができるものです。 &lt;code&gt;new&lt;/code&gt; で関数を呼び出してインスタンスを作成すると、 &lt;code&gt;prototype&lt;/code&gt; プロパティに割り当てた値にアクセスできます。 &lt;code&gt;this&lt;/code&gt; を使用してこれらの値にアクセスします。</target>
        </trans-unit>
        <trans-unit id="469e0788e79d852a9a805ea846c580f27362cc2a" translate="yes" xml:space="preserve">
          <source>Gentle explanation of 'this' keyword in JavaScript</source>
          <target state="translated">JavaScriptでの'this'キーワードの優しい説明</target>
        </trans-unit>
        <trans-unit id="14a9ca90c670d793e8de8f4b937b4808ca9a99f8" translate="yes" xml:space="preserve">
          <source>He gives code examples, explanations, and solutions, which I thought was very helpful.</source>
          <target state="translated">コード例や解説、解決策を教えてくれるので、とても参考になると思いました。</target>
        </trans-unit>
        <trans-unit id="542541ad020f39c0dd65066d67e5d1be86126656" translate="yes" xml:space="preserve">
          <source>Here is the summary:</source>
          <target state="translated">以下、まとめです。</target>
        </trans-unit>
        <trans-unit id="1d75950e5613f2d50e01a7e225b9725bf0505513" translate="yes" xml:space="preserve">
          <source>How do we manipulate &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; を &lt;code&gt;call&lt;/code&gt; と &lt;code&gt;apply&lt;/code&gt; でどのように操作しますか？</target>
        </trans-unit>
        <trans-unit id="509b1a748402f9fa1f52f877d915151ea7eacf7c" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;this&lt;/code&gt; work and when should it be used?</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; はどのように機能し、いつ使用する必要がありますか？</target>
        </trans-unit>
        <trans-unit id="c59a24b0ebdaf81d21086f1154af537b99a98f5d" translate="yes" xml:space="preserve">
          <source>How does the “this” keyword work</source>
          <target state="translated">この」というキーワードはどのように作用するのか</target>
        </trans-unit>
        <trans-unit id="8f5642913527f63ddc8d0489b7f04d5dca4b4e15" translate="yes" xml:space="preserve">
          <source>How does this work? Well, let's see what happens when we use the &lt;code&gt;new&lt;/code&gt; keyword.</source>
          <target state="translated">これはどのように作動しますか？ さて、 &lt;code&gt;new&lt;/code&gt; キーワードを使用するとどうなるか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="25cd4eb543ab592a2c8fdba2a85b8eac25657436" translate="yes" xml:space="preserve">
          <source>How is the function &lt;em&gt;invoked&lt;/em&gt;?</source>
          <target state="translated">関数&lt;em&gt;は&lt;/em&gt;どのように&lt;em&gt;呼び出され&lt;/em&gt;ますか？</target>
        </trans-unit>
        <trans-unit id="6f351646cb35f88a1be59388fbb15c6a9a0a2c91" translate="yes" xml:space="preserve">
          <source>How is the value of &lt;code&gt;this&lt;/code&gt; determined?</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; の価値はどのように決定されますか？</target>
        </trans-unit>
        <trans-unit id="2e8b8683e60bc5d1aab340b438427ac67cec8ead" translate="yes" xml:space="preserve">
          <source>How the function is called (including as an object method, use of &lt;em&gt;call&lt;/em&gt; and &lt;em&gt;apply&lt;/em&gt;, use of &lt;em&gt;new&lt;/em&gt;)</source>
          <target state="translated">関数の&lt;em&gt;呼び出し&lt;/em&gt;方法（オブジェクトメソッドとしての&lt;em&gt;呼び出し&lt;/em&gt; 、 &lt;em&gt;call&lt;/em&gt;および&lt;em&gt;applyの&lt;/em&gt;使用、 &lt;em&gt;newの&lt;/em&gt;使用を含む）</target>
        </trans-unit>
        <trans-unit id="41df7a9ac498fb8701396ea8333d73de768c8a4f" translate="yes" xml:space="preserve">
          <source>However use of &lt;code&gt;this&lt;/code&gt; indirectly through the other function called inside the event handling function or event property resolves to the global object &lt;code&gt;window&lt;/code&gt;.</source>
          <target state="translated">ただし、イベント処理関数またはイベントプロパティ内で呼び出された他の関数を介して間接的に &lt;code&gt;this&lt;/code&gt; 使用すると、グローバルオブジェクト &lt;code&gt;window&lt;/code&gt; 解決されます 。</target>
        </trans-unit>
        <trans-unit id="b57106c514445ec802e1cd473722a5a17ec00810" translate="yes" xml:space="preserve">
          <source>However, invoking it explicitly using window object shall result in
the following</source>
          <target state="translated">ただし、ウィンドウオブジェクトを用いて明示的に呼び出すと、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f29f3dcc991cc0d0219d93627781059b44927c91" translate="yes" xml:space="preserve">
          <source>I have a different take on &lt;code&gt;this&lt;/code&gt; from the other answers that I hope is helpful.</source>
          <target state="translated">私は &lt;code&gt;this&lt;/code&gt; が他の回答とは異なる見方をしています。</target>
        </trans-unit>
        <trans-unit id="12126d6f03dcab3e8bc1580e1ffa7e034bb107bc" translate="yes" xml:space="preserve">
          <source>I have noticed that there doesn't appear to be a clear explanation of what the &lt;code&gt;this&lt;/code&gt; keyword is and how it is correctly (and incorrectly) used in JavaScript on the Stack Overflow site.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; キーワードが何であるか、およびStack OverflowサイトのJavaScriptで正しく（および誤って）使用されている方法の明確な説明がないようです。</target>
        </trans-unit>
        <trans-unit id="1460f7d950fc7da3126879c166cd50e7e5efc4dc" translate="yes" xml:space="preserve">
          <source>I have witnessed some very strange behaviour with it and have failed to understand why it has occurred.</source>
          <target state="translated">非常に奇妙な行動を目の当たりにしましたが、なぜそれが起こったのか理解できませんでした。</target>
        </trans-unit>
        <trans-unit id="5a8ffb9e545c5cf5851a2f18d53651ef1e65e1af" translate="yes" xml:space="preserve">
          <source>I recommend reading &lt;a href=&quot;https://mikewest.org&quot;&gt;Mike West&lt;/a&gt;'s article &lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;Scope in JavaScript&lt;/a&gt; (&lt;a href=&quot;http://web.archive.org/web/20110725013125/http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;mirror&lt;/a&gt;) first. It is an excellent, friendly introduction to the concepts of &lt;code&gt;this&lt;/code&gt; and scope chains in JavaScript.</source>
          <target state="translated">最初に&lt;a href=&quot;https://mikewest.org&quot;&gt;Mike West&lt;/a&gt;の記事&lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;Scope in JavaScript&lt;/a&gt; （ &lt;a href=&quot;http://web.archive.org/web/20110725013125/http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;mirror&lt;/a&gt; ）を読むことをお勧めします 。 これは、JavaScriptの &lt;code&gt;this&lt;/code&gt; 概念とスコープチェーンの概念をわかりやすく、わかりやすく紹介したものです。</target>
        </trans-unit>
        <trans-unit id="2f8031248cc83596d7bde88186a31b74ce913e61" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Object&lt;/code&gt; contains a property which holds a &lt;code&gt;Function&lt;/code&gt;, the property is called a method. This method, when called, will always have it's &lt;code&gt;this&lt;/code&gt; variable set to the &lt;code&gt;Object&lt;/code&gt; it is associated with. This is true for both strict and non-strict modes.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; に &lt;code&gt;Function&lt;/code&gt; を保持するプロパティが含まれている場合、そのプロパティはメソッドと呼ばれます。 このメソッドが呼び出されると、関連付けられている &lt;code&gt;Object&lt;/code&gt; に設定された &lt;code&gt;this&lt;/code&gt; 変数が常に使用されます。 これは、厳密モードと非厳密モードの両方に当てはまります。</target>
        </trans-unit>
        <trans-unit id="f9f88fafad52186ab62424ffeb6795041b66ab36" translate="yes" xml:space="preserve">
          <source>If no explicit owner is defined, then the top most owner, the window object, is referenced.</source>
          <target state="translated">明示的な所有者が定義されていない場合は、最上位の所有者であるウィンドウオブジェクトが参照されます。</target>
        </trans-unit>
        <trans-unit id="abea008c9ccdd3ff813706bd9d78b13581e069ae" translate="yes" xml:space="preserve">
          <source>If the event handler is inline, &lt;code&gt;this&lt;/code&gt; refers to global object</source>
          <target state="translated">イベントハンドラーがインラインの場合、 &lt;code&gt;this&lt;/code&gt; はグローバルオブジェクトを参照します</target>
        </trans-unit>
        <trans-unit id="f545568898aa3f9f5ee670cd77b9d433d0a46089" translate="yes" xml:space="preserve">
          <source>If the function is called with NEW keyword then THIS will be bound to the newly created object.</source>
          <target state="translated">関数がNEWキーワードで呼び出された場合、THISは新しく作成されたオブジェクトにバインドされます。</target>
        </trans-unit>
        <trans-unit id="6ee87374d289abdd7ecf8ddb47adfb37ca1d1d0e" translate="yes" xml:space="preserve">
          <source>If the method is on an object's prototype chain, &lt;code&gt;this&lt;/code&gt; inside such method refers to the object the method was called on, as if the method is defined on the object.</source>
          <target state="translated">メソッドがオブジェクトのプロトタイプチェーン上にある場合、そのようなメソッド内のこのメソッドは、メソッドがオブジェクトで定義されているかのように、メソッドが呼び出されたオブジェクトを参照します。</target>
        </trans-unit>
        <trans-unit id="0f184b072ae7cca9bec0b9152d5ee281a0952b2c" translate="yes" xml:space="preserve">
          <source>If we miss &lt;code&gt;new&lt;/code&gt; keyword, &lt;code&gt;whatIsThis&lt;/code&gt; referes to the most global context it can find(&lt;code&gt;window&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; キーワードを見逃した場合、 &lt;code&gt;whatIsThis&lt;/code&gt; は、検索できる最もグローバルなコンテキストを参照します（ &lt;code&gt;window&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="08b356112172b63c41e869c9033bb2d83cf69377" translate="yes" xml:space="preserve">
          <source>If you are wondering how a JavaScript library manipulates the value of &lt;code&gt;this&lt;/code&gt;, the library is simply using one of the built-in JavaScript functions accepting a &lt;code&gt;thisArg&lt;/code&gt;. You, too, can write your own function taking a callback function and &lt;code&gt;thisArg&lt;/code&gt;:</source>
          <target state="translated">JavaScriptライブラリが &lt;code&gt;this&lt;/code&gt; の値をどのように操作するのか疑問に思っている場合、ライブラリは &lt;code&gt;thisArg&lt;/code&gt; を受け入れる組み込みのJavaScript関数の1つを単に使用しています。 あなたも、コールバック関数と &lt;code&gt;thisArg&lt;/code&gt; を取る独自の関数を書くことができます：</target>
        </trans-unit>
        <trans-unit id="a05e4a50ca55b0ab68c8d4be4da417b51bf22da0" translate="yes" xml:space="preserve">
          <source>If you call a function with &lt;code&gt;new&lt;/code&gt; the &lt;code&gt;this&lt;/code&gt; will be a new context, it will not reference the global &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; で関数を呼び出すと、 &lt;code&gt;this&lt;/code&gt; は新しいコンテキストとなり、グローバル &lt;code&gt;this&lt;/code&gt; を参照しません。</target>
        </trans-unit>
        <trans-unit id="02cbcf4e964a2153e423ad418b22f8c3fd0762a2" translate="yes" xml:space="preserve">
          <source>If you just call a function then &lt;code&gt;this&lt;/code&gt; is the &quot;global object&quot; which in the browser is the window</source>
          <target state="translated">関数を呼び出すだけの場合、 &lt;code&gt;this&lt;/code&gt; は「グローバルオブジェクト」であり、ブラウザではウィンドウです。</target>
        </trans-unit>
        <trans-unit id="d0e810fa1822dca8618162a82abee010cf8edbef" translate="yes" xml:space="preserve">
          <source>If you run this same piece of code in an environment like node.js, &lt;code&gt;this&lt;/code&gt; would refer to the global variable in your app.</source>
          <target state="translated">これと同じコードをnode.jsのような環境で実行する場合、 &lt;code&gt;this&lt;/code&gt; はアプリのグローバル変数を参照します。</target>
        </trans-unit>
        <trans-unit id="d3d6688717298c61d86ba4872a3543c0973adcae" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;use strict;&lt;/code&gt;, in which case &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;use strict;&lt;/code&gt; を使用する場合; 、その場合、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;undefined&lt;/code&gt; なります</target>
        </trans-unit>
        <trans-unit id="4534c020e272fd844f4a0447a32701b45e3c9a14" translate="yes" xml:space="preserve">
          <source>In &quot;Non Strict Mode&quot;, Calling/Invoking this function directly through   &lt;strong&gt;&quot;UserDefinedFunction()&quot;&lt;/strong&gt; will automatically call/invoke
it as &lt;strong&gt;&quot;window.UserDefinedFunction()&quot;&lt;/strong&gt; making &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; as the
&lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; (and hence the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) within &lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt;.Invoking this function in &quot;Non Strict Mode&quot; will result in the following</source>
          <target state="translated">「非厳密モード」では、 &lt;strong&gt;「UserDefinedFunction（）」&lt;/strong&gt;を介してこの関数を直接呼び出し/呼び出すと、自動的に&lt;strong&gt;「window.UserDefinedFunction（）」&lt;/strong&gt;として&lt;strong&gt;呼び出さ&lt;/strong&gt;れ、 &lt;strong&gt;「&lt;/strong&gt; &lt;strong&gt;window」&lt;/strong&gt;が&lt;strong&gt;「現在のオブジェクト」&lt;/strong&gt; （したがって&lt;strong&gt;「」&lt;/strong&gt;の値）になります&lt;strong&gt;。 this&lt;/strong&gt; ））内の&lt;strong&gt;「&lt;/strong&gt; UserDefinedFunction &lt;strong&gt;」&lt;/strong&gt; 。この関数を「非厳密モード」で呼び出すと、次のようになります。</target>
        </trans-unit>
        <trans-unit id="a86f46ab5fd04ce187322c9dacbc63583d2300ac" translate="yes" xml:space="preserve">
          <source>In &quot;Strict Mode&quot;, Calling/Invoking the function directly through
&lt;strong&gt;&quot;UserDefinedFunction()&quot;&lt;/strong&gt; will &lt;strong&gt;&quot;NOT&quot;&lt;/strong&gt; automatically call/invoke it as &lt;strong&gt;&quot;window.UserDefinedFunction()&quot;&lt;/strong&gt;.Hence the &lt;strong&gt;&quot;current
object&quot;&lt;/strong&gt; (and the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) within
&lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt; shall be &lt;strong&gt;undefined&lt;/strong&gt;. Invoking this function in &quot;Strict Mode&quot; will result in the following</source>
          <target state="translated">「厳密モード」では、 &lt;strong&gt;「UserDefinedFunction（）」&lt;/strong&gt;を介して直接関数を呼び出したり呼び出したりしても、自動的に&lt;strong&gt;「window.UserDefinedFunction（）」&lt;/strong&gt;として呼び出されたり呼び出されたりし&lt;strong&gt;ません&lt;/strong&gt; &lt;strong&gt;。&lt;/strong&gt;したがって、 &lt;strong&gt;「現在のオブジェクト」&lt;/strong&gt; （および&lt;strong&gt;「this」の&lt;/strong&gt;値） ） &lt;strong&gt;「UserDefinedFunction」&lt;/strong&gt;内は&lt;strong&gt;未定義&lt;/strong&gt;です。 この機能を「厳密モード」で呼び出すと、次のようになります。</target>
        </trans-unit>
        <trans-unit id="324ac6a318b326d5cd6ec138a5535c67787f43fe" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;node&lt;/code&gt; executing from a script, &lt;code&gt;this&lt;/code&gt; at the global scope starts as an empty object. It is not the same as &lt;code&gt;global&lt;/code&gt;</source>
          <target state="translated">スクリプトから実行する &lt;code&gt;node&lt;/code&gt; では、 &lt;code&gt;this&lt;/code&gt; はグローバルスコープで空のオブジェクトとして始まります。 &lt;code&gt;global&lt;/code&gt; と同じではありません</target>
        </trans-unit>
        <trans-unit id="e86f9b9c713dc09a44f881bdef02363ebb098cc7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;node&lt;/code&gt; using the repl, &lt;code&gt;this&lt;/code&gt; is the top namespace. You can refer to it as &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">replを使用する &lt;code&gt;node&lt;/code&gt; は、 &lt;code&gt;this&lt;/code&gt; が最上位の名前空間です。 あなたはそれを &lt;code&gt;global&lt;/code&gt; 呼ぶことができます。</target>
        </trans-unit>
        <trans-unit id="ffab00b98bc67260544caac0fccb102e726b7819" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;Client/Browser&lt;/strong&gt;&lt;code&gt;this&lt;/code&gt; keyword is a global object which is &lt;code&gt;window&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;クライアント/ブラウザで&lt;/strong&gt;は、 &lt;code&gt;this&lt;/code&gt; キーワードは &lt;code&gt;window&lt;/code&gt; あるグローバルオブジェクトです</target>
        </trans-unit>
        <trans-unit id="1f8bea0a49922aa0e3476e6f13ff485166460709" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;Server/Node/Javascript runtime&lt;/strong&gt;&lt;code&gt;this&lt;/code&gt; keyword is also a global object which is &lt;code&gt;module.exports&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;サーバー/ノード/ JavaScriptランタイムでは、&lt;/strong&gt; &lt;code&gt;this&lt;/code&gt; キーワードも &lt;code&gt;module.exports&lt;/code&gt; であるグローバルオブジェクトです</target>
        </trans-unit>
        <trans-unit id="4079e8901c7bbc5e93844e5cba0c225cbd71f87b" translate="yes" xml:space="preserve">
          <source>In Global Context &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; always refers to the &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; object</source>
          <target state="translated">グローバルコンテキストでは、 &lt;strong&gt;「this」は&lt;/strong&gt;常に&lt;strong&gt;「window」&lt;/strong&gt;オブジェクトを指します</target>
        </trans-unit>
        <trans-unit id="2878a1d2151511dedfc3b49078b6bb8743b5e514" translate="yes" xml:space="preserve">
          <source>In JavaScript there are operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;. There is also the dot operator which is &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">JavaScriptには &lt;code&gt;+&lt;/code&gt; や &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; などの演算子があります。 ドット演算子もあり &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6efa6728b16de4e8625617c966cac872299fcc61" translate="yes" xml:space="preserve">
          <source>In a browser, at the global scope, &lt;code&gt;this&lt;/code&gt; is the &lt;code&gt;window&lt;/code&gt;object</source>
          <target state="translated">ブラウザーのグローバルスコープでは、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;window&lt;/code&gt; オブジェクトです。</target>
        </trans-unit>
        <trans-unit id="471827f41377d6ddd619a309af3ab2d6e951cd2c" translate="yes" xml:space="preserve">
          <source>In an HTML DOM event handler, &lt;code&gt;this&lt;/code&gt; is always a reference to the DOM element the event was attached to</source>
          <target state="translated">HTML DOMイベントハンドラーでは、 &lt;code&gt;this&lt;/code&gt; は常に、イベントがアタッチされたDOM要素への参照です。</target>
        </trans-unit>
        <trans-unit id="f43a8566d5e8782dd6106131e8e134eb235d04cf" translate="yes" xml:space="preserve">
          <source>In an arrow function, &lt;code&gt;this&lt;/code&gt; will behave like common variables: it will be inherited from its lexical scope. The function's &lt;code&gt;this&lt;/code&gt;, where the arrow function is defined, will be the arrow function's &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">アロー関数では、 &lt;code&gt;this&lt;/code&gt; は一般的な変数のように動作します。レキシカルスコープから継承されます。 アロー関数が定義されている関数の &lt;code&gt;this&lt;/code&gt; は、アロー関数のthisになります。</target>
        </trans-unit>
        <trans-unit id="e0ed578783f6c0844fb69401e88c46b1d4c812d5" translate="yes" xml:space="preserve">
          <source>In both cases, this is set to window.</source>
          <target state="translated">どちらの場合も、これはwindowに設定されています。</target>
        </trans-unit>
        <trans-unit id="3c2d641383f797d7802108f589e4b9aefd246bdb" translate="yes" xml:space="preserve">
          <source>In event listeners the value of &lt;code&gt;this&lt;/code&gt;  refers to the DOM element on which the event was called.</source>
          <target state="translated">イベントリスナーでは、 &lt;code&gt;this&lt;/code&gt; 値はイベントが呼び出されたDOM要素を参照します。</target>
        </trans-unit>
        <trans-unit id="21221c02e3ea6b186925dee47bb0aff97b3c7622" translate="yes" xml:space="preserve">
          <source>In other words &lt;code&gt;bar.foo()&lt;/code&gt; translates into &lt;code&gt;const temp = bar.foo; temp.call(bar);&lt;/code&gt;</source>
          <target state="translated">つまり、 &lt;code&gt;bar.foo()&lt;/code&gt; は &lt;code&gt;const temp = bar.foo; temp.call(bar);&lt;/code&gt; 変換されます。 temp.call（bar）;</target>
        </trans-unit>
        <trans-unit id="e583468a15187c915f71a5317544c6b871de6462" translate="yes" xml:space="preserve">
          <source>In other words,</source>
          <target state="translated">言い換えれば</target>
        </trans-unit>
        <trans-unit id="27d6a458ca3d5e041f95d454ee2e6dbc62b5e228" translate="yes" xml:space="preserve">
          <source>In pseudoclassical terms, the way many lectures teach the 'this' keyword is as an object instantiated by a class or object constructor. Each time a new object is constructed from a class, imagine that under the hood a local instance of a 'this' object is created and returned. I remember it taught like this:</source>
          <target state="translated">擬似古典派用語では、多くの講義で「this」キーワードを教える方法は、クラスやオブジェクトのコンストラクタによってインスタンス化されたオブジェクトとして教えています。新しいオブジェクトがクラスから構築されるたびに、'this' オブジェクトのローカルインスタンスが作成されて返されることを想像してください。私はこのように教えられたのを覚えています。</target>
        </trans-unit>
        <trans-unit id="cd2387ea5c279e482429632a93ee4100a845238a" translate="yes" xml:space="preserve">
          <source>In the above code, we see that the value of &lt;code&gt;this&lt;/code&gt; changed with the nested scope, but we wanted the value of &lt;code&gt;this&lt;/code&gt; from the original scope. So we 'copied' &lt;code&gt;this&lt;/code&gt; to &lt;code&gt;that&lt;/code&gt; and used the copy instead of &lt;code&gt;this&lt;/code&gt;. Clever, eh?</source>
          <target state="translated">上記のコードでは、ネストされたスコープによって &lt;code&gt;this&lt;/code&gt; の値が変化したことがわかりますが、元のスコープから &lt;code&gt;this&lt;/code&gt; 値を求めていました。 そのため、これを「コピー」し、 &lt;code&gt;this&lt;/code&gt; 代わりにコピーを使用しました。 賢い、え？</target>
        </trans-unit>
        <trans-unit id="43224f60c133b11951481d44412c4fce99a0226f" translate="yes" xml:space="preserve">
          <source>In the above example we see that when &lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt; was
invoked through &lt;strong&gt;o1&lt;/strong&gt;, &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; takes value of &lt;strong&gt;o1&lt;/strong&gt; and the
value of its properties &lt;strong&gt;&quot;a&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;b&quot;&lt;/strong&gt; get displayed. The value
of &lt;strong&gt;&quot;c&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;d&quot;&lt;/strong&gt; were shown as &lt;strong&gt;undefined&lt;/strong&gt; as &lt;strong&gt;o1&lt;/strong&gt; does
not define these properties</source>
          <target state="translated">上記の例では、 &lt;strong&gt;「UserDefinedFunction」&lt;/strong&gt;が&lt;strong&gt;o1&lt;/strong&gt;を介して呼び出された場合、 &lt;strong&gt;「this」&lt;/strong&gt;は&lt;strong&gt;o1の&lt;/strong&gt;値を取り、そのプロパティ&lt;strong&gt;「a」&lt;/strong&gt;と&lt;strong&gt;「b」の値&lt;/strong&gt;が表示されることがわかります。 &lt;strong&gt;「c」&lt;/strong&gt;と&lt;strong&gt;「d」&lt;/strong&gt;の値は、 &lt;strong&gt;o1&lt;/strong&gt;がこれらのプロパティを定義しないため、 &lt;strong&gt;未定義&lt;/strong&gt;として表示されました</target>
        </trans-unit>
        <trans-unit id="96cc1a99aaa4e2084ab88b3ca40dccb578c47d7d" translate="yes" xml:space="preserve">
          <source>In the above this will be bound to 'myCar' object</source>
          <target state="translated">上記の場合、これは'myCar'オブジェクトにバインドされます。</target>
        </trans-unit>
        <trans-unit id="c83013fb1cd27e083ad60085d21979e56ba40fe5" translate="yes" xml:space="preserve">
          <source>In the case of the &lt;code&gt;Array.prototype&lt;/code&gt; functions, the given &lt;code&gt;callbackfn&lt;/code&gt; is called in an execution context where ThisBinding is set to &lt;code&gt;thisArg&lt;/code&gt; if supplied; otherwise, to the global object.</source>
          <target state="translated">&lt;code&gt;Array.prototype&lt;/code&gt; 関数の場合、指定された &lt;code&gt;callbackfn&lt;/code&gt; fnは、ThisContextingがthisArgに設定されている実行コンテキストで呼び出されます（指定されて &lt;code&gt;thisArg&lt;/code&gt; 場合）。 それ以外の場合は、グローバルオブジェクトに。</target>
        </trans-unit>
        <trans-unit id="c033f7496c40486ad987d93a68b83caa6838c09d" translate="yes" xml:space="preserve">
          <source>In the case of the &lt;code&gt;Function.prototype&lt;/code&gt; functions, they are called on a function object, but rather than setting ThisBinding to the function object, ThisBinding is set to the &lt;code&gt;thisArg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Function.prototype&lt;/code&gt; 関数の場合、関数オブジェクトで呼び出されますが、ThisBindingを関数オブジェクトに設定するのではなく、 &lt;code&gt;thisArg&lt;/code&gt; 設定します。</target>
        </trans-unit>
        <trans-unit id="aaeae9315cfc2930a15076b4cb90e923ca76ddd7" translate="yes" xml:space="preserve">
          <source>In the first example, the font color of the button shall be set to
white when it is clicked.</source>
          <target state="translated">第1の例では、ボタンがクリックされたときのフォント色を白に設定するものとする。</target>
        </trans-unit>
        <trans-unit id="2e598c3cda0bdc325d8abb172c4e83c3b44ff6a8" translate="yes" xml:space="preserve">
          <source>In the following cases, we would see how to manipulate the value of &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">次の場合、 &lt;code&gt;this&lt;/code&gt; の値を操作する方法を確認します。</target>
        </trans-unit>
        <trans-unit id="430cd67bcc3100745a24d8b9fbad17bfca3af311" translate="yes" xml:space="preserve">
          <source>In the latter case, you merely reference the function, not hand it over to the element. Therefore, &lt;code&gt;this&lt;/code&gt; will refer to the window object.</source>
          <target state="translated">後者の場合、関数に参照を渡すだけで、要素には渡しません。 したがって、 &lt;code&gt;this&lt;/code&gt; はウィンドウオブジェクトを参照します。</target>
        </trans-unit>
        <trans-unit id="1dd405f2048b51f3afad5fd52c3f9bfc8120d1ae" translate="yes" xml:space="preserve">
          <source>In the second example when the &lt;strong&gt;&quot;div&quot;&lt;/strong&gt; element is clicked it shall
call the &lt;strong&gt;OnDivClick&lt;/strong&gt; function with its second parameter
referencing the clicked div element. However the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;
within OnDivClick &lt;strong&gt;SHALL NOT&lt;/strong&gt; reference the clicked &lt;strong&gt;div&lt;/strong&gt;
element. It shall be set as the &lt;strong&gt;&quot;window object&quot;&lt;/strong&gt; or
&lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; in &lt;strong&gt;Non strict&lt;/strong&gt; and &lt;strong&gt;Strict Modes&lt;/strong&gt; respectively (if &lt;strong&gt;OnDivClick&lt;/strong&gt; is an &lt;strong&gt;unbound function&lt;/strong&gt;) or set to a predefined
Bound value (if &lt;strong&gt;OnDivClick&lt;/strong&gt; is a &lt;strong&gt;bound function&lt;/strong&gt;)</source>
          <target state="translated">2番目の例では、 &lt;strong&gt;「div」&lt;/strong&gt;要素がクリックされると、クリックされたdiv要素を参照する2番目のパラメーターで&lt;strong&gt;OnDivClick&lt;/strong&gt;関数を呼び出します。 ただし、OnDivClick内の&lt;strong&gt;「this」の&lt;/strong&gt;値は、クリックされた&lt;strong&gt;div&lt;/strong&gt;要素を参照してはなり&lt;strong&gt;ません&lt;/strong&gt; 。 これは、 &lt;strong&gt;非厳密&lt;/strong&gt; &lt;strong&gt;モード&lt;/strong&gt;と&lt;strong&gt;厳密モードで&lt;/strong&gt;それぞれ&lt;strong&gt;「ウィンドウオブジェクト」&lt;/strong&gt;または&lt;strong&gt;「未定義」&lt;/strong&gt;として設定されるか（ &lt;strong&gt;OnDivClick&lt;/strong&gt;が&lt;strong&gt;非バインド関数の場合&lt;/strong&gt; ）、または事前定義されたBound値に設定されます（ &lt;strong&gt;OnDivClick&lt;/strong&gt;が&lt;strong&gt;バインド関数の場合&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="81ed2e6a494f7f2dc46f5d18d6632785957e98bc" translate="yes" xml:space="preserve">
          <source>In this case, THIS will be bound to the object which is explicitly passed to the function.</source>
          <target state="translated">この場合、thisは明示的に関数に渡されたオブジェクトにバインドされます。</target>
        </trans-unit>
        <trans-unit id="0df985536051bb82097890e1a0953285b688bcea" translate="yes" xml:space="preserve">
          <source>In this example, the JavaScript interpreter enters function code, but because &lt;code&gt;myFun&lt;/code&gt;/&lt;code&gt;obj.myMethod&lt;/code&gt; is not called on an object, ThisBinding is set to &lt;code&gt;window&lt;/code&gt;.</source>
          <target state="translated">この例では、JavaScriptインタープリターが関数コードに入りますが、 &lt;code&gt;myFun&lt;/code&gt; / &lt;code&gt;obj.myMethod&lt;/code&gt; がオブジェクトで呼び出されないため、ThisBindingは &lt;code&gt;window&lt;/code&gt; に設定されます 。</target>
        </trans-unit>
        <trans-unit id="2bb2e91de5338b6aa278265043941f191287a902" translate="yes" xml:space="preserve">
          <source>In two words, &lt;code&gt;this&lt;/code&gt; in JavaScript points the object from whom (or from whose execution context) the current function was run and it's always read-only, you can't set it anyway (such an attempt will end up with 'Invalid left-hand side in assignment' message.</source>
          <target state="translated">つまり、JavaScriptの &lt;code&gt;this&lt;/code&gt; は、現在の関数の実行元（または実行コンテキスト）のオブジェクトをポイントし、常に読み取り専用であり、それを設定することはできません（そのような試みは、「無効な左-割り当てのメッセージのハンドサイド。</target>
        </trans-unit>
        <trans-unit id="934e0a8e43701b41d397444e208dc6649f33774f" translate="yes" xml:space="preserve">
          <source>Index:</source>
          <target state="translated">Index:</target>
        </trans-unit>
        <trans-unit id="8659b0f0077283eb99e2d1bd963b7db35f13f69b" translate="yes" xml:space="preserve">
          <source>Inside HTML attributes in which you can put JavaScript, &lt;code&gt;this&lt;/code&gt; is a reference to the element.</source>
          <target state="translated">JavaScriptを配置できるHTML属性の内部では、 &lt;code&gt;this&lt;/code&gt; は要素への参照です。</target>
        </trans-unit>
        <trans-unit id="9e308c1af402a51e3c742eaeb80b4ffd7fa67c95" translate="yes" xml:space="preserve">
          <source>Inside a Direct  &quot;Non Bound Function&quot; Call, &lt;strong&gt;the object that
invoked the function call becomes the &quot;current object&quot;&lt;/strong&gt; (and hence
the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;). If a function is called without a explicit &lt;strong&gt;current object&lt;/strong&gt;, the &lt;strong&gt;current object&lt;/strong&gt; is either the &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; object (For Non Strict Mode) or &lt;strong&gt;undefined&lt;/strong&gt; (For Strict Mode)  . Any function (or variable) defined in
&lt;strong&gt;Global Context&lt;/strong&gt; automatically becomes a property of the &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; object.For e.g Suppose function is defined in Global Context as</source>
          <target state="translated">直接「非バインド関数」呼び出しの内部&lt;strong&gt;では、関数呼び出しを呼び出したオブジェクトが「現在のオブジェクト」になります&lt;/strong&gt; （したがって、 &lt;strong&gt;「this」の&lt;/strong&gt;値になります）。 明示的な&lt;strong&gt;現在のオブジェクト&lt;/strong&gt;なしで関数が呼び出された場合、 &lt;strong&gt;現在のオブジェクト&lt;/strong&gt;は&lt;strong&gt;「ウィンドウ」&lt;/strong&gt;オブジェクト（非厳密モードの場合）または&lt;strong&gt;未定義&lt;/strong&gt; （厳密モードの場合）のいずれかです。 &lt;strong&gt;グローバルコンテキストで&lt;/strong&gt;定義された関数（または変数）は、自動的に&lt;strong&gt;「ウィンドウ」&lt;/strong&gt;オブジェクトのプロパティになり&lt;strong&gt;ます。&lt;/strong&gt;たとえば、Suppose関数はグローバルコンテキストで次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="e90ac117b0316d7973d69a03502107870607096b" translate="yes" xml:space="preserve">
          <source>Inside a constructor function, the &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; (and hence the value of 
&lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) references the object that is currently being created
through &lt;strong&gt;&quot;new&quot;&lt;/strong&gt; irrespective of the bind status of the function. However
if the constructor is a bound function it shall get called with 
predefined set of arguments as set for the bound function.</source>
          <target state="translated">コンストラクター関数内では、 &lt;strong&gt;「現在のオブジェクト」&lt;/strong&gt; （したがって&lt;strong&gt;「this」の&lt;/strong&gt;値）は、関数のバインドステータスに関係なく、 &lt;strong&gt;「new」&lt;/strong&gt;を通じて現在作成されているオブジェクトを参照します。 ただし、コンストラクターがバインドされた関数の場合は、バインドされた関数に設定されている事前定義された引数のセットを使用して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="07896e58b529f3fb8b5b73a6120efa70bb3ab536" translate="yes" xml:space="preserve">
          <source>Irrespective of the context in which it is used, &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; always references the &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; in Javascript. However, what the &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; is  differs according to &lt;strong&gt;context&lt;/strong&gt;. The &lt;strong&gt;context&lt;/strong&gt; may be exactly &lt;strong&gt;1 of the 6&lt;/strong&gt; following:</source>
          <target state="translated">それが使用されるコンテキストに関係なく、 &lt;strong&gt;「this」は&lt;/strong&gt;常にJavaScriptの&lt;strong&gt;「現在のオブジェクト」を&lt;/strong&gt;参照し&lt;strong&gt;ます&lt;/strong&gt; 。 ただし、 &lt;strong&gt;「現在のオブジェクト」&lt;/strong&gt;とは、 &lt;strong&gt;コンテキスト&lt;/strong&gt;によって異なり&lt;strong&gt;ます&lt;/strong&gt; 。 &lt;strong&gt;コンテキスト&lt;/strong&gt;は&lt;strong&gt;、&lt;/strong&gt;次&lt;strong&gt;の6つの中の1つです&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ddbde6677e66a2eef6ce94f5856c81e48273985" translate="yes" xml:space="preserve">
          <source>It is difficult to get a good grasp of JS, or write more than anything trivial in it, if you don't understand it thoroughly. You cannot just afford to take a quick dip :) I think the best way to get started with JS is to first watch these video lectures by Douglas Crockford - &lt;a href=&quot;http://yuiblog.com/crockford/&quot;&gt;http://yuiblog.com/crockford/&lt;/a&gt;, which covers this and that, and everything else about JS.</source>
          <target state="translated">JSを完全に理解していないと、JSを十分に理解したり、些細なことよりも多くを記述したりすることは困難です。 あなたはちょっとひと泳ぎするだけの余裕はありません:)私はJSを始めるための最良の方法は、ダグラス・クロックフォードによるこれらのビデオ講義を最初に見ることです-http: &lt;a href=&quot;http://yuiblog.com/crockford/&quot;&gt;//yuiblog.com/crockford/&lt;/a&gt; JSに関する他のすべて。</target>
        </trans-unit>
        <trans-unit id="7126c04f305ed904207b61e181769dea029be5b6" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to assign &lt;em&gt;arrays&lt;/em&gt; or &lt;em&gt;objects&lt;/em&gt; on the &lt;code&gt;prototype&lt;/code&gt;. If you want instances to each have their own arrays, create them in the function, not the prototype.</source>
          <target state="translated">通常、 &lt;code&gt;prototype&lt;/code&gt; に&lt;em&gt;配列&lt;/em&gt;または&lt;em&gt;オブジェクト&lt;/em&gt;を割り当てるのは誤りです。 インスタンスごとに独自の配列が必要な場合は、プロトタイプではなく関数内にインスタンスを作成します。</target>
        </trans-unit>
        <trans-unit id="992dc5d399c1eb9c5819d08e8cdc27405e9a0bff" translate="yes" xml:space="preserve">
          <source>JQuery proxy is another way you can use to make sure this in a function will be the value you desire. (Check &lt;a href=&quot;https://stackoverflow.com/q/4986329/340046&quot;&gt;Understanding $.proxy()&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/q/3349380/340046&quot;&gt;jQuery.proxy() usage&lt;/a&gt;)</source>
          <target state="translated">JQueryプロキシーは、関数内でこれを確実に希望の値にするために使用できるもう1つの方法です。 （ &lt;a href=&quot;https://stackoverflow.com/q/4986329/340046&quot;&gt;$ .proxy（）&lt;/a&gt; 、 &lt;a href=&quot;https://stackoverflow.com/q/3349380/340046&quot;&gt;jQuery.proxy（）の使用法の&lt;/a&gt; 理解を確認してください）</target>
        </trans-unit>
        <trans-unit id="be6b0ab456696ba8d67592a42d2412b774842021" translate="yes" xml:space="preserve">
          <source>Javascript's &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">JavaScriptは &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2453951365a295c5909c9ed643507672357709f3" translate="yes" xml:space="preserve">
          <source>Just for fun, test your understanding with some examples</source>
          <target state="translated">お楽しみに、いくつかの例を使ってあなたの理解度をテストしてみてください。</target>
        </trans-unit>
        <trans-unit id="894c85eb8e48c996ee7525b62829676432dc120f" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;bind&lt;/code&gt;, a new invisible function is created that calls the given function with a bound value for &lt;code&gt;objectForThis&lt;/code&gt; but unlike &lt;code&gt;bind&lt;/code&gt; the object to be bound is implicit. It's whatever &lt;code&gt;this&lt;/code&gt; happens to be when the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is used.</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; と同じように、 &lt;code&gt;objectForThis&lt;/code&gt; のバインドされた値で指定された関数を呼び出す新しい非表示の関数が作成されますが、 &lt;code&gt;bind&lt;/code&gt; とは異なり、 バインドされるオブジェクトは暗黙的です。 &lt;code&gt;=&amp;gt;&lt;/code&gt; 演算子が使用されている場合、 &lt;code&gt;this&lt;/code&gt; が起こります。</target>
        </trans-unit>
        <trans-unit id="fcbd5d2a27f1bec48bd69a467c70b7017b49d1da" translate="yes" xml:space="preserve">
          <source>Keep in mind &lt;code&gt;exports&lt;/code&gt; is just a reference to &lt;code&gt;module.exports&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;exports&lt;/code&gt; は &lt;code&gt;module.exports&lt;/code&gt; への参照にすぎないことに注意してください</target>
        </trans-unit>
        <trans-unit id="5fa70764a0750c44aea026597b2b0bb54778bd69" translate="yes" xml:space="preserve">
          <source>Let us look at another example. Please look at the following code</source>
          <target state="translated">もう一つの例を見てみましょう。以下のコードを見てください。</target>
        </trans-unit>
        <trans-unit id="674fee26bf2169d5b7390a8d6cb04650d870ce43" translate="yes" xml:space="preserve">
          <source>Let's log &lt;code&gt;this&lt;/code&gt; keyword to the console in global scope without any more code but</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; キーワードを、コードなしでグローバルスコープのコンソールに記録しましょう。</target>
        </trans-unit>
        <trans-unit id="347a6545cb2fdbde1b257137e4557d5c3e7376d9" translate="yes" xml:space="preserve">
          <source>Lexically for arrow functions (they adopt the &lt;em&gt;this&lt;/em&gt; of their outer execution context)</source>
          <target state="translated">字句的にアロー関数用（ &lt;em&gt;これ&lt;/em&gt;は外部実行コンテキストの&lt;em&gt;this&lt;/em&gt;を採用）</target>
        </trans-unit>
        <trans-unit id="4b794c51b008429d9440459755a0aea70b021d1b" translate="yes" xml:space="preserve">
          <source>Most people get confused when they try to use &quot;this&quot; inside of anonymous closure functions like:</source>
          <target state="translated">のような匿名クロージャ関数の中で &quot;this &quot;を使おうとすると、ほとんどの人が混乱してしまいます。</target>
        </trans-unit>
        <trans-unit id="24a1c5ba7f20054e6cc97447ca4ff99819209a36" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; can override the value of &lt;code&gt;this&lt;/code&gt; set by dot method invocation we discussed in the second bullet.
Simple enough :)</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; と &lt;code&gt;apply&lt;/code&gt; は、2番目の箇条書きで説明したドットメソッド呼び出しによって &lt;code&gt;this&lt;/code&gt; セットの値をオーバーライドできることに注意してください。 十分に単純です:)</target>
        </trans-unit>
        <trans-unit id="d5fda3afa616c2908147257d1b4538bffe1f96f3" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;functionObject.bind&lt;/code&gt; did not exist we could make our own like this</source>
          <target state="translated">&lt;code&gt;functionObject.bind&lt;/code&gt; が存在しない場合は、次のようにすることができます。</target>
        </trans-unit>
        <trans-unit id="fd156fe39e6cb3e81a3dc10a1d0665f3a2485dfd" translate="yes" xml:space="preserve">
          <source>Note that if a method is stored (or rather, copied) in another variable, the reference to &lt;code&gt;this&lt;/code&gt; is no longer preserved in the new variable. For example:</source>
          <target state="translated">メソッドが別の変数に格納（またはコピー）されている場合、 &lt;code&gt;this&lt;/code&gt; への参照は新しい変数に保持されなくなります。 例えば：</target>
        </trans-unit>
        <trans-unit id="767a361d58ea1665f1185636ce54e8f7e4d5a7b8" translate="yes" xml:space="preserve">
          <source>Note that if you use strict mode then &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">厳密モードを使用する場合、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;undefined&lt;/code&gt; なることに注意してください</target>
        </trans-unit>
        <trans-unit id="235f4aca4b6e147c89ad215706ae8a6e2deabb75" translate="yes" xml:space="preserve">
          <source>Note that it doesn't matter how the function was created (mostly...). All of these will produce the same results</source>
          <target state="translated">関数がどのように作成されたかは問題ではないことに注意してください(ほとんどの場合...)。これらはすべて同じ結果を生成します。</target>
        </trans-unit>
        <trans-unit id="2b700c221638ceb27ecd2fe681cd4c26833c39cf" translate="yes" xml:space="preserve">
          <source>Note that the official ECMAScript spec nowhere states that such types of functions are actual &lt;code&gt;constructor&lt;/code&gt; functions. They are just normal functions, and &lt;code&gt;new&lt;/code&gt; can be used on any function. It's just that we use them as such, and so we call them as such only.</source>
          <target state="translated">公式のECMAScript仕様には、そのようなタイプの関数は実際の &lt;code&gt;constructor&lt;/code&gt; 関数であるとはどこにも記載されていないことに注意してください。 これらは通常の関数であり、 &lt;code&gt;new&lt;/code&gt; は任意の関数で使用できます。 私たちはそれらをそのように使用するだけなので、それらをそのようにのみ呼びます。</target>
        </trans-unit>
        <trans-unit id="bd960096fd51dca1613866611c29d9d73d149c0d" translate="yes" xml:space="preserve">
          <source>Note that we are running this in the normal mode, i.e. strict mode is not used.</source>
          <target state="translated">これは通常のモードで実行していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="81c5b121bb3b104b797c415c59fc9f82cf7e31ea" translate="yes" xml:space="preserve">
          <source>Now if we run this in strict mode by adding the statement &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; to the beginning of the function declaration, &lt;code&gt;this&lt;/code&gt; would no longer refer to the global variable in either of the environments. This is done to avoid confusions in strict mode. &lt;code&gt;this&lt;/code&gt; would, in this case just log &lt;code&gt;undefined&lt;/code&gt;, because that is what it is, it is not defined.</source>
          <target state="translated">ここで、 &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; というステートメントを追加して、strictモードでこれを実行すると、 関数宣言の始めに、 &lt;code&gt;this&lt;/code&gt; はどちらの環境でもグローバル変数を参照しなくなります。 これは、厳密モードでの混乱を避けるために行われます。 &lt;code&gt;this&lt;/code&gt; は、この場合は単に &lt;code&gt;undefined&lt;/code&gt; をログに記録することになります。</target>
        </trans-unit>
        <trans-unit id="bdb993d7f3927fbada79fbc0cdf43dcb01f54dc1" translate="yes" xml:space="preserve">
          <source>Now. Let's imagine we make a function that explicitly sets &lt;code&gt;this&lt;/code&gt; before calling another function and then call it with the &lt;code&gt;.&lt;/code&gt; (dot) operator</source>
          <target state="translated">今。 別の関数を呼び出す前に &lt;code&gt;this&lt;/code&gt; を明示的に設定する関数を作成し、それをで呼び出すとしましょう &lt;code&gt;.&lt;/code&gt; （ドット）演算子</target>
        </trans-unit>
        <trans-unit id="f7c9c2091cfaff21dd7fae4ea95609c87cb2899e" translate="yes" xml:space="preserve">
          <source>Object literal notation creates an instance of object which we can use immediately. With function we may need to first create its instance using &lt;code&gt;new&lt;/code&gt; operator.</source>
          <target state="translated">オブジェクトリテラル表記は、すぐに使用できるオブジェクトのインスタンスを作成します。 関数では、最初に &lt;code&gt;new&lt;/code&gt; 演算子を使用してインスタンスを作成する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="25ff51b9b77d4e3cd4a459c2231b84b262b58dee" translate="yes" xml:space="preserve">
          <source>Once you start getting used to &lt;code&gt;this&lt;/code&gt;, the rules are actually pretty simple. The &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1&quot;&gt;ECMAScript 5.1 Standard&lt;/a&gt; defines &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; に慣れると、ルールは実際にはかなり単純になります。 &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1&quot;&gt;ECMAScript 5.1標準&lt;/a&gt;は &lt;code&gt;this&lt;/code&gt; 定義します ：</target>
        </trans-unit>
        <trans-unit id="ba28d64a842cc863e8fd947ef8b2d2761787ca76" translate="yes" xml:space="preserve">
          <source>One other wrinkle is the prototype chain. When you use &lt;code&gt;a.b&lt;/code&gt; JavaScript first looks on the object referenced directly by &lt;code&gt;a&lt;/code&gt; for the property &lt;code&gt;b&lt;/code&gt;. If &lt;code&gt;b&lt;/code&gt; is not found on the object then JavaScript will look in the object's prototype to find &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">もう1つのしわは、プロトタイプチェーンです。 &lt;code&gt;a.b&lt;/code&gt; を使用する場合、JavaScriptはまず、 &lt;code&gt;b&lt;/code&gt; によって直接参照されるオブジェクトでプロパティbを探します。 オブジェクトで &lt;code&gt;b&lt;/code&gt; が見つからない場合、JavaScriptはオブジェクトのプロトタイプを調べて &lt;code&gt;b&lt;/code&gt; を見つけます。</target>
        </trans-unit>
        <trans-unit id="519ab8586252702931098aa46525bc513da1698f" translate="yes" xml:space="preserve">
          <source>One way to look at JavaScript is to see that there are only 1 way to call a function&lt;sup&gt;1&lt;/sup&gt;. It is</source>
          <target state="translated">JavaScriptを見る1つの方法は、関数を呼び出す方法が1つしかないことを確認することです&lt;sup&gt;1&lt;/sup&gt; 。 です</target>
        </trans-unit>
        <trans-unit id="e6cc1f21389aeed3c994d1fb9ea99f0e63bb1e99" translate="yes" xml:space="preserve">
          <source>Outside all functions (i.e. in global context) the &lt;strong&gt;&quot;current
object&quot;&lt;/strong&gt; (and hence the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) is always the
&lt;strong&gt;&quot;window&quot;&lt;/strong&gt; object for browsers.</source>
          <target state="translated">すべての関数の外側（つまり、グローバルコンテキスト）では、 &lt;strong&gt;「現在のオブジェクト」&lt;/strong&gt; （したがって&lt;strong&gt;「this」の&lt;/strong&gt;値）は常にブラウザーの&lt;strong&gt;「ウィンドウ」&lt;/strong&gt;オブジェクトです。</target>
        </trans-unit>
        <trans-unit id="458f4f8a250f5217e985cebc8035a133a4cc6496" translate="yes" xml:space="preserve">
          <source>Please look at the following HTML Snippet</source>
          <target state="translated">以下のHTMLスニペットをご覧ください。</target>
        </trans-unit>
        <trans-unit id="c23e76e8d97b29eedd68eb763eb4329893b8b3a7" translate="yes" xml:space="preserve">
          <source>Presenting.... &lt;code&gt;bind&lt;/code&gt;!</source>
          <target state="translated">提示しています... &lt;code&gt;bind&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="5dff48a80d21897b1a7b4ec4d3e064bd791cf0a7" translate="yes" xml:space="preserve">
          <source>Pretty straightforward, eh?</source>
          <target state="translated">簡単だろ?</target>
        </trans-unit>
        <trans-unit id="d68dbd2ff1e0f0c272d49f9c85bec5340d93f7ba" translate="yes" xml:space="preserve">
          <source>Probably the most detailed and comprehensive article on &lt;code&gt;this&lt;/code&gt; is the following:</source>
          <target state="translated">おそらく &lt;code&gt;this&lt;/code&gt; に関する最も詳細で包括的な記事は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="aec57670cb741243fb4b52dc59dfa257130956b6" translate="yes" xml:space="preserve">
          <source>See the difference between the three? It is subtle, but they are used differently. Like &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;bind&lt;/code&gt; will also over-ride the value of &lt;code&gt;this&lt;/code&gt; set by dot-method invocation.</source>
          <target state="translated">3つの違いをご覧ください。 微妙ですが、使い方は異なります。 &lt;code&gt;call&lt;/code&gt; および &lt;code&gt;apply&lt;/code&gt; と同様に、 &lt;code&gt;bind&lt;/code&gt; もドットメソッド呼び出しによって &lt;code&gt;this&lt;/code&gt; セットの値をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="d6a6db24764ce1a8198a5fb69df54904ebb96362" translate="yes" xml:space="preserve">
          <source>See the following code:</source>
          <target state="translated">以下のコードを参照してください。</target>
        </trans-unit>
        <trans-unit id="044b35bd261da09f7c8b736e9469b64b95b16433" translate="yes" xml:space="preserve">
          <source>Similarly when &lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt; was invoked through &lt;strong&gt;o2&lt;/strong&gt;,
&lt;strong&gt;&quot;this&quot;&lt;/strong&gt; takes value of &lt;strong&gt;o2&lt;/strong&gt; and the value of its properties &lt;strong&gt;&quot;c&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;d&quot;&lt;/strong&gt; get displayed.The value of &lt;strong&gt;&quot;a&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;b&quot;&lt;/strong&gt; were shown as &lt;strong&gt;undefined&lt;/strong&gt; as &lt;strong&gt;o2&lt;/strong&gt; does not define these properties.</source>
          <target state="translated">同様に、 &lt;strong&gt;「UserDefinedFunction」&lt;/strong&gt;が&lt;strong&gt;o2&lt;/strong&gt;を通じて呼び出された場合、 &lt;strong&gt;「this」&lt;/strong&gt;は&lt;strong&gt;o2の&lt;/strong&gt;値を取り、そのプロパティ&lt;strong&gt;「c」&lt;/strong&gt;および&lt;strong&gt;「d」の&lt;/strong&gt;値が表示されます。 &lt;strong&gt;「a」&lt;/strong&gt;および&lt;strong&gt;「b」の&lt;/strong&gt; &lt;strong&gt;値は&lt;/strong&gt; 、 &lt;strong&gt;o2と&lt;/strong&gt;同様に&lt;strong&gt;未定義&lt;/strong&gt;として表示されましたこれらのプロパティを定義しないでください。</target>
        </trans-unit>
        <trans-unit id="4681c4e7dfd2de2b681bc6a9a880fb39de0fc724" translate="yes" xml:space="preserve">
          <source>Similarly, when you use &lt;code&gt;this&lt;/code&gt; directly inside the event property (like &lt;code&gt;&amp;lt;button onclick=&quot;...this...&quot; &amp;gt;&lt;/code&gt;) of the element, it refers to the element.</source>
          <target state="translated">同様に、 &lt;code&gt;this&lt;/code&gt; を要素のイベントプロパティ（ &lt;code&gt;&amp;lt;button onclick=&quot;...this...&quot; &amp;gt;&lt;/code&gt; ）内で直接使用すると、要素を参照します。</target>
        </trans-unit>
        <trans-unit id="fc5642eed954e43be8c2b08ea6204f5beae34cb6" translate="yes" xml:space="preserve">
          <source>Simple answer:</source>
          <target state="translated">単純な答えです。</target>
        </trans-unit>
        <trans-unit id="cd0c21407e549024fd8ebade4d9db293fa35da67" translate="yes" xml:space="preserve">
          <source>Simple function invocation</source>
          <target state="translated">単純な関数呼び出し</target>
        </trans-unit>
        <trans-unit id="d7af4d79d12ac932a60b3bcbb4551442c40a1a19" translate="yes" xml:space="preserve">
          <source>So here, inside each(), &quot;this&quot; doesn't hold the &quot;value&quot; that you expect it to (from</source>
          <target state="translated">つまり、ここでは each()の中で、&quot;this&quot; は期待している &quot;値 &quot;を保持していません (</target>
        </trans-unit>
        <trans-unit id="2dedd77da3beb2baf299eed38237e8b9cb499c92" translate="yes" xml:space="preserve">
          <source>So if I did</source>
          <target state="translated">もし私がそうしたら</target>
        </trans-unit>
        <trans-unit id="f9ad9f9ed5dfd5b4e3d833b6c8840ad972fab14b" translate="yes" xml:space="preserve">
          <source>So the Semantic of &quot;this&quot; is different from the traditional OOP languages. And it causes problems:
1. when a function is passed to another variable (most likely, a callback); and 2. when a closure is invoked from a member method of a class.</source>
          <target state="translated">このように、&quot;this &quot;のセマンティックは従来のOOP言語とは異なります。そして、それは問題を引き起こします:1.関数が別の変数に渡されたとき(ほとんどの場合、コールバック)、2.クラスのメンバメソッドからクロージャが呼び出されたとき。</target>
        </trans-unit>
        <trans-unit id="40cd6970e0b84898911ea5a78a1e7dfb515b5bcf" translate="yes" xml:space="preserve">
          <source>So the above code will log &lt;code&gt;{myObj: &quot;is cool&quot;}, [1, 2, 3]&lt;/code&gt; in the console. Pretty nice way to change the value of &lt;code&gt;this&lt;/code&gt; in any function.</source>
          <target state="translated">したがって、上記のコードは、コンソールに &lt;code&gt;{myObj: &quot;is cool&quot;}, [1, 2, 3]&lt;/code&gt; を記録します。 任意の関数で &lt;code&gt;this&lt;/code&gt; の値を変更するかなり良い方法。</target>
        </trans-unit>
        <trans-unit id="522ff2123214afbd475283a209499ed36291eb73" translate="yes" xml:space="preserve">
          <source>So yeah, since &lt;code&gt;function&lt;/code&gt;s are also &lt;code&gt;Objects&lt;/code&gt; (and in-fact first class variables in Javascript), even functions have methods which are... well, functions themselves.</source>
          <target state="translated">つまり、 &lt;code&gt;function&lt;/code&gt; sも &lt;code&gt;Objects&lt;/code&gt; （およびJavaScriptの実際のファーストクラス変数）なので、関数にもメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="0f3b2a9afffa56a30d094f3e24ed8cf50303768c" translate="yes" xml:space="preserve">
          <source>So, everything else can be described by how it translates into &lt;code&gt;functionObject.call&lt;/code&gt;.</source>
          <target state="translated">したがって、それ以外のすべては、 &lt;code&gt;functionObject.call&lt;/code&gt; にどのように変換されるかで説明できます。</target>
        </trans-unit>
        <trans-unit id="790a624bffefadda17b70c21c4b01c0c58df0ee7" translate="yes" xml:space="preserve">
          <source>So, just like the rules above</source>
          <target state="translated">だから、上記のルールのように</target>
        </trans-unit>
        <trans-unit id="914ff3d89be46de1e5d463f23bd9e8ec17bc3b6b" translate="yes" xml:space="preserve">
          <source>So, that's the same behavior as:</source>
          <target state="translated">と同じ行動なんですね。</target>
        </trans-unit>
        <trans-unit id="3752107636af96b291a982ec3e8aba9fd5bc3976" translate="yes" xml:space="preserve">
          <source>Sometimes, you don't like the fact that &lt;code&gt;this&lt;/code&gt; changes with scope, especially nested scope. Take a look at the following example.</source>
          <target state="translated">場合によっては、 &lt;code&gt;this&lt;/code&gt; がスコープ、特にネストされたスコープによって変わるという事実が気に入らないことがあります。 次の例を見てください。</target>
        </trans-unit>
        <trans-unit id="3dcb878280db0a0ee997fedf6a06a9e25d983362" translate="yes" xml:space="preserve">
          <source>Summary &lt;code&gt;this&lt;/code&gt; Javascript:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; Javascriptの要約：</target>
        </trans-unit>
        <trans-unit id="870ae78c66193024be4337db8b9c61bdcf897d92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.&lt;/code&gt; operator when used with a function on the right and an object on the left effectively means &quot;pass object as &lt;code&gt;this&lt;/code&gt; to function.</source>
          <target state="translated">&lt;code&gt;.&lt;/code&gt; 演算子は、右側の関数と左側のオブジェクトで使用すると、「 &lt;code&gt;this&lt;/code&gt; を機能させるためにオブジェクトを渡す」ことを意味します。</target>
        </trans-unit>
        <trans-unit id="5dc19a793d0ce3f7b84a548e2b6a4dbb98f0fbaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; キーワード</target>
        </trans-unit>
        <trans-unit id="5c7d3a19cb8b6bc930a3cf143fd794ae8cdebd95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; keyword behaves differently in JavaScript compared to other languages. In Object Oriented languages, the &lt;code&gt;this&lt;/code&gt; keyword refers to the current instance of the class. In JavaScript the value of &lt;code&gt;this&lt;/code&gt; is determined by the invocation context of function (&lt;em&gt;&lt;code&gt;context.function()&lt;/code&gt;&lt;/em&gt;) and where it is called.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; キーワードの動作は、JavaScriptでは他の言語とは異なります。 オブジェクト指向言語では、 &lt;code&gt;this&lt;/code&gt; キーワードはクラスの現在のインスタンスを参照します。 JavaScriptでは、 &lt;code&gt;this&lt;/code&gt; 値は関数の呼び出しコンテキスト（ &lt;em&gt; &lt;code&gt;context.function()&lt;/code&gt; &lt;/em&gt; ）と、それが呼び出される場所によって決まります。</target>
        </trans-unit>
        <trans-unit id="8118d827d29ceed5b5f484813a32a7dbdecf8a1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; keyword evaluates to the value of the ThisBinding of the current execution context</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; キーワードは、現在の実行コンテキストのThisBindingの値に評価されます</target>
        </trans-unit>
        <trans-unit id="21236dd5251fb6c854cd82db5d7b667a4cfa5baa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; keyword is &lt;a href=&quot;http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/#When_this_is_most_misunderstood_and_becomes_tricky&quot;&gt;most misunderstood&lt;/a&gt; when: 1) we borrow a method that uses &lt;code&gt;this&lt;/code&gt;, 2) we assign a method that uses &lt;code&gt;this&lt;/code&gt; to a variable, 3) a function that uses &lt;code&gt;this&lt;/code&gt; is passed as a callback function, and 4) &lt;code&gt;this&lt;/code&gt; is used inside a closure &amp;mdash; an inner function. &lt;sup&gt;(2)&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; キーワードは、1） &lt;code&gt;this&lt;/code&gt; を使用するメソッドを借用する、2）これを使用するメソッドを変数に割り当てる、3） &lt;code&gt;this&lt;/code&gt; を使用する関数がコールバック関数として渡される、および4） &lt;code&gt;this&lt;/code&gt; が次の場合に&lt;a href=&quot;http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/#When_this_is_most_misunderstood_and_becomes_tricky&quot;&gt;最も誤解さ&lt;/a&gt;れます。クロージャー内で使用されます&amp;mdash;内部関数。 &lt;sup&gt;（2）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0273a69ad15752e42d17d46c263b491390395350" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;this&lt;/em&gt; reference ALWAYS refers to (and holds the value of) an
  object&amp;mdash;a singular object&amp;mdash;and it is usually used inside a function or a
  method, although it can be used outside a function in the global
  scope. Note that when we use strict mode, this holds the value of
  undefined in global functions and in anonymous functions that are not
  bound to any object.</source>
          <target state="translated">&lt;em&gt;this&lt;/em&gt;参照は常にオブジェクト（単一のオブジェクト）を参照（およびその値を保持）し、通常は関数またはメソッドの内部で使用されますが、グローバルスコープの関数の外部で使用することもできます。 strictモードを使用する場合、グローバル関数およびオブジェクトにバインドされていない無名関数のundefinedの値が保持されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0bfa8fcb62a7f1e00d91e50841a62afe63da5f55" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; in above examples refer to &quot;button&quot; element and the
&quot;div&quot; element respectively.</source>
          <target state="translated">上記の例の&lt;strong&gt;「this」&lt;/strong&gt;は、「button」要素と「div」要素をそれぞれ参照しています。</target>
        </trans-unit>
        <trans-unit id="f95de8ec5b813d1517bdbcb77f6c0c1a7fb9c6c1" translate="yes" xml:space="preserve">
          <source>The above code clearly shows that the &quot;this&quot; value for any &quot;NON
Bound Function&quot; can be altered through &lt;strong&gt;call/apply&lt;/strong&gt;. Also,if the
&lt;strong&gt;&quot;this&quot;&lt;/strong&gt; parameter is  not explicitly passed to &lt;strong&gt;call/apply&lt;/strong&gt;, &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; (and hence the value of &quot;this&quot;) is set to &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; in Non strict mode and &lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; in strict mode.</source>
          <target state="translated">上記のコードは、「非バインド関数」の「this」値が&lt;strong&gt;call / apply&lt;/strong&gt;を通じて変更できることを明確に示してい&lt;strong&gt;ます&lt;/strong&gt; 。 また、 &lt;strong&gt;「this」&lt;/strong&gt;パラメーターが明示的に&lt;strong&gt;call / applyに&lt;/strong&gt;渡されない&lt;strong&gt;場合&lt;/strong&gt; 、 &lt;strong&gt;「現在のオブジェクト」&lt;/strong&gt; （したがって「this」の値）は非厳密モードでは&lt;strong&gt;「ウィンドウ」に&lt;/strong&gt; 、厳密モードでは&lt;strong&gt;「未定義」&lt;/strong&gt;に設定されます。</target>
        </trans-unit>
        <trans-unit id="c6c331ad3ba8cbd437f9af0ab0775ebb81b757f7" translate="yes" xml:space="preserve">
          <source>The code above translates to</source>
          <target state="translated">上記のコードは次のように翻訳されます。</target>
        </trans-unit>
        <trans-unit id="48a4deba793f1321a1d058e028490a18d81f4854" translate="yes" xml:space="preserve">
          <source>The constructor of this &lt;code&gt;Object&lt;/code&gt; has its constructor set to &lt;code&gt;Person&lt;/code&gt;. Also, note that &lt;code&gt;typeof awal&lt;/code&gt; would return &lt;code&gt;Object&lt;/code&gt; only.</source>
          <target state="translated">この &lt;code&gt;Object&lt;/code&gt; のコンストラクターのコンストラクターは &lt;code&gt;Person&lt;/code&gt; に設定されています。 また、 &lt;code&gt;typeof awal&lt;/code&gt; は &lt;code&gt;Object&lt;/code&gt; のみを返すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="598e31c8f2d3b5ebb3d9a975927bac31dd78c17d" translate="yes" xml:space="preserve">
          <source>The following describes each of this contexts one by one:</source>
          <target state="translated">以下では、この文脈を一つ一つ説明していきます。</target>
        </trans-unit>
        <trans-unit id="5ffc86b9fbcb86bd5ce90c80ade9aac7f6674126" translate="yes" xml:space="preserve">
          <source>The following summarizes the entire article</source>
          <target state="translated">記事全体をまとめると以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b9c4aa48554b8690755f430230adc7aead0e4875" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;Person&lt;/code&gt; itself is now invoked; &lt;code&gt;this&lt;/code&gt; being a reference to the newly constructed object &lt;code&gt;awal&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;Person&lt;/code&gt; 自体が呼び出されます。 &lt;code&gt;this&lt;/code&gt; は、新しく構築されたオブジェクト &lt;code&gt;awal&lt;/code&gt; への参照です 。</target>
        </trans-unit>
        <trans-unit id="d26b585e0f11b2474001731ad046d99b221862ac" translate="yes" xml:space="preserve">
          <source>The idea behind &lt;code&gt;this&lt;/code&gt; is to understand that the function invocation types have the significant importance on setting &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="translated">この背後にある考え方は、関数の呼び出しタイプが &lt;code&gt;this&lt;/code&gt; 値の設定に非常に重要であることを理解することです。</target>
        </trans-unit>
        <trans-unit id="cd9df2dd9475c12d7d70a035ffbc3060e8d9dccf" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;myFun.call(obj);&lt;/code&gt; is invoking the special built-in function &lt;code&gt;Function.prototype.call()&lt;/code&gt;, which accepts &lt;code&gt;thisArg&lt;/code&gt; as the first argument.</source>
          <target state="translated">行 &lt;code&gt;myFun.call(obj);&lt;/code&gt; &lt;code&gt;thisArg&lt;/code&gt; を最初の引数として受け入れる特別な組み込み関数 &lt;code&gt;Function.prototype.call()&lt;/code&gt; を呼び出しています。</target>
        </trans-unit>
        <trans-unit id="205b8665ab9d83e5add811cf8bd2f784d1caf68a" translate="yes" xml:space="preserve">
          <source>The reason for writing &quot;in most other cases&quot; is because there are eight ECMAScript 5 built-in functions that allow ThisBinding to be specified in the arguments list. These special functions take a so-called &lt;code&gt;thisArg&lt;/code&gt; which becomes the ThisBinding when calling the function (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.3&quot;&gt;&amp;sect;10.4.3&lt;/a&gt;).</source>
          <target state="translated">「他のほとんどの場合」と書く理由は、ThisBindingを引数リストで指定できるようにする8つのECMAScript 5組み込み関数があるためです。 これらの特別な関数は、関数を呼び出すときに &lt;code&gt;thisArg&lt;/code&gt; になる、いわゆるthisArgを受け取ります（ &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.3&quot;&gt;&amp;sect;10.4.3&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a1d54f980faedf5c96fee5c403683ca230e1320f" translate="yes" xml:space="preserve">
          <source>The same above behavior is achieved when we attach the function to the event handler using Microsoft's Event Registration model method &lt;code&gt;attachEvent&lt;/code&gt;. Instead of assigning the function to the event handler (and the thus making the function method of the element), it calls the function on the event (effectively calling it in global context).</source>
          <target state="translated">上記の同じ動作は、Microsoftのイベント登録モデルのメソッド &lt;code&gt;attachEvent&lt;/code&gt; を使用して関数をイベントハンドラーにアタッチしたときにも実現されます。 関数をイベントハンドラーに割り当てる（つまり、要素の関数メソッドを作成する）代わりに、イベントで関数を呼び出します（グローバルコンテキストで効果的に呼び出します）。</target>
        </trans-unit>
        <trans-unit id="f835f6ede39f09721b6b3a08a6766f6a816b4a55" translate="yes" xml:space="preserve">
          <source>The value of &quot;this&quot; depends on the &quot;context&quot; in which the function is executed. The context can be any object or the global object, i.e., window.</source>
          <target state="translated">this &quot;の値は、関数が実行される &quot;コンテキスト &quot;に依存します。コンテキストには、任意のオブジェクトやグローバルオブジェクト、つまりウィンドウを指定できます。</target>
        </trans-unit>
        <trans-unit id="8f71afcd2f8c39c35d17ede8ea64967e5b3dabc9" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;this&lt;/code&gt; is determined by &lt;strong&gt;how the function is invoked not, where it was created!&lt;/strong&gt;</source>
          <target state="translated">この値は&lt;strong&gt;、関数が呼び出さ&lt;/strong&gt;れた&lt;strong&gt;方法ではなく、作成された場所&lt;/strong&gt;によって決まり&lt;strong&gt;ます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85a035ea25fb197d75ddcfad6ad7ecc47bbf83df" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; is fixed for a Bound function and cannot be
overriden by &lt;strong&gt;call&lt;/strong&gt; and &lt;strong&gt;apply&lt;/strong&gt; methods of the function.</source>
          <target state="translated">&lt;strong&gt;「this」&lt;/strong&gt;の値はBound関数に対して固定されており、関数の&lt;strong&gt;呼び出し&lt;/strong&gt;および&lt;strong&gt;適用&lt;/strong&gt;メソッドによってオーバーライドすることはできません。</target>
        </trans-unit>
        <trans-unit id="732a7262b87dd35272a2fefa011c384eaf4c1806" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; within a Non Bound function can be overriden by
&lt;strong&gt;call&lt;/strong&gt; and &lt;strong&gt;apply&lt;/strong&gt; methods of the function.</source>
          <target state="translated">非バインド関数内の&lt;strong&gt;「this」&lt;/strong&gt;の値は、関数の&lt;strong&gt;呼び出し&lt;/strong&gt;および&lt;strong&gt;適用&lt;/strong&gt;メソッドによってオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="986983b3bc829dee13e4af0f6cd58cc64ea6a541" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; within a Non Bound function is the reference to object in context of which the function is invoked (&lt;strong&gt;&quot;current object&quot;&lt;/strong&gt;)</source>
          <target state="translated">非バインド関数内の&lt;strong&gt;「this」&lt;/strong&gt;の値は、関数が呼び出されたコンテキスト内の&lt;strong&gt;オブジェクト&lt;/strong&gt; （ &lt;strong&gt;「現在のオブジェクト」&lt;/strong&gt; ）への参照です</target>
        </trans-unit>
        <trans-unit id="94e5e1e54d6e891723770f7f55f8c8aa368f150f" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; within a constructor is the object that is being
created and initialized</source>
          <target state="translated">コンストラクター内の&lt;strong&gt;「this」&lt;/strong&gt;の値は、作成および初期化されるオブジェクトです</target>
        </trans-unit>
        <trans-unit id="5ff56d075173f67c99015d872ca5e48d81c42ed8" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; within an inline DOM event handler is reference
to the element for which the event handler is given.</source>
          <target state="translated">インラインDOMイベントハンドラー内の&lt;strong&gt;「this」&lt;/strong&gt;の値は、イベントハンドラーが指定されている要素への参照です。</target>
        </trans-unit>
        <trans-unit id="23a806a2918ae62d9efe5b8e4d50db0d562119c4" translate="yes" xml:space="preserve">
          <source>There are Four Scenarios where &lt;em&gt;this&lt;/em&gt; can be confusing:</source>
          <target state="translated">これが混乱する可能性のあるシナリオが4つあります。</target>
        </trans-unit>
        <trans-unit id="e38bf69ca4f13895c35d97268be9b7f0be29ccd7" translate="yes" xml:space="preserve">
          <source>There are different ways to do this. If you have called native methods in Javascript like &lt;code&gt;forEach&lt;/code&gt; and &lt;code&gt;slice&lt;/code&gt;, you should already know that the &lt;code&gt;this&lt;/code&gt; variable in that case refers to the &lt;code&gt;Object&lt;/code&gt; on which you called that function (Note that in javascript, just about everything is an &lt;code&gt;Object&lt;/code&gt;, including &lt;code&gt;Array&lt;/code&gt;s and &lt;code&gt;Function&lt;/code&gt;s). Take the following code for example.</source>
          <target state="translated">これにはさまざまな方法があります。 &lt;code&gt;forEach&lt;/code&gt; や &lt;code&gt;slice&lt;/code&gt; のようなJavaScriptでネイティブメソッドを呼び出した場合、その場合の &lt;code&gt;this&lt;/code&gt; 変数は、その関数を呼び出した &lt;code&gt;Object&lt;/code&gt; を参照することをすでに知っているはずです（JavaScriptでは、ほとんどすべてが &lt;code&gt;Array&lt;/code&gt; を含むObjectであることに注意してください）および &lt;code&gt;Function&lt;/code&gt; s）。 たとえば、次のコードを見てください。</target>
        </trans-unit>
        <trans-unit id="279973f865726145d86bc2b948936a3c5ea84f1b" translate="yes" xml:space="preserve">
          <source>There are various ways to define an object's prototype, the most common in 2019 is the &lt;code&gt;class&lt;/code&gt; keyword. For the purposes of &lt;code&gt;this&lt;/code&gt; though it doesn't matter. What matters is that as it looks in object &lt;code&gt;a&lt;/code&gt; for property &lt;code&gt;b&lt;/code&gt; if it finds property &lt;code&gt;b&lt;/code&gt; on the object or in it's prototype chain if &lt;code&gt;b&lt;/code&gt; ends up being a function then the same rules as above apply. The function &lt;code&gt;b&lt;/code&gt; references will be called using the &lt;code&gt;call&lt;/code&gt; method and passing &lt;code&gt;a&lt;/code&gt; as objectForThis as shown a the top of this answer.</source>
          <target state="translated">オブジェクトのプロトタイプを定義するにはさまざまな方法がありますが、2019年に最も一般的なのは &lt;code&gt;class&lt;/code&gt; キーワードです。 &lt;code&gt;this&lt;/code&gt; は目的ではありませんが。 重要なのは、オブジェクト &lt;code&gt;a&lt;/code&gt; でプロパティ &lt;code&gt;b&lt;/code&gt; を探すときにオブジェクトbが見つかった場合、またはプロトタイプチェーンで &lt;code&gt;b&lt;/code&gt; が関数になった場合、上記と同じルールが適用されるということです。 関数 &lt;code&gt;b&lt;/code&gt; の参照は、 &lt;code&gt;call&lt;/code&gt; メソッドを使用して呼び出され &lt;code&gt;a&lt;/code&gt; をobjectForThisとして渡します。</target>
        </trans-unit>
        <trans-unit id="4b176e3b91607484833f86d66ef5e37c3e87f616" translate="yes" xml:space="preserve">
          <source>There is a lot of confusion regarding how &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; keyword is interpreted in JavaScript. Hopefully this article will lay all those to rest once and for all. And a lot more. Please read the entire article carefully. Be forewarned that this article is long.</source>
          <target state="translated">JavaScriptで&lt;strong&gt;「this」&lt;/strong&gt;キーワードがどのように解釈されるかについては、多くの混乱があります。 うまくいけば、この記事ですべての人が一休みできるようになるでしょう。 そして、もっとたくさん。 記事全体を注意深くお読みください。 この記事は長いので注意してください。</target>
        </trans-unit>
        <trans-unit id="9bf2606f55ac02610bfeca5231ecaa8045e7e025" translate="yes" xml:space="preserve">
          <source>There is always some value supplied for &lt;code&gt;objectForThis&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;objectForThis&lt;/code&gt; には常にいくつかの値が提供されます 。</target>
        </trans-unit>
        <trans-unit id="6f5b72ee2e27b15caab5b155ad2ccf879983f917" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special case I didn&amp;rsquo;t yet mention. When constructing a new object via the &lt;code&gt;new&lt;/code&gt; operator, the JavaScript interpreter creates a new, empty object, sets some internal properties, and then calls the constructor function on the new object. Thus, when a function is called in a constructor context, the value of &lt;code&gt;this&lt;/code&gt; is the new object that the interpreter created:</source>
          <target state="translated">まだ触れていない特別なケースがあります。 JavaScriptインタープリターは、 &lt;code&gt;new&lt;/code&gt; オペレーターを介して新しいオブジェクトを作成するときに、新しい空のオブジェクトを作成し、いくつかの内部プロパティを設定してから、新しいオブジェクトでコンストラクター関数を呼び出します。 したがって、関数がコンストラクターコンテキストで呼び出されると、 &lt;code&gt;this&lt;/code&gt; 値はインタープリターが作成した新しいオブジェクトになります。</target>
        </trans-unit>
        <trans-unit id="2d3a18e72bf0f045f8f3de4d4504d75c62e5dcda" translate="yes" xml:space="preserve">
          <source>These methods allows to write a function once and invoke it in different context. In other words, they allows to specify the value of &lt;code&gt;this&lt;/code&gt; which will be used while the function is being executed. They also take any parameters to be passed to the original function when it is invoked.</source>
          <target state="translated">これらのメソッドを使用すると、関数を1回記述して別のコンテキストで呼び出すことができます。 つまり、関数の実行中に使用される &lt;code&gt;this&lt;/code&gt; の値を指定できます。 また、呼び出されたときに元の関数に渡されるすべてのパラメーターを受け取ります。</target>
        </trans-unit>
        <trans-unit id="4ade0a7126aef80885995d3c6e7d2a3b5b9a749a" translate="yes" xml:space="preserve">
          <source>These special built-in functions are:</source>
          <target state="translated">これらの特殊な内蔵機能は</target>
        </trans-unit>
        <trans-unit id="85527d5006265cfde99894b7c55c9fb14d1c3dc8" translate="yes" xml:space="preserve">
          <source>This is a typical example of using &lt;code&gt;call&lt;/code&gt;. It basically takes the first parameter and sets &lt;code&gt;this&lt;/code&gt; in the function &lt;code&gt;foo&lt;/code&gt; as a reference to &lt;code&gt;thisArg&lt;/code&gt;.  All other parameters passed to &lt;code&gt;call&lt;/code&gt; is passed to the function &lt;code&gt;foo&lt;/code&gt; as arguments.</source>
          <target state="translated">これは &lt;code&gt;call&lt;/code&gt; を使用する典型的な例です。 基本的には最初のパラメーターを取り、 &lt;code&gt;thisArg&lt;/code&gt; をthisArgへの参照として関数 &lt;code&gt;foo&lt;/code&gt; に設定します 。 &lt;code&gt;call&lt;/code&gt; に渡される他のすべてのパラメーターは、引数として関数 &lt;code&gt;foo&lt;/code&gt; に渡されます。</target>
        </trans-unit>
        <trans-unit id="29ed5f10284269291bb711c4ff11d342e2767871" translate="yes" xml:space="preserve">
          <source>This is different from Python, in which accessing a method (&lt;code&gt;obj.myMethod&lt;/code&gt;) creates a &lt;a href=&quot;http://docs.python.org/3/library/stdtypes.html#methods&quot;&gt;bound method object&lt;/a&gt;.</source>
          <target state="translated">これは、メソッド（ &lt;code&gt;obj.myMethod&lt;/code&gt; ）にアクセスして&lt;a href=&quot;http://docs.python.org/3/library/stdtypes.html#methods&quot;&gt;バインドされたメソッドオブジェクトを&lt;/a&gt;作成するPythonとは異なります 。</target>
        </trans-unit>
        <trans-unit id="a132674b519e683c1c771b823eb5a1e2de6af493" translate="yes" xml:space="preserve">
          <source>This is the best explanation I've seen: &lt;a href=&quot;http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/&quot;&gt;Understand JavaScripts &lt;em&gt;this&lt;/em&gt; with Clarity&lt;/a&gt;</source>
          <target state="translated">これは私が見た中で最も良い説明です： &lt;a href=&quot;http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/&quot;&gt;&lt;em&gt;これ&lt;/em&gt;をJavaScriptで理解する&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b0808c58b0591e7278bd423057d577254441336b" translate="yes" xml:space="preserve">
          <source>This is the case for JavaScript code that is evaluated at the top-level, e.g. when directly inside a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">これは、トップレベルで評価されるJavaScriptコードの場合です（例： &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 内に直接）。</target>
        </trans-unit>
        <trans-unit id="802391aac07cdb035195e6978ec32a12d3125ef9" translate="yes" xml:space="preserve">
          <source>This is what both &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;=&amp;gt;&lt;/code&gt; functions effectively do. They are more syntactic sugar. They effectively build a new invisible function exactly like &lt;code&gt;bar&lt;/code&gt; above that explicitly sets &lt;code&gt;this&lt;/code&gt; before it calls whatever function is specified. In the case of bind &lt;code&gt;this&lt;/code&gt; is set to whatever you pass to &lt;code&gt;bind&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;bind&lt;/code&gt; 関数と &lt;code&gt;=&amp;gt;&lt;/code&gt; 関数の両方が効果的に行うことです。 彼らはより構文的な砂糖です。 指定された関数を呼び出す前に明示的に &lt;code&gt;this&lt;/code&gt; 設定する上記の &lt;code&gt;bar&lt;/code&gt; まったく同じように、新しい非表示関数を効果的に構築します。 bindの場合、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;bind&lt;/code&gt; に渡すものに設定されます。</target>
        </trans-unit>
        <trans-unit id="3f377690fefdec48899ec0d15066da36044d96e2" translate="yes" xml:space="preserve">
          <source>This mindset is correct when dealing with &lt;code&gt;this&lt;/code&gt; and will save you from headache.</source>
          <target state="translated">この考え方はこれに対処するときに正しく、頭痛からあなたを救います。</target>
        </trans-unit>
        <trans-unit id="fe922a11381e67c113153def83bf53886fc17c59" translate="yes" xml:space="preserve">
          <source>This new &lt;code&gt;Object&lt;/code&gt; would be assigned the prototype of &lt;code&gt;Person.prototype&lt;/code&gt;. This means that any method or property in the &lt;code&gt;Person&lt;/code&gt; prototype would be available to all instances of &lt;code&gt;Person&lt;/code&gt;, including &lt;code&gt;awal&lt;/code&gt;.</source>
          <target state="translated">この新しい &lt;code&gt;Object&lt;/code&gt; は、 &lt;code&gt;Person.prototype&lt;/code&gt; のプロトタイプが割り当てられます。 つまり、 &lt;code&gt;Person&lt;/code&gt; プロトタイプのメソッドまたはプロパティは、 &lt;code&gt;awal&lt;/code&gt; を含む &lt;code&gt;Person&lt;/code&gt; のすべてのインスタンスで使用できます。</target>
        </trans-unit>
        <trans-unit id="8390b31573bde1e5e11596eda14bd9837b0066dd" translate="yes" xml:space="preserve">
          <source>This occurs when calling a function. If a function is called on an object, such as in &lt;code&gt;obj.myMethod()&lt;/code&gt; or the equivalent &lt;code&gt;obj[&quot;myMethod&quot;]()&lt;/code&gt;, then ThisBinding is set to the object (&lt;code&gt;obj&lt;/code&gt; in the example; &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-13.2.1&quot;&gt;&amp;sect;13.2.1&lt;/a&gt;). In most other cases, ThisBinding is set to the global object (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.3&quot;&gt;&amp;sect;10.4.3&lt;/a&gt;).</source>
          <target state="translated">これは、関数を呼び出すときに発生します。 &lt;code&gt;obj.myMethod()&lt;/code&gt; または同等の &lt;code&gt;obj[&quot;myMethod&quot;]()&lt;/code&gt; などのオブジェクトで関数が呼び出された場合、ThisBindingはオブジェクト（例では &lt;code&gt;obj&lt;/code&gt; ; &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-13.2.1&quot;&gt;&amp;sect;13.2.1&lt;/a&gt; ）に設定されます。 他のほとんどの場合、ThisBindingはグローバルオブジェクトに設定されます（ &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.3&quot;&gt;&amp;sect;10.4.3&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="31e21fd5682329c65723d9fdb2afb15437924824" translate="yes" xml:space="preserve">
          <source>This one was tricky. When evaluating the eval code, &lt;code&gt;this&lt;/code&gt; is &lt;code&gt;obj&lt;/code&gt;. However, in the eval code, &lt;code&gt;myFun&lt;/code&gt; is not called on an object, so ThisBinding is set to &lt;code&gt;window&lt;/code&gt; for the call.</source>
          <target state="translated">これはトリッキーでした。 評価コードを評価する場合、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;obj&lt;/code&gt; です。 ただし、evalコードでは、 &lt;code&gt;myFun&lt;/code&gt; はオブジェクトで呼び出されないため、ThisBindingは呼び出しの &lt;code&gt;window&lt;/code&gt; に設定されます 。</target>
        </trans-unit>
        <trans-unit id="906f21f1345827c9f5f29e264d69b70a0a4c77a2" translate="yes" xml:space="preserve">
          <source>ThisBinding is set to the global object &lt;em&gt;as if&lt;/em&gt; executing in the initial global execution context (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;&amp;sect;10.4.2&lt;/a&gt; (1)).</source>
          <target state="translated">ThisBindingは、初期グローバル実行コンテキストで実行さ&lt;em&gt;れているかのように&lt;/em&gt;グローバルオブジェクトに設定されます（ &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;&amp;sect;10.4.2&lt;/a&gt; （1））。</target>
        </trans-unit>
        <trans-unit id="05a9ff5b30e366baba755d7af02bdee90564da08" translate="yes" xml:space="preserve">
          <source>ThisBinding is something that the JavaScript interpreter maintains as it evaluates JavaScript code, like a special CPU register which holds a reference to an object. The interpreter updates the ThisBinding whenever establishing an execution context in one of only three different cases:</source>
          <target state="translated">ThisBindingは、オブジェクトへの参照を保持する特別なCPUレジスタのように、JavaScriptのコードを評価する際にJavaScriptインタープリタが保持するものです。インタープリタは、3 つの異なるケースのうちの 1 つで実行コンテキストを確立するたびに ThisBinding を更新します。</target>
        </trans-unit>
        <trans-unit id="99dd9cee0f0141c71707204de7a8eb68227dcb58" translate="yes" xml:space="preserve">
          <source>Those are the rules for plain JavaScript. When you begin using JavaScript libraries (e.g. jQuery), you may find that certain library functions manipulate the value of &lt;code&gt;this&lt;/code&gt;. The developers of those JavaScript libraries do this because it tends to support the most common use cases, and users of the library typically find this behavior to be more convenient. When passing callback functions referencing &lt;code&gt;this&lt;/code&gt; to library functions, you should refer to the documentation for any guarantees about what the value of &lt;code&gt;this&lt;/code&gt; is when the function is called.</source>
          <target state="translated">これらはプレーンJavaScriptのルールです。 JavaScriptライブラリ（jQueryなど）の使用を開始すると、特定のライブラリ関数が &lt;code&gt;this&lt;/code&gt; の値を操作する場合があります 。 これらのJavaScriptライブラリの開発者は、最も一般的な使用事例をサポートする傾向があるため、これを行います。また、ライブラリのユーザーは、通常、この動作がより便利であると感じています。 これを参照するコールバック関数をライブラリー関数に渡す場合、関数が呼び出されたときの値が何であるかについては、ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="e2e075f690095f8a07098f5032ffef152a676d5a" translate="yes" xml:space="preserve">
          <source>Try it out; you'll begin to like this pattern of programming</source>
          <target state="translated">試してみると、このパターンのプログラミングが好きになります。</target>
        </trans-unit>
        <trans-unit id="b31340518b4d3450382a16fe42d7b550a535da55" translate="yes" xml:space="preserve">
          <source>Unless you &lt;code&gt;bind&lt;/code&gt; the context</source>
          <target state="translated">コンテキストを &lt;code&gt;bind&lt;/code&gt; しない限り</target>
        </trans-unit>
        <trans-unit id="44c1de29d488c2efbb55dbbf89180707d408e09f" translate="yes" xml:space="preserve">
          <source>Use of &lt;em&gt;bind&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;バインドの&lt;/em&gt;使用</target>
        </trans-unit>
        <trans-unit id="130803684886f32a73870ec3182481aa18a857a0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;bind&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="c9f1a654f7867f9709c86fb54556d6b1085312f6" translate="yes" xml:space="preserve">
          <source>Usually the value of &lt;code&gt;this&lt;/code&gt; is determined by the Object which is left of the dot. (&lt;code&gt;window&lt;/code&gt; in global space)</source>
          <target state="translated">通常、 &lt;code&gt;this&lt;/code&gt; 値は、ドットの左側にあるオブジェクトによって決定されます。 （グローバル空間の &lt;code&gt;window&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3fe0e54dcbb7644fba3d3f361c514bd846e8caf6" translate="yes" xml:space="preserve">
          <source>We can try above points with functions too. However there are some differences.</source>
          <target state="translated">上記の点は関数でも試すことができます。ただし、いくつかの違いがあります。</target>
        </trans-unit>
        <trans-unit id="02ee79a3f4e52fa8dc6015c8800e56de11fbd2ff" translate="yes" xml:space="preserve">
          <source>We use this similar to the way we use pronouns in natural languages like English:  &amp;ldquo;John is running fast because &lt;strong&gt;&lt;em&gt;he&lt;/em&gt;&lt;/strong&gt; is trying to catch the train.&amp;rdquo; Instead we could have written &amp;ldquo;&amp;hellip; &lt;strong&gt;&lt;em&gt;John&lt;/em&gt;&lt;/strong&gt; is trying to catch the train&amp;rdquo;.</source>
          <target state="translated">これは、英語などの自然言語で代名詞を使用するのと同じように使用します。「ジョンは電車に乗ろうとしているので&lt;strong&gt;&lt;em&gt;、&lt;/em&gt;&lt;/strong&gt;速く走っています。」 代わりに、「&amp;hellip; &lt;strong&gt;&lt;em&gt;ジョン&lt;/em&gt;&lt;/strong&gt;は電車に乗ろうとしている」と書くこともできました。</target>
        </trans-unit>
        <trans-unit id="59c84c3a56d40f1298569aad07647b4063c6d313" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;var that = this&lt;/code&gt; means in JavaScript</source>
          <target state="translated">&lt;code&gt;var that = this&lt;/code&gt; はJavaScriptで何を意味するか</target>
        </trans-unit>
        <trans-unit id="d6960afa81986e4b8866c2cd069e74c4a085e98a" translate="yes" xml:space="preserve">
          <source>What holds the future</source>
          <target state="translated">未来はどうなっているのか</target>
        </trans-unit>
        <trans-unit id="8522002fd86f4ae1d009f9373919bcfac6e5aa3c" translate="yes" xml:space="preserve">
          <source>What if we call the function as a method with Object-dot notation?</source>
          <target state="translated">オブジェクトドット記法で関数をメソッドとして呼び出すとどうなるか?</target>
        </trans-unit>
        <trans-unit id="e90a818f0c0f181348f3ffa33436750e9c56414d" translate="yes" xml:space="preserve">
          <source>What if we use the &lt;code&gt;new&lt;/code&gt; keyword?</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; キーワードを使用するとどうなりますか？</target>
        </trans-unit>
        <trans-unit id="0b741f1c36a30a2f39adb4807b11baf832686d62" translate="yes" xml:space="preserve">
          <source>What is held in &lt;code&gt;this&lt;/code&gt; by default?</source>
          <target state="translated">これにはデフォルトで何が保持され &lt;code&gt;this&lt;/code&gt; いますか？</target>
        </trans-unit>
        <trans-unit id="f31de30789ea80d6b68979bdfc23922eb652ecfe" translate="yes" xml:space="preserve">
          <source>What is the value of &lt;code&gt;this&lt;/code&gt; at the marked line when &lt;code&gt;obj.staticFunction()&lt;/code&gt; is executed? Why?</source>
          <target state="translated">&lt;code&gt;obj.staticFunction()&lt;/code&gt; が実行されたときにマークされた行で &lt;code&gt;this&lt;/code&gt; の値は何ですか？ どうして？</target>
        </trans-unit>
        <trans-unit id="19602fe263ba02a9e70190487cdbb1f5d8295602" translate="yes" xml:space="preserve">
          <source>What is the value of &lt;code&gt;this&lt;/code&gt; at the marked line? Why?</source>
          <target state="translated">マークされたラインで &lt;code&gt;this&lt;/code&gt; の価値は何ですか？ どうして？</target>
        </trans-unit>
        <trans-unit id="10b02218e944261b661613e959beb9dc45a0a0c1" translate="yes" xml:space="preserve">
          <source>What value has &lt;code&gt;this&lt;/code&gt; where the arrow function is &lt;em&gt;defined&lt;/em&gt;?</source>
          <target state="translated">アロー関数が&lt;em&gt;定義され&lt;/em&gt;て &lt;code&gt;this&lt;/code&gt; 場合、 これにはどのような値がありますか？</target>
        </trans-unit>
        <trans-unit id="e78621a0c74b5518e2c62eeba51b08b351f0dc5e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use strict&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; in global and in anonymous functions that are not bound to any object holds a value of &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;use strict&lt;/code&gt; 場合、 &lt;code&gt;this&lt;/code&gt; はどのオブジェクトにもバインドされていないグローバル関数および無名関数で、 &lt;code&gt;undefined&lt;/code&gt; の値を保持します。</target>
        </trans-unit>
        <trans-unit id="7834bcbc1ad278f4ac5802fab1061efa51a8ede7" translate="yes" xml:space="preserve">
          <source>When a &lt;strong&gt;&quot;Non Bound Function&quot;&lt;/strong&gt; is called through
&lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;functionName.apply&lt;/em&gt;&lt;/strong&gt;, the &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; (and hence the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) is set to the value of
&lt;strong&gt;&quot;this&quot;&lt;/strong&gt; parameter (first parameter) passed to &lt;strong&gt;call/apply&lt;/strong&gt;. The following code demonstrates the same.</source>
          <target state="translated">&lt;strong&gt;「非バインド関数」&lt;/strong&gt;が&lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt;または&lt;strong&gt;&lt;em&gt;functionName.apply&lt;/em&gt;&lt;/strong&gt;を介して呼び出されると、 &lt;strong&gt;「現在のオブジェクト」&lt;/strong&gt; （したがって&lt;strong&gt;「this」&lt;/strong&gt;の値）は、 &lt;strong&gt;呼び出しに&lt;/strong&gt;渡される&lt;strong&gt;「this」&lt;/strong&gt;パラメーター（最初のパラメーター）の値に設定され&lt;strong&gt;ます。 / apply&lt;/strong&gt; 。 次のコードは同じことを示しています。</target>
        </trans-unit>
        <trans-unit id="51ee7e3f1872cc53a0ea74134a7dcd791782c6b5" translate="yes" xml:space="preserve">
          <source>When a method which relies on &lt;em&gt;this&lt;/em&gt; is assigned to a variable across contexts, in which case &lt;em&gt;this&lt;/em&gt; references another object than originally intended.</source>
          <target state="translated">これに依存するメソッドがコンテキスト全体の変数に割り当てられている場合、 &lt;em&gt;これ&lt;/em&gt;は、本来意図されていたものとは別のオブジェクトを参照します。</target>
        </trans-unit>
        <trans-unit id="c21e1c0cd6eaa7a56b15d8a8d9f7696b5ea3ba0b" translate="yes" xml:space="preserve">
          <source>When adding event handler through JavaScript, &lt;code&gt;this&lt;/code&gt; refers to DOM element that generated the event.</source>
          <target state="translated">JavaScriptを介してイベントハンドラーを追加する場合、 &lt;code&gt;this&lt;/code&gt; はイベントを生成したDOM要素を参照します。</target>
        </trans-unit>
        <trans-unit id="f9cdfe0773a82ce634e71531211148636519905c" translate="yes" xml:space="preserve">
          <source>When evaluating code in the initial global execution context, ThisBinding is set to the global object, &lt;code&gt;window&lt;/code&gt; (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.1.1&quot;&gt;&amp;sect;10.4.1.1&lt;/a&gt;).</source>
          <target state="translated">初期グローバル実行コンテキストでコードを評価するとき、ThisBindingはグローバルオブジェクト &lt;code&gt;window&lt;/code&gt; に設定されます （ &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.1.1&quot;&gt;&amp;sect;10.4.1.1&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a6a1241496a32c546213391c9684a37c3f770157" translate="yes" xml:space="preserve">
          <source>When having troubles identifying &lt;code&gt;this&lt;/code&gt;, &lt;strong&gt;do not&lt;/strong&gt; ask yourself:</source>
          <target state="translated">これを特定&lt;strong&gt;できない&lt;/strong&gt;場合は、次の&lt;strong&gt;ことを&lt;/strong&gt;自問&lt;strong&gt;しないで&lt;/strong&gt;ください。</target>
        </trans-unit>
        <trans-unit id="21c5f0557070fcbb938fbc68a83481429de1ab57" translate="yes" xml:space="preserve">
          <source>When in function is called with the &lt;code&gt;new&lt;/code&gt; keyword the value of &lt;code&gt;this&lt;/code&gt; refers to the newly created object</source>
          <target state="translated">関数内で &lt;code&gt;new&lt;/code&gt; キーワードを指定して呼び出されると、 &lt;code&gt;this&lt;/code&gt; 値は新しく作成されたオブジェクトを参照します</target>
        </trans-unit>
        <trans-unit id="72b6f37ac72430df1d8593cb30420726f4ef738c" translate="yes" xml:space="preserve">
          <source>When line1 is executed, JavaScript establishes an execution context (EC) for the function call, setting &lt;code&gt;this&lt;/code&gt; to the &lt;strong&gt;object referenced by whatever came before the last &quot;.&quot;&lt;/strong&gt;. so in the last line you can understand that &lt;code&gt;a()&lt;/code&gt; was executed in the global context which is the &lt;code&gt;window&lt;/code&gt;.</source>
          <target state="translated">line1が実行されると、JavaScriptは関数呼び出しの実行コンテキスト（EC）を確立し、 &lt;code&gt;this&lt;/code&gt; を&lt;strong&gt;最後の「。」の前に来たものが参照するオブジェクトに&lt;/strong&gt;設定し&lt;strong&gt;ます。&lt;/strong&gt; 。 したがって、最後の行では、 &lt;code&gt;a()&lt;/code&gt; が &lt;code&gt;window&lt;/code&gt; であるグローバルコンテキストで実行されたことを理解できます 。</target>
        </trans-unit>
        <trans-unit id="d92af4bea245247c6b438883984c33bed622ea0a" translate="yes" xml:space="preserve">
          <source>When new &lt;code&gt;Person()&lt;/code&gt; is executed, a completely new object is created. &lt;code&gt;Person&lt;/code&gt; is called and its &lt;code&gt;this&lt;/code&gt; is set to reference that new object.</source>
          <target state="translated">new &lt;code&gt;Person()&lt;/code&gt; が実行されると、完全に新しいオブジェクトが作成されます。 &lt;code&gt;Person&lt;/code&gt; が呼び出され、 &lt;code&gt;this&lt;/code&gt; がその新しいオブジェクトを参照するように設定されます。</target>
        </trans-unit>
        <trans-unit id="306c3e489768ae032ad521b39781632f59757922" translate="yes" xml:space="preserve">
          <source>When running in a browser, the value of &lt;code&gt;this&lt;/code&gt; would be logged as &lt;code&gt;window&lt;/code&gt;. This is because &lt;code&gt;window&lt;/code&gt; is the global variable in a web browser's scope.</source>
          <target state="translated">ブラウザで実行している場合、 &lt;code&gt;this&lt;/code&gt; 値は &lt;code&gt;window&lt;/code&gt; として記録されます 。 これは、 &lt;code&gt;window&lt;/code&gt; がWebブラウザーのスコープ内のグローバル変数であるためです。</target>
        </trans-unit>
        <trans-unit id="c446d142725f86e5cae11afca3f3dc6b1b2b729d" translate="yes" xml:space="preserve">
          <source>When the function is used as a constructor (that is when it is called with &lt;code&gt;new&lt;/code&gt; keyword), &lt;code&gt;this&lt;/code&gt; inside function body points to the new object being constructed.</source>
          <target state="translated">関数がコンストラクターとして使用される場合（つまり、 &lt;code&gt;new&lt;/code&gt; キーワードで呼び出される場合）、 &lt;code&gt;this&lt;/code&gt; 関数内の本体は、作成される新しいオブジェクトを指します。</target>
        </trans-unit>
        <trans-unit id="9363e1921613ca1efc56fe00d3f9bed0e7ff0634" translate="yes" xml:space="preserve">
          <source>When using &lt;em&gt;this&lt;/em&gt; along with the bind, apply, and call methods.</source>
          <target state="translated">これをbind、apply、callメソッドと一緒に使用する場合。</target>
        </trans-unit>
        <trans-unit id="3f06c3fcab4e5f6d63f2ca2b14de2f0e5c884eca" translate="yes" xml:space="preserve">
          <source>When we pass a method (that uses &lt;em&gt;this&lt;/em&gt;) as an argument to be used as a callback function.</source>
          <target state="translated">メソッド（ &lt;em&gt;this&lt;/em&gt;を使用&lt;em&gt;する&lt;/em&gt; ）を引数として渡し、コールバック関数として使用する場合。</target>
        </trans-unit>
        <trans-unit id="90f8c4932f81072077b5e29262c1cb9a5e197bac" translate="yes" xml:space="preserve">
          <source>When we use an inner function (a closure). It is important to take note that closures cannot access the outer function&amp;rsquo;s &lt;em&gt;this&lt;/em&gt; variable by using the this keyword because the this variable is accessible only by the function itself, not by inner functions.</source>
          <target state="translated">内部関数（クロージャー）を使用する場合。 this変数は関数自体からのみアクセス可能であり、内部関数からはアクセスできないため、クロージャーはthisキーワードを使用して外部関数の&lt;em&gt;this&lt;/em&gt;変数にアクセスできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="53aef58f636acbf9068698d4996ade0921bbfa2d" translate="yes" xml:space="preserve">
          <source>When you assign function directly to event handlers of an element, use of &lt;code&gt;this&lt;/code&gt; directly inside event handling function refers to the corresponding element. Such direct function assignment can be done using &lt;code&gt;addeventListener&lt;/code&gt; method or through the traditional event registration methods like &lt;code&gt;onclick&lt;/code&gt;.</source>
          <target state="translated">要素のイベントハンドラーに直接関数を割り当てる場合、 &lt;code&gt;this&lt;/code&gt; をイベント処理関数内で直接使用すると、対応する要素が参照されます。 このような直接的な関数の割り当ては、 &lt;code&gt;addeventListener&lt;/code&gt; メソッドを使用するか、 &lt;code&gt;onclick&lt;/code&gt; などの従来のイベント登録メソッドを使用して行うことができます。</target>
        </trans-unit>
        <trans-unit id="baae7a28429ffc8ffa19c066579bec164fbe4c42" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;this&lt;/code&gt; in global context, it is bound to global object (&lt;code&gt;window&lt;/code&gt; in browser)</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; をグローバルコンテキストで使用すると、グローバルオブジェクト（ブラウザの &lt;code&gt;window&lt;/code&gt; ）にバインドされます</target>
        </trans-unit>
        <trans-unit id="2cd00de08c1b80d16d90bbb50289443efdf1c856" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;this&lt;/code&gt; inside a function defined in the global context, &lt;code&gt;this&lt;/code&gt; is still bound to global object since the function is actually made a method of global context.</source>
          <target state="translated">グローバルコンテキストで定義された関数の内部で &lt;code&gt;this&lt;/code&gt; を使用すると、関数は実際にはグローバルコンテキストのメソッドになるため、 &lt;code&gt;this&lt;/code&gt; はグローバルオブジェクトにバインドされます。</target>
        </trans-unit>
        <trans-unit id="8d179ffca69128a51c69505a9563d82ba3e8c1a4" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;this&lt;/code&gt; inside function that is invoked without any context (i.e. not on any object), it is bound to the global object (&lt;code&gt;window&lt;/code&gt; in browser)(even if the function is defined inside the object) .</source>
          <target state="translated">コンテキストなしで（つまり、オブジェクト上ではなく）呼び出される &lt;code&gt;this&lt;/code&gt; 内部関数を使用すると、グローバル関数（ブラウザの &lt;code&gt;window&lt;/code&gt; ）にバインドされます（関数がオブジェクト内で定義されている場合でも）。</target>
        </trans-unit>
        <trans-unit id="7909d383b2cdb2682dbc516d4d07f2a0250ff82b" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;this&lt;/code&gt; keyword inside an object method, &lt;code&gt;this&lt;/code&gt; is bound to the &quot;immediate&quot; enclosing object.</source>
          <target state="translated">オブジェクトメソッド内で &lt;code&gt;this&lt;/code&gt; キーワードを使用すると、 &lt;code&gt;this&lt;/code&gt; は「即時」の囲みオブジェクトにバインドされます。</target>
        </trans-unit>
        <trans-unit id="83b1b8689f73a2750a7952c4091b19bcec3490d7" translate="yes" xml:space="preserve">
          <source>Whenever a function is invoked, it is invoked in context of an
object (&lt;strong&gt;&quot;current object&quot;&lt;/strong&gt;). If the &lt;strong&gt;current object&lt;/strong&gt; is not explicitly provided,
the &lt;strong&gt;current object&lt;/strong&gt;  is the &lt;strong&gt;&quot;window object&quot;&lt;/strong&gt; in &lt;strong&gt;NON Strict
Mode&lt;/strong&gt; and &lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; in Strict Mode by default.</source>
          <target state="translated">関数が呼び出されるときは常に、オブジェクト（ &lt;strong&gt;「現在のオブジェクト」&lt;/strong&gt; ）のコンテキストで呼び出されます。 &lt;strong&gt;現在のオブジェクト&lt;/strong&gt;が明示的に提供されていない場合、 &lt;strong&gt;現在のオブジェクト&lt;/strong&gt;は、デフォルトでは&lt;strong&gt;非厳密モードの&lt;/strong&gt; &lt;strong&gt;「ウィンドウオブジェクト」&lt;/strong&gt;であり、 &lt;strong&gt;厳密モード&lt;/strong&gt;では&lt;strong&gt;「未定義」&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="c1e2d9b7e33f4aae1fb2ee3c05579c089c455131" translate="yes" xml:space="preserve">
          <source>Where is &lt;em&gt;&lt;code&gt;this&lt;/code&gt; taken from&lt;/em&gt;?</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;this&lt;/code&gt; &lt;/em&gt;はどこ&lt;em&gt;から取られたの&lt;/em&gt;ですか？</target>
        </trans-unit>
        <trans-unit id="9b9fe2edee77fa966a9bca11a2314adc27b17dde" translate="yes" xml:space="preserve">
          <source>Whether the code is in strict or non-strict mode</source>
          <target state="translated">コードがストリクトモードか非ストリクトモードか</target>
        </trans-unit>
        <trans-unit id="c67697bc299f31a4867d9e3ec63fd31a1acb34d6" translate="yes" xml:space="preserve">
          <source>Whether the code was invoked using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">コードが&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;を使用して呼び出されたかどうか</target>
        </trans-unit>
        <trans-unit id="95b195c331d5df50ce3d94202285a5aa9dff77e9" translate="yes" xml:space="preserve">
          <source>While arrow-functions provide an alternative to using &lt;code&gt;bind()&lt;/code&gt;, it&amp;rsquo;s important to note that they essentially are disabling the traditional &lt;code&gt;this&lt;/code&gt; mechanism in favor of more widely understood lexical scoping. &lt;sup&gt;(1)&lt;/sup&gt;</source>
          <target state="translated">矢印関数は &lt;code&gt;bind()&lt;/code&gt; を使用する代わりに使用できますが、より広く理解されている字句スコープを優先して、従来の &lt;code&gt;this&lt;/code&gt; メカニズムを無効にしていることに注意することが重要です。 &lt;sup&gt;（1）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1ed94bc080271febddcf89764199947c7c3fdafb" translate="yes" xml:space="preserve">
          <source>Whould &lt;a href=&quot;http://www.quirksmode.org/js/this.html&quot;&gt;this&lt;/a&gt; help? (Most confusion of 'this' in javascript is coming from the fact that it generally is not linked to your object, but to the current executing scope -- that might not be exactly how it works but is always feels like that to me -- see the article for a complete explanation)</source>
          <target state="translated">&lt;a href=&quot;http://www.quirksmode.org/js/this.html&quot;&gt;これは&lt;/a&gt;誰に役立ちますか？ （JavaScriptの 'this'のほとんどの混乱は、それが通常はオブジェクトにリンクされていないが、現在の実行スコープにリンクされているという事実から来ています-それは正確に機能するわけではないかもしれませんが、常に私にはそのように感じられます-完全な説明については記事を参照してください）</target>
        </trans-unit>
        <trans-unit id="b4fb795b23dbff94bf4305a128bec5ae7d7ea74e" translate="yes" xml:space="preserve">
          <source>With Constructor</source>
          <target state="translated">コンストラクタと</target>
        </trans-unit>
        <trans-unit id="3b1aa9ad3adbb8fddf6c31fef8a04fbd8c6ce154" translate="yes" xml:space="preserve">
          <source>With event handlers</source>
          <target state="translated">イベントハンドラを使って</target>
        </trans-unit>
        <trans-unit id="15ce445da4009f96d02170197211759e9e416399" translate="yes" xml:space="preserve">
          <source>You can also manipulate the context using &lt;code&gt;.apply()&lt;/code&gt;&lt;code&gt;.call()&lt;/code&gt; and &lt;code&gt;.bind()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.apply()&lt;/code&gt; . &lt;code&gt;.call()&lt;/code&gt; と &lt;code&gt;.bind()&lt;/code&gt; を使用してコンテキストを操作することもできます</target>
        </trans-unit>
        <trans-unit id="d4c81bc669883bad79d12946f0cdcef3cb41ac57" translate="yes" xml:space="preserve">
          <source>You can manipulate the value of &lt;code&gt;this&lt;/code&gt; with the functions: &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;bind&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 値は、関数 &lt;code&gt;call&lt;/code&gt; 、 &lt;code&gt;apply&lt;/code&gt; 、 &lt;code&gt;bind&lt;/code&gt; で操作できます 。</target>
        </trans-unit>
        <trans-unit id="9aafe015410fc61c26eb7b85e5f45fd78ded6a07" translate="yes" xml:space="preserve">
          <source>You can set the value of &lt;em&gt;this&lt;/em&gt; using &lt;code&gt;func.call&lt;/code&gt;, &lt;code&gt;func.apply&lt;/code&gt; or &lt;code&gt;func.bind&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func.call&lt;/code&gt; 、 &lt;code&gt;func.apply&lt;/code&gt; または &lt;code&gt;func.bind&lt;/code&gt; を使用して、 &lt;em&gt;この&lt;/em&gt;値を設定できます。</target>
        </trans-unit>
        <trans-unit id="3bc00565d4384be2eef6cc38bfd42c85cf8d0315" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;eval&lt;/code&gt; to access &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; を使用して &lt;code&gt;this&lt;/code&gt; にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="cca5c93685569cae1cf0ccae89b950fa2dccdaf8" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;this&lt;/code&gt; in any function on an object to refer to other properties on that object. This is not the same as an instance created with &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; をオブジェクトの任意の関数で使用して 、そのオブジェクトの他のプロパティを参照できます。 これは、 &lt;code&gt;new&lt;/code&gt; で作成されたインスタンスとは異なります。</target>
        </trans-unit>
        <trans-unit id="b4d5df9ef1b310c884c8d57fbfb242857d89270e" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;with&lt;/code&gt; to add &lt;code&gt;this&lt;/code&gt; to the current scope to read and write to values on &lt;code&gt;this&lt;/code&gt; without referring to &lt;code&gt;this&lt;/code&gt; explicitly.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; を現在のスコープに追加するために &lt;code&gt;with&lt;/code&gt; を使用すると 、明示的に &lt;code&gt;this&lt;/code&gt; を参照せずに、 この値を読み書きできます。</target>
        </trans-unit>
        <trans-unit id="54e27d188f0d38ee9602bf7437198a4746e2a173" translate="yes" xml:space="preserve">
          <source>above it). So, to get over this (no pun intended) problem, a developer could:</source>
          <target state="translated">その上)。そこで、この問題を乗り越えるために、開発者ができることがあります。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="9515c8375c0b70748ad0886b201ac47811d74397" translate="yes" xml:space="preserve">
          <source>and then we could call it like this</source>
          <target state="translated">こう呼ぶこともできる</target>
        </trans-unit>
        <trans-unit id="226abeaecd5ff1c4ed49f5e280892fe18bd8990d" translate="yes" xml:space="preserve">
          <source>but &lt;strong&gt;do&lt;/strong&gt; ask yourself:</source>
          <target state="translated">しかし&lt;strong&gt;、&lt;/strong&gt;自問&lt;strong&gt;して&lt;/strong&gt;みてください：</target>
        </trans-unit>
        <trans-unit id="841108c86e9fbb4edafbf1fc269ca06fbd9c2aa7" translate="yes" xml:space="preserve">
          <source>is the same as</source>
          <target state="translated">と同じです。</target>
        </trans-unit>
        <trans-unit id="52bf064bbb0874e1615c452b86946146a06f7150" translate="yes" xml:space="preserve">
          <source>it becomes the property of the window object, as if you have defined
it as</source>
          <target state="translated">として定義したかのように、ウィンドウオブジェクトのプロパティになります。</target>
        </trans-unit>
        <trans-unit id="030861400725df2cccdbd01f8186798d77f7e41a" translate="yes" xml:space="preserve">
          <source>jQuery makes this trivial to change with jQuery.proxy.</source>
          <target state="translated">jQueryはこれをjQuery.proxyで簡単に変更できるようにしています。</target>
        </trans-unit>
        <trans-unit id="f36f025d3a5f8c92288a34e977b81bdd71e6227d" translate="yes" xml:space="preserve">
          <source>javascriptissexy.com - &lt;a href=&quot;http://goo.gl/pvl0GX&quot;&gt;http://goo.gl/pvl0GX&lt;/a&gt;</source>
          <target state="translated">javascriptissexy.com- &lt;a href=&quot;http://goo.gl/pvl0GX&quot;&gt;http://goo.gl/pvl0GX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4049836cfbefc8188779c17bb3962e791ecad445" translate="yes" xml:space="preserve">
          <source>the jQuery will in many places have &lt;code&gt;this&lt;/code&gt; refer to a DOM element.</source>
          <target state="translated">jQueryは多くの場所で &lt;code&gt;this&lt;/code&gt; をDOM要素を参照します。</target>
        </trans-unit>
        <trans-unit id="3be4a57468f0408033e4ea27c9512e741f1fbc8b" translate="yes" xml:space="preserve">
          <source>this use for Scope just like this</source>
          <target state="translated">スコープはこのような使い方をします。</target>
        </trans-unit>
        <trans-unit id="0be011b10726d85ae6873c3f4ffc235cfde3ceb9" translate="yes" xml:space="preserve">
          <source>value of txt1 and txt is same
in Above example 
$(this)=$('#tbleName tbody tr') is Same</source>
          <target state="translated">上記の例ではtxt1とtxtの値は同じです $(this)=$('#tbleName tbody tr')は同じです。</target>
        </trans-unit>
        <trans-unit id="a40cac89bb894a88e8ef678122403134449a72d5" translate="yes" xml:space="preserve">
          <source>was effectively translated into</source>
          <target state="translated">に効果的に翻訳されていました。</target>
        </trans-unit>
        <trans-unit id="eee2fd622722c8b192547f36dd5b9891b7a1ad1e" translate="yes" xml:space="preserve">
          <source>which means</source>
          <target state="translated">と言うと</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
