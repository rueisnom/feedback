<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/3127429">
    <body>
      <group id="3127429">
        <trans-unit id="1f8742c489830fbb68ca2ba261bc508b53df7499" translate="yes" xml:space="preserve">
          <source>&quot;this&quot; is all about scope. Every function has its own scope, and since everything in JS is an object, even a function can store some values into itself using &quot;this&quot;. OOP 101 teaches that &quot;this&quot; is only applicable to &lt;em&gt;instances&lt;/em&gt; of an object. Therefore, every-time a function executes, a new &quot;instance&quot; of that function has a new meaning of &quot;this&quot;.</source>
          <target state="translated">&amp;laquo;это&amp;raquo; все о сфере. Каждая функция имеет свою область видимости, и поскольку все в JS является объектом, даже функция может сохранять некоторые значения в себе, используя &amp;laquo;this&amp;raquo;. ООП 101 учит, что &amp;laquo;это&amp;raquo; применимо только к &lt;em&gt;экземплярам&lt;/em&gt; объекта. Следовательно, каждый раз, когда функция выполняется, новый &amp;laquo;экземпляр&amp;raquo; этой функции приобретает новое значение &amp;laquo;this&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b087ac216caabb7017868b37aca9a9d6e2dc3acd" translate="yes" xml:space="preserve">
          <source>&quot;this&quot; keyword is always dependant on the context of invocation. They are mentioned below.</source>
          <target state="translated">&quot;это&quot; ключевое слово всегда зависит от контекста вызова.Они упоминаются ниже.</target>
        </trans-unit>
        <trans-unit id="f3a3f86fe5a29d3e243308285b4b562e5ee68cee" translate="yes" xml:space="preserve">
          <source>&amp;hellip;by a direct call to &lt;code&gt;eval()&lt;/code&gt;
ThisBinding is left unchanged; it is the same value as the ThisBinding of the calling execution context (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;&amp;sect;10.4.2&lt;/a&gt; (2)(a)).</source>
          <target state="translated">&amp;hellip; Прямым вызовом &lt;code&gt;eval()&lt;/code&gt; ThisBinding остается без изменений; это то же значение, что и ThisBinding для вызывающего контекста выполнения ( &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;&amp;sect;10.4.2&lt;/a&gt; (2) (a)).</target>
        </trans-unit>
        <trans-unit id="9cc3cef106ffb16fe471cb3389ab7a4426b808f0" translate="yes" xml:space="preserve">
          <source>&amp;hellip;if not by a direct call to &lt;code&gt;eval()&lt;/code&gt;</source>
          <target state="translated">&amp;hellip; Если не прямым вызовом &lt;code&gt;eval()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51102ac175310aed1bea1f10200498ad1af008e5" translate="yes" xml:space="preserve">
          <source>&amp;sect;15.1.2.1.1 defines what a direct call to &lt;code&gt;eval()&lt;/code&gt; is. Basically, &lt;code&gt;eval(...)&lt;/code&gt; is a direct call whereas something like &lt;code&gt;(0, eval)(...)&lt;/code&gt; or &lt;code&gt;var indirectEval = eval; indirectEval(...);&lt;/code&gt; is an indirect call to &lt;code&gt;eval()&lt;/code&gt;. See &lt;a href=&quot;https://stackoverflow.com/a/9107491/196844&quot;&gt;chuckj's answer&lt;/a&gt; to &lt;a href=&quot;https://stackoverflow.com/q/9107240/196844&quot;&gt;(1, eval)('this') vs eval('this') in JavaScript?&lt;/a&gt; and &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/#indirect-eval-call&quot;&gt;Dmitry Soshnikov&amp;rsquo;s ECMA-262-5 in detail. Chapter 2. Strict Mode.&lt;/a&gt; for when you might use an indirect &lt;code&gt;eval()&lt;/code&gt; call.</source>
          <target state="translated">&amp;sect;15.1.2.1.1 определяет, что такое прямой вызов &lt;code&gt;eval()&lt;/code&gt; . По сути, &lt;code&gt;eval(...)&lt;/code&gt; - это прямой вызов, тогда как что-то вроде &lt;code&gt;(0, eval)(...)&lt;/code&gt; или &lt;code&gt;var indirectEval = eval; indirectEval(...);&lt;/code&gt; indirectEval (...); это косвенный вызов &lt;code&gt;eval()&lt;/code&gt; . Смотрите &lt;a href=&quot;https://stackoverflow.com/a/9107491/196844&quot;&gt;ответ Чака&lt;/a&gt; на &lt;a href=&quot;https://stackoverflow.com/q/9107240/196844&quot;&gt;(1, eval) ('this') против eval ('this') в JavaScript?&lt;/a&gt; и &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/#indirect-eval-call&quot;&gt;ECMA-262-5 Дмитрия Сошникова в деталях.&lt;/a&gt; Глава 2. Строгий режим. когда вы можете использовать косвенный вызов &lt;code&gt;eval()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d811f7b2b609ced44226e1cc0f2cc624eac9c4ae" translate="yes" xml:space="preserve">
          <source>1. Initial global execution context</source>
          <target state="translated">1.Начальный глобальный контекст исполнения</target>
        </trans-unit>
        <trans-unit id="a1fa3b35a9272755e31354f7d5e59caf11fa3cf1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://bjorn.tipling.com/all-this&quot;&gt;Here&lt;/a&gt; is one good source of &lt;code&gt;this&lt;/code&gt; in &lt;code&gt;JavaScript&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://bjorn.tipling.com/all-this&quot;&gt;Вот&lt;/a&gt; один хороший источник &lt;code&gt;this&lt;/code&gt; в &lt;code&gt;JavaScript&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b49c71fe77018d6aeff02cd966c9eb2f2def9fd9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;Arrow functions&lt;/a&gt; (introduced in ECMA6) alter the scope of &lt;code&gt;this&lt;/code&gt;. See the existing canonical question, &lt;a href=&quot;https://stackoverflow.com/questions/34361379/arrow-function-vs-function-declaration-expressions-are-they-equivalent-exch&quot;&gt;Arrow function vs function declaration / expressions: Are they equivalent / exchangeable?&lt;/a&gt; for more information. But in short:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;Функции стрелок&lt;/a&gt; (введенные в ECMA6) изменяют объем &lt;code&gt;this&lt;/code&gt; . Смотрите существующий канонический вопрос, &lt;a href=&quot;https://stackoverflow.com/questions/34361379/arrow-function-vs-function-declaration-expressions-are-they-equivalent-exch&quot;&gt;функция Arrow против объявления / выражений функции: являются ли они эквивалентными / заменяемыми?&lt;/a&gt; для дополнительной информации. Но вкратце:</target>
        </trans-unit>
        <trans-unit id="7f751a15d113e0f9a8416dec1351c576d0282769" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-11.1.1&quot;&gt;&amp;sect;11.1.1&lt;/a&gt; The &lt;code&gt;this&lt;/code&gt; keyword</source>
          <target state="translated">&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-11.1.1&quot;&gt;&amp;sect;11.1.1&lt;/a&gt; Ключевое слово &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="424e6d7255bde2010b643c058d5b8f1d62241294" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;apply&lt;/code&gt; is almost the same as &lt;code&gt;call&lt;/code&gt; accept that it takes only two parameters: &lt;code&gt;thisArg&lt;/code&gt; and an array which contains the arguments to be passed to the function. So the above &lt;code&gt;call&lt;/code&gt; call can be translated to &lt;code&gt;apply&lt;/code&gt; like this:</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; почти то же самое, что &lt;code&gt;call&lt;/code&gt; accept, что он принимает только два параметра: &lt;code&gt;thisArg&lt;/code&gt; и массив, который содержит аргументы для передачи в функцию. Таким образом, приведенный выше &lt;code&gt;call&lt;/code&gt; может быть переведен так:</target>
        </trans-unit>
        <trans-unit id="382d7e3908485b3ab834fd0e20e7a2a1529aef8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bind&lt;/code&gt; is a brother of &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;.  It is also a method inherited by all functions from the global &lt;code&gt;Function&lt;/code&gt; constructor in Javascript. The difference between &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;call&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; is that both &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; will actually invoke the function. &lt;code&gt;bind&lt;/code&gt;, on the other hand, returns a new function with the &lt;code&gt;thisArg&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt; pre-set. Let's take an example to better understand this:</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; - брат по &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; . Это также метод, унаследованный всеми функциями от глобального конструктора &lt;code&gt;Function&lt;/code&gt; в Javascript. Разница между &lt;code&gt;bind&lt;/code&gt; и &lt;code&gt;call&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; заключается в том, что и &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; фактически вызовут функцию. &lt;code&gt;bind&lt;/code&gt; , с другой стороны, возвращает новую функцию с &lt;code&gt;thisArg&lt;/code&gt; &lt;code&gt;arguments&lt;/code&gt; thisArg и аргументами . Давайте рассмотрим пример, чтобы лучше понять это:</target>
        </trans-unit>
        <trans-unit id="d372c94fc4d01f36f32e9424821af8fae90a6d1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;obj.foo()&lt;/code&gt; translates to &lt;code&gt;const temp = obj.foo; temp.call(obj);&lt;/code&gt; which means the arrow operator inside &lt;code&gt;foo&lt;/code&gt; will bind &lt;code&gt;obj&lt;/code&gt; to a new invisible function and return that new invisible function which is assigned to &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;b()&lt;/code&gt; will work as it always has as &lt;code&gt;b.call(window)&lt;/code&gt; or &lt;code&gt;b.call(undefined)&lt;/code&gt; calling the new invisible function that &lt;code&gt;foo&lt;/code&gt; created. That invisible function ignores the &lt;code&gt;this&lt;/code&gt; passed into it and  passes &lt;code&gt;obj&lt;/code&gt; as objectForThis` to the arrow function.</source>
          <target state="translated">&lt;code&gt;obj.foo()&lt;/code&gt; переводится как &lt;code&gt;const temp = obj.foo; temp.call(obj);&lt;/code&gt; temp.call (OBJ); Это означает, что оператор стрелки внутри &lt;code&gt;foo&lt;/code&gt; свяжет &lt;code&gt;obj&lt;/code&gt; с новой невидимой функцией и вернет ту новую невидимую функцию, которая назначена &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;b()&lt;/code&gt; будет работать, как всегда, как &lt;code&gt;b.call(window)&lt;/code&gt; или &lt;code&gt;b.call(undefined)&lt;/code&gt; вызывая новую невидимую функцию, созданную &lt;code&gt;foo&lt;/code&gt; . Эта невидимая функция игнорирует &lt;code&gt;this&lt;/code&gt; , переданный в нее, и передает &lt;code&gt;obj&lt;/code&gt; как objectForThis` в функцию стрелки.</target>
        </trans-unit>
        <trans-unit id="cc4f263a38b1f6aedd93045cde762a01d7dc5a49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;obj&lt;/code&gt; &amp;mdash; When calling a function on an object, ThisBinding is set to the object.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; - при вызове функции для объекта ThisBinding устанавливается для объекта.</target>
        </trans-unit>
        <trans-unit id="107d6e7f7fb924b5dc3445b4c08dd5f9aaa0aaa7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; can be used to refer to the object being created</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; может быть использовано для ссылки на создаваемый объект</target>
        </trans-unit>
        <trans-unit id="c811f8b7269bca9f651630faab87a3c3f3e35ac4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; helps to get the current object (a.k.a. execution context) we work with. If you understand in which object the current function is getting executed, you can understand easily what current &lt;code&gt;this&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; помогает получить текущий объект (или контекст выполнения), с которым мы работаем. Если вы понимаете, в каком объекте выполняется текущая функция, вы можете легко понять, что &lt;code&gt;this&lt;/code&gt; за текущая функция.</target>
        </trans-unit>
        <trans-unit id="b4aeb36a0b116d9deb56aa0b8774cb04edd881be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; in JavaScript always refers to the 'owner' of the function that is &lt;strong&gt;being executed&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; в JavaScript всегда относится к &amp;laquo;владельцу&amp;raquo; выполняемой функции.</target>
        </trans-unit>
        <trans-unit id="7c3f84f931c948a2cb7f1e59f0d6dfa830ab07b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; is one of the misunderstood concept in JavaScript because it behaves little differently from place to place. Simply, &lt;code&gt;this&lt;/code&gt; refers to the &lt;strong&gt;&quot;owner&quot; of the function we are currently executing&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; одна из неправильно понятых концепций в JavaScript, потому что она ведет себя немного по-разному в разных местах. Проще говоря, &lt;code&gt;this&lt;/code&gt; относится к &lt;strong&gt;&amp;laquo;владельцу&amp;raquo; функции, которую мы выполняем в настоящее время&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="13e02a751d5916a050a8b3dc4252bc2caca654cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; would refer to the element object. But be careful, a lot of people make this mistake.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; будет относиться к элементу объекта. Но будьте осторожны, многие люди совершают эту ошибку.</target>
        </trans-unit>
        <trans-unit id="f5240944b8f27af27e4b000a78873eeedbe95583" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;&lt;strong&gt;is not assigned a value&lt;/strong&gt; until an object invokes the function where it is defined. In the global scope, all global variables and functions are defined on the &lt;code&gt;window&lt;/code&gt; object. Therefore, &lt;code&gt;this&lt;/code&gt; in a global function refers to (and has the value of) the global &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; &lt;strong&gt;значению не присваивается,&lt;/strong&gt; пока объект не вызовет функцию, в которой он определен. В глобальной области видимости все глобальные переменные и функции определены в объекте &lt;code&gt;window&lt;/code&gt; . Следовательно, &lt;code&gt;this&lt;/code&gt; в глобальной функции относится (и имеет значение) к объекту глобального &lt;code&gt;window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2017743fc4e80e00beebfb42e3038d8fb7f5b026" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window&lt;/code&gt; &amp;mdash; The marked line is evaluated in the initial global execution context.</source>
          <target state="translated">&lt;code&gt;window&lt;/code&gt; - отмеченная строка оценивается в начальном глобальном контексте выполнения.</target>
        </trans-unit>
        <trans-unit id="f4be438a760254b14a91ab09c03d45c80ef71f1b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Few places where &lt;code&gt;this&lt;/code&gt; can be differentiated&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Несколько мест, где &lt;code&gt;this&lt;/code&gt; можно дифференцировать&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09380dc0b6ee6bdf73de503a58ea18d71700e94d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I recommend to better try this in &lt;a href=&quot;http://jsfiddle.net/Mahesha999/xKtzC/8/embedded/html,js,result&quot;&gt;JSFiddle&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Я рекомендую лучше попробовать это в &lt;a href=&quot;http://jsfiddle.net/Mahesha999/xKtzC/8/embedded/html,js,result&quot;&gt;JSFiddle&lt;/a&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="89af8ce5b9c6ddaddba039f802cac788a61fd49a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Since this thread has bumped up, I have compiled few points for readers new to &lt;code&gt;this&lt;/code&gt; topic.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Поскольку эта тема увеличилась, я собрал несколько пунктов для читателей, впервые знакомых с &lt;code&gt;this&lt;/code&gt; темой.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf09c380c346a11478b95850016d50cc8b3825f2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;To reveal the answers, mouse over the light yellow boxes.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Чтобы раскрыть ответы, наведите курсор мыши на светло-желтые прямоугольники.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ff1f9889e4b9c65093673c35d707361ce7a29d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. When used in global context&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. При использовании в глобальном контексте&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1cb747759f0fbb0bff69036f9d6d60f4aa3fa28d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. When used inside object method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. При использовании внутри метода объекта&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a912f1682aefdda6a1d36527df19cad6af2400d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. When invoking context-less function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3. При вызове функции без контекста&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc4963b484aa9c5ab6a24d462de6d79d10013299" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. When used inside constructor function&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;4. При использовании внутри функции конструктора&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1151d51ab92181c7cb05dad8e085d7369e1d980f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5. When used inside function defined on prototype chain&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5. При использовании внутри функции, определенной в цепочке прототипов&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1836a9a4449c1ab65274d2b92c93146cbd04cfc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;6. Inside call(), apply() and bind() functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;6. Внутри функций call (), apply () и bind ()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5eb140bea3b13dba943d1a806bc843988b98056" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;7. &lt;code&gt;this&lt;/code&gt; inside event handlers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;7. &lt;code&gt;this&lt;/code&gt; внутри обработчиков событий&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9d21ab1911b874d328796c84c4b427f924e6226" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;8. &lt;code&gt;this&lt;/code&gt; in ES6 arrow function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;8. &lt;code&gt;this&lt;/code&gt; в функции стрелки ES6&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="718494e8c6739afd0ac4b8944ca72f98a1b42d96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;fun.apply(obj1 [, argsArray])&lt;/code&gt;&lt;/strong&gt; Sets &lt;code&gt;obj1&lt;/code&gt; as the value of &lt;code&gt;this&lt;/code&gt; inside &lt;code&gt;fun()&lt;/code&gt; and calls &lt;code&gt;fun()&lt;/code&gt; passing elements of &lt;code&gt;argsArray&lt;/code&gt; as its arguments.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;fun.apply(obj1 [, argsArray])&lt;/code&gt; &lt;/strong&gt; Устанавливает &lt;code&gt;obj1&lt;/code&gt; в качестве значения &lt;code&gt;this&lt;/code&gt; внутри &lt;code&gt;fun()&lt;/code&gt; и вызывает &lt;code&gt;fun()&lt;/code&gt; передавая элементы &lt;code&gt;argsArray&lt;/code&gt; в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="9efe54b50d151a789da3c3d7e3f5f9c6142683ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;fun.bind(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])&lt;/code&gt;&lt;/strong&gt; - Returns the reference to the function &lt;code&gt;fun&lt;/code&gt; with &lt;code&gt;this&lt;/code&gt; inside fun bound to &lt;code&gt;obj1&lt;/code&gt; and parameters of &lt;code&gt;fun&lt;/code&gt; bound to the   parameters specified &lt;code&gt;arg1, arg2, arg3,...&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;fun.bind(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])&lt;/code&gt; &lt;/strong&gt; - возвращает ссылку на функцию &lt;code&gt;fun&lt;/code&gt; с &lt;code&gt;this&lt;/code&gt; внутри fun, связанным с &lt;code&gt;obj1&lt;/code&gt; , и параметрами &lt;code&gt;fun&lt;/code&gt; , связанными с параметрами, указанными &lt;code&gt;arg1, arg2, arg3,...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2fa93f1be283db9398b00d14dcb4562d31a96a58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;fun.call(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])&lt;/code&gt;&lt;/strong&gt; - Sets &lt;code&gt;obj1&lt;/code&gt; as the value of &lt;code&gt;this&lt;/code&gt; inside &lt;code&gt;fun()&lt;/code&gt; and calls &lt;code&gt;fun()&lt;/code&gt; passing &lt;code&gt;arg1, arg2, arg3, ...&lt;/code&gt; as its arguments.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;fun.call(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])&lt;/code&gt; &lt;/strong&gt; - устанавливает &lt;code&gt;obj1&lt;/code&gt; в качестве значения &lt;code&gt;this&lt;/code&gt; внутри &lt;code&gt;fun()&lt;/code&gt; и вызывает &lt;code&gt;fun()&lt;/code&gt; передавая &lt;code&gt;arg1, arg2, arg3, ...&lt;/code&gt; качестве своих аргументов.</target>
        </trans-unit>
        <trans-unit id="418f0b4779a9d1418d184d2b02d0207c370e9e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;References:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;References:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="78d38ee0591e57aa045e4c0f056e77a623a22b30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM event this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DOM событие это&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0611618ab4bef86d4217dc74878abb5876ef1d1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Everything else is syntactic sugar for &lt;code&gt;functionObject.call&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Все остальное является синтаксическим сахаром для &lt;code&gt;functionObject.call&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="085e18e665d8e1d81d0ca5c6a9023f7d3da54da0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FUNCTION IS CALLED EXPLICITLY USING CALL AND APPLY METHODS.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ФУНКЦИЯ ВЫЗЫВАЕТСЯ ТОЛЬКО С ИСПОЛЬЗОВАНИЕМ МЕТОДОВ ВЫЗОВА И ПРИМЕНЕНИЯ.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d75456f909e4fd7563b46975c382623f3dc3c8e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FUNCTION IS CALLED WITH NEW KEYWORD&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ФУНКЦИЯ ВЫЗЫВАЕТСЯ С НОВЫМ КЛЮЧОМ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1325e530872f52dae1b1e7bc729151d7fd17b95d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For event handlers:&lt;/strong&gt; inline event handlers, such as &lt;code&gt;&amp;lt;element onclick=&quot;foo&quot;&amp;gt;&lt;/code&gt;, override any other handlers attached earlier and before, so be careful and it's better to stay off of inline event delegation at all.
And thanks to Zara Alaverdyan who inspired me to this list of examples through a dissenting debate :)</source>
          <target state="translated">&lt;strong&gt;Для обработчиков событий:&lt;/strong&gt; встроенные обработчики событий, такие как &lt;code&gt;&amp;lt;element onclick=&quot;foo&quot;&amp;gt;&lt;/code&gt; , переопределяют любые другие обработчики, присоединенные ранее и до этого, поэтому будьте осторожны, и лучше вообще избегать делегирования встроенных событий. И спасибо Zara Alaverdyan, которая вдохновила меня на этот список примеров через несогласные дебаты :)</target>
        </trans-unit>
        <trans-unit id="894baeb26ee211c848adbf141fef8ea332f2d512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global Context&lt;/strong&gt; (i.e. Outside all functions):</source>
          <target state="translated">&lt;strong&gt;Глобальный контекст&lt;/strong&gt; (т.е. вне всех функций):</target>
        </trans-unit>
        <trans-unit id="168e0b60ab24edf5659b7603a5e6761ba4b78bc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global&lt;/strong&gt; (i.e. Outside all functions)</source>
          <target state="translated">&lt;strong&gt;Глобальный&lt;/strong&gt; (т.е. вне всех функций)</target>
        </trans-unit>
        <trans-unit id="a9b296c5fddc1bb4ff71359ff1b16bcabd27c0ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HTML this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTML это&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="917118becd0e6d67a05db3eed2df871405cda7a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IF FUNCTION IS CALLED WITH OBJECT IMPLICITLY THEN THIS WILL BE BOUND TO THAT OBJECT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ЕСЛИ ФУНКЦИЯ ВЫЗЫВАЕТСЯ С ОБЪЕКТОМ, НЕПРАВИЛЬНО, ТОГДА ЭТО БУДЕТ СВЯЗАНО С ЭТИМ ОБЪЕКТОМ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ba8db8e3f1fc0f64367058719c6e34521b6988c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IN STRICT MODE THIS WILL BE UNDEFINED&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;В строгом режиме это будет не определено&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d0ea3429b59410b8f4d00a4cc84074280bda9ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside &quot;Bound Function&quot; Call&lt;/strong&gt; (i.e. a function that &lt;strong&gt;has been bound&lt;/strong&gt; by calling &lt;strong&gt;&lt;em&gt;functionName.bind&lt;/em&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;Внутри вызова &amp;laquo;Связанная функция&amp;raquo;&lt;/strong&gt; (то есть функция, &lt;strong&gt;которая была связана&lt;/strong&gt; вызовом &lt;strong&gt;&lt;em&gt;functionName.bind&lt;/em&gt;&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="173ec8ce03dcc96425b564f955f3e8db1cca03ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside &quot;Bound Function&quot; Call&lt;/strong&gt; (i.e. a function that has been bound by calling &lt;strong&gt;&lt;em&gt;functionName.bind&lt;/em&gt;&lt;/strong&gt;):</source>
          <target state="translated">&lt;strong&gt;Внутри вызова &amp;laquo;Связанной функции&amp;raquo;&lt;/strong&gt; (то есть функции, которая была связана вызовом &lt;strong&gt;&lt;em&gt;functionName.bind&lt;/em&gt;&lt;/strong&gt; ):</target>
        </trans-unit>
        <trans-unit id="3e875249daa0473a8fdf23ad502cdf3367b1cde8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Direct &quot;Non Bound Function&quot; Call&lt;/strong&gt; (i.e. a function that has &lt;strong&gt;not been&lt;/strong&gt; bound by calling &lt;strong&gt;&lt;em&gt;functionName.bind&lt;/em&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;Внутри прямого вызова &amp;laquo;&lt;/strong&gt; &lt;strong&gt;Не&lt;/strong&gt; связанная &lt;strong&gt;функция&amp;raquo;&lt;/strong&gt; (т.е. функция, которая &lt;strong&gt;не была&lt;/strong&gt; связана вызовом &lt;strong&gt;&lt;em&gt;functionName.bind&lt;/em&gt;&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="8c57485accd3f8de730dc301d4b4402bc9d5ff6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Direct &quot;Non Bound Function&quot; Call&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Внутри Direct &quot;Не связанная функция&quot; Вызов&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="20b6606bfe8a1a339672457b5987c0bbe9801b32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Indirect &quot;Non Bound Function&quot; Call&lt;/strong&gt; through &lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;functionName.apply&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Внутри Косвенный &quot;Не связанная функция&quot; Вызов&lt;/strong&gt; через &lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; и &lt;strong&gt;&lt;em&gt;functionName.apply&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f6bbd439250c2f70bd753a9c1867ff4ae0334cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Indirect &quot;Non Bound Function&quot; Call&lt;/strong&gt; through &lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;functionName.apply&lt;/em&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Внутри косвенного вызова &amp;laquo;Не связанная функция&amp;raquo; вызов&lt;/strong&gt; через &lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; и &lt;strong&gt;&lt;em&gt;functionName.apply&lt;/em&gt;&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="b687e55bef18e96403dcec84a064997fff961ba4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Inline DOM event handler&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Внутри встроенного обработчика событий DOM&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b733413aa17352a3e9b6ca5623c81d22f47452b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inside Inline DOM event handler&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Внутри встроенного обработчика событий DOM&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="266e0d16f0275a7b45db6e40b0e84253044c47e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Trying it all with functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Попытка все это с функциями&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b798c488f44ac56ef97819e55be72d13bc6ae204" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WHEN FUNCTION IS CALLED WITHOUT ANY CONTEXT THEN THIS WILL BE BOUND TO GLOBAL OBJECT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;КОГДА ФУНКЦИЯ ВЫЗЫВАЕТСЯ БЕЗ ЛЮБОГО КОНТЕКСТА, ЭТО БУДЕТ СВЯЗАНО С ГЛОБАЛЬНЫМ ОБЪЕКТОМ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ff4d1e2e595c31a6b0764e1ad94e2fa48fffb37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;While Object Creation through &quot;new&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пока создание объекта через &amp;laquo;новый&amp;raquo;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8198d31ce2fb4af76a276cd2353f3b893b2b3c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;While Object Creation through &quot;new&quot;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;При создании объекта через &amp;laquo;новый&amp;raquo;&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="bd0054da704663fa349cd05f6dec86874b0a5b98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;eval this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;оценить это&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b6e7cb5e761aba02987ecc24374a500c50b2f3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;function this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;функция это&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d575ef4572a4d0f70d88145f3266940c01dbe092" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;global this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;глобальный это&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf73e6df87566417c40b38e407048179eb72abf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;JQuery это&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="267215baf52fd6931b04140eff3d560dfdf04823" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;object this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;возразить это&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6993e186af398b71572f7532218e7b60a53b53e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;prototype this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;прототип этого&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f609ef0b01e29c7688ac86f84c3b2fd9542bc770" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;this &amp;amp; Object Prototypes&lt;/strong&gt;, by Kyle Simpson. &amp;copy; 2014 Getify Solutions.</source>
          <target state="translated">&lt;strong&gt;Это и Объектные Прототипы&lt;/strong&gt; , Кайл Симпсон. &amp;copy; 2014 Getify Solutions.</target>
        </trans-unit>
        <trans-unit id="d68567ba0092c29c333f4067dcc1219804e03507" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;with this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;с этим&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bb486259298102ba39377e4ed03a0fb81bf8790" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;&lt;code&gt;apply&lt;/code&gt; is another function similar to &lt;code&gt;call&lt;/code&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; &lt;code&gt;apply&lt;/code&gt; это еще одна функция, похожая на &lt;code&gt;call&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="521d8887a5ef2e61310029a52ca75b452424b493" translate="yes" xml:space="preserve">
          <source>A bound function is a function whose &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; value has been
fixed. The following code demonstrated how &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; works in case
of bound function</source>
          <target state="translated">Связанная функция - это функция, значение которой &lt;strong&gt;this&lt;/strong&gt; было зафиксировано. Следующий код демонстрирует, как работает &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; в случае связанной функции</target>
        </trans-unit>
        <trans-unit id="ef2db31f656b33473e747f5be7b06a3421bd96e7" translate="yes" xml:space="preserve">
          <source>A little bit info about &lt;strong&gt;this&lt;/strong&gt; keyword</source>
          <target state="translated">Немного информации об &lt;strong&gt;этом&lt;/strong&gt; ключевом слове</target>
        </trans-unit>
        <trans-unit id="bba748cf8bf63af49cb69595a0f4e85a54d40178" translate="yes" xml:space="preserve">
          <source>Above &lt;code&gt;f1&lt;/code&gt; is made a method of global object. Thus we can also call it on &lt;code&gt;window&lt;/code&gt; object as follows:</source>
          <target state="translated">Выше &lt;code&gt;f1&lt;/code&gt; сделан метод глобального объекта. Таким образом, мы можем также вызвать его для объекта &lt;code&gt;window&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="b753f43e6cc93cab6d731a784a044886d520b74f" translate="yes" xml:space="preserve">
          <source>Above I have put the word immediate in double quotes. It is to make the point that if you nest the object inside another object, then &lt;code&gt;this&lt;/code&gt; is bound to the immediate parent.</source>
          <target state="translated">Выше я поместил слово сразу в двойных кавычках. Следует подчеркнуть, что если вы вложите объект в другой объект, &lt;code&gt;this&lt;/code&gt; будет связано с непосредственным родителем.</target>
        </trans-unit>
        <trans-unit id="d0e03fe81743bbdb1803208b752058307d77c7c9" translate="yes" xml:space="preserve">
          <source>Above we added members to objects using object literal notation. We can add members to functions by using &lt;code&gt;this&lt;/code&gt;. to specify them.</source>
          <target state="translated">Выше мы добавляли элементы к объектам, используя буквенную запись объекта. Мы можем добавить членов к функциям, используя &lt;code&gt;this&lt;/code&gt; . указать их.</target>
        </trans-unit>
        <trans-unit id="378cd99eed8979a93e73069d633b7546f12e1467" translate="yes" xml:space="preserve">
          <source>Above we create 3 variables with same name 'val'. One in global context, one inside obj and the other inside innerMethod of obj. JavaScript resolves identifiers within a particular context by going up the scope chain from local go global.</source>
          <target state="translated">Выше мы создаем 3 переменные с одинаковым именем 'val'.Одна в глобальном контексте,одна внутри объекта,другая внутри метода innerMethod объекта.JavaScript разрешает идентификаторы в определенном контексте,идя вверх по цепочке scope из local go global.</target>
        </trans-unit>
        <trans-unit id="4fbc9235f1c80f74cce8e944e82472b1cf3e26c7" translate="yes" xml:space="preserve">
          <source>Again these all are just syntactic sugar for</source>
          <target state="translated">Опять же,все это просто синтаксический сахар для</target>
        </trans-unit>
        <trans-unit id="44f5606c7c264327eaf36478d243b0e4ee2e66c7" translate="yes" xml:space="preserve">
          <source>All functions inherit from the global &lt;code&gt;Function&lt;/code&gt;, and two of its many methods are &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;, and both can be used to manipulate the value of &lt;code&gt;this&lt;/code&gt; in the function on which they are called.</source>
          <target state="translated">Все функции наследуются от глобальной &lt;code&gt;Function&lt;/code&gt; , и два из ее многочисленных методов &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; , и обе могут использоваться для манипулирования значением &lt;code&gt;this&lt;/code&gt; в функции, для которой они вызываются.</target>
        </trans-unit>
        <trans-unit id="65bb256adbc34f0e662f2e6886cf45e5da2fe2e0" translate="yes" xml:space="preserve">
          <source>All these methods are defined on &lt;code&gt;Function.prototype&lt;/code&gt;.</source>
          <target state="translated">Все эти методы определены в &lt;code&gt;Function.prototype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f3251d2eefcb2ea293e403dfdf0b701c95967f7" translate="yes" xml:space="preserve">
          <source>Also in an object literal approach, we can explicitly add members to already defined object using dot operator. This gets added to the specific instance only. However I have added variable to the function prototype so that it gets reflected in all instances of the function.</source>
          <target state="translated">Также в объектно-литературном подходе можно явно добавлять члены к уже определенному объекту с помощью точечного оператора.Это добавляется только к конкретному экземпляру.Однако я добавил переменную в прототип функции,чтобы она отражалась во всех экземплярах функции.</target>
        </trans-unit>
        <trans-unit id="42a17cccb4a20658564c0ef8e45cbac226648a85" translate="yes" xml:space="preserve">
          <source>Also note that neither of these three functions do any change to the original function. &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; would return the value from freshly constructed functions while &lt;code&gt;bind&lt;/code&gt; will return the freshly constructed function itself, ready to be called.</source>
          <target state="translated">Также обратите внимание, что ни одна из этих трех функций не изменяет исходную функцию. &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; вернут значение из только что созданных функций, в то время как &lt;code&gt;bind&lt;/code&gt; вернет саму недавно созданную функцию, готовую к вызову .</target>
        </trans-unit>
        <trans-unit id="96bacdecd2f20c6e4133c59029163b3a5024cc7a" translate="yes" xml:space="preserve">
          <source>Angus Croll - &lt;a href=&quot;http://goo.gl/Z2RacU&quot;&gt;http://goo.gl/Z2RacU&lt;/a&gt;</source>
          <target state="translated">Ангус Кролл - &lt;a href=&quot;http://goo.gl/Z2RacU&quot;&gt;http://goo.gl/Z2RacU&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc6d0b4a3431a2895e9d69a29dd7c9026e676f98" translate="yes" xml:space="preserve">
          <source>Arrow functions</source>
          <target state="translated">Функции стрелок</target>
        </trans-unit>
        <trans-unit id="0c6f0eb1c1ab36699d24af9b8c41dcdfa8f179e2" translate="yes" xml:space="preserve">
          <source>Arrow functions don't have their own &lt;code&gt;this&lt;/code&gt;.... binding.
  Instead, those identifiers are resolved in the lexical scope like any
  other variable. That means that inside an arrow function, &lt;code&gt;this&lt;/code&gt;...refer(s) to the values of &lt;code&gt;this&lt;/code&gt; in the environment
  the arrow function is defined in.</source>
          <target state="translated">Функции со стрелками не имеют своих собственных привязок. Вместо этого эти идентификаторы разрешаются в лексической области, как и любая другая переменная. Это означает, что внутри функции стрелки &lt;code&gt;this&lt;/code&gt; ... ссылается на значения &lt;code&gt;this&lt;/code&gt; в среде, в которой определена функция стрелки.</target>
        </trans-unit>
        <trans-unit id="b50c4e79c0e3f7852862c14187e6ddd0825a3bd5" translate="yes" xml:space="preserve">
          <source>Arrow functions, the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator are syntactic sugar for bind</source>
          <target state="translated">Функции стрелок, оператор &lt;code&gt;=&amp;gt;&lt;/code&gt; являются синтаксическим сахаром для привязки</target>
        </trans-unit>
        <trans-unit id="203d51646bb4fd08eace6d614d8c939e2e57a916" translate="yes" xml:space="preserve">
          <source>As given in the code above, &lt;strong&gt;&quot;this&quot; value for any &quot;Bound Function&quot;
CANNOT be altered through call/apply&lt;/strong&gt;. Also, if the &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;
parameter is  not explicitly passed to bind, &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt;
(and hence the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; ) is set to &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; in Non
strict mode and &lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; in strict mode.  One more thing.
Binding an already bound function does not change the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;.
It remains set as the value set by first bind function.</source>
          <target state="translated">Как указано в приведенном выше коде, значение &lt;strong&gt;&amp;laquo;this&amp;raquo; для любой &amp;laquo;Связанной функции&amp;raquo; НЕ МОЖЕТ быть изменено посредством вызова / применения&lt;/strong&gt; . Кроме того, если параметр &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; не передан явно для привязки, &lt;strong&gt;&amp;laquo;текущий объект&amp;raquo;&lt;/strong&gt; (и, следовательно, значение &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; ) устанавливается в &lt;strong&gt;&amp;laquo;window&amp;raquo;&lt;/strong&gt; в нестрогом режиме и &lt;strong&gt;&amp;laquo;undefined&amp;raquo;&lt;/strong&gt; в строгом режиме. Еще кое-что. Привязка уже связанной функции не меняет значение &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; . Он остается установленным в качестве значения, установленного первой функцией связывания.</target>
        </trans-unit>
        <trans-unit id="d5edefb33540455ad04404ac360e751fa53a32fc" translate="yes" xml:space="preserve">
          <source>Below I tried out all the things that we did with Object and &lt;code&gt;this&lt;/code&gt; above, but by first creating function instead of directly writing an object.</source>
          <target state="translated">Ниже я опробовал все то, что мы сделали с Object и выше, но сначала создав функцию вместо прямой записи объекта.</target>
        </trans-unit>
        <trans-unit id="1304a85574c9a47bfc387cb1181284252d8be183" translate="yes" xml:space="preserve">
          <source>Binding and already bound function does not change the value of &quot;this&quot;. It remains set as the value set by first bind function.</source>
          <target state="translated">Функция привязки и уже привязанная функция не изменяет значение &quot;this&quot;.Оно остается установленным в качестве значения,установленного первой функцией привязки.</target>
        </trans-unit>
        <trans-unit id="21140ee58286bc8b79afc046971cefc9d15813d9" translate="yes" xml:space="preserve">
          <source>But as of ES6 conceptually you can even translate that into</source>
          <target state="translated">Но что касается ES6,концептуально вы можете даже перевести это на язык</target>
        </trans-unit>
        <trans-unit id="65a473e0027f5ed69ce186b407bc8fdb48bdca1e" translate="yes" xml:space="preserve">
          <source>By default, and what confuses most beginners, when a listener is called after an event is raised on a DOM element, the &lt;em&gt;this&lt;/em&gt; value of the function is the DOM element.</source>
          <target state="translated">По умолчанию, и то, что смущает большинство начинающих, когда слушатель вызывается после того, как событие вызвано в элементе DOM, значением &lt;em&gt;this&lt;/em&gt; функции является элемент DOM.</target>
        </trans-unit>
        <trans-unit id="d6d441b4209195e14353f9a1f6054d514dd9abbd" translate="yes" xml:space="preserve">
          <source>By now the difference between &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;bind&lt;/code&gt; must have become apparent. &lt;code&gt;apply&lt;/code&gt; allows to specify the arguments to function as array-like object i.e. an object with a numeric &lt;code&gt;length&lt;/code&gt; property and corresponding non-negative integer properties. Whereas &lt;code&gt;call&lt;/code&gt; allows to specify the arguments to the function directly. Both &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;call&lt;/code&gt; immediately invokes the function in the specified context and with the specified arguments. On the other hand, &lt;code&gt;bind&lt;/code&gt; simply returns the function bound to the specified &lt;code&gt;this&lt;/code&gt; value and the arguments. We can capture the reference to this returned function by assigning it to a variable and later we can call it any time.</source>
          <target state="translated">К настоящему времени разница между &lt;code&gt;apply&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;bind&lt;/code&gt; уже стала очевидной. &lt;code&gt;apply&lt;/code&gt; позволяет указывать аргументы для функции в виде массива-подобного объекта, то есть объекта с числовым свойством &lt;code&gt;length&lt;/code&gt; и соответствующими неотрицательными целочисленными свойствами. В то время как &lt;code&gt;call&lt;/code&gt; позволяет указывать аргументы функции напрямую. Как &lt;code&gt;apply&lt;/code&gt; ,так и &lt;code&gt;call&lt;/code&gt; сразу вызывают функцию в указанном контексте и с указанными аргументами. С другой стороны, &lt;code&gt;bind&lt;/code&gt; просто возвращает функцию, связанную с указанным значением &lt;code&gt;this&lt;/code&gt; и аргументами. Мы можем захватить ссылку на эту возвращаемую функцию, присвоив ее переменной, и позже мы можем вызвать ее в любое время.</target>
        </trans-unit>
        <trans-unit id="f4ff7db3d2943e81347a74ac6f68ad3f64995792" translate="yes" xml:space="preserve">
          <source>Calling a function on an object</source>
          <target state="translated">Вызов функции на объекте</target>
        </trans-unit>
        <trans-unit id="8967949e0052bf4fec471f1e862bcdb2f857d888" translate="yes" xml:space="preserve">
          <source>Calling a method of a object</source>
          <target state="translated">Вызов метода объекта</target>
        </trans-unit>
        <trans-unit id="2a0f01b7dbab312f469277a939897da668bb1530" translate="yes" xml:space="preserve">
          <source>Calling functions on Functions: &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;</source>
          <target state="translated">Вызов функций на Функции: &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a2d9c2f761f313e12a3f59af3ad126c32d5b68b" translate="yes" xml:space="preserve">
          <source>Calling the function with the &lt;code&gt;new&lt;/code&gt; keyword would immediately initialize an &lt;code&gt;Object&lt;/code&gt; of type &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">Вызов функции с &lt;code&gt;new&lt;/code&gt; ключевым словом немедленно инициализирует &lt;code&gt;Object&lt;/code&gt; типа &lt;code&gt;Person&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c59fcda4559bb7741c9e317275c16e64acbc60a" translate="yes" xml:space="preserve">
          <source>Consider a constructor function in Javascript:</source>
          <target state="translated">Рассмотрим функцию конструктора в Javascript:</target>
        </trans-unit>
        <trans-unit id="908dded501f1eb025abaae1e462f1b9398ed9b15" translate="yes" xml:space="preserve">
          <source>Consider the following function:</source>
          <target state="translated">Рассмотрим следующую функцию:</target>
        </trans-unit>
        <trans-unit id="88d43b78335fb71e23d3a8324b00ba1dcbae38f4" translate="yes" xml:space="preserve">
          <source>Considering a more commonly practical scenario:</source>
          <target state="translated">Рассматривая более распространенный практический сценарий:</target>
        </trans-unit>
        <trans-unit id="e15054647d5d4825673bec78e395e8f11fd5d1bd" translate="yes" xml:space="preserve">
          <source>Copying &lt;code&gt;this&lt;/code&gt; to solve nested-scope issues.</source>
          <target state="translated">Копирование &lt;code&gt;this&lt;/code&gt; чтобы решить проблемы вложенной области.</target>
        </trans-unit>
        <trans-unit id="04b00eef3c0f84d63c5bf373bc4fbfa1f1f1f418" translate="yes" xml:space="preserve">
          <source>Daniel, awesome explanation! A couple of words on this and good list of &lt;code&gt;this&lt;/code&gt; execution context pointer in case of event handlers.</source>
          <target state="translated">Даниэль, классное объяснение! Несколько слов об этом и хорошем списке &lt;code&gt;this&lt;/code&gt; указателя контекста выполнения в случае обработчиков событий.</target>
        </trans-unit>
        <trans-unit id="df12cce3f2c22b0cfea79b58f42e474a2d9806ee" translate="yes" xml:space="preserve">
          <source>Defined in &lt;a href=&quot;https://leanpub.com/understandinges6/read&quot;&gt;ECMA Script 6&lt;/a&gt;, arrow-functions adopt the &lt;code&gt;this&lt;/code&gt; binding from the
enclosing (function or global) scope.</source>
          <target state="translated">Определяемые в &lt;a href=&quot;https://leanpub.com/understandinges6/read&quot;&gt;скрипте ECMA 6&lt;/a&gt; , функции-стрелки принимают привязку &lt;code&gt;this&lt;/code&gt; из окружающей (функциональной или глобальной) области видимости.</target>
        </trans-unit>
        <trans-unit id="128f370e01dcc41eacea0f41d2c828ef2ac1d087" translate="yes" xml:space="preserve">
          <source>Entering eval code</source>
          <target state="translated">Ввод оценочного кода</target>
        </trans-unit>
        <trans-unit id="2ee3bc84b3cdd8c94c92611d8db5e0176f368f84" translate="yes" xml:space="preserve">
          <source>Entering function code</source>
          <target state="translated">Ввод кода функции</target>
        </trans-unit>
        <trans-unit id="6d5f131f63e2b46f200e419e32d757a476bff5fb" translate="yes" xml:space="preserve">
          <source>Even if you add function explicitly to the object as a method, it still follows above rules, that is &lt;code&gt;this&lt;/code&gt; still points to the immediate parent object.</source>
          <target state="translated">Даже если вы явно добавляете функцию к объекту как метод, она все равно следует приведенным выше правилам, то есть &lt;code&gt;this&lt;/code&gt; все еще указывает на непосредственный родительский объект.</target>
        </trans-unit>
        <trans-unit id="5bd2dbf0b8d00773801e52b8a0a2d5c918eeff2f" translate="yes" xml:space="preserve">
          <source>Every &lt;em&gt;execution context&lt;/em&gt; in javascript has a &lt;em&gt;this&lt;/em&gt; parameter that is set by:</source>
          <target state="translated">Каждый &lt;em&gt;контекст выполнения&lt;/em&gt; в javascript имеет параметр &lt;em&gt;this,&lt;/em&gt; который устанавливается:</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="05376964e6969860e3233532567e5c90c576ce63" translate="yes" xml:space="preserve">
          <source>Example constructor:</source>
          <target state="translated">Пример конструктора:</target>
        </trans-unit>
        <trans-unit id="4e8e909da4d8e05122cc933de6fde902781e02f1" translate="yes" xml:space="preserve">
          <source>Example event listeners:</source>
          <target state="translated">Примеры слушателей событий:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="27a003083ab2583d3a2ad4eed814443aff4033fd" translate="yes" xml:space="preserve">
          <source>Except in the case of DOM event handlers or when a &lt;code&gt;thisArg&lt;/code&gt; is provided (see further down), both in node and in a browser using &lt;code&gt;this&lt;/code&gt; in a function that is not called with &lt;code&gt;new&lt;/code&gt; references the global scope&amp;hellip;</source>
          <target state="translated">За исключением случая с обработчиками событий DOM или когда предоставляется &lt;code&gt;thisArg&lt;/code&gt; (см. Далее), как в узле, так и в браузере, используя &lt;code&gt;this&lt;/code&gt; в функции, которая не вызывается с &lt;code&gt;new&lt;/code&gt; ссылками на глобальную область видимости&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="ee189376deeee0556de246c1ff07244efeae84a9" translate="yes" xml:space="preserve">
          <source>Extra stuff, copy this</source>
          <target state="translated">Дополнительные вещи,скопируй это</target>
        </trans-unit>
        <trans-unit id="a79ebf936a8f65b125ea48abc5225b5dc6cabb06" translate="yes" xml:space="preserve">
          <source>Following the translation to use &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;obj.bar()&lt;/code&gt; becomes &lt;code&gt;const temp = obj.bar; temp.call(obj);&lt;/code&gt;. When we enter the &lt;code&gt;bar&lt;/code&gt; function we call &lt;code&gt;foo&lt;/code&gt; but we explicitly passed in another object for objectForThis so when we arrive at foo &lt;code&gt;this&lt;/code&gt; is that inner object.</source>
          <target state="translated">После перевода для использования &lt;code&gt;call&lt;/code&gt; &lt;code&gt;obj.bar()&lt;/code&gt; становится &lt;code&gt;const temp = obj.bar; temp.call(obj);&lt;/code&gt; temp.call (OBJ); , Когда мы входим в функцию &lt;code&gt;bar&lt;/code&gt; , мы вызываем &lt;code&gt;foo&lt;/code&gt; , но мы явно передаем другой объект для objectForThis, поэтому, когда мы приходим к foo, &lt;code&gt;this&lt;/code&gt; тот самый внутренний объект.</target>
        </trans-unit>
        <trans-unit id="987a7929690e08340ed411e619558b9514d1934d" translate="yes" xml:space="preserve">
          <source>For an arrow function (special case of context transparency) ask yourself:</source>
          <target state="translated">Для функции стрелки (особый случай контекстной прозрачности)спросите себя:</target>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">Вызов функции</target>
        </trans-unit>
        <trans-unit id="845fc2d1f33b0159fa8601b6b79fdc1e053598bf" translate="yes" xml:space="preserve">
          <source>Functions you create become function objects. They automatically get a special &lt;code&gt;prototype&lt;/code&gt; property, which is something you can assign values to. When you create an instance by calling your function with &lt;code&gt;new&lt;/code&gt; you get access to the values you assigned to the &lt;code&gt;prototype&lt;/code&gt; property. You access those values using &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">Создаваемые вами функции становятся объектами функций. Они автоматически получают специальное свойство &lt;code&gt;prototype&lt;/code&gt; , которому вы можете присвоить значения. Когда вы создаете экземпляр, вызывая вашу функцию с &lt;code&gt;new&lt;/code&gt; вы получаете доступ к значениям, которые вы присвоили свойству &lt;code&gt;prototype&lt;/code&gt; . Вы получаете доступ к этим значениям, используя &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="469e0788e79d852a9a805ea846c580f27362cc2a" translate="yes" xml:space="preserve">
          <source>Gentle explanation of 'this' keyword in JavaScript</source>
          <target state="translated">Мягкое объяснение ключевого слова 'this' в JavaScript</target>
        </trans-unit>
        <trans-unit id="14a9ca90c670d793e8de8f4b937b4808ca9a99f8" translate="yes" xml:space="preserve">
          <source>He gives code examples, explanations, and solutions, which I thought was very helpful.</source>
          <target state="translated">Он приводит примеры кода,объяснения и решения,которые,по моему мнению,были очень полезны.</target>
        </trans-unit>
        <trans-unit id="542541ad020f39c0dd65066d67e5d1be86126656" translate="yes" xml:space="preserve">
          <source>Here is the summary:</source>
          <target state="translated">Вот резюме:</target>
        </trans-unit>
        <trans-unit id="1d75950e5613f2d50e01a7e225b9725bf0505513" translate="yes" xml:space="preserve">
          <source>How do we manipulate &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;?</source>
          <target state="translated">Как мы можем манипулировать &lt;code&gt;this&lt;/code&gt; с помощью &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="509b1a748402f9fa1f52f877d915151ea7eacf7c" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;this&lt;/code&gt; work and when should it be used?</source>
          <target state="translated">Как &lt;code&gt;this&lt;/code&gt; работает и когда его следует использовать?</target>
        </trans-unit>
        <trans-unit id="c59a24b0ebdaf81d21086f1154af537b99a98f5d" translate="yes" xml:space="preserve">
          <source>How does the “this” keyword work</source>
          <target state="translated">Как работает ключевое слово &quot;это&quot;</target>
        </trans-unit>
        <trans-unit id="8f5642913527f63ddc8d0489b7f04d5dca4b4e15" translate="yes" xml:space="preserve">
          <source>How does this work? Well, let's see what happens when we use the &lt;code&gt;new&lt;/code&gt; keyword.</source>
          <target state="translated">Как это работает? Что ж, посмотрим, что произойдет, когда мы используем &lt;code&gt;new&lt;/code&gt; ключевое слово.</target>
        </trans-unit>
        <trans-unit id="25cd4eb543ab592a2c8fdba2a85b8eac25657436" translate="yes" xml:space="preserve">
          <source>How is the function &lt;em&gt;invoked&lt;/em&gt;?</source>
          <target state="translated">Как вызывается функция?</target>
        </trans-unit>
        <trans-unit id="6f351646cb35f88a1be59388fbb15c6a9a0a2c91" translate="yes" xml:space="preserve">
          <source>How is the value of &lt;code&gt;this&lt;/code&gt; determined?</source>
          <target state="translated">Как определяется стоимость &lt;code&gt;this&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="2e8b8683e60bc5d1aab340b438427ac67cec8ead" translate="yes" xml:space="preserve">
          <source>How the function is called (including as an object method, use of &lt;em&gt;call&lt;/em&gt; and &lt;em&gt;apply&lt;/em&gt;, use of &lt;em&gt;new&lt;/em&gt;)</source>
          <target state="translated">Как вызывается функция (в том числе как метод объекта, использование &lt;em&gt;call&lt;/em&gt; и &lt;em&gt;apply&lt;/em&gt; , использование &lt;em&gt;new&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="41df7a9ac498fb8701396ea8333d73de768c8a4f" translate="yes" xml:space="preserve">
          <source>However use of &lt;code&gt;this&lt;/code&gt; indirectly through the other function called inside the event handling function or event property resolves to the global object &lt;code&gt;window&lt;/code&gt;.</source>
          <target state="translated">Однако использование &lt;code&gt;this&lt;/code&gt; косвенно через другую функцию, вызываемую внутри функции обработки события или свойства события, разрешается в окне глобального объекта.</target>
        </trans-unit>
        <trans-unit id="b57106c514445ec802e1cd473722a5a17ec00810" translate="yes" xml:space="preserve">
          <source>However, invoking it explicitly using window object shall result in
the following</source>
          <target state="translated">Однако явное обращение к нему с использованием объекта окна приводит к следующему</target>
        </trans-unit>
        <trans-unit id="f29f3dcc991cc0d0219d93627781059b44927c91" translate="yes" xml:space="preserve">
          <source>I have a different take on &lt;code&gt;this&lt;/code&gt; from the other answers that I hope is helpful.</source>
          <target state="translated">У меня есть другое мнение об &lt;code&gt;this&lt;/code&gt; из других ответов, которые, я надеюсь, будут полезны.</target>
        </trans-unit>
        <trans-unit id="12126d6f03dcab3e8bc1580e1ffa7e034bb107bc" translate="yes" xml:space="preserve">
          <source>I have noticed that there doesn't appear to be a clear explanation of what the &lt;code&gt;this&lt;/code&gt; keyword is and how it is correctly (and incorrectly) used in JavaScript on the Stack Overflow site.</source>
          <target state="translated">Я заметил, что нет четкого объяснения того, что &lt;code&gt;this&lt;/code&gt; ключевое слово и как оно правильно (и неправильно) используется в JavaScript на сайте переполнения стека.</target>
        </trans-unit>
        <trans-unit id="1460f7d950fc7da3126879c166cd50e7e5efc4dc" translate="yes" xml:space="preserve">
          <source>I have witnessed some very strange behaviour with it and have failed to understand why it has occurred.</source>
          <target state="translated">Я был свидетелем очень странного поведения с ним и не смог понять,почему это произошло.</target>
        </trans-unit>
        <trans-unit id="5a8ffb9e545c5cf5851a2f18d53651ef1e65e1af" translate="yes" xml:space="preserve">
          <source>I recommend reading &lt;a href=&quot;https://mikewest.org&quot;&gt;Mike West&lt;/a&gt;'s article &lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;Scope in JavaScript&lt;/a&gt; (&lt;a href=&quot;http://web.archive.org/web/20110725013125/http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;mirror&lt;/a&gt;) first. It is an excellent, friendly introduction to the concepts of &lt;code&gt;this&lt;/code&gt; and scope chains in JavaScript.</source>
          <target state="translated">Я рекомендую сначала прочитать статью &lt;a href=&quot;https://mikewest.org&quot;&gt;Майка Веста&lt;/a&gt; &amp;laquo; &lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;Область применения в JavaScript&lt;/a&gt; ( &lt;a href=&quot;http://web.archive.org/web/20110725013125/http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;зеркало&lt;/a&gt; )&amp;raquo;. Это отличное, дружественное введение в концепции &lt;code&gt;this&lt;/code&gt; и цепочки областей действия в JavaScript.</target>
        </trans-unit>
        <trans-unit id="2f8031248cc83596d7bde88186a31b74ce913e61" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Object&lt;/code&gt; contains a property which holds a &lt;code&gt;Function&lt;/code&gt;, the property is called a method. This method, when called, will always have it's &lt;code&gt;this&lt;/code&gt; variable set to the &lt;code&gt;Object&lt;/code&gt; it is associated with. This is true for both strict and non-strict modes.</source>
          <target state="translated">Если &lt;code&gt;Object&lt;/code&gt; содержит свойство, которое содержит &lt;code&gt;Function&lt;/code&gt; , свойство называется методом. Этот метод при вызове всегда будет иметь &lt;code&gt;this&lt;/code&gt; переменную, установленную на &lt;code&gt;Object&lt;/code&gt; он связан. Это верно как для строгих, так и для нестрогих режимов.</target>
        </trans-unit>
        <trans-unit id="f9f88fafad52186ab62424ffeb6795041b66ab36" translate="yes" xml:space="preserve">
          <source>If no explicit owner is defined, then the top most owner, the window object, is referenced.</source>
          <target state="translated">Если явный владелец не определен,то на объект окна,являющийся самым верхним владельцем,делается ссылка.</target>
        </trans-unit>
        <trans-unit id="abea008c9ccdd3ff813706bd9d78b13581e069ae" translate="yes" xml:space="preserve">
          <source>If the event handler is inline, &lt;code&gt;this&lt;/code&gt; refers to global object</source>
          <target state="translated">Если обработчик события встроен, &lt;code&gt;this&lt;/code&gt; относится к глобальному объекту</target>
        </trans-unit>
        <trans-unit id="f545568898aa3f9f5ee670cd77b9d433d0a46089" translate="yes" xml:space="preserve">
          <source>If the function is called with NEW keyword then THIS will be bound to the newly created object.</source>
          <target state="translated">Если функция вызывается с помощью НОВОГО ключевого слова,то THIS будет привязан к вновь созданному объекту.</target>
        </trans-unit>
        <trans-unit id="6ee87374d289abdd7ecf8ddb47adfb37ca1d1d0e" translate="yes" xml:space="preserve">
          <source>If the method is on an object's prototype chain, &lt;code&gt;this&lt;/code&gt; inside such method refers to the object the method was called on, as if the method is defined on the object.</source>
          <target state="translated">Если метод находится в цепочке прототипов объекта, &lt;code&gt;this&lt;/code&gt; внутри такого метода относится к объекту, к которому был вызван метод, как если бы метод был определен для объекта.</target>
        </trans-unit>
        <trans-unit id="0f184b072ae7cca9bec0b9152d5ee281a0952b2c" translate="yes" xml:space="preserve">
          <source>If we miss &lt;code&gt;new&lt;/code&gt; keyword, &lt;code&gt;whatIsThis&lt;/code&gt; referes to the most global context it can find(&lt;code&gt;window&lt;/code&gt;)</source>
          <target state="translated">Если мы пропустим &lt;code&gt;new&lt;/code&gt; ключевое слово, &lt;code&gt;whatIsThis&lt;/code&gt; ссылается на самый глобальный контекст, который может найти ( &lt;code&gt;window&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="08b356112172b63c41e869c9033bb2d83cf69377" translate="yes" xml:space="preserve">
          <source>If you are wondering how a JavaScript library manipulates the value of &lt;code&gt;this&lt;/code&gt;, the library is simply using one of the built-in JavaScript functions accepting a &lt;code&gt;thisArg&lt;/code&gt;. You, too, can write your own function taking a callback function and &lt;code&gt;thisArg&lt;/code&gt;:</source>
          <target state="translated">Если вам интересно, как библиотека JavaScript манипулирует значением &lt;code&gt;this&lt;/code&gt; , библиотека просто использует одну из встроенных функций JavaScript, принимающих &lt;code&gt;thisArg&lt;/code&gt; . Вы также можете написать свою собственную функцию с функцией обратного вызова и &lt;code&gt;thisArg&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a05e4a50ca55b0ab68c8d4be4da417b51bf22da0" translate="yes" xml:space="preserve">
          <source>If you call a function with &lt;code&gt;new&lt;/code&gt; the &lt;code&gt;this&lt;/code&gt; will be a new context, it will not reference the global &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">Если вы вызываете функцию с &lt;code&gt;new&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; будет новым контекстом, это не будет ссылаться на глобальное &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02cbcf4e964a2153e423ad418b22f8c3fd0762a2" translate="yes" xml:space="preserve">
          <source>If you just call a function then &lt;code&gt;this&lt;/code&gt; is the &quot;global object&quot; which in the browser is the window</source>
          <target state="translated">Если вы просто вызываете функцию, то &lt;code&gt;this&lt;/code&gt; &amp;laquo;глобальный объект&amp;raquo;, который в браузере является окном</target>
        </trans-unit>
        <trans-unit id="d0e810fa1822dca8618162a82abee010cf8edbef" translate="yes" xml:space="preserve">
          <source>If you run this same piece of code in an environment like node.js, &lt;code&gt;this&lt;/code&gt; would refer to the global variable in your app.</source>
          <target state="translated">Если вы запустите этот же кусок кода в среде, такой как node.js, &lt;code&gt;this&lt;/code&gt; будет означать глобальную переменную в вашем приложении.</target>
        </trans-unit>
        <trans-unit id="d3d6688717298c61d86ba4872a3543c0973adcae" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;use strict;&lt;/code&gt;, in which case &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">Если вы &lt;code&gt;use strict;&lt;/code&gt; в этом случае &lt;code&gt;this&lt;/code&gt; будет &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4534c020e272fd844f4a0447a32701b45e3c9a14" translate="yes" xml:space="preserve">
          <source>In &quot;Non Strict Mode&quot;, Calling/Invoking this function directly through   &lt;strong&gt;&quot;UserDefinedFunction()&quot;&lt;/strong&gt; will automatically call/invoke
it as &lt;strong&gt;&quot;window.UserDefinedFunction()&quot;&lt;/strong&gt; making &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; as the
&lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; (and hence the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) within &lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt;.Invoking this function in &quot;Non Strict Mode&quot; will result in the following</source>
          <target state="translated">В &amp;laquo;Не строгом режиме&amp;raquo; вызов / вызов этой функции напрямую через &lt;strong&gt;&amp;laquo;UserDefinedFunction ()&amp;raquo;&lt;/strong&gt; автоматически вызовет / вызовет ее как &lt;strong&gt;&amp;laquo;window.UserDefinedFunction ()&amp;raquo;,&lt;/strong&gt; делая &lt;strong&gt;&amp;laquo;окно&amp;raquo;&lt;/strong&gt; &lt;strong&gt;&amp;laquo;текущим объектом&amp;raquo;&lt;/strong&gt; (и, следовательно, значением &lt;strong&gt;&amp;laquo; this &quot;&lt;/strong&gt; ) внутри &lt;strong&gt;&quot; UserDefinedFunction &quot;.&lt;/strong&gt; Вызов этой функции в&quot; не строгом режиме &quot;приведет к следующему</target>
        </trans-unit>
        <trans-unit id="a86f46ab5fd04ce187322c9dacbc63583d2300ac" translate="yes" xml:space="preserve">
          <source>In &quot;Strict Mode&quot;, Calling/Invoking the function directly through
&lt;strong&gt;&quot;UserDefinedFunction()&quot;&lt;/strong&gt; will &lt;strong&gt;&quot;NOT&quot;&lt;/strong&gt; automatically call/invoke it as &lt;strong&gt;&quot;window.UserDefinedFunction()&quot;&lt;/strong&gt;.Hence the &lt;strong&gt;&quot;current
object&quot;&lt;/strong&gt; (and the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) within
&lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt; shall be &lt;strong&gt;undefined&lt;/strong&gt;. Invoking this function in &quot;Strict Mode&quot; will result in the following</source>
          <target state="translated">В &amp;laquo;Строгом режиме&amp;raquo; вызов / вызов функции напрямую через &lt;strong&gt;&amp;laquo;UserDefinedFunction ()&amp;raquo;&lt;/strong&gt; будет &lt;strong&gt;&amp;laquo;НЕ&amp;raquo;&lt;/strong&gt; автоматически вызывать / вызывать ее как &lt;strong&gt;&amp;laquo;window.UserDefinedFunction ()&amp;raquo;.&lt;/strong&gt; Подразумевает &lt;strong&gt;&amp;laquo;текущий объект&amp;raquo;&lt;/strong&gt; (и значение &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; ) внутри &lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt; должно быть &lt;strong&gt;неопределенным&lt;/strong&gt; . Вызов этой функции в &amp;laquo;Строгом режиме&amp;raquo; приведет к следующему</target>
        </trans-unit>
        <trans-unit id="324ac6a318b326d5cd6ec138a5535c67787f43fe" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;node&lt;/code&gt; executing from a script, &lt;code&gt;this&lt;/code&gt; at the global scope starts as an empty object. It is not the same as &lt;code&gt;global&lt;/code&gt;</source>
          <target state="translated">В &lt;code&gt;node&lt;/code&gt; выполняемом из скрипта, &lt;code&gt;this&lt;/code&gt; в глобальной области видимости начинается как пустой объект. Это не то же самое, что &lt;code&gt;global&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e86f9b9c713dc09a44f881bdef02363ebb098cc7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;node&lt;/code&gt; using the repl, &lt;code&gt;this&lt;/code&gt; is the top namespace. You can refer to it as &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;node&lt;/code&gt; использующем repl, &lt;code&gt;this&lt;/code&gt; верхнее пространство имен. Вы можете назвать это &lt;code&gt;global&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffab00b98bc67260544caac0fccb102e726b7819" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;Client/Browser&lt;/strong&gt;&lt;code&gt;this&lt;/code&gt; keyword is a global object which is &lt;code&gt;window&lt;/code&gt;</source>
          <target state="translated">В &lt;strong&gt;клиенте / браузере&lt;/strong&gt; &lt;code&gt;this&lt;/code&gt; ключевое слово является глобальным объектом, который является &lt;code&gt;window&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f8bea0a49922aa0e3476e6f13ff485166460709" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;Server/Node/Javascript runtime&lt;/strong&gt;&lt;code&gt;this&lt;/code&gt; keyword is also a global object which is &lt;code&gt;module.exports&lt;/code&gt;</source>
          <target state="translated">В &lt;strong&gt;среде выполнения Server / Node / Javascript&lt;/strong&gt; &lt;code&gt;this&lt;/code&gt; ключевое слово также является глобальным объектом, который представляет собой &lt;code&gt;module.exports&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4079e8901c7bbc5e93844e5cba0c225cbd71f87b" translate="yes" xml:space="preserve">
          <source>In Global Context &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; always refers to the &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; object</source>
          <target state="translated">В глобальном контексте &lt;strong&gt;&amp;laquo;это&amp;raquo;&lt;/strong&gt; всегда относится к объекту &lt;strong&gt;&amp;laquo;окна&amp;raquo;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2878a1d2151511dedfc3b49078b6bb8743b5e514" translate="yes" xml:space="preserve">
          <source>In JavaScript there are operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;. There is also the dot operator which is &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">В JavaScript есть операторы типа &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;-&lt;/code&gt; и &lt;code&gt;*&lt;/code&gt; . Существует также точка оператора, который есть &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6efa6728b16de4e8625617c966cac872299fcc61" translate="yes" xml:space="preserve">
          <source>In a browser, at the global scope, &lt;code&gt;this&lt;/code&gt; is the &lt;code&gt;window&lt;/code&gt;object</source>
          <target state="translated">В браузере, в глобальном масштабе, &lt;code&gt;this&lt;/code&gt; объект &lt;code&gt;window&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="471827f41377d6ddd619a309af3ab2d6e951cd2c" translate="yes" xml:space="preserve">
          <source>In an HTML DOM event handler, &lt;code&gt;this&lt;/code&gt; is always a reference to the DOM element the event was attached to</source>
          <target state="translated">В обработчике событий HTML DOM &lt;code&gt;this&lt;/code&gt; всегда ссылка на элемент DOM, к которому было прикреплено событие</target>
        </trans-unit>
        <trans-unit id="f43a8566d5e8782dd6106131e8e134eb235d04cf" translate="yes" xml:space="preserve">
          <source>In an arrow function, &lt;code&gt;this&lt;/code&gt; will behave like common variables: it will be inherited from its lexical scope. The function's &lt;code&gt;this&lt;/code&gt;, where the arrow function is defined, will be the arrow function's &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">В функции стрелки &lt;code&gt;this&lt;/code&gt; будет вести себя как общие переменные: оно будет унаследовано от его лексической области видимости. Функция &lt;code&gt;this&lt;/code&gt; , в которой определена функция стрелки, будет функцией &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0ed578783f6c0844fb69401e88c46b1d4c812d5" translate="yes" xml:space="preserve">
          <source>In both cases, this is set to window.</source>
          <target state="translated">В обоих случаях установлено окно.</target>
        </trans-unit>
        <trans-unit id="3c2d641383f797d7802108f589e4b9aefd246bdb" translate="yes" xml:space="preserve">
          <source>In event listeners the value of &lt;code&gt;this&lt;/code&gt;  refers to the DOM element on which the event was called.</source>
          <target state="translated">В прослушивателях событий значение &lt;code&gt;this&lt;/code&gt; относится к элементу DOM, для которого было вызвано событие.</target>
        </trans-unit>
        <trans-unit id="21221c02e3ea6b186925dee47bb0aff97b3c7622" translate="yes" xml:space="preserve">
          <source>In other words &lt;code&gt;bar.foo()&lt;/code&gt; translates into &lt;code&gt;const temp = bar.foo; temp.call(bar);&lt;/code&gt;</source>
          <target state="translated">Другими словами, &lt;code&gt;bar.foo()&lt;/code&gt; переводится в &lt;code&gt;const temp = bar.foo; temp.call(bar);&lt;/code&gt; temp.call (бар);</target>
        </trans-unit>
        <trans-unit id="e583468a15187c915f71a5317544c6b871de6462" translate="yes" xml:space="preserve">
          <source>In other words,</source>
          <target state="translated">Другими словами,</target>
        </trans-unit>
        <trans-unit id="27d6a458ca3d5e041f95d454ee2e6dbc62b5e228" translate="yes" xml:space="preserve">
          <source>In pseudoclassical terms, the way many lectures teach the 'this' keyword is as an object instantiated by a class or object constructor. Each time a new object is constructed from a class, imagine that under the hood a local instance of a 'this' object is created and returned. I remember it taught like this:</source>
          <target state="translated">В псевдоклассическом смысле то,как во многих лекциях ключевое слово &quot;this&quot; преподается как объект,инстанцированный классом или конструктором объекта.Каждый раз,когда новый объект создается из класса,представьте себе,что под капотом создается и возвращается локальный экземпляр 'this' объекта.Я помню,как это учили:</target>
        </trans-unit>
        <trans-unit id="cd2387ea5c279e482429632a93ee4100a845238a" translate="yes" xml:space="preserve">
          <source>In the above code, we see that the value of &lt;code&gt;this&lt;/code&gt; changed with the nested scope, but we wanted the value of &lt;code&gt;this&lt;/code&gt; from the original scope. So we 'copied' &lt;code&gt;this&lt;/code&gt; to &lt;code&gt;that&lt;/code&gt; and used the copy instead of &lt;code&gt;this&lt;/code&gt;. Clever, eh?</source>
          <target state="translated">В приведенном выше коде мы видим, что значение &lt;code&gt;this&lt;/code&gt; изменялось с вложенной областью действия, но мы хотели получить значение &lt;code&gt;this&lt;/code&gt; из исходной области действия. Таким образом, мы &amp;laquo;скопировали&amp;raquo; &lt;code&gt;this&lt;/code&gt; к &lt;code&gt;that&lt;/code&gt; и использовали копию вместо &lt;code&gt;this&lt;/code&gt; . Умно, а?</target>
        </trans-unit>
        <trans-unit id="43224f60c133b11951481d44412c4fce99a0226f" translate="yes" xml:space="preserve">
          <source>In the above example we see that when &lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt; was
invoked through &lt;strong&gt;o1&lt;/strong&gt;, &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; takes value of &lt;strong&gt;o1&lt;/strong&gt; and the
value of its properties &lt;strong&gt;&quot;a&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;b&quot;&lt;/strong&gt; get displayed. The value
of &lt;strong&gt;&quot;c&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;d&quot;&lt;/strong&gt; were shown as &lt;strong&gt;undefined&lt;/strong&gt; as &lt;strong&gt;o1&lt;/strong&gt; does
not define these properties</source>
          <target state="translated">В приведенном выше примере мы видим, что когда &lt;strong&gt;&amp;laquo;UserDefinedFunction&amp;raquo; вызывался&lt;/strong&gt; через &lt;strong&gt;o1&lt;/strong&gt; , &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; принимает значение &lt;strong&gt;o1,&lt;/strong&gt; и отображаются значения его свойств &lt;strong&gt;&amp;laquo;a&amp;raquo;&lt;/strong&gt; и &lt;strong&gt;&amp;laquo;b&amp;raquo;&lt;/strong&gt; . Значения &lt;strong&gt;&quot;c&quot;&lt;/strong&gt; и &lt;strong&gt;&quot;d&quot;&lt;/strong&gt; были показаны как &lt;strong&gt;неопределенные,&lt;/strong&gt; поскольку &lt;strong&gt;o1&lt;/strong&gt; не определяет эти свойства</target>
        </trans-unit>
        <trans-unit id="96cc1a99aaa4e2084ab88b3ca40dccb578c47d7d" translate="yes" xml:space="preserve">
          <source>In the above this will be bound to 'myCar' object</source>
          <target state="translated">В приведенном выше примере он будет связан с объектом &quot;myCar&quot;.</target>
        </trans-unit>
        <trans-unit id="c83013fb1cd27e083ad60085d21979e56ba40fe5" translate="yes" xml:space="preserve">
          <source>In the case of the &lt;code&gt;Array.prototype&lt;/code&gt; functions, the given &lt;code&gt;callbackfn&lt;/code&gt; is called in an execution context where ThisBinding is set to &lt;code&gt;thisArg&lt;/code&gt; if supplied; otherwise, to the global object.</source>
          <target state="translated">В случае функций &lt;code&gt;Array.prototype&lt;/code&gt; данный &lt;code&gt;callbackfn&lt;/code&gt; вызывается в контексте выполнения, где ThisBinding установлен в &lt;code&gt;thisArg&lt;/code&gt; , если он предоставлен; в противном случае к глобальному объекту.</target>
        </trans-unit>
        <trans-unit id="c033f7496c40486ad987d93a68b83caa6838c09d" translate="yes" xml:space="preserve">
          <source>In the case of the &lt;code&gt;Function.prototype&lt;/code&gt; functions, they are called on a function object, but rather than setting ThisBinding to the function object, ThisBinding is set to the &lt;code&gt;thisArg&lt;/code&gt;.</source>
          <target state="translated">В случае &lt;code&gt;Function.prototype&lt;/code&gt; они вызываются для объекта функции, но вместо установки ThisBinding для объекта функции ThisBinding устанавливается в &lt;code&gt;thisArg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaeae9315cfc2930a15076b4cb90e923ca76ddd7" translate="yes" xml:space="preserve">
          <source>In the first example, the font color of the button shall be set to
white when it is clicked.</source>
          <target state="translated">В первом примере цвет шрифта кнопки при нажатии устанавливается белым.</target>
        </trans-unit>
        <trans-unit id="2e598c3cda0bdc325d8abb172c4e83c3b44ff6a8" translate="yes" xml:space="preserve">
          <source>In the following cases, we would see how to manipulate the value of &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">В следующих случаях мы увидим, как манипулировать значением &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="430cd67bcc3100745a24d8b9fbad17bfca3af311" translate="yes" xml:space="preserve">
          <source>In the latter case, you merely reference the function, not hand it over to the element. Therefore, &lt;code&gt;this&lt;/code&gt; will refer to the window object.</source>
          <target state="translated">В последнем случае вы просто ссылаетесь на функцию, а не передаете ее элементу. Следовательно, &lt;code&gt;this&lt;/code&gt; будет относиться к объекту окна.</target>
        </trans-unit>
        <trans-unit id="1dd405f2048b51f3afad5fd52c3f9bfc8120d1ae" translate="yes" xml:space="preserve">
          <source>In the second example when the &lt;strong&gt;&quot;div&quot;&lt;/strong&gt; element is clicked it shall
call the &lt;strong&gt;OnDivClick&lt;/strong&gt; function with its second parameter
referencing the clicked div element. However the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;
within OnDivClick &lt;strong&gt;SHALL NOT&lt;/strong&gt; reference the clicked &lt;strong&gt;div&lt;/strong&gt;
element. It shall be set as the &lt;strong&gt;&quot;window object&quot;&lt;/strong&gt; or
&lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; in &lt;strong&gt;Non strict&lt;/strong&gt; and &lt;strong&gt;Strict Modes&lt;/strong&gt; respectively (if &lt;strong&gt;OnDivClick&lt;/strong&gt; is an &lt;strong&gt;unbound function&lt;/strong&gt;) or set to a predefined
Bound value (if &lt;strong&gt;OnDivClick&lt;/strong&gt; is a &lt;strong&gt;bound function&lt;/strong&gt;)</source>
          <target state="translated">Во втором примере при щелчке элемента &lt;strong&gt;&amp;laquo;div&amp;raquo;&lt;/strong&gt; он должен вызвать функцию &lt;strong&gt;OnDivClick,&lt;/strong&gt; второй параметр которой ссылается на элемент div, по &lt;strong&gt;которому&lt;/strong&gt; щелкнули. Однако значение &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; в OnDivClick &lt;strong&gt;НЕ ДОЛЖНО&lt;/strong&gt; ссылаться на нажатый элемент &lt;strong&gt;div&lt;/strong&gt; . Он должен быть установлен как &lt;strong&gt;&amp;laquo;объект окна&amp;raquo;&lt;/strong&gt; или &lt;strong&gt;&amp;laquo;неопределенный&amp;raquo;&lt;/strong&gt; в &lt;strong&gt;нестрогих&lt;/strong&gt; и &lt;strong&gt;строгих&lt;/strong&gt; &lt;strong&gt;режимах&lt;/strong&gt; соответственно (если &lt;strong&gt;OnDivClick&lt;/strong&gt; является &lt;strong&gt;несвязанной функцией&lt;/strong&gt; ) или установлен в предопределенное значение Bound (если &lt;strong&gt;OnDivClick&lt;/strong&gt; является &lt;strong&gt;связанной функцией&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="81ed2e6a494f7f2dc46f5d18d6632785957e98bc" translate="yes" xml:space="preserve">
          <source>In this case, THIS will be bound to the object which is explicitly passed to the function.</source>
          <target state="translated">В этом случае ЭТО будет привязано к объекту,который явно передан функции.</target>
        </trans-unit>
        <trans-unit id="0df985536051bb82097890e1a0953285b688bcea" translate="yes" xml:space="preserve">
          <source>In this example, the JavaScript interpreter enters function code, but because &lt;code&gt;myFun&lt;/code&gt;/&lt;code&gt;obj.myMethod&lt;/code&gt; is not called on an object, ThisBinding is set to &lt;code&gt;window&lt;/code&gt;.</source>
          <target state="translated">В этом примере интерпретатор JavaScript вводит код функции, но поскольку &lt;code&gt;myFun&lt;/code&gt; / &lt;code&gt;obj.myMethod&lt;/code&gt; не вызывается для объекта, ThisBinding установлен в &lt;code&gt;window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bb2e91de5338b6aa278265043941f191287a902" translate="yes" xml:space="preserve">
          <source>In two words, &lt;code&gt;this&lt;/code&gt; in JavaScript points the object from whom (or from whose execution context) the current function was run and it's always read-only, you can't set it anyway (such an attempt will end up with 'Invalid left-hand side in assignment' message.</source>
          <target state="translated">В двух словах, &lt;code&gt;this&lt;/code&gt; в JavaScript указывает на объект, от которого (или от чьего контекста выполнения) была запущена текущая функция, и она всегда доступна только для чтения, в любом случае вы не можете установить ее (такая попытка будет заканчиваться 'Invalid left- сторона стороны в сообщении присваивания.</target>
        </trans-unit>
        <trans-unit id="934e0a8e43701b41d397444e208dc6649f33774f" translate="yes" xml:space="preserve">
          <source>Index:</source>
          <target state="translated">Index:</target>
        </trans-unit>
        <trans-unit id="8659b0f0077283eb99e2d1bd963b7db35f13f69b" translate="yes" xml:space="preserve">
          <source>Inside HTML attributes in which you can put JavaScript, &lt;code&gt;this&lt;/code&gt; is a reference to the element.</source>
          <target state="translated">Внутри атрибутов HTML, в которые вы можете поместить JavaScript, &lt;code&gt;this&lt;/code&gt; ссылка на элемент.</target>
        </trans-unit>
        <trans-unit id="9e308c1af402a51e3c742eaeb80b4ffd7fa67c95" translate="yes" xml:space="preserve">
          <source>Inside a Direct  &quot;Non Bound Function&quot; Call, &lt;strong&gt;the object that
invoked the function call becomes the &quot;current object&quot;&lt;/strong&gt; (and hence
the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;). If a function is called without a explicit &lt;strong&gt;current object&lt;/strong&gt;, the &lt;strong&gt;current object&lt;/strong&gt; is either the &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; object (For Non Strict Mode) or &lt;strong&gt;undefined&lt;/strong&gt; (For Strict Mode)  . Any function (or variable) defined in
&lt;strong&gt;Global Context&lt;/strong&gt; automatically becomes a property of the &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; object.For e.g Suppose function is defined in Global Context as</source>
          <target state="translated">Внутри прямого вызова &amp;laquo;Не связанная функция&amp;raquo; &lt;strong&gt;объект, вызвавший вызов функции, становится &amp;laquo;текущим объектом&amp;raquo;&lt;/strong&gt; (и, следовательно, значением &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; ). Если функция вызывается без явного &lt;strong&gt;текущего объекта&lt;/strong&gt; , &lt;strong&gt;текущий объект&lt;/strong&gt; является либо &lt;strong&gt;&amp;laquo;оконным&amp;raquo;&lt;/strong&gt; объектом (для нестрого режима), либо &lt;strong&gt;неопределенным&lt;/strong&gt; (для строгого режима). Любая функция (или переменная), определенная в &lt;strong&gt;глобальном контексте,&lt;/strong&gt; автоматически становится свойством объекта &lt;strong&gt;&amp;laquo;окна&amp;raquo;.&lt;/strong&gt; Например, предположим, что функция определяется в глобальном контексте как</target>
        </trans-unit>
        <trans-unit id="e90ac117b0316d7973d69a03502107870607096b" translate="yes" xml:space="preserve">
          <source>Inside a constructor function, the &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; (and hence the value of 
&lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) references the object that is currently being created
through &lt;strong&gt;&quot;new&quot;&lt;/strong&gt; irrespective of the bind status of the function. However
if the constructor is a bound function it shall get called with 
predefined set of arguments as set for the bound function.</source>
          <target state="translated">Внутри функции конструктора &lt;strong&gt;&amp;laquo;текущий объект&amp;raquo;&lt;/strong&gt; (и, следовательно, значение &lt;strong&gt;&amp;laquo;этого&amp;raquo;&lt;/strong&gt; ) ссылается на объект, который в данный момент создается через &lt;strong&gt;&amp;laquo;новый&amp;raquo;,&lt;/strong&gt; независимо от состояния привязки функции. Однако, если конструктор является связанной функцией, он должен вызываться с предопределенным набором аргументов, установленным для связанной функции.</target>
        </trans-unit>
        <trans-unit id="07896e58b529f3fb8b5b73a6120efa70bb3ab536" translate="yes" xml:space="preserve">
          <source>Irrespective of the context in which it is used, &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; always references the &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; in Javascript. However, what the &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; is  differs according to &lt;strong&gt;context&lt;/strong&gt;. The &lt;strong&gt;context&lt;/strong&gt; may be exactly &lt;strong&gt;1 of the 6&lt;/strong&gt; following:</source>
          <target state="translated">Независимо от контекста, в котором он используется, &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; всегда ссылается на &lt;strong&gt;&amp;laquo;текущий объект&amp;raquo;&lt;/strong&gt; в Javascript. Однако то, чем является &lt;strong&gt;&amp;laquo;текущий объект&amp;raquo;,&lt;/strong&gt; зависит от &lt;strong&gt;контекста&lt;/strong&gt; . &lt;strong&gt;Контекст&lt;/strong&gt; может быть ровно &lt;strong&gt;1 из 6&lt;/strong&gt; следующих:</target>
        </trans-unit>
        <trans-unit id="0ddbde6677e66a2eef6ce94f5856c81e48273985" translate="yes" xml:space="preserve">
          <source>It is difficult to get a good grasp of JS, or write more than anything trivial in it, if you don't understand it thoroughly. You cannot just afford to take a quick dip :) I think the best way to get started with JS is to first watch these video lectures by Douglas Crockford - &lt;a href=&quot;http://yuiblog.com/crockford/&quot;&gt;http://yuiblog.com/crockford/&lt;/a&gt;, which covers this and that, and everything else about JS.</source>
          <target state="translated">Трудно получить хорошее представление о JS или написать более, чем что-либо тривиальное в нем, если вы не понимаете его полностью. Вы не можете позволить себе просто окунуться :) Я думаю, что лучший способ начать работу с JS - это сначала посмотреть эти видео-лекции Дугласа Крокфорда - &lt;a href=&quot;http://yuiblog.com/crockford/&quot;&gt;http://yuiblog.com/crockford/&lt;/a&gt; , которые охватывают то и это, и все остальное о JS.</target>
        </trans-unit>
        <trans-unit id="7126c04f305ed904207b61e181769dea029be5b6" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to assign &lt;em&gt;arrays&lt;/em&gt; or &lt;em&gt;objects&lt;/em&gt; on the &lt;code&gt;prototype&lt;/code&gt;. If you want instances to each have their own arrays, create them in the function, not the prototype.</source>
          <target state="translated">Обычно ошибочно назначать &lt;em&gt;массивы&lt;/em&gt; или &lt;em&gt;объекты&lt;/em&gt; &lt;code&gt;prototype&lt;/code&gt; . Если вы хотите, чтобы экземпляры имели свои собственные массивы, создайте их в функции, а не в прототипе.</target>
        </trans-unit>
        <trans-unit id="992dc5d399c1eb9c5819d08e8cdc27405e9a0bff" translate="yes" xml:space="preserve">
          <source>JQuery proxy is another way you can use to make sure this in a function will be the value you desire. (Check &lt;a href=&quot;https://stackoverflow.com/q/4986329/340046&quot;&gt;Understanding $.proxy()&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/q/3349380/340046&quot;&gt;jQuery.proxy() usage&lt;/a&gt;)</source>
          <target state="translated">Прокси-сервер JQuery - это еще один способ, которым вы можете использовать, чтобы убедиться, что в функции будет значение, которое вы хотите. (Проверьте &lt;a href=&quot;https://stackoverflow.com/q/4986329/340046&quot;&gt;понимание использования $ .proxy ()&lt;/a&gt; , &lt;a href=&quot;https://stackoverflow.com/q/3349380/340046&quot;&gt;jQuery.proxy ()&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="be6b0ab456696ba8d67592a42d2412b774842021" translate="yes" xml:space="preserve">
          <source>Javascript's &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">Это яваскрипт</target>
        </trans-unit>
        <trans-unit id="2453951365a295c5909c9ed643507672357709f3" translate="yes" xml:space="preserve">
          <source>Just for fun, test your understanding with some examples</source>
          <target state="translated">Просто ради забавы,проверьте свое понимание на некоторых примерах.</target>
        </trans-unit>
        <trans-unit id="894c85eb8e48c996ee7525b62829676432dc120f" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;bind&lt;/code&gt;, a new invisible function is created that calls the given function with a bound value for &lt;code&gt;objectForThis&lt;/code&gt; but unlike &lt;code&gt;bind&lt;/code&gt; the object to be bound is implicit. It's whatever &lt;code&gt;this&lt;/code&gt; happens to be when the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is used.</source>
          <target state="translated">Так же, как &lt;code&gt;bind&lt;/code&gt; , создается новая невидимая функция, которая вызывает данную функцию со связанным значением для &lt;code&gt;objectForThis&lt;/code&gt; , но в отличие от &lt;code&gt;bind&lt;/code&gt; объект, который должен быть связан, является неявным. Это то, что происходит, когда используется оператор &lt;code&gt;=&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcbd5d2a27f1bec48bd69a467c70b7017b49d1da" translate="yes" xml:space="preserve">
          <source>Keep in mind &lt;code&gt;exports&lt;/code&gt; is just a reference to &lt;code&gt;module.exports&lt;/code&gt;</source>
          <target state="translated">Имейте в виду, что &lt;code&gt;exports&lt;/code&gt; - это просто ссылка на &lt;code&gt;module.exports&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fa70764a0750c44aea026597b2b0bb54778bd69" translate="yes" xml:space="preserve">
          <source>Let us look at another example. Please look at the following code</source>
          <target state="translated">Давайте рассмотрим другой пример.Пожалуйста,посмотрите на следующий код</target>
        </trans-unit>
        <trans-unit id="674fee26bf2169d5b7390a8d6cb04650d870ce43" translate="yes" xml:space="preserve">
          <source>Let's log &lt;code&gt;this&lt;/code&gt; keyword to the console in global scope without any more code but</source>
          <target state="translated">Давайте запишем &lt;code&gt;this&lt;/code&gt; ключевое слово в консоли в глобальной области видимости без кода, но</target>
        </trans-unit>
        <trans-unit id="347a6545cb2fdbde1b257137e4557d5c3e7376d9" translate="yes" xml:space="preserve">
          <source>Lexically for arrow functions (they adopt the &lt;em&gt;this&lt;/em&gt; of their outer execution context)</source>
          <target state="translated">Лексически для функций стрелок (они принимают &lt;em&gt;this&lt;/em&gt; из своего внешнего контекста выполнения)</target>
        </trans-unit>
        <trans-unit id="4b794c51b008429d9440459755a0aea70b021d1b" translate="yes" xml:space="preserve">
          <source>Most people get confused when they try to use &quot;this&quot; inside of anonymous closure functions like:</source>
          <target state="translated">Большинство людей путаются,когда пытаются использовать &quot;это&quot; внутри анонимных функций закрытия типа:</target>
        </trans-unit>
        <trans-unit id="24a1c5ba7f20054e6cc97447ca4ff99819209a36" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; can override the value of &lt;code&gt;this&lt;/code&gt; set by dot method invocation we discussed in the second bullet.
Simple enough :)</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; могут переопределить значение &lt;code&gt;this&lt;/code&gt; набора с помощью вызова метода точки, который мы обсуждали во втором пункте. Достаточно просто :)</target>
        </trans-unit>
        <trans-unit id="d5fda3afa616c2908147257d1b4538bffe1f96f3" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;functionObject.bind&lt;/code&gt; did not exist we could make our own like this</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;functionObject.bind&lt;/code&gt; не существует, мы можем сделать наш собственный вот так</target>
        </trans-unit>
        <trans-unit id="fd156fe39e6cb3e81a3dc10a1d0665f3a2485dfd" translate="yes" xml:space="preserve">
          <source>Note that if a method is stored (or rather, copied) in another variable, the reference to &lt;code&gt;this&lt;/code&gt; is no longer preserved in the new variable. For example:</source>
          <target state="translated">Обратите внимание, что если метод хранится (или, скорее, копируется) в другой переменной, ссылка на него больше не сохраняется в новой переменной. Например:</target>
        </trans-unit>
        <trans-unit id="767a361d58ea1665f1185636ce54e8f7e4d5a7b8" translate="yes" xml:space="preserve">
          <source>Note that if you use strict mode then &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">Обратите внимание, что если вы используете строгий режим, то &lt;code&gt;this&lt;/code&gt; будет &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="235f4aca4b6e147c89ad215706ae8a6e2deabb75" translate="yes" xml:space="preserve">
          <source>Note that it doesn't matter how the function was created (mostly...). All of these will produce the same results</source>
          <target state="translated">Обратите внимание,что не имеет значения,как была создана функция (в основном...).Все это даст один и тот же результат.</target>
        </trans-unit>
        <trans-unit id="2b700c221638ceb27ecd2fe681cd4c26833c39cf" translate="yes" xml:space="preserve">
          <source>Note that the official ECMAScript spec nowhere states that such types of functions are actual &lt;code&gt;constructor&lt;/code&gt; functions. They are just normal functions, and &lt;code&gt;new&lt;/code&gt; can be used on any function. It's just that we use them as such, and so we call them as such only.</source>
          <target state="translated">Обратите внимание, что в официальной спецификации ECMAScript нигде не говорится, что такие типы функций являются фактическими функциями &lt;code&gt;constructor&lt;/code&gt; . Это просто обычные функции, и &lt;code&gt;new&lt;/code&gt; могут быть использованы для любой функции. Просто мы используем их как таковые, и поэтому мы называем их только таковыми.</target>
        </trans-unit>
        <trans-unit id="bd960096fd51dca1613866611c29d9d73d149c0d" translate="yes" xml:space="preserve">
          <source>Note that we are running this in the normal mode, i.e. strict mode is not used.</source>
          <target state="translated">Обратите внимание,что мы работаем в обычном режиме,т.е.строгий режим не используется.</target>
        </trans-unit>
        <trans-unit id="81c5b121bb3b104b797c415c59fc9f82cf7e31ea" translate="yes" xml:space="preserve">
          <source>Now if we run this in strict mode by adding the statement &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; to the beginning of the function declaration, &lt;code&gt;this&lt;/code&gt; would no longer refer to the global variable in either of the environments. This is done to avoid confusions in strict mode. &lt;code&gt;this&lt;/code&gt; would, in this case just log &lt;code&gt;undefined&lt;/code&gt;, because that is what it is, it is not defined.</source>
          <target state="translated">Теперь, если мы запустим это в строгом режиме, добавив выражение &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; к началу объявления функции &lt;code&gt;this&lt;/code&gt; больше не будет ссылаться на глобальную переменную ни в одной из сред. Это сделано, чтобы избежать путаницы в строгом режиме. в этом случае это просто журнал &lt;code&gt;undefined&lt;/code&gt; , потому что это то, что он есть, он не определен.</target>
        </trans-unit>
        <trans-unit id="bdb993d7f3927fbada79fbc0cdf43dcb01f54dc1" translate="yes" xml:space="preserve">
          <source>Now. Let's imagine we make a function that explicitly sets &lt;code&gt;this&lt;/code&gt; before calling another function and then call it with the &lt;code&gt;.&lt;/code&gt; (dot) operator</source>
          <target state="translated">Сейчас. Давайте представим, что мы создаем функцию, которая явно устанавливает &lt;code&gt;this&lt;/code&gt; перед вызовом другой функции, а затем вызываем ее с помощью &lt;code&gt;.&lt;/code&gt; (точка) оператор</target>
        </trans-unit>
        <trans-unit id="f7c9c2091cfaff21dd7fae4ea95609c87cb2899e" translate="yes" xml:space="preserve">
          <source>Object literal notation creates an instance of object which we can use immediately. With function we may need to first create its instance using &lt;code&gt;new&lt;/code&gt; operator.</source>
          <target state="translated">Буквенная нотация объекта создает экземпляр объекта, который мы можем использовать немедленно. С помощью функции нам может понадобиться сначала создать ее экземпляр с помощью оператора &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25ff51b9b77d4e3cd4a459c2231b84b262b58dee" translate="yes" xml:space="preserve">
          <source>Once you start getting used to &lt;code&gt;this&lt;/code&gt;, the rules are actually pretty simple. The &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1&quot;&gt;ECMAScript 5.1 Standard&lt;/a&gt; defines &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">Как только вы начинаете привыкать к &lt;code&gt;this&lt;/code&gt; , правила на самом деле довольно просты. Стандарт &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1&quot;&gt;ECMAScript 5.1&lt;/a&gt; определяет &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ba28d64a842cc863e8fd947ef8b2d2761787ca76" translate="yes" xml:space="preserve">
          <source>One other wrinkle is the prototype chain. When you use &lt;code&gt;a.b&lt;/code&gt; JavaScript first looks on the object referenced directly by &lt;code&gt;a&lt;/code&gt; for the property &lt;code&gt;b&lt;/code&gt;. If &lt;code&gt;b&lt;/code&gt; is not found on the object then JavaScript will look in the object's prototype to find &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Еще одна морщина - это прототип цепи. Когда вы используете &lt;code&gt;a.b&lt;/code&gt; JavaScript сначала смотрит на объект, на который ссылается &lt;code&gt;a&lt;/code&gt; для свойства &lt;code&gt;b&lt;/code&gt; . Если &lt;code&gt;b&lt;/code&gt; не найден в объекте, тогда JavaScript будет искать в прототипе объекта, чтобы найти &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="519ab8586252702931098aa46525bc513da1698f" translate="yes" xml:space="preserve">
          <source>One way to look at JavaScript is to see that there are only 1 way to call a function&lt;sup&gt;1&lt;/sup&gt;. It is</source>
          <target state="translated">Один из способов взглянуть на JavaScript - это увидеть только 1 способ вызова функции &lt;sup&gt;1&lt;/sup&gt; . это</target>
        </trans-unit>
        <trans-unit id="e6cc1f21389aeed3c994d1fb9ea99f0e63bb1e99" translate="yes" xml:space="preserve">
          <source>Outside all functions (i.e. in global context) the &lt;strong&gt;&quot;current
object&quot;&lt;/strong&gt; (and hence the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) is always the
&lt;strong&gt;&quot;window&quot;&lt;/strong&gt; object for browsers.</source>
          <target state="translated">Вне всех функций (т. Е. В глобальном контексте) &lt;strong&gt;&amp;laquo;текущий объект&amp;raquo;&lt;/strong&gt; (и, следовательно, значение &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; ) всегда является объектом &lt;strong&gt;&amp;laquo;окна&amp;raquo;&lt;/strong&gt; для браузеров.</target>
        </trans-unit>
        <trans-unit id="458f4f8a250f5217e985cebc8035a133a4cc6496" translate="yes" xml:space="preserve">
          <source>Please look at the following HTML Snippet</source>
          <target state="translated">Пожалуйста,ознакомьтесь со следующим фрагментом HTML</target>
        </trans-unit>
        <trans-unit id="c23e76e8d97b29eedd68eb763eb4329893b8b3a7" translate="yes" xml:space="preserve">
          <source>Presenting.... &lt;code&gt;bind&lt;/code&gt;!</source>
          <target state="translated">Представляя .... &lt;code&gt;bind&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="5dff48a80d21897b1a7b4ec4d3e064bd791cf0a7" translate="yes" xml:space="preserve">
          <source>Pretty straightforward, eh?</source>
          <target state="translated">Довольно прямолинейно,да?</target>
        </trans-unit>
        <trans-unit id="d68dbd2ff1e0f0c272d49f9c85bec5340d93f7ba" translate="yes" xml:space="preserve">
          <source>Probably the most detailed and comprehensive article on &lt;code&gt;this&lt;/code&gt; is the following:</source>
          <target state="translated">Вероятно, самая подробная и всесторонняя статья по &lt;code&gt;this&lt;/code&gt; поводу следующая:</target>
        </trans-unit>
        <trans-unit id="aec57670cb741243fb4b52dc59dfa257130956b6" translate="yes" xml:space="preserve">
          <source>See the difference between the three? It is subtle, but they are used differently. Like &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;bind&lt;/code&gt; will also over-ride the value of &lt;code&gt;this&lt;/code&gt; set by dot-method invocation.</source>
          <target state="translated">Видишь разницу между тремя? Это тонко, но они используются по-разному. Подобно &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; , &lt;code&gt;bind&lt;/code&gt; также переопределит значение &lt;code&gt;this&lt;/code&gt; набора при вызове точечного метода.</target>
        </trans-unit>
        <trans-unit id="d6a6db24764ce1a8198a5fb69df54904ebb96362" translate="yes" xml:space="preserve">
          <source>See the following code:</source>
          <target state="translated">См.следующий код:</target>
        </trans-unit>
        <trans-unit id="044b35bd261da09f7c8b736e9469b64b95b16433" translate="yes" xml:space="preserve">
          <source>Similarly when &lt;strong&gt;&quot;UserDefinedFunction&quot;&lt;/strong&gt; was invoked through &lt;strong&gt;o2&lt;/strong&gt;,
&lt;strong&gt;&quot;this&quot;&lt;/strong&gt; takes value of &lt;strong&gt;o2&lt;/strong&gt; and the value of its properties &lt;strong&gt;&quot;c&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;d&quot;&lt;/strong&gt; get displayed.The value of &lt;strong&gt;&quot;a&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;b&quot;&lt;/strong&gt; were shown as &lt;strong&gt;undefined&lt;/strong&gt; as &lt;strong&gt;o2&lt;/strong&gt; does not define these properties.</source>
          <target state="translated">Аналогично, когда &lt;strong&gt;&amp;laquo;UserDefinedFunction&amp;raquo;&lt;/strong&gt; вызывается через &lt;strong&gt;o2&lt;/strong&gt; , &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; принимает значение &lt;strong&gt;o2,&lt;/strong&gt; и отображаются значения его свойств &lt;strong&gt;&amp;laquo;c&amp;raquo;&lt;/strong&gt; и &lt;strong&gt;&amp;laquo;d&amp;raquo;.&lt;/strong&gt; Значения &lt;strong&gt;&amp;laquo;a&amp;raquo;&lt;/strong&gt; и &lt;strong&gt;&amp;laquo;b&amp;raquo;&lt;/strong&gt; были показаны как &lt;strong&gt;неопределенные,&lt;/strong&gt; как и &lt;strong&gt;o2&lt;/strong&gt; не определять эти свойства.</target>
        </trans-unit>
        <trans-unit id="4681c4e7dfd2de2b681bc6a9a880fb39de0fc724" translate="yes" xml:space="preserve">
          <source>Similarly, when you use &lt;code&gt;this&lt;/code&gt; directly inside the event property (like &lt;code&gt;&amp;lt;button onclick=&quot;...this...&quot; &amp;gt;&lt;/code&gt;) of the element, it refers to the element.</source>
          <target state="translated">Точно так же, когда вы используете &lt;code&gt;this&lt;/code&gt; непосредственно внутри свойства события (например, &lt;code&gt;&amp;lt;button onclick=&quot;...this...&quot; &amp;gt;&lt;/code&gt; ) элемента, оно ссылается на элемент.</target>
        </trans-unit>
        <trans-unit id="fc5642eed954e43be8c2b08ea6204f5beae34cb6" translate="yes" xml:space="preserve">
          <source>Simple answer:</source>
          <target state="translated">Простой ответ:</target>
        </trans-unit>
        <trans-unit id="cd0c21407e549024fd8ebade4d9db293fa35da67" translate="yes" xml:space="preserve">
          <source>Simple function invocation</source>
          <target state="translated">Простой вызов функции</target>
        </trans-unit>
        <trans-unit id="d7af4d79d12ac932a60b3bcbb4551442c40a1a19" translate="yes" xml:space="preserve">
          <source>So here, inside each(), &quot;this&quot; doesn't hold the &quot;value&quot; that you expect it to (from</source>
          <target state="translated">Так что здесь,внутри каждой(),&quot;this&quot; не держит &quot;значение&quot;,которое вы ожидаете от него (от</target>
        </trans-unit>
        <trans-unit id="2dedd77da3beb2baf299eed38237e8b9cb499c92" translate="yes" xml:space="preserve">
          <source>So if I did</source>
          <target state="translated">Так что,если бы я это сделал.</target>
        </trans-unit>
        <trans-unit id="f9ad9f9ed5dfd5b4e3d833b6c8840ad972fab14b" translate="yes" xml:space="preserve">
          <source>So the Semantic of &quot;this&quot; is different from the traditional OOP languages. And it causes problems:
1. when a function is passed to another variable (most likely, a callback); and 2. when a closure is invoked from a member method of a class.</source>
          <target state="translated">Так что семантика &quot;это&quot; отличается от традиционных ООП-языков.И это вызывает проблемы:1.когда функция передается другой переменной (скорее всего,обратный вызов);и 2.когда вызывается закрытие из метода-членов класса.</target>
        </trans-unit>
        <trans-unit id="40cd6970e0b84898911ea5a78a1e7dfb515b5bcf" translate="yes" xml:space="preserve">
          <source>So the above code will log &lt;code&gt;{myObj: &quot;is cool&quot;}, [1, 2, 3]&lt;/code&gt; in the console. Pretty nice way to change the value of &lt;code&gt;this&lt;/code&gt; in any function.</source>
          <target state="translated">Таким образом, приведенный выше код будет регистрировать &lt;code&gt;{myObj: &quot;is cool&quot;}, [1, 2, 3]&lt;/code&gt; в консоли. Довольно хороший способ изменить значение &lt;code&gt;this&lt;/code&gt; в любой функции.</target>
        </trans-unit>
        <trans-unit id="522ff2123214afbd475283a209499ed36291eb73" translate="yes" xml:space="preserve">
          <source>So yeah, since &lt;code&gt;function&lt;/code&gt;s are also &lt;code&gt;Objects&lt;/code&gt; (and in-fact first class variables in Javascript), even functions have methods which are... well, functions themselves.</source>
          <target state="translated">Так что да, поскольку &lt;code&gt;function&lt;/code&gt; s также являются &lt;code&gt;Objects&lt;/code&gt; (и фактически переменными первого класса в Javascript), даже функции имеют методы, которые ... ну, сами функции.</target>
        </trans-unit>
        <trans-unit id="0f3b2a9afffa56a30d094f3e24ed8cf50303768c" translate="yes" xml:space="preserve">
          <source>So, everything else can be described by how it translates into &lt;code&gt;functionObject.call&lt;/code&gt;.</source>
          <target state="translated">Итак, все остальное можно описать тем, как оно переводится в &lt;code&gt;functionObject.call&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="790a624bffefadda17b70c21c4b01c0c58df0ee7" translate="yes" xml:space="preserve">
          <source>So, just like the rules above</source>
          <target state="translated">Итак,так же,как и вышеприведенные правила</target>
        </trans-unit>
        <trans-unit id="914ff3d89be46de1e5d463f23bd9e8ec17bc3b6b" translate="yes" xml:space="preserve">
          <source>So, that's the same behavior as:</source>
          <target state="translated">Значит,это то же самое поведение:</target>
        </trans-unit>
        <trans-unit id="3752107636af96b291a982ec3e8aba9fd5bc3976" translate="yes" xml:space="preserve">
          <source>Sometimes, you don't like the fact that &lt;code&gt;this&lt;/code&gt; changes with scope, especially nested scope. Take a look at the following example.</source>
          <target state="translated">Иногда вам не нравится тот факт, что &lt;code&gt;this&lt;/code&gt; меняется с областью действия, особенно с вложенной областью действия. Посмотрите на следующий пример.</target>
        </trans-unit>
        <trans-unit id="3dcb878280db0a0ee997fedf6a06a9e25d983362" translate="yes" xml:space="preserve">
          <source>Summary &lt;code&gt;this&lt;/code&gt; Javascript:</source>
          <target state="translated">Резюме &lt;code&gt;this&lt;/code&gt; Javascript:</target>
        </trans-unit>
        <trans-unit id="870ae78c66193024be4337db8b9c61bdcf897d92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.&lt;/code&gt; operator when used with a function on the right and an object on the left effectively means &quot;pass object as &lt;code&gt;this&lt;/code&gt; to function.</source>
          <target state="translated">&lt;code&gt;.&lt;/code&gt; Оператор, когда используется с функцией справа и объектом слева, фактически означает &amp;laquo;передать объект как &lt;code&gt;this&lt;/code&gt; функция&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="5dc19a793d0ce3f7b84a548e2b6a4dbb98f0fbaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; ключевое слово</target>
        </trans-unit>
        <trans-unit id="5c7d3a19cb8b6bc930a3cf143fd794ae8cdebd95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; keyword behaves differently in JavaScript compared to other languages. In Object Oriented languages, the &lt;code&gt;this&lt;/code&gt; keyword refers to the current instance of the class. In JavaScript the value of &lt;code&gt;this&lt;/code&gt; is determined by the invocation context of function (&lt;em&gt;&lt;code&gt;context.function()&lt;/code&gt;&lt;/em&gt;) and where it is called.</source>
          <target state="translated">Ключевое слово &lt;code&gt;this&lt;/code&gt; ведет себя по-разному в JavaScript по сравнению с другими языками. В объектно-ориентированных языках ключевое слово &lt;code&gt;this&lt;/code&gt; ссылается на текущий экземпляр класса. В JavaScript значение &lt;code&gt;this&lt;/code&gt; определяется контекстом вызова функции ( &lt;em&gt; &lt;code&gt;context.function()&lt;/code&gt; &lt;/em&gt; ) и местом ее вызова.</target>
        </trans-unit>
        <trans-unit id="8118d827d29ceed5b5f484813a32a7dbdecf8a1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; keyword evaluates to the value of the ThisBinding of the current execution context</source>
          <target state="translated">Ключевое слово &lt;code&gt;this&lt;/code&gt; оценивается как значение ThisBinding текущего контекста выполнения.</target>
        </trans-unit>
        <trans-unit id="21236dd5251fb6c854cd82db5d7b667a4cfa5baa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; keyword is &lt;a href=&quot;http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/#When_this_is_most_misunderstood_and_becomes_tricky&quot;&gt;most misunderstood&lt;/a&gt; when: 1) we borrow a method that uses &lt;code&gt;this&lt;/code&gt;, 2) we assign a method that uses &lt;code&gt;this&lt;/code&gt; to a variable, 3) a function that uses &lt;code&gt;this&lt;/code&gt; is passed as a callback function, and 4) &lt;code&gt;this&lt;/code&gt; is used inside a closure &amp;mdash; an inner function. &lt;sup&gt;(2)&lt;/sup&gt;</source>
          <target state="translated">Ключевое слово &lt;code&gt;this&lt;/code&gt; &lt;a href=&quot;http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/#When_this_is_most_misunderstood_and_becomes_tricky&quot;&gt;наиболее неправильно понято,&lt;/a&gt; когда: 1) мы заимствуем метод, который использует &lt;code&gt;this&lt;/code&gt; , 2) мы назначаем метод, который использует &lt;code&gt;this&lt;/code&gt; для переменной, 3) функция, которая использует &lt;code&gt;this&lt;/code&gt; , передается как функция обратного вызова, и 4) &lt;code&gt;this&lt;/code&gt; используется внутри замыкания - внутренняя функция. &lt;sup&gt;(2)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0273a69ad15752e42d17d46c263b491390395350" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;this&lt;/em&gt; reference ALWAYS refers to (and holds the value of) an
  object&amp;mdash;a singular object&amp;mdash;and it is usually used inside a function or a
  method, although it can be used outside a function in the global
  scope. Note that when we use strict mode, this holds the value of
  undefined in global functions and in anonymous functions that are not
  bound to any object.</source>
          <target state="translated">Эта ссылка ВСЕГДА ссылается (и содержит значение) на объект - единственный объект - и обычно используется внутри функции или метода, хотя может использоваться и вне функции в глобальной области видимости. Обратите внимание, что когда мы используем строгий режим, он содержит значение undefined в глобальных функциях и в анонимных функциях, которые не связаны ни с одним объектом.</target>
        </trans-unit>
        <trans-unit id="0bfa8fcb62a7f1e00d91e50841a62afe63da5f55" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; in above examples refer to &quot;button&quot; element and the
&quot;div&quot; element respectively.</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;This&amp;raquo;&lt;/strong&gt; в вышеприведенных примерах относится к элементу &amp;laquo;button&amp;raquo; и элементу &amp;laquo;div&amp;raquo; соответственно.</target>
        </trans-unit>
        <trans-unit id="f95de8ec5b813d1517bdbcb77f6c0c1a7fb9c6c1" translate="yes" xml:space="preserve">
          <source>The above code clearly shows that the &quot;this&quot; value for any &quot;NON
Bound Function&quot; can be altered through &lt;strong&gt;call/apply&lt;/strong&gt;. Also,if the
&lt;strong&gt;&quot;this&quot;&lt;/strong&gt; parameter is  not explicitly passed to &lt;strong&gt;call/apply&lt;/strong&gt;, &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; (and hence the value of &quot;this&quot;) is set to &lt;strong&gt;&quot;window&quot;&lt;/strong&gt; in Non strict mode and &lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; in strict mode.</source>
          <target state="translated">Приведенный выше код ясно показывает, что значение &amp;laquo;this&amp;raquo; для любой &amp;laquo;NON Bound Function&amp;raquo; может быть изменено с помощью &lt;strong&gt;call / apply&lt;/strong&gt; . Кроме того, если параметр &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; явно не передан в &lt;strong&gt;call / apply&lt;/strong&gt; , &lt;strong&gt;&amp;laquo;текущий объект&amp;raquo;&lt;/strong&gt; (и, следовательно, значение &amp;laquo;this&amp;raquo;) устанавливается в &lt;strong&gt;&amp;laquo;window&amp;raquo;&lt;/strong&gt; в нестрогом режиме и &lt;strong&gt;&amp;laquo;undefined&amp;raquo;&lt;/strong&gt; в строгом режиме.</target>
        </trans-unit>
        <trans-unit id="c6c331ad3ba8cbd437f9af0ab0775ebb81b757f7" translate="yes" xml:space="preserve">
          <source>The code above translates to</source>
          <target state="translated">Приведенный выше код транслируется в</target>
        </trans-unit>
        <trans-unit id="48a4deba793f1321a1d058e028490a18d81f4854" translate="yes" xml:space="preserve">
          <source>The constructor of this &lt;code&gt;Object&lt;/code&gt; has its constructor set to &lt;code&gt;Person&lt;/code&gt;. Also, note that &lt;code&gt;typeof awal&lt;/code&gt; would return &lt;code&gt;Object&lt;/code&gt; only.</source>
          <target state="translated">Конструктор этого &lt;code&gt;Object&lt;/code&gt; имеет конструктор &lt;code&gt;Person&lt;/code&gt; . Также обратите внимание, что &lt;code&gt;typeof awal&lt;/code&gt; будет возвращать только &lt;code&gt;Object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="598e31c8f2d3b5ebb3d9a975927bac31dd78c17d" translate="yes" xml:space="preserve">
          <source>The following describes each of this contexts one by one:</source>
          <target state="translated">Ниже поочередно описывается каждый из этих контекстов:</target>
        </trans-unit>
        <trans-unit id="5ffc86b9fbcb86bd5ce90c80ade9aac7f6674126" translate="yes" xml:space="preserve">
          <source>The following summarizes the entire article</source>
          <target state="translated">Ниже кратко излагается вся статья</target>
        </trans-unit>
        <trans-unit id="b9c4aa48554b8690755f430230adc7aead0e4875" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;Person&lt;/code&gt; itself is now invoked; &lt;code&gt;this&lt;/code&gt; being a reference to the newly constructed object &lt;code&gt;awal&lt;/code&gt;.</source>
          <target state="translated">Теперь вызывается сама функция &lt;code&gt;Person&lt;/code&gt; ; &lt;code&gt;this&lt;/code&gt; ссылка на недавно построенный объект &lt;code&gt;awal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d26b585e0f11b2474001731ad046d99b221862ac" translate="yes" xml:space="preserve">
          <source>The idea behind &lt;code&gt;this&lt;/code&gt; is to understand that the function invocation types have the significant importance on setting &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="translated">Идея заключается в том, чтобы понять, что типы вызова функций имеют большое значение при установке &lt;code&gt;this&lt;/code&gt; значения.</target>
        </trans-unit>
        <trans-unit id="cd9df2dd9475c12d7d70a035ffbc3060e8d9dccf" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;myFun.call(obj);&lt;/code&gt; is invoking the special built-in function &lt;code&gt;Function.prototype.call()&lt;/code&gt;, which accepts &lt;code&gt;thisArg&lt;/code&gt; as the first argument.</source>
          <target state="translated">Строка &lt;code&gt;myFun.call(obj);&lt;/code&gt; вызывает специальную встроенную функцию &lt;code&gt;Function.prototype.call()&lt;/code&gt; , которая принимает &lt;code&gt;thisArg&lt;/code&gt; в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="205b8665ab9d83e5add811cf8bd2f784d1caf68a" translate="yes" xml:space="preserve">
          <source>The reason for writing &quot;in most other cases&quot; is because there are eight ECMAScript 5 built-in functions that allow ThisBinding to be specified in the arguments list. These special functions take a so-called &lt;code&gt;thisArg&lt;/code&gt; which becomes the ThisBinding when calling the function (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.3&quot;&gt;&amp;sect;10.4.3&lt;/a&gt;).</source>
          <target state="translated">Причина написания &amp;laquo;в большинстве других случаев&amp;raquo; заключается в том, что существует восемь встроенных функций ECMAScript 5, которые позволяют указывать ThisBinding в списке аргументов. Эти специальные функции принимают так называемый &lt;code&gt;thisArg&lt;/code&gt; , который становится ThisBinding при вызове функции ( &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.3&quot;&gt;&amp;sect;10.4.3&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a1d54f980faedf5c96fee5c403683ca230e1320f" translate="yes" xml:space="preserve">
          <source>The same above behavior is achieved when we attach the function to the event handler using Microsoft's Event Registration model method &lt;code&gt;attachEvent&lt;/code&gt;. Instead of assigning the function to the event handler (and the thus making the function method of the element), it calls the function on the event (effectively calling it in global context).</source>
          <target state="translated">Такое же поведение выше достигается, когда мы присоединяем функцию к обработчику событий с помощью метода модели регистрации событий Microsoft метод &lt;code&gt;attachEvent&lt;/code&gt; . Вместо того, чтобы назначать функцию обработчику события (и, таким образом, создавать метод функции элемента), она вызывает функцию для события (фактически вызывая ее в глобальном контексте).</target>
        </trans-unit>
        <trans-unit id="f835f6ede39f09721b6b3a08a6766f6a816b4a55" translate="yes" xml:space="preserve">
          <source>The value of &quot;this&quot; depends on the &quot;context&quot; in which the function is executed. The context can be any object or the global object, i.e., window.</source>
          <target state="translated">Значение &quot;this&quot; зависит от &quot;контекста&quot;,в котором выполняется функция.Контекстом может быть любой объект или глобальный объект,т.е.окно.</target>
        </trans-unit>
        <trans-unit id="8f71afcd2f8c39c35d17ede8ea64967e5b3dabc9" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;this&lt;/code&gt; is determined by &lt;strong&gt;how the function is invoked not, where it was created!&lt;/strong&gt;</source>
          <target state="translated">Значение &lt;code&gt;this&lt;/code&gt; определяется тем, &lt;strong&gt;как функция вызывается не там, где она была создана!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85a035ea25fb197d75ddcfad6ad7ecc47bbf83df" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; is fixed for a Bound function and cannot be
overriden by &lt;strong&gt;call&lt;/strong&gt; and &lt;strong&gt;apply&lt;/strong&gt; methods of the function.</source>
          <target state="translated">Значение &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; является фиксированным для функции Bound и не может быть переопределено &lt;strong&gt;вызовом&lt;/strong&gt; и &lt;strong&gt;применением&lt;/strong&gt; методов функции.</target>
        </trans-unit>
        <trans-unit id="732a7262b87dd35272a2fefa011c384eaf4c1806" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; within a Non Bound function can be overriden by
&lt;strong&gt;call&lt;/strong&gt; and &lt;strong&gt;apply&lt;/strong&gt; methods of the function.</source>
          <target state="translated">Значение &lt;strong&gt;this&lt;/strong&gt; в функции Non Bound может быть переопределено &lt;strong&gt;вызовом&lt;/strong&gt; и &lt;strong&gt;применением&lt;/strong&gt; методов функции.</target>
        </trans-unit>
        <trans-unit id="986983b3bc829dee13e4af0f6cd58cc64ea6a541" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; within a Non Bound function is the reference to object in context of which the function is invoked (&lt;strong&gt;&quot;current object&quot;&lt;/strong&gt;)</source>
          <target state="translated">Значение &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; в функции Non Bound является ссылкой на объект, в контексте которого вызывается функция ( &lt;strong&gt;&amp;laquo;текущий объект&amp;raquo;&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="94e5e1e54d6e891723770f7f55f8c8aa368f150f" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; within a constructor is the object that is being
created and initialized</source>
          <target state="translated">Значение &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; в конструкторе - это объект, который создается и инициализируется</target>
        </trans-unit>
        <trans-unit id="5ff56d075173f67c99015d872ca5e48d81c42ed8" translate="yes" xml:space="preserve">
          <source>The value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; within an inline DOM event handler is reference
to the element for which the event handler is given.</source>
          <target state="translated">Значение &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; в встроенном обработчике событий DOM является ссылкой на элемент, для которого предоставляется обработчик события.</target>
        </trans-unit>
        <trans-unit id="23a806a2918ae62d9efe5b8e4d50db0d562119c4" translate="yes" xml:space="preserve">
          <source>There are Four Scenarios where &lt;em&gt;this&lt;/em&gt; can be confusing:</source>
          <target state="translated">Есть четыре сценария, в которых &lt;em&gt;это&lt;/em&gt; может сбить с толку:</target>
        </trans-unit>
        <trans-unit id="e38bf69ca4f13895c35d97268be9b7f0be29ccd7" translate="yes" xml:space="preserve">
          <source>There are different ways to do this. If you have called native methods in Javascript like &lt;code&gt;forEach&lt;/code&gt; and &lt;code&gt;slice&lt;/code&gt;, you should already know that the &lt;code&gt;this&lt;/code&gt; variable in that case refers to the &lt;code&gt;Object&lt;/code&gt; on which you called that function (Note that in javascript, just about everything is an &lt;code&gt;Object&lt;/code&gt;, including &lt;code&gt;Array&lt;/code&gt;s and &lt;code&gt;Function&lt;/code&gt;s). Take the following code for example.</source>
          <target state="translated">Есть разные способы сделать это. Если вы вызывали нативные методы в Javascript, такие как &lt;code&gt;forEach&lt;/code&gt; и &lt;code&gt;slice&lt;/code&gt; , вы уже должны знать, что переменная &lt;code&gt;this&lt;/code&gt; в этом случае относится к &lt;code&gt;Object&lt;/code&gt; для которого вы вызвали эту функцию (обратите внимание, что в javascript практически все является &lt;code&gt;Object&lt;/code&gt; , включая &lt;code&gt;Array&lt;/code&gt; и &lt;code&gt;Function&lt;/code&gt; s). Возьмите следующий код для примера.</target>
        </trans-unit>
        <trans-unit id="279973f865726145d86bc2b948936a3c5ea84f1b" translate="yes" xml:space="preserve">
          <source>There are various ways to define an object's prototype, the most common in 2019 is the &lt;code&gt;class&lt;/code&gt; keyword. For the purposes of &lt;code&gt;this&lt;/code&gt; though it doesn't matter. What matters is that as it looks in object &lt;code&gt;a&lt;/code&gt; for property &lt;code&gt;b&lt;/code&gt; if it finds property &lt;code&gt;b&lt;/code&gt; on the object or in it's prototype chain if &lt;code&gt;b&lt;/code&gt; ends up being a function then the same rules as above apply. The function &lt;code&gt;b&lt;/code&gt; references will be called using the &lt;code&gt;call&lt;/code&gt; method and passing &lt;code&gt;a&lt;/code&gt; as objectForThis as shown a the top of this answer.</source>
          <target state="translated">Существуют различные способы определения прототипа объекта, наиболее распространенным в 2019 году является ключевое слово &lt;code&gt;class&lt;/code&gt; . Для целей &lt;code&gt;this&lt;/code&gt; хотя это не имеет значения. Важно то, что, когда он ищет в объекте &lt;code&gt;a&lt;/code&gt; свойство &lt;code&gt;b&lt;/code&gt; , если находит свойство &lt;code&gt;b&lt;/code&gt; в объекте или в цепочке прототипов, если &lt;code&gt;b&lt;/code&gt; оказывается функцией, то применяются те же правила, что и выше. Ссылки на функцию &lt;code&gt;b&lt;/code&gt; будут вызываться с использованием метода &lt;code&gt;call&lt;/code&gt; и передачи &lt;code&gt;a&lt;/code&gt; в качестве objectForThis, как показано в верхней части этого ответа.</target>
        </trans-unit>
        <trans-unit id="4b176e3b91607484833f86d66ef5e37c3e87f616" translate="yes" xml:space="preserve">
          <source>There is a lot of confusion regarding how &lt;strong&gt;&quot;this&quot;&lt;/strong&gt; keyword is interpreted in JavaScript. Hopefully this article will lay all those to rest once and for all. And a lot more. Please read the entire article carefully. Be forewarned that this article is long.</source>
          <target state="translated">Существует много путаницы в отношении того, как &lt;strong&gt;это&lt;/strong&gt; ключевое слово интерпретируется в JavaScript. Надеемся, что эта статья положит конец всем раз и навсегда. И многое другое. Пожалуйста, внимательно прочитайте всю статью. Будьте предупреждены, что эта статья длинная.</target>
        </trans-unit>
        <trans-unit id="9bf2606f55ac02610bfeca5231ecaa8045e7e025" translate="yes" xml:space="preserve">
          <source>There is always some value supplied for &lt;code&gt;objectForThis&lt;/code&gt;.</source>
          <target state="translated">Для &lt;code&gt;objectForThis&lt;/code&gt; всегда указывается какое-то значение.</target>
        </trans-unit>
        <trans-unit id="6f5b72ee2e27b15caab5b155ad2ccf879983f917" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special case I didn&amp;rsquo;t yet mention. When constructing a new object via the &lt;code&gt;new&lt;/code&gt; operator, the JavaScript interpreter creates a new, empty object, sets some internal properties, and then calls the constructor function on the new object. Thus, when a function is called in a constructor context, the value of &lt;code&gt;this&lt;/code&gt; is the new object that the interpreter created:</source>
          <target state="translated">Есть особый случай, о котором я еще не упомянул. При создании нового объекта с помощью оператора &lt;code&gt;new&lt;/code&gt; интерпретатор JavaScript создает новый пустой объект, устанавливает некоторые внутренние свойства и затем вызывает функцию конструктора для нового объекта. Таким образом, когда функция вызывается в контексте конструктора, значением &lt;code&gt;this&lt;/code&gt; является новый объект, созданный интерпретатором:</target>
        </trans-unit>
        <trans-unit id="2d3a18e72bf0f045f8f3de4d4504d75c62e5dcda" translate="yes" xml:space="preserve">
          <source>These methods allows to write a function once and invoke it in different context. In other words, they allows to specify the value of &lt;code&gt;this&lt;/code&gt; which will be used while the function is being executed. They also take any parameters to be passed to the original function when it is invoked.</source>
          <target state="translated">Эти методы позволяют написать функцию один раз и вызвать ее в другом контексте. Другими словами, они позволяют указать значение &lt;code&gt;this&lt;/code&gt; которое будет использоваться во время выполнения функции. Они также принимают любые параметры, которые должны быть переданы исходной функции при ее вызове.</target>
        </trans-unit>
        <trans-unit id="4ade0a7126aef80885995d3c6e7d2a3b5b9a749a" translate="yes" xml:space="preserve">
          <source>These special built-in functions are:</source>
          <target state="translated">Эти специальные встроенные функции:</target>
        </trans-unit>
        <trans-unit id="85527d5006265cfde99894b7c55c9fb14d1c3dc8" translate="yes" xml:space="preserve">
          <source>This is a typical example of using &lt;code&gt;call&lt;/code&gt;. It basically takes the first parameter and sets &lt;code&gt;this&lt;/code&gt; in the function &lt;code&gt;foo&lt;/code&gt; as a reference to &lt;code&gt;thisArg&lt;/code&gt;.  All other parameters passed to &lt;code&gt;call&lt;/code&gt; is passed to the function &lt;code&gt;foo&lt;/code&gt; as arguments.</source>
          <target state="translated">Это типичный пример использования &lt;code&gt;call&lt;/code&gt; . Он в основном принимает первый параметр и устанавливает &lt;code&gt;this&lt;/code&gt; в функции &lt;code&gt;foo&lt;/code&gt; как ссылку на &lt;code&gt;thisArg&lt;/code&gt; . Все остальные параметры, передаваемые для &lt;code&gt;call&lt;/code&gt; , передаются функции &lt;code&gt;foo&lt;/code&gt; в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="29ed5f10284269291bb711c4ff11d342e2767871" translate="yes" xml:space="preserve">
          <source>This is different from Python, in which accessing a method (&lt;code&gt;obj.myMethod&lt;/code&gt;) creates a &lt;a href=&quot;http://docs.python.org/3/library/stdtypes.html#methods&quot;&gt;bound method object&lt;/a&gt;.</source>
          <target state="translated">Это отличается от Python, в котором доступ к методу ( &lt;code&gt;obj.myMethod&lt;/code&gt; ) создает &lt;a href=&quot;http://docs.python.org/3/library/stdtypes.html#methods&quot;&gt;связанный объект метода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a132674b519e683c1c771b823eb5a1e2de6af493" translate="yes" xml:space="preserve">
          <source>This is the best explanation I've seen: &lt;a href=&quot;http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/&quot;&gt;Understand JavaScripts &lt;em&gt;this&lt;/em&gt; with Clarity&lt;/a&gt;</source>
          <target state="translated">Это лучшее объяснение, которое я видел: &lt;a href=&quot;http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/&quot;&gt;понять JavaScripts &lt;em&gt;это&lt;/em&gt; с Clarity&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b0808c58b0591e7278bd423057d577254441336b" translate="yes" xml:space="preserve">
          <source>This is the case for JavaScript code that is evaluated at the top-level, e.g. when directly inside a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Это касается кода JavaScript, который оценивается на верхнем уровне, например, когда он находится непосредственно внутри &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="802391aac07cdb035195e6978ec32a12d3125ef9" translate="yes" xml:space="preserve">
          <source>This is what both &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;=&amp;gt;&lt;/code&gt; functions effectively do. They are more syntactic sugar. They effectively build a new invisible function exactly like &lt;code&gt;bar&lt;/code&gt; above that explicitly sets &lt;code&gt;this&lt;/code&gt; before it calls whatever function is specified. In the case of bind &lt;code&gt;this&lt;/code&gt; is set to whatever you pass to &lt;code&gt;bind&lt;/code&gt;.</source>
          <target state="translated">Это то, что эффективно выполняют функции &lt;code&gt;bind&lt;/code&gt; и &lt;code&gt;=&amp;gt;&lt;/code&gt; . Они более синтаксические сахара. Они эффективно создают новую невидимую функцию в точности как вышеупомянутая &lt;code&gt;bar&lt;/code&gt; которая явно устанавливает &lt;code&gt;this&lt;/code&gt; прежде чем она вызовет любую указанную функцию. В случае связывания &lt;code&gt;this&lt;/code&gt; установлено на то, что вы передаете &lt;code&gt;bind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f377690fefdec48899ec0d15066da36044d96e2" translate="yes" xml:space="preserve">
          <source>This mindset is correct when dealing with &lt;code&gt;this&lt;/code&gt; and will save you from headache.</source>
          <target state="translated">Такое мышление является правильным при работе с &lt;code&gt;this&lt;/code&gt; и избавит вас от головной боли.</target>
        </trans-unit>
        <trans-unit id="fe922a11381e67c113153def83bf53886fc17c59" translate="yes" xml:space="preserve">
          <source>This new &lt;code&gt;Object&lt;/code&gt; would be assigned the prototype of &lt;code&gt;Person.prototype&lt;/code&gt;. This means that any method or property in the &lt;code&gt;Person&lt;/code&gt; prototype would be available to all instances of &lt;code&gt;Person&lt;/code&gt;, including &lt;code&gt;awal&lt;/code&gt;.</source>
          <target state="translated">Этому новому &lt;code&gt;Object&lt;/code&gt; будет присвоен прототип &lt;code&gt;Person.prototype&lt;/code&gt; . Это означает, что любой метод или свойство в прототипе &lt;code&gt;Person&lt;/code&gt; будет доступно для всех экземпляров &lt;code&gt;Person&lt;/code&gt; , включая &lt;code&gt;awal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8390b31573bde1e5e11596eda14bd9837b0066dd" translate="yes" xml:space="preserve">
          <source>This occurs when calling a function. If a function is called on an object, such as in &lt;code&gt;obj.myMethod()&lt;/code&gt; or the equivalent &lt;code&gt;obj[&quot;myMethod&quot;]()&lt;/code&gt;, then ThisBinding is set to the object (&lt;code&gt;obj&lt;/code&gt; in the example; &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-13.2.1&quot;&gt;&amp;sect;13.2.1&lt;/a&gt;). In most other cases, ThisBinding is set to the global object (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.3&quot;&gt;&amp;sect;10.4.3&lt;/a&gt;).</source>
          <target state="translated">Это происходит при вызове функции. Если функция вызывается для объекта, например, в &lt;code&gt;obj.myMethod()&lt;/code&gt; или эквивалентном &lt;code&gt;obj[&quot;myMethod&quot;]()&lt;/code&gt; , тогда ThisBinding устанавливается на объект ( &lt;code&gt;obj&lt;/code&gt; в примере; &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-13.2.1&quot;&gt;&amp;sect;13.2.1&lt;/a&gt; ). В большинстве других случаев ThisBinding устанавливается на глобальный объект ( &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.3&quot;&gt;&amp;sect;10.4.3&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="31e21fd5682329c65723d9fdb2afb15437924824" translate="yes" xml:space="preserve">
          <source>This one was tricky. When evaluating the eval code, &lt;code&gt;this&lt;/code&gt; is &lt;code&gt;obj&lt;/code&gt;. However, in the eval code, &lt;code&gt;myFun&lt;/code&gt; is not called on an object, so ThisBinding is set to &lt;code&gt;window&lt;/code&gt; for the call.</source>
          <target state="translated">Этот был хитрым. При оценке eval-кода &lt;code&gt;this&lt;/code&gt; &lt;code&gt;obj&lt;/code&gt; . Однако в eval-коде &lt;code&gt;myFun&lt;/code&gt; не вызывается для объекта, поэтому ThisBinding установлен в &lt;code&gt;window&lt;/code&gt; для вызова.</target>
        </trans-unit>
        <trans-unit id="906f21f1345827c9f5f29e264d69b70a0a4c77a2" translate="yes" xml:space="preserve">
          <source>ThisBinding is set to the global object &lt;em&gt;as if&lt;/em&gt; executing in the initial global execution context (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;&amp;sect;10.4.2&lt;/a&gt; (1)).</source>
          <target state="translated">ThisBinding устанавливается для глобального объекта, &lt;em&gt;как если бы он&lt;/em&gt; выполнялся в начальном глобальном контексте выполнения ( &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;&amp;sect;10.4.2&lt;/a&gt; (1)).</target>
        </trans-unit>
        <trans-unit id="05a9ff5b30e366baba755d7af02bdee90564da08" translate="yes" xml:space="preserve">
          <source>ThisBinding is something that the JavaScript interpreter maintains as it evaluates JavaScript code, like a special CPU register which holds a reference to an object. The interpreter updates the ThisBinding whenever establishing an execution context in one of only three different cases:</source>
          <target state="translated">ThisBinding-это то,что JavaScript-интерпретатор поддерживает,так как он оценивает JavaScript-код,например,специальный регистр процессора,который содержит ссылку на объект.Интерпретатор обновляет ThisBinding всякий раз,когда устанавливает контекст выполнения в одном из трёх различных случаев:</target>
        </trans-unit>
        <trans-unit id="99dd9cee0f0141c71707204de7a8eb68227dcb58" translate="yes" xml:space="preserve">
          <source>Those are the rules for plain JavaScript. When you begin using JavaScript libraries (e.g. jQuery), you may find that certain library functions manipulate the value of &lt;code&gt;this&lt;/code&gt;. The developers of those JavaScript libraries do this because it tends to support the most common use cases, and users of the library typically find this behavior to be more convenient. When passing callback functions referencing &lt;code&gt;this&lt;/code&gt; to library functions, you should refer to the documentation for any guarantees about what the value of &lt;code&gt;this&lt;/code&gt; is when the function is called.</source>
          <target state="translated">Это правила для простого JavaScript. Когда вы начинаете использовать библиотеки JavaScript (например, jQuery), вы можете обнаружить, что некоторые библиотечные функции манипулируют значением &lt;code&gt;this&lt;/code&gt; . Разработчики этих библиотек JavaScript делают это, потому что это имеет тенденцию поддерживать наиболее распространенные варианты использования, и пользователи библиотеки обычно считают такое поведение более удобным. При передаче функций обратного вызова, ссылающихся на &lt;code&gt;this&lt;/code&gt; библиотечным функциям, вы должны ссылаться на документацию для любых гарантий того, каково значение &lt;code&gt;this&lt;/code&gt; при вызове функции.</target>
        </trans-unit>
        <trans-unit id="e2e075f690095f8a07098f5032ffef152a676d5a" translate="yes" xml:space="preserve">
          <source>Try it out; you'll begin to like this pattern of programming</source>
          <target state="translated">Попробуй,тебе начнет нравиться этот паттерн программирования.</target>
        </trans-unit>
        <trans-unit id="b31340518b4d3450382a16fe42d7b550a535da55" translate="yes" xml:space="preserve">
          <source>Unless you &lt;code&gt;bind&lt;/code&gt; the context</source>
          <target state="translated">Если вы не &lt;code&gt;bind&lt;/code&gt; контекст</target>
        </trans-unit>
        <trans-unit id="44c1de29d488c2efbb55dbbf89180707d408e09f" translate="yes" xml:space="preserve">
          <source>Use of &lt;em&gt;bind&lt;/em&gt;</source>
          <target state="translated">Использование &lt;em&gt;связывания&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="130803684886f32a73870ec3182481aa18a857a0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;bind&lt;/code&gt;.</source>
          <target state="translated">Используя &lt;code&gt;bind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9f1a654f7867f9709c86fb54556d6b1085312f6" translate="yes" xml:space="preserve">
          <source>Usually the value of &lt;code&gt;this&lt;/code&gt; is determined by the Object which is left of the dot. (&lt;code&gt;window&lt;/code&gt; in global space)</source>
          <target state="translated">Обычно значение &lt;code&gt;this&lt;/code&gt; определяется объектом, который находится слева от точки. ( &lt;code&gt;window&lt;/code&gt; в глобальном пространстве)</target>
        </trans-unit>
        <trans-unit id="3fe0e54dcbb7644fba3d3f361c514bd846e8caf6" translate="yes" xml:space="preserve">
          <source>We can try above points with functions too. However there are some differences.</source>
          <target state="translated">Можно попробовать и выше с функциями.Однако есть некоторые отличия.</target>
        </trans-unit>
        <trans-unit id="02ee79a3f4e52fa8dc6015c8800e56de11fbd2ff" translate="yes" xml:space="preserve">
          <source>We use this similar to the way we use pronouns in natural languages like English:  &amp;ldquo;John is running fast because &lt;strong&gt;&lt;em&gt;he&lt;/em&gt;&lt;/strong&gt; is trying to catch the train.&amp;rdquo; Instead we could have written &amp;ldquo;&amp;hellip; &lt;strong&gt;&lt;em&gt;John&lt;/em&gt;&lt;/strong&gt; is trying to catch the train&amp;rdquo;.</source>
          <target state="translated">Мы используем это подобно тому, как мы используем местоимения на естественных языках, таких как английский: &amp;laquo;Джон быстро бегает, потому &lt;strong&gt;&lt;em&gt;что&lt;/em&gt;&lt;/strong&gt; пытается сесть на поезд&amp;raquo;. Вместо этого мы могли бы написать &amp;laquo;&amp;hellip; &lt;strong&gt;&lt;em&gt;Джон&lt;/em&gt;&lt;/strong&gt; пытается сесть на поезд&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="59c84c3a56d40f1298569aad07647b4063c6d313" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;var that = this&lt;/code&gt; means in JavaScript</source>
          <target state="translated">Что такое &lt;code&gt;var that = this&lt;/code&gt; означает в JavaScript</target>
        </trans-unit>
        <trans-unit id="d6960afa81986e4b8866c2cd069e74c4a085e98a" translate="yes" xml:space="preserve">
          <source>What holds the future</source>
          <target state="translated">Что удерживает будущее</target>
        </trans-unit>
        <trans-unit id="8522002fd86f4ae1d009f9373919bcfac6e5aa3c" translate="yes" xml:space="preserve">
          <source>What if we call the function as a method with Object-dot notation?</source>
          <target state="translated">Что,если мы вызовем функцию как метод с нотацией &quot;Точка объекта&quot;?</target>
        </trans-unit>
        <trans-unit id="e90a818f0c0f181348f3ffa33436750e9c56414d" translate="yes" xml:space="preserve">
          <source>What if we use the &lt;code&gt;new&lt;/code&gt; keyword?</source>
          <target state="translated">Что если мы используем &lt;code&gt;new&lt;/code&gt; ключевое слово?</target>
        </trans-unit>
        <trans-unit id="0b741f1c36a30a2f39adb4807b11baf832686d62" translate="yes" xml:space="preserve">
          <source>What is held in &lt;code&gt;this&lt;/code&gt; by default?</source>
          <target state="translated">Что в &lt;code&gt;this&lt;/code&gt; содержится по умолчанию?</target>
        </trans-unit>
        <trans-unit id="f31de30789ea80d6b68979bdfc23922eb652ecfe" translate="yes" xml:space="preserve">
          <source>What is the value of &lt;code&gt;this&lt;/code&gt; at the marked line when &lt;code&gt;obj.staticFunction()&lt;/code&gt; is executed? Why?</source>
          <target state="translated">Каково значение &lt;code&gt;this&lt;/code&gt; в отмеченной строке при выполнении &lt;code&gt;obj.staticFunction()&lt;/code&gt; ? Почему?</target>
        </trans-unit>
        <trans-unit id="19602fe263ba02a9e70190487cdbb1f5d8295602" translate="yes" xml:space="preserve">
          <source>What is the value of &lt;code&gt;this&lt;/code&gt; at the marked line? Why?</source>
          <target state="translated">Какова ценность &lt;code&gt;this&lt;/code&gt; в отмеченной линии? Почему?</target>
        </trans-unit>
        <trans-unit id="10b02218e944261b661613e959beb9dc45a0a0c1" translate="yes" xml:space="preserve">
          <source>What value has &lt;code&gt;this&lt;/code&gt; where the arrow function is &lt;em&gt;defined&lt;/em&gt;?</source>
          <target state="translated">Какое значение имеет &lt;code&gt;this&lt;/code&gt; где определяется функция стрелки?</target>
        </trans-unit>
        <trans-unit id="e78621a0c74b5518e2c62eeba51b08b351f0dc5e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use strict&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; in global and in anonymous functions that are not bound to any object holds a value of &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;use strict&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt; в глобальных и в анонимных функциях, которые не связаны ни с одним объектом, имеет значение &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7834bcbc1ad278f4ac5802fab1061efa51a8ede7" translate="yes" xml:space="preserve">
          <source>When a &lt;strong&gt;&quot;Non Bound Function&quot;&lt;/strong&gt; is called through
&lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;functionName.apply&lt;/em&gt;&lt;/strong&gt;, the &lt;strong&gt;&quot;current object&quot;&lt;/strong&gt; (and hence the value of &lt;strong&gt;&quot;this&quot;&lt;/strong&gt;) is set to the value of
&lt;strong&gt;&quot;this&quot;&lt;/strong&gt; parameter (first parameter) passed to &lt;strong&gt;call/apply&lt;/strong&gt;. The following code demonstrates the same.</source>
          <target state="translated">Когда &lt;strong&gt;&amp;laquo;Non Bound Function&amp;raquo;&lt;/strong&gt; вызывается через &lt;strong&gt;&lt;em&gt;functionName.call&lt;/em&gt;&lt;/strong&gt; или &lt;strong&gt;&lt;em&gt;functionName.apply&lt;/em&gt;&lt;/strong&gt; , &lt;strong&gt;&amp;laquo;текущий объект&amp;raquo;&lt;/strong&gt; (и, следовательно, значение &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; ) устанавливается равным значению параметра &lt;strong&gt;&amp;laquo;this&amp;raquo;&lt;/strong&gt; (первого параметра), передаваемого для &lt;strong&gt;вызова / применить&lt;/strong&gt; . Следующий код демонстрирует то же самое.</target>
        </trans-unit>
        <trans-unit id="51ee7e3f1872cc53a0ea74134a7dcd791782c6b5" translate="yes" xml:space="preserve">
          <source>When a method which relies on &lt;em&gt;this&lt;/em&gt; is assigned to a variable across contexts, in which case &lt;em&gt;this&lt;/em&gt; references another object than originally intended.</source>
          <target state="translated">Когда метод, основанный на &lt;em&gt;этом&lt;/em&gt; , назначается переменной в разных контекстах, в этом случае &lt;em&gt;он&lt;/em&gt; ссылается на другой объект, чем первоначально предполагалось.</target>
        </trans-unit>
        <trans-unit id="c21e1c0cd6eaa7a56b15d8a8d9f7696b5ea3ba0b" translate="yes" xml:space="preserve">
          <source>When adding event handler through JavaScript, &lt;code&gt;this&lt;/code&gt; refers to DOM element that generated the event.</source>
          <target state="translated">При добавлении обработчика событий через JavaScript &lt;code&gt;this&lt;/code&gt; относится к элементу DOM, который сгенерировал событие.</target>
        </trans-unit>
        <trans-unit id="f9cdfe0773a82ce634e71531211148636519905c" translate="yes" xml:space="preserve">
          <source>When evaluating code in the initial global execution context, ThisBinding is set to the global object, &lt;code&gt;window&lt;/code&gt; (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.1.1&quot;&gt;&amp;sect;10.4.1.1&lt;/a&gt;).</source>
          <target state="translated">При оценке кода в начальном глобальном контексте выполнения ThisBinding устанавливается на глобальный объект, &lt;code&gt;window&lt;/code&gt; ( &lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-10.4.1.1&quot;&gt;&amp;sect;10.4.1.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a6a1241496a32c546213391c9684a37c3f770157" translate="yes" xml:space="preserve">
          <source>When having troubles identifying &lt;code&gt;this&lt;/code&gt;, &lt;strong&gt;do not&lt;/strong&gt; ask yourself:</source>
          <target state="translated">Если возникают проблемы с выявлением &lt;code&gt;this&lt;/code&gt; , &lt;strong&gt;не&lt;/strong&gt; спрашивайте себя:</target>
        </trans-unit>
        <trans-unit id="21c5f0557070fcbb938fbc68a83481429de1ab57" translate="yes" xml:space="preserve">
          <source>When in function is called with the &lt;code&gt;new&lt;/code&gt; keyword the value of &lt;code&gt;this&lt;/code&gt; refers to the newly created object</source>
          <target state="translated">Когда в функции вызывается с &lt;code&gt;new&lt;/code&gt; ключевым словом, значение &lt;code&gt;this&lt;/code&gt; относится к вновь созданному объекту</target>
        </trans-unit>
        <trans-unit id="72b6f37ac72430df1d8593cb30420726f4ef738c" translate="yes" xml:space="preserve">
          <source>When line1 is executed, JavaScript establishes an execution context (EC) for the function call, setting &lt;code&gt;this&lt;/code&gt; to the &lt;strong&gt;object referenced by whatever came before the last &quot;.&quot;&lt;/strong&gt;. so in the last line you can understand that &lt;code&gt;a()&lt;/code&gt; was executed in the global context which is the &lt;code&gt;window&lt;/code&gt;.</source>
          <target state="translated">Когда line1 выполняется, JavaScript устанавливает контекст выполнения (EC) для вызова функции, устанавливая &lt;code&gt;this&lt;/code&gt; для &lt;strong&gt;объекта, на который ссылается то, что предшествовало последнему &amp;laquo;.&amp;raquo;&lt;/strong&gt; , поэтому в последней строке вы можете понять, что &lt;code&gt;a()&lt;/code&gt; был выполнен в глобальном контексте, который является &lt;code&gt;window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d92af4bea245247c6b438883984c33bed622ea0a" translate="yes" xml:space="preserve">
          <source>When new &lt;code&gt;Person()&lt;/code&gt; is executed, a completely new object is created. &lt;code&gt;Person&lt;/code&gt; is called and its &lt;code&gt;this&lt;/code&gt; is set to reference that new object.</source>
          <target state="translated">Когда выполняется новая &lt;code&gt;Person()&lt;/code&gt; , создается совершенно новый объект. &lt;code&gt;Person&lt;/code&gt; и его &lt;code&gt;this&lt;/code&gt; устанавливается для ссылки на этот новый объект.</target>
        </trans-unit>
        <trans-unit id="306c3e489768ae032ad521b39781632f59757922" translate="yes" xml:space="preserve">
          <source>When running in a browser, the value of &lt;code&gt;this&lt;/code&gt; would be logged as &lt;code&gt;window&lt;/code&gt;. This is because &lt;code&gt;window&lt;/code&gt; is the global variable in a web browser's scope.</source>
          <target state="translated">При запуске в браузере значение &lt;code&gt;this&lt;/code&gt; будет записано как &lt;code&gt;window&lt;/code&gt; . Это потому, что &lt;code&gt;window&lt;/code&gt; является глобальной переменной в области видимости веб-браузера.</target>
        </trans-unit>
        <trans-unit id="c446d142725f86e5cae11afca3f3dc6b1b2b729d" translate="yes" xml:space="preserve">
          <source>When the function is used as a constructor (that is when it is called with &lt;code&gt;new&lt;/code&gt; keyword), &lt;code&gt;this&lt;/code&gt; inside function body points to the new object being constructed.</source>
          <target state="translated">Когда функция используется в качестве конструктора (то есть когда она вызывается с &lt;code&gt;new&lt;/code&gt; ключевым словом), &lt;code&gt;this&lt;/code&gt; внутреннее тело функции указывает на конструируемый новый объект.</target>
        </trans-unit>
        <trans-unit id="9363e1921613ca1efc56fe00d3f9bed0e7ff0634" translate="yes" xml:space="preserve">
          <source>When using &lt;em&gt;this&lt;/em&gt; along with the bind, apply, and call methods.</source>
          <target state="translated">При использовании &lt;em&gt;этого&lt;/em&gt; вместе с привязкой, применением и вызовом методов.</target>
        </trans-unit>
        <trans-unit id="3f06c3fcab4e5f6d63f2ca2b14de2f0e5c884eca" translate="yes" xml:space="preserve">
          <source>When we pass a method (that uses &lt;em&gt;this&lt;/em&gt;) as an argument to be used as a callback function.</source>
          <target state="translated">Когда мы передаем метод (который использует &lt;em&gt;это&lt;/em&gt; ) в качестве аргумента для использования в качестве функции обратного вызова.</target>
        </trans-unit>
        <trans-unit id="90f8c4932f81072077b5e29262c1cb9a5e197bac" translate="yes" xml:space="preserve">
          <source>When we use an inner function (a closure). It is important to take note that closures cannot access the outer function&amp;rsquo;s &lt;em&gt;this&lt;/em&gt; variable by using the this keyword because the this variable is accessible only by the function itself, not by inner functions.</source>
          <target state="translated">Когда мы используем внутреннюю функцию (замыкание). Важно отметить, что замыкания не могут получить доступ к переменной &lt;em&gt;this&lt;/em&gt; внешней функции с помощью ключевого слова this, потому что переменная this доступна только самой функции, а не внутренним функциям.</target>
        </trans-unit>
        <trans-unit id="53aef58f636acbf9068698d4996ade0921bbfa2d" translate="yes" xml:space="preserve">
          <source>When you assign function directly to event handlers of an element, use of &lt;code&gt;this&lt;/code&gt; directly inside event handling function refers to the corresponding element. Such direct function assignment can be done using &lt;code&gt;addeventListener&lt;/code&gt; method or through the traditional event registration methods like &lt;code&gt;onclick&lt;/code&gt;.</source>
          <target state="translated">Когда вы назначаете функцию непосредственно обработчикам событий элемента, использование &lt;code&gt;this&lt;/code&gt; непосредственно внутри функции обработки событий относится к соответствующему элементу. Такое прямое назначение функции может быть выполнено с использованием метода &lt;code&gt;addeventListener&lt;/code&gt; или с помощью традиционных методов регистрации событий, таких как &lt;code&gt;onclick&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="baae7a28429ffc8ffa19c066579bec164fbe4c42" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;this&lt;/code&gt; in global context, it is bound to global object (&lt;code&gt;window&lt;/code&gt; in browser)</source>
          <target state="translated">Когда вы используете &lt;code&gt;this&lt;/code&gt; в глобальном контексте, это связано с глобальным объектом ( &lt;code&gt;window&lt;/code&gt; в браузере)</target>
        </trans-unit>
        <trans-unit id="2cd00de08c1b80d16d90bbb50289443efdf1c856" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;this&lt;/code&gt; inside a function defined in the global context, &lt;code&gt;this&lt;/code&gt; is still bound to global object since the function is actually made a method of global context.</source>
          <target state="translated">Когда вы используете &lt;code&gt;this&lt;/code&gt; внутри функции, определенной в глобальном контексте, &lt;code&gt;this&lt;/code&gt; все еще привязано к глобальному объекту, поскольку функция фактически сделана методом глобального контекста.</target>
        </trans-unit>
        <trans-unit id="8d179ffca69128a51c69505a9563d82ba3e8c1a4" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;this&lt;/code&gt; inside function that is invoked without any context (i.e. not on any object), it is bound to the global object (&lt;code&gt;window&lt;/code&gt; in browser)(even if the function is defined inside the object) .</source>
          <target state="translated">Когда вы используете &lt;code&gt;this&lt;/code&gt; внутреннюю функцию, которая вызывается без какого-либо контекста (т.е. не для какого-либо объекта), она привязывается к глобальному объекту ( &lt;code&gt;window&lt;/code&gt; в браузере) (даже если функция определена внутри объекта).</target>
        </trans-unit>
        <trans-unit id="7909d383b2cdb2682dbc516d4d07f2a0250ff82b" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;this&lt;/code&gt; keyword inside an object method, &lt;code&gt;this&lt;/code&gt; is bound to the &quot;immediate&quot; enclosing object.</source>
          <target state="translated">Когда вы используете &lt;code&gt;this&lt;/code&gt; ключевое слово внутри метода объекта, &lt;code&gt;this&lt;/code&gt; связывается с &amp;laquo;непосредственным&amp;raquo; включающим объектом.</target>
        </trans-unit>
        <trans-unit id="83b1b8689f73a2750a7952c4091b19bcec3490d7" translate="yes" xml:space="preserve">
          <source>Whenever a function is invoked, it is invoked in context of an
object (&lt;strong&gt;&quot;current object&quot;&lt;/strong&gt;). If the &lt;strong&gt;current object&lt;/strong&gt; is not explicitly provided,
the &lt;strong&gt;current object&lt;/strong&gt;  is the &lt;strong&gt;&quot;window object&quot;&lt;/strong&gt; in &lt;strong&gt;NON Strict
Mode&lt;/strong&gt; and &lt;strong&gt;&quot;undefined&quot;&lt;/strong&gt; in Strict Mode by default.</source>
          <target state="translated">Всякий раз, когда вызывается функция, она вызывается в контексте объекта ( &lt;strong&gt;&amp;laquo;текущий объект&amp;raquo;&lt;/strong&gt; ). Если &lt;strong&gt;текущий объект&lt;/strong&gt; явно не указан, то &lt;strong&gt;текущий объект&lt;/strong&gt; является &lt;strong&gt;&amp;laquo;оконным объектом&amp;raquo;&lt;/strong&gt; в &lt;strong&gt;строгом режиме&lt;/strong&gt; и &lt;strong&gt;не определен&lt;/strong&gt; в строгом режиме по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c1e2d9b7e33f4aae1fb2ee3c05579c089c455131" translate="yes" xml:space="preserve">
          <source>Where is &lt;em&gt;&lt;code&gt;this&lt;/code&gt; taken from&lt;/em&gt;?</source>
          <target state="translated">Откуда &lt;em&gt; &lt;code&gt;this&lt;/code&gt; взято&lt;/em&gt; ?</target>
        </trans-unit>
        <trans-unit id="9b9fe2edee77fa966a9bca11a2314adc27b17dde" translate="yes" xml:space="preserve">
          <source>Whether the code is in strict or non-strict mode</source>
          <target state="translated">Вне зависимости от того,находится ли код в строгом или нестрогом режиме.</target>
        </trans-unit>
        <trans-unit id="c67697bc299f31a4867d9e3ec63fd31a1acb34d6" translate="yes" xml:space="preserve">
          <source>Whether the code was invoked using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Был ли код вызван с помощью &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95b195c331d5df50ce3d94202285a5aa9dff77e9" translate="yes" xml:space="preserve">
          <source>While arrow-functions provide an alternative to using &lt;code&gt;bind()&lt;/code&gt;, it&amp;rsquo;s important to note that they essentially are disabling the traditional &lt;code&gt;this&lt;/code&gt; mechanism in favor of more widely understood lexical scoping. &lt;sup&gt;(1)&lt;/sup&gt;</source>
          <target state="translated">Хотя функции-стрелки предоставляют альтернативу использованию &lt;code&gt;bind()&lt;/code&gt; , важно отметить, что они по сути отключают традиционный механизм &lt;code&gt;this&lt;/code&gt; в пользу более широко понимаемой лексической области видимости. &lt;sup&gt;(1)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1ed94bc080271febddcf89764199947c7c3fdafb" translate="yes" xml:space="preserve">
          <source>Whould &lt;a href=&quot;http://www.quirksmode.org/js/this.html&quot;&gt;this&lt;/a&gt; help? (Most confusion of 'this' in javascript is coming from the fact that it generally is not linked to your object, but to the current executing scope -- that might not be exactly how it works but is always feels like that to me -- see the article for a complete explanation)</source>
          <target state="translated">Как &lt;a href=&quot;http://www.quirksmode.org/js/this.html&quot;&gt;это может&lt;/a&gt; помочь? (Большая путаница с &amp;laquo;этим&amp;raquo; в javascript связана с тем, что он, как правило, связан не с вашим объектом, а с текущей областью выполнения - это может быть не совсем так, как это работает, но мне всегда кажется, что это так - см. статью для полного объяснения)</target>
        </trans-unit>
        <trans-unit id="b4fb795b23dbff94bf4305a128bec5ae7d7ea74e" translate="yes" xml:space="preserve">
          <source>With Constructor</source>
          <target state="translated">С конструктором</target>
        </trans-unit>
        <trans-unit id="3b1aa9ad3adbb8fddf6c31fef8a04fbd8c6ce154" translate="yes" xml:space="preserve">
          <source>With event handlers</source>
          <target state="translated">С обработчиками событий</target>
        </trans-unit>
        <trans-unit id="15ce445da4009f96d02170197211759e9e416399" translate="yes" xml:space="preserve">
          <source>You can also manipulate the context using &lt;code&gt;.apply()&lt;/code&gt;&lt;code&gt;.call()&lt;/code&gt; and &lt;code&gt;.bind()&lt;/code&gt;</source>
          <target state="translated">Вы также можете управлять контекстом, используя &lt;code&gt;.apply()&lt;/code&gt; &lt;code&gt;.call()&lt;/code&gt; и &lt;code&gt;.bind()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4c81bc669883bad79d12946f0cdcef3cb41ac57" translate="yes" xml:space="preserve">
          <source>You can manipulate the value of &lt;code&gt;this&lt;/code&gt; with the functions: &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;bind&lt;/code&gt;</source>
          <target state="translated">Вы можете манипулировать значением &lt;code&gt;this&lt;/code&gt; с помощью функций: &lt;code&gt;call&lt;/code&gt; , &lt;code&gt;apply&lt;/code&gt; , &lt;code&gt;bind&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9aafe015410fc61c26eb7b85e5f45fd78ded6a07" translate="yes" xml:space="preserve">
          <source>You can set the value of &lt;em&gt;this&lt;/em&gt; using &lt;code&gt;func.call&lt;/code&gt;, &lt;code&gt;func.apply&lt;/code&gt; or &lt;code&gt;func.bind&lt;/code&gt;.</source>
          <target state="translated">Вы можете установить это значение, используя &lt;code&gt;func.call&lt;/code&gt; , &lt;code&gt;func.apply&lt;/code&gt; или &lt;code&gt;func.bind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bc00565d4384be2eef6cc38bfd42c85cf8d0315" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;eval&lt;/code&gt; to access &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;eval&lt;/code&gt; для доступа к &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cca5c93685569cae1cf0ccae89b950fa2dccdaf8" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;this&lt;/code&gt; in any function on an object to refer to other properties on that object. This is not the same as an instance created with &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;this&lt;/code&gt; в любой функции объекта для ссылки на другие свойства этого объекта. Это не то же самое, что экземпляр, созданный с помощью &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4d5df9ef1b310c884c8d57fbfb242857d89270e" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;with&lt;/code&gt; to add &lt;code&gt;this&lt;/code&gt; to the current scope to read and write to values on &lt;code&gt;this&lt;/code&gt; without referring to &lt;code&gt;this&lt;/code&gt; explicitly.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;with&lt;/code&gt; чтобы добавить &lt;code&gt;this&lt;/code&gt; в текущую область, чтобы читать и записывать значения в &lt;code&gt;this&lt;/code&gt; не ссылаясь на &lt;code&gt;this&lt;/code&gt; явно.</target>
        </trans-unit>
        <trans-unit id="54e27d188f0d38ee9602bf7437198a4746e2a173" translate="yes" xml:space="preserve">
          <source>above it). So, to get over this (no pun intended) problem, a developer could:</source>
          <target state="translated">над ним).Итак,чтобы справиться с этой проблемой (без каламбура),разработчик мог бы:</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="9515c8375c0b70748ad0886b201ac47811d74397" translate="yes" xml:space="preserve">
          <source>and then we could call it like this</source>
          <target state="translated">и тогда мы могли бы назвать это так</target>
        </trans-unit>
        <trans-unit id="226abeaecd5ff1c4ed49f5e280892fe18bd8990d" translate="yes" xml:space="preserve">
          <source>but &lt;strong&gt;do&lt;/strong&gt; ask yourself:</source>
          <target state="translated">но спросите себя:</target>
        </trans-unit>
        <trans-unit id="841108c86e9fbb4edafbf1fc269ca06fbd9c2aa7" translate="yes" xml:space="preserve">
          <source>is the same as</source>
          <target state="translated">такой же,как</target>
        </trans-unit>
        <trans-unit id="52bf064bbb0874e1615c452b86946146a06f7150" translate="yes" xml:space="preserve">
          <source>it becomes the property of the window object, as if you have defined
it as</source>
          <target state="translated">он становится свойством объекта окна,как если бы вы определили его как</target>
        </trans-unit>
        <trans-unit id="030861400725df2cccdbd01f8186798d77f7e41a" translate="yes" xml:space="preserve">
          <source>jQuery makes this trivial to change with jQuery.proxy.</source>
          <target state="translated">jQuery делает это тривиальным для изменения с помощью jQuery.proxy.</target>
        </trans-unit>
        <trans-unit id="f36f025d3a5f8c92288a34e977b81bdd71e6227d" translate="yes" xml:space="preserve">
          <source>javascriptissexy.com - &lt;a href=&quot;http://goo.gl/pvl0GX&quot;&gt;http://goo.gl/pvl0GX&lt;/a&gt;</source>
          <target state="translated">javascriptissexy.com - &lt;a href=&quot;http://goo.gl/pvl0GX&quot;&gt;http://goo.gl/pvl0GX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4049836cfbefc8188779c17bb3962e791ecad445" translate="yes" xml:space="preserve">
          <source>the jQuery will in many places have &lt;code&gt;this&lt;/code&gt; refer to a DOM element.</source>
          <target state="translated">во многих местах jQuery будет ссылаться на элемент DOM.</target>
        </trans-unit>
        <trans-unit id="3be4a57468f0408033e4ea27c9512e741f1fbc8b" translate="yes" xml:space="preserve">
          <source>this use for Scope just like this</source>
          <target state="translated">это использование для Scope вот так</target>
        </trans-unit>
        <trans-unit id="0be011b10726d85ae6873c3f4ffc235cfde3ceb9" translate="yes" xml:space="preserve">
          <source>value of txt1 and txt is same
in Above example 
$(this)=$('#tbleName tbody tr') is Same</source>
          <target state="translated">значение txt1 и txt одинаково в приведенном выше примере $(this)=$('#tbleName tbody tr')равно Same</target>
        </trans-unit>
        <trans-unit id="a40cac89bb894a88e8ef678122403134449a72d5" translate="yes" xml:space="preserve">
          <source>was effectively translated into</source>
          <target state="translated">было эффективно переведено на</target>
        </trans-unit>
        <trans-unit id="eee2fd622722c8b192547f36dd5b9891b7a1ad1e" translate="yes" xml:space="preserve">
          <source>which means</source>
          <target state="translated">что означает</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
