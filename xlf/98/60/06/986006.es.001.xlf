<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/986006">
    <body>
      <group id="986006">
        <trans-unit id="a1b152a892ef513d9a4d8de1e227286558de128b" translate="yes" xml:space="preserve">
          <source>&quot;...variables [names] are &lt;em&gt;not&lt;/em&gt; objects; they cannot be denoted by other variables or referred to by objects.&quot;</source>
          <target state="translated">&quot;... las variables [nombres] &lt;em&gt;no&lt;/em&gt; son objetos; no pueden ser denotadas por otras variables o referidas por objetos&quot;.</target>
        </trans-unit>
        <trans-unit id="ec2f8b9ef1eca2860982704b2396e6f5e99305cc" translate="yes" xml:space="preserve">
          <source>&quot;In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a new value anywhere within the function&amp;rsquo;s body, it&amp;rsquo;s assumed to be a local. If a variable is ever assigned a new value inside the function, the variable is implicitly local, and you need to explicitly declare it as &amp;lsquo;global&amp;rsquo;.
Though a bit surprising at first, a moment&amp;rsquo;s consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, you&amp;rsquo;d be using global all the time. You&amp;rsquo;d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.&quot;</source>
          <target state="translated">&quot;En Python, las variables a las que solo se hace referencia dentro de una funci&amp;oacute;n son impl&amp;iacute;citamente globales. Si a una variable se le asigna un nuevo valor en cualquier parte del cuerpo de la funci&amp;oacute;n, se supone que es local. Si a una variable se le asigna un nuevo valor dentro de la funci&amp;oacute;n, la variable es impl&amp;iacute;citamente local, y debe declararla expl&amp;iacute;citamente como 'global'. Aunque un poco sorprendente al principio, un momento de consideraci&amp;oacute;n lo explica. Por un lado, requerir variables globales asignadas proporciona una barrera contra los efectos secundarios no deseados. por otro lado, si se necesitara global para todas las referencias globales, estar&amp;iacute;a usando global todo el tiempo. Tendr&amp;iacute;a que declarar como global cada referencia a una funci&amp;oacute;n incorporada o a un componente de un m&amp;oacute;dulo importado. Este desorden derrotar&amp;iacute;a la utilidad de la declaraci&amp;oacute;n global para identificar los efectos secundarios &quot;.</target>
        </trans-unit>
        <trans-unit id="42c22aec244c5d347e54be65aaab6403cdf146a7" translate="yes" xml:space="preserve">
          <source>(Yeah I know this can be inconvenient, but sometimes it is simple enough to do this.)</source>
          <target state="translated">(Sí,sé que esto puede ser un inconveniente,pero a veces es bastante simple hacerlo.)</target>
        </trans-unit>
        <trans-unit id="8a51a221218346c2c1772a44d0e7cc971cece6c5" translate="yes" xml:space="preserve">
          <source>(edit - Blair has updated his enormously popular answer so that it is now accurate)</source>
          <target state="translated">(edición-Blair ha actualizado su respuesta enormemente popular para que ahora sea precisa)</target>
        </trans-unit>
        <trans-unit id="a62a78c201c7282875384fa5a4bbe69e0365e928" translate="yes" xml:space="preserve">
          <source>(edit 2019-04-28)</source>
          <target state="translated">(edición 2019-04-28)</target>
        </trans-unit>
        <trans-unit id="8b9f3efa3729cce732344f81bf8d7d82f28606bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self.variable&lt;/code&gt; is a reference to the string object &lt;code&gt;'Original'&lt;/code&gt;. When you call &lt;code&gt;Change&lt;/code&gt; you create a second reference &lt;code&gt;var&lt;/code&gt; to the object. Inside the function you reassign the reference &lt;code&gt;var&lt;/code&gt; to a different string object &lt;code&gt;'Changed'&lt;/code&gt;, but the reference &lt;code&gt;self.variable&lt;/code&gt; is separate and does not change.</source>
          <target state="translated">&lt;code&gt;self.variable&lt;/code&gt; es una referencia al objeto de cadena &lt;code&gt;'Original'&lt;/code&gt; . Cuando llama a &lt;code&gt;Change&lt;/code&gt; , crea una segunda &lt;code&gt;var&lt;/code&gt; de referencia para el objeto. Dentro de la funci&amp;oacute;n, reasigna la &lt;code&gt;var&lt;/code&gt; de referencia a un objeto de cadena diferente &lt;code&gt;'Changed'&lt;/code&gt; , pero la &lt;code&gt;self.variable&lt;/code&gt; referencia est&amp;aacute; separada y no cambia.</target>
        </trans-unit>
        <trans-unit id="4229ed636553c69cfddd84246fc10b33ff69719b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++:&lt;/strong&gt; Both pass-by-reference or pass-by-value are allowed. If a parameter is passed by reference, you can either modify it or not depending upon whether the parameter was passed as const or not. However, const or not, the parameter maintains the reference to the object and reference cannot be assigned to point to a different object within the called function.</source>
          <target state="translated">&lt;strong&gt;C ++:&lt;/strong&gt; se permiten tanto el paso por referencia como el paso por valor. Si un par&amp;aacute;metro se pasa por referencia, puede modificarlo o no dependiendo de si el par&amp;aacute;metro se pas&amp;oacute; como constante o no. Sin embargo, constante o no, el par&amp;aacute;metro mantiene la referencia al objeto y no se puede asignar referencia para apuntar a un objeto diferente dentro de la funci&amp;oacute;n llamada.</target>
        </trans-unit>
        <trans-unit id="b3be1ec03105d4972fcbe3fec3a499e2307f9ee7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; It's been noted that this doesn't answer the question that @David originally asked, &quot;Is there something I can do to pass the variable by actual reference?&quot;. Let's work on that.</source>
          <target state="translated">&lt;strong&gt;EDITAR:&lt;/strong&gt; Se ha observado que esto no responde la pregunta que @David originalmente pregunt&amp;oacute;: &quot;&amp;iquest;Hay algo que pueda hacer para pasar la variable por referencia real?&quot;. Trabajemos en eso.</target>
        </trans-unit>
        <trans-unit id="d892af211725dce0575cd510d5913eae3f198cec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's immutable, so there's nothing we can do to change the contents of the string&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Es inmutable, por lo que no hay nada que podamos hacer para cambiar el contenido de la cadena.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee9513e042a85a4c63813585beec33bd12875b0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java&amp;amp;C#:&lt;/strong&gt; primitive types(include string)pass by value(copy), Reference type is passed by reference(address copy) so all changes made in the parameter in the called function are visible to the caller.</source>
          <target state="translated">&lt;strong&gt;Java &amp;amp; C #:&lt;/strong&gt; los tipos primitivos (incluir cadena) pasan por valor (copia), el tipo de referencia se pasa por referencia (copia de direcci&amp;oacute;n) para que todos los cambios realizados en el par&amp;aacute;metro en la funci&amp;oacute;n llamada sean visibles para el llamante.</target>
        </trans-unit>
        <trans-unit id="b6bd3f4d372e7f7c7ecfb3b235bcc93f977ff2b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's try to modify the list that was passed to a method:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Intentemos modificar la lista que se pas&amp;oacute; a un m&amp;eacute;todo:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be2b61cd76cc0ed218c950fa9a0f695fe658d0b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now let's see what happens when we try to change the reference that was passed in as a parameter:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ahora veamos qu&amp;eacute; sucede cuando intentamos cambiar la referencia que se pas&amp;oacute; como par&amp;aacute;metro:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1bb1d2d46eeb3cfe61924c812bf981baeae0193b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now, let's try to change the reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ahora, tratemos de cambiar la referencia&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5b90913af1169e0301615a93fc64f0e5b948b1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python:&lt;/strong&gt; 
Python is &amp;ldquo;pass-by-object-reference&amp;rdquo;, of which it is often said: &amp;ldquo;Object references are passed by value.&amp;rdquo;[Read here]&lt;a href=&quot;https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/&quot;&gt;1&lt;/a&gt;. Both the caller and the function refer to the same object but the parameter in the function is a new variable which is just holding a copy of the object in the caller. Like C++, a parameter can be either modified or not in function - This depends upon the type of object passed. eg; An immutable object type cannot be modified in the called function whereas a mutable object can be either updated or re-initialized. A crucial difference between updating or re-assigning/re-initializing the mutable variable is that updated value gets reflected back in the called function whereas the reinitialized value does not. Scope of any assignment of new object to a mutable variable is local to the function in the python. Examples provided by @blair-conrad are great to understand this.</source>
          <target state="translated">&lt;strong&gt;Python:&lt;/strong&gt; Python es &quot;referencia de paso por objeto&quot;, del cual a menudo se dice: &quot;Las referencias de objeto se pasan por valor&quot;. [Lea aqu&amp;iacute;] &lt;a href=&quot;https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/&quot;&gt;1&lt;/a&gt; . Tanto la persona que llama como la funci&amp;oacute;n se refieren al mismo objeto, pero el par&amp;aacute;metro en la funci&amp;oacute;n es una nueva variable que solo contiene una copia del objeto en la persona que llama. Al igual que C ++, un par&amp;aacute;metro puede modificarse o no en funci&amp;oacute;n: esto depende del tipo de objeto pasado. p.ej; Un tipo de objeto inmutable no se puede modificar en la funci&amp;oacute;n llamada, mientras que un objeto mutable se puede actualizar o reinicializar. Una diferencia crucial entre actualizar o reasignar / reinicializar la variable mutable es que el valor actualizado se refleja en la funci&amp;oacute;n llamada, mientras que el valor reinicializado no. El alcance de cualquier asignaci&amp;oacute;n de un nuevo objeto a una variable mutable es local para la funci&amp;oacute;n en la pit&amp;oacute;n. Los ejemplos proporcionados por @ blair-conrad son geniales para entender esto.</target>
        </trans-unit>
        <trans-unit id="9883e919e7997c4bcd00e7db78ba8af7ca037be6" translate="yes" xml:space="preserve">
          <source>A lot of insights in answers here, but i think an additional point is not clearly mentioned here explicitly.   Quoting from python documentation &lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&lt;/a&gt;</source>
          <target state="translated">Una gran cantidad de ideas en las respuestas aqu&amp;iacute;, pero creo que un punto adicional no se menciona claramente aqu&amp;iacute; expl&amp;iacute;citamente. Citando de la documentaci&amp;oacute;n de Python &lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b9bc6a21011e77a1fc1acf4db17ae8c442f98ed" translate="yes" xml:space="preserve">
          <source>A simple trick I normally use is to just wrap it in a list:</source>
          <target state="translated">Un simple truco que normalmente uso es envolverlo en una lista:</target>
        </trans-unit>
        <trans-unit id="1c34629702aff601e9017462b805c4e1564c10a6" translate="yes" xml:space="preserve">
          <source>Again, since the &lt;code&gt;the_string&lt;/code&gt; parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The &lt;code&gt;the_string&lt;/code&gt; was a copy of the &lt;code&gt;outer_string&lt;/code&gt; reference, and we had &lt;code&gt;the_string&lt;/code&gt; point to a new string, but there was no way to change where &lt;code&gt;outer_string&lt;/code&gt; pointed.</source>
          <target state="translated">Nuevamente, dado que el par&amp;aacute;metro &lt;code&gt;the_string&lt;/code&gt; se pas&amp;oacute; por valor, asignarle una nueva cadena no tuvo ning&amp;uacute;n efecto que el c&amp;oacute;digo fuera del m&amp;eacute;todo pudiera ver. &lt;code&gt;the_string&lt;/code&gt; era una copia de la referencia &lt;code&gt;outer_string&lt;/code&gt; , y ten&amp;iacute;amos el punto &lt;code&gt;the_string&lt;/code&gt; a una nueva cadena, pero no hab&amp;iacute;a forma de cambiar el &lt;code&gt;outer_string&lt;/code&gt; hacia afuera .</target>
        </trans-unit>
        <trans-unit id="c9e5405e129e476d3e0ef475249c330ed3f6dfb5" translate="yes" xml:space="preserve">
          <source>Although this seems a little cumbersome.</source>
          <target state="translated">Aunque esto parece un poco engorroso.</target>
        </trans-unit>
        <trans-unit id="2d97b97ac2c4c28ba96535277dd72cff612ba228" translate="yes" xml:space="preserve">
          <source>Another solution would be to create a static method like this:</source>
          <target state="translated">Otra solución sería crear un método estático como este:</target>
        </trans-unit>
        <trans-unit id="b0c7226e7708d9f8704f1ddf855b76d4d0e697d8" translate="yes" xml:space="preserve">
          <source>Arguments are &lt;a href=&quot;http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference&quot;&gt;passed by assignment&lt;/a&gt;. The rationale behind this is twofold:</source>
          <target state="translated">Los argumentos se &lt;a href=&quot;http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference&quot;&gt;pasan por asignaci&amp;oacute;n&lt;/a&gt; . La raz&amp;oacute;n detr&amp;aacute;s de esto es doble:</target>
        </trans-unit>
        <trans-unit id="57fce48e3511c0b229efd7be720f8de1904d6840" translate="yes" xml:space="preserve">
          <source>As @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out:</source>
          <target state="translated">Como muestra la respuesta de @Andrea,podrías devolver el nuevo valor.Esto no cambia la forma en que se pasan las cosas,pero te permite obtener la información que quieres de vuelta:</target>
        </trans-unit>
        <trans-unit id="3fc39df4449e0220d47d2afd67496a6547200ecf" translate="yes" xml:space="preserve">
          <source>As you can state you need to have a mutable object, but let me suggest you to check over the global variables as they can help you or even solve this kind of issue!</source>
          <target state="translated">Como puedes decir,necesitas tener un objeto mutable,pero déjame sugerirte que compruebes las variables globales,ya que pueden ayudarte o incluso resolver este tipo de problemas.</target>
        </trans-unit>
        <trans-unit id="1173d3f94d407863d6672e2edbfad0d748c8d95e" translate="yes" xml:space="preserve">
          <source>Aside from all the great explanations on how this stuff works in Python, I don't see a simple suggestion for the problem. As you seem to do create objects and instances, the pythonic way of handling instance variables and changing them is the following:</source>
          <target state="translated">Aparte de todas las grandes explicaciones sobre cómo funciona esto en Python,no veo una simple sugerencia para el problema.Como parece que se crean objetos e instancias,la forma pitónica de manejar las variables de las instancias y cambiarlas es la siguiente:</target>
        </trans-unit>
        <trans-unit id="955f20c5fd3d4cf266b4f4f30cefc9bede9bc806" translate="yes" xml:space="preserve">
          <source>Assignment binds a name to an object.</source>
          <target state="translated">La asignación vincula un nombre a un objeto.</target>
        </trans-unit>
        <trans-unit id="44eb458222e5cac4dd20238f7eb9ffa3a0a032f1" translate="yes" xml:space="preserve">
          <source>David Cournapeau's answer points to the real answer and explains why the behavior in Blair Conrad's post seems to be correct while the definitions are not.</source>
          <target state="translated">La respuesta de David Cournapeau apunta a la respuesta real y explica por qué el comportamiento en el puesto de Blair Conrad parece ser correcto mientras que las definiciones no lo son.</target>
        </trans-unit>
        <trans-unit id="6ba040c2f2a2d80842507aa7fb2215325e5e6c43" translate="yes" xml:space="preserve">
          <source>Effbot (aka Fredrik Lundh) has described Python's variable passing style as call-by-object:  &lt;a href=&quot;http://effbot.org/zone/call-by-object.htm&quot;&gt;http://effbot.org/zone/call-by-object.htm&lt;/a&gt;</source>
          <target state="translated">Effbot (tambi&amp;eacute;n conocido como Fredrik Lundh) ha descrito el estilo de paso variable de Python como llamada por objeto: &lt;a href=&quot;http://effbot.org/zone/call-by-object.htm&quot;&gt;http://effbot.org/zone/call-by-object.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="feb265a8df8e110e2790224a1da7e1861c9fda44" translate="yes" xml:space="preserve">
          <source>Even when passing a mutable object to a function this still applies. And to me clearly explains the reason for the difference in behavior between assigning to the object and operating on the object in the function.</source>
          <target state="translated">Incluso cuando se pasa un objeto mutable a una función,esto sigue siendo válido.Y a mí me explica claramente la razón de la diferencia de comportamiento entre asignar al objeto y operar sobre el objeto en la función.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="63aabb26e4f4644f4690795ae16738f9c1f5f4da" translate="yes" xml:space="preserve">
          <source>For just reading there is even a shorter way of just using &lt;code&gt;lambda: x&lt;/code&gt; which returns a callable that when called returns the current value of x. This is somewhat like &quot;call by name&quot; used in languages in the distant past.</source>
          <target state="translated">Para solo leer, hay una forma m&amp;aacute;s corta de usar &lt;code&gt;lambda: x&lt;/code&gt; que devuelve un invocable que cuando se llama devuelve el valor actual de x. Esto es algo as&amp;iacute; como &quot;llamar por nombre&quot; usado en idiomas en el pasado distante.</target>
        </trans-unit>
        <trans-unit id="a82f8b81c3ead144e50f2f04d42ea8cbd19c3b82" translate="yes" xml:space="preserve">
          <source>Here is a significant quote:</source>
          <target state="translated">Aquí hay una cita significativa:</target>
        </trans-unit>
        <trans-unit id="64605a5b8fffbc932d2851dd3c0a9a3b81ea1391" translate="yes" xml:space="preserve">
          <source>Here is the example that proves that Python uses passing by reference:</source>
          <target state="translated">Aquí está el ejemplo que demuestra que Python utiliza el paso por referencia:</target>
        </trans-unit>
        <trans-unit id="4652a9a03eda229eaa585e4d8b3108f912ea3767" translate="yes" xml:space="preserve">
          <source>Here is the simple (I hope) explanation of the concept &lt;code&gt;pass by object&lt;/code&gt; used in Python.</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; la explicaci&amp;oacute;n simple (espero) del concepto de &lt;code&gt;pass by object&lt;/code&gt; utilizado en Python.</target>
        </trans-unit>
        <trans-unit id="48484f80102edbe70571bc88f85e228361438a9f" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;ByRef&lt;/code&gt; class wraps a dictionary access. So attribute access to &lt;code&gt;wrapped&lt;/code&gt; is translated to a item access in the passed dictionary. By passing the result of the builtin &lt;code&gt;locals&lt;/code&gt; and the name of a local variable this ends up accessing a local variable. The python documentation as of 3.5 advises that changing the dictionary might not work but it seems to work for me.</source>
          <target state="translated">Aqu&amp;iacute; la clase &lt;code&gt;ByRef&lt;/code&gt; envuelve un acceso al diccionario. Por lo tanto, el acceso al atributo &lt;code&gt;wrapped&lt;/code&gt; se traduce en un acceso al elemento en el diccionario aprobado. Al pasar el resultado de los &lt;code&gt;locals&lt;/code&gt; incorporados y el nombre de una variable local, esto termina accediendo a una variable local. La documentaci&amp;oacute;n de Python a partir de 3.5 informa que cambiar el diccionario podr&amp;iacute;a no funcionar, pero parece funcionar para m&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="d0be6fb2e163967ac2361db4b4dde754f1a7b504" translate="yes" xml:space="preserve">
          <source>Hope that clarifies the issue for you.</source>
          <target state="translated">Espero que eso le aclare el asunto.</target>
        </trans-unit>
        <trans-unit id="ac9f35a5c40f1a54d0e975658a953c9ccceb917a" translate="yes" xml:space="preserve">
          <source>How do I pass a variable by reference</source>
          <target state="translated">¿Cómo paso una variable por referencia</target>
        </trans-unit>
        <trans-unit id="2635b21aa1a1e66c5ca7fed959d2e61ba0068f22" translate="yes" xml:space="preserve">
          <source>How do we get around this?</source>
          <target state="translated">¿Cómo podemos evitar esto?</target>
        </trans-unit>
        <trans-unit id="f2d3f338abd337442158a979a1f5de30af33097e" translate="yes" xml:space="preserve">
          <source>How to pass by reference</source>
          <target state="translated">Cómo pasar por referencia</target>
        </trans-unit>
        <trans-unit id="072a54410009d923de415851395bc3f915f1966d" translate="yes" xml:space="preserve">
          <source>How to read the example in the question</source>
          <target state="translated">Cómo leer el ejemplo de la pregunta</target>
        </trans-unit>
        <trans-unit id="f10e3c369b21afb8efe5cb8ff95bfee39a5c9ffa" translate="yes" xml:space="preserve">
          <source>I found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.</source>
          <target state="translated">Encontré las otras respuestas bastante largas y complicadas,así que creé este simple diagrama para explicar la forma en que Python trata las variables y parámetros.</target>
        </trans-unit>
        <trans-unit id="3ca5711f1032450bdfe039601daafa6c14debe97" translate="yes" xml:space="preserve">
          <source>I hope this clears things up a little.</source>
          <target state="translated">Espero que esto aclare un poco las cosas.</target>
        </trans-unit>
        <trans-unit id="779f081125662b16c96e53373144d42eb57b8923" translate="yes" xml:space="preserve">
          <source>I think it is important to note that the current post with the most votes (by Blair Conrad), while being correct with respect to its result, is misleading and is borderline incorrect based on its definitions.  While there are many languages (like C) that allow the user to either pass by reference or pass by value, Python is not one of them.</source>
          <target state="translated">Creo que es importante señalar que el puesto actual con más votos (de Blair Conrad),si bien es correcto en cuanto a su resultado,es engañoso y está al borde de lo incorrecto según sus definiciones.Aunque hay muchos idiomas (como el C)que permiten al usuario pasar por referencia o pasar por valor,Python no es uno de ellos.</target>
        </trans-unit>
        <trans-unit id="1caf319e1b878a7a9add11ed6d02d3179fc2d9bb" translate="yes" xml:space="preserve">
          <source>I used the following method to quickly convert a couple of Fortran codes to Python.  True, it's not pass by reference as the original question was posed, but is a simple work around in some cases.</source>
          <target state="translated">Utilicé el siguiente método para convertir rápidamente un par de códigos Fortran a Python.Cierto,no es pasar por referencia como se planteó la pregunta original,pero es un trabajo sencillo en algunos casos.</target>
        </trans-unit>
        <trans-unit id="f8f3af9f0dc96665fb36e21e7dd8ea0010188a92" translate="yes" xml:space="preserve">
          <source>I'm sure someone else could clarify this further.</source>
          <target state="translated">Estoy seguro de que alguien más podría aclarar esto más.</target>
        </trans-unit>
        <trans-unit id="8fd3fb5434919f5765b442b73f1a2ea249604d75" translate="yes" xml:space="preserve">
          <source>If it is an &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;immutable&lt;/a&gt; object (e.g. a bool, number, string), the way to go is to wrap it in a mutable object.</source>
          <target state="translated">Si se trata de un objeto &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;inmutable&lt;/a&gt; (por ejemplo, un bool, n&amp;uacute;mero, cadena), el camino a seguir es envolverlo en un objeto mutable.</target>
        </trans-unit>
        <trans-unit id="e8ff937ee3cf391aa9369bcc79fcdbacd051a2eb" translate="yes" xml:space="preserve">
          <source>If the argument was passed by value, the outer &lt;code&gt;lst&lt;/code&gt; could not be modified. The green are the target objects (the black is the value stored inside, the red is the object type), the yellow is the memory with the reference value inside -- drawn as the arrow. The blue solid arrow is the reference value that was passed to the function (via the dashed blue arrow path). The ugly dark yellow is the internal dictionary. (It actually could be drawn also as a green ellipse. The colour and the shape only says it is internal.)</source>
          <target state="translated">Si el argumento fue pasado por valor, el &lt;code&gt;lst&lt;/code&gt; externo no podr&amp;iacute;a modificarse. El verde son los objetos de destino (el negro es el valor almacenado en el interior, el rojo es el tipo de objeto), el amarillo es la memoria con el valor de referencia en el interior, dibujado como la flecha. La flecha s&amp;oacute;lida azul es el valor de referencia que se pas&amp;oacute; a la funci&amp;oacute;n (a trav&amp;eacute;s de la ruta de la flecha azul discontinua). El feo amarillo oscuro es el diccionario interno. (En realidad, podr&amp;iacute;a dibujarse tambi&amp;eacute;n como una elipse verde. El color y la forma solo dicen que es interno).</target>
        </trans-unit>
        <trans-unit id="0dd316a07900ad81da1e569611d0d7f972700c53" translate="yes" xml:space="preserve">
          <source>If you pass a &lt;em&gt;mutable&lt;/em&gt; object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object.</source>
          <target state="translated">Si pasa un objeto &lt;em&gt;mutable&lt;/em&gt; a un m&amp;eacute;todo, el m&amp;eacute;todo obtiene una referencia a ese mismo objeto y puede mutarlo para deleite de su coraz&amp;oacute;n, pero si vuelve a vincular la referencia en el m&amp;eacute;todo, el alcance externo no sabr&amp;aacute; nada al respecto, y despu&amp;eacute;s Una vez hecho, la referencia externa seguir&amp;aacute; apuntando al objeto original.</target>
        </trans-unit>
        <trans-unit id="6f1b4b35463994559a0edb1ad6a1b8357fb742a0" translate="yes" xml:space="preserve">
          <source>If you pass an &lt;em&gt;immutable&lt;/em&gt; object to a method, you still can't rebind the outer reference, and you can't even mutate the object.</source>
          <target state="translated">Si pasa un objeto &lt;em&gt;inmutable&lt;/em&gt; a un m&amp;eacute;todo, a&amp;uacute;n no puede volver a vincular la referencia externa, y ni siquiera puede mutar el objeto.</target>
        </trans-unit>
        <trans-unit id="bc1e60fe42ced701dd9148c0ff6beca470127f04" translate="yes" xml:space="preserve">
          <source>If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:</source>
          <target state="translated">Si realmente quisieras evitar usar un valor de retorno,podrías crear una clase para mantener tu valor y pasarlo a la función o usar una clase existente,como una lista:</target>
        </trans-unit>
        <trans-unit id="9688763625be69eed8ed0d10e131598208128be6" translate="yes" xml:space="preserve">
          <source>If you want the behavior, Blair Conrad's answer is fine.  But if you want to know the nuts and bolts of why Python is neither pass by value or pass by reference, read David Cournapeau's answer.</source>
          <target state="translated">Si quieres el comportamiento,la respuesta de Blair Conrad está bien.Pero si quieres saber los detalles de por qué Python no es ni un valor de paso ni una referencia de paso,lee la respuesta de David Cournapeau.</target>
        </trans-unit>
        <trans-unit id="e5596ea1ad94c7661a4350a8652098d786a4cc4b" translate="yes" xml:space="preserve">
          <source>Immutable arguments are effectively passed &amp;ldquo;&lt;strong&gt;by value&lt;/strong&gt;.&amp;rdquo; Objects such as integers and strings are passed by object reference instead of by copying, but because you can&amp;rsquo;t change immutable objects in place anyhow, the effect is much like making a copy.</source>
          <target state="translated">Los argumentos inmutables se pasan efectivamente &quot; &lt;strong&gt;por valor&lt;/strong&gt; &quot;. Los objetos como enteros y cadenas se pasan por referencia de objeto en lugar de copiar, pero de todos modos, como no puede cambiar los objetos inmutables en su lugar, el efecto es muy similar a hacer una copia.</target>
        </trans-unit>
        <trans-unit id="6302f1ff1c0c2b90057d999e0b3858fc9d2a2e08" translate="yes" xml:space="preserve">
          <source>In compiled languages, a variable is a memory space that is able to capture the value of the type. In Python, a variable is a name (captured internally as a string) bound to the reference variable that holds the reference value to the target object. The name of the variable is the key in the internal dictionary, the value part of that dictionary item stores the reference value to the target.</source>
          <target state="translated">En los lenguajes compilados,una variable es un espacio de memoria que es capaz de capturar el valor del tipo.En Python,una variable es un nombre (capturado internamente como una cadena)vinculado a la variable de referencia que contiene el valor de referencia del objeto objetivo.El nombre de la variable es la clave en el diccionario interno,la parte del valor de ese elemento del diccionario almacena el valor de referencia al objeto.</target>
        </trans-unit>
        <trans-unit id="271a2c315dedadaa6b644002264db432c9330e40" translate="yes" xml:space="preserve">
          <source>In instance methods, you normally refer to &lt;code&gt;self&lt;/code&gt; to access instance attributes. It is normal to set instance attributes in &lt;code&gt;__init__&lt;/code&gt; and read or change them in instance methods. That is also why you pass &lt;code&gt;self&lt;/code&gt; als the first argument to &lt;code&gt;def Change&lt;/code&gt;.</source>
          <target state="translated">En los m&amp;eacute;todos de instancia, normalmente se refiere a &lt;code&gt;self&lt;/code&gt; para acceder a los atributos de la instancia. Es normal establecer atributos de instancia en &lt;code&gt;__init__&lt;/code&gt; y leerlos o cambiarlos en m&amp;eacute;todos de instancia. Esa es tambi&amp;eacute;n la raz&amp;oacute;n por la que se pasa a &lt;code&gt;self&lt;/code&gt; como el primer argumento para &lt;code&gt;def Change&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fae6b090cdbf66824da7924b6168f4173a64868f" translate="yes" xml:space="preserve">
          <source>In the code shown in the question, the statement &lt;code&gt;self.Change(self.variable)&lt;/code&gt; binds the name &lt;code&gt;var&lt;/code&gt; (in the scope of function &lt;code&gt;Change&lt;/code&gt;) to the object that holds the value &lt;code&gt;'Original'&lt;/code&gt; and the assignment &lt;code&gt;var = 'Changed'&lt;/code&gt; (in the body of function &lt;code&gt;Change&lt;/code&gt;) assigns that same name again: to some other object (that happens to hold a string as well but could have been something else entirely).</source>
          <target state="translated">En el c&amp;oacute;digo que se muestra en la pregunta, la declaraci&amp;oacute;n &lt;code&gt;self.Change(self.variable)&lt;/code&gt; vincula el nombre &lt;code&gt;var&lt;/code&gt; (en el &amp;aacute;mbito de la funci&amp;oacute;n &lt;code&gt;Change&lt;/code&gt; ) al objeto que contiene el valor &lt;code&gt;'Original'&lt;/code&gt; y la asignaci&amp;oacute;n &lt;code&gt;var = 'Changed'&lt;/code&gt; (en el cuerpo de la funci&amp;oacute;n &lt;code&gt;Change&lt;/code&gt; ) asigna ese mismo nombre nuevamente: a alg&amp;uacute;n otro objeto (que tambi&amp;eacute;n contiene una cadena pero podr&amp;iacute;a haber sido algo completamente diferente).</target>
        </trans-unit>
        <trans-unit id="d174ebf38cb48196530f520173f23f96ee505c2d" translate="yes" xml:space="preserve">
          <source>In this case the variable titled &lt;code&gt;var&lt;/code&gt; in the method &lt;code&gt;Change&lt;/code&gt; is assigned a reference to &lt;code&gt;self.variable&lt;/code&gt;, and you immediately assign a string to &lt;code&gt;var&lt;/code&gt;. It's no longer pointing to &lt;code&gt;self.variable&lt;/code&gt;. The following code snippet shows what would happen if you modify the data structure pointed to by &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;self.variable&lt;/code&gt;, in this case a list:</source>
          <target state="translated">En este caso, a la variable titulada &lt;code&gt;var&lt;/code&gt; en el m&amp;eacute;todo &lt;code&gt;Change&lt;/code&gt; se le asigna una referencia a &lt;code&gt;self.variable&lt;/code&gt; , e inmediatamente asigna una cadena a &lt;code&gt;var&lt;/code&gt; . Ya no apunta a &lt;code&gt;self.variable&lt;/code&gt; . El siguiente fragmento de c&amp;oacute;digo muestra lo que suceder&amp;iacute;a si modifica la estructura de datos a la que apunta &lt;code&gt;var&lt;/code&gt; y &lt;code&gt;self.variable&lt;/code&gt; , en este caso una lista:</target>
        </trans-unit>
        <trans-unit id="c93eaa9797f60173290b5121f5aebea5bd45b163" translate="yes" xml:space="preserve">
          <source>In your example, when the &lt;code&gt;Change&lt;/code&gt; method is called--a &lt;a href=&quot;http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces&quot;&gt;namespace&lt;/a&gt; is created for it; and &lt;code&gt;var&lt;/code&gt; becomes a name, within that namespace, for the string object &lt;code&gt;'Original'&lt;/code&gt;. That object then has a name in two namespaces. Next, &lt;code&gt;var = 'Changed'&lt;/code&gt; binds &lt;code&gt;var&lt;/code&gt; to a new string object, and thus the method's namespace forgets about &lt;code&gt;'Original'&lt;/code&gt;. Finally, that namespace is forgotten, and the string &lt;code&gt;'Changed'&lt;/code&gt; along with it.</source>
          <target state="translated">En su ejemplo, cuando se llama al m&amp;eacute;todo &lt;code&gt;Change&lt;/code&gt; , se crea un &lt;a href=&quot;http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces&quot;&gt;espacio de nombres&lt;/a&gt; para &amp;eacute;l; y &lt;code&gt;var&lt;/code&gt; se convierte en un nombre, dentro de ese espacio de nombres, para el objeto de cadena &lt;code&gt;'Original'&lt;/code&gt; . Ese objeto tiene un nombre en dos espacios de nombres. A continuaci&amp;oacute;n, &lt;code&gt;var = 'Changed'&lt;/code&gt; vincula &lt;code&gt;var&lt;/code&gt; a un nuevo objeto de cadena y, por lo tanto, el espacio de nombres del m&amp;eacute;todo se olvida de &lt;code&gt;'Original'&lt;/code&gt; . Finalmente, ese espacio de nombres se olvida, y la cadena &lt;code&gt;'Changed'&lt;/code&gt; junto con &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="bb33c9ab807f193d39872eed5e22af0127a40637" translate="yes" xml:space="preserve">
          <source>Is there something I can do to pass the variable by actual reference?</source>
          <target state="translated">¿Hay algo que pueda hacer para pasar la variable por referencia real?</target>
        </trans-unit>
        <trans-unit id="d7e7bdb80421d5ef59aefc489f344f221587bba6" translate="yes" xml:space="preserve">
          <source>It is neither pass-by-value or pass-by-reference - it is call-by-object. See this, by Fredrik Lundh:</source>
          <target state="translated">No es ni paso-por-valor ni paso-por-referencia-es llamada por objeto.Mira esto,de Fredrik Lundh:</target>
        </trans-unit>
        <trans-unit id="48bb347a9d7faf829dae8ac2ec01719f82c86124" translate="yes" xml:space="preserve">
          <source>It's an ugly hack, but it works. ;-P</source>
          <target state="translated">Es un hack feo,pero funciona.;-P</target>
        </trans-unit>
        <trans-unit id="c4d93e3229bff3269f3ab05cdf6305855b9bc82f" translate="yes" xml:space="preserve">
          <source>List - a mutable type</source>
          <target state="translated">Lista-un tipo mutable</target>
        </trans-unit>
        <trans-unit id="e145738e57fdf9ea90a9bfc63f28785068e9be9d" translate="yes" xml:space="preserve">
          <source>Mutable arguments are effectively passed &amp;ldquo;&lt;strong&gt;by pointer&lt;/strong&gt;.&amp;rdquo; Objects such as lists
and dictionaries are also passed by object reference, which is similar to the way C
passes arrays as pointers&amp;mdash;mutable objects can be changed in place in the function,
much like C arrays.</source>
          <target state="translated">Los argumentos mutables se pasan efectivamente &quot; &lt;strong&gt;por puntero&lt;/strong&gt; &quot;. Los objetos como las listas y los diccionarios tambi&amp;eacute;n se pasan por referencia de objeto, que es similar a la forma en que C pasa las matrices como punteros: los objetos mutables se pueden cambiar en su lugar en la funci&amp;oacute;n, al igual que las matrices de C.</target>
        </trans-unit>
        <trans-unit id="ed19ef46a33530a5532cfcd97126ae99cb3242a0" translate="yes" xml:space="preserve">
          <source>Objects are allocated on the heap and pointers to them can be passed around anywhere.</source>
          <target state="translated">Los objetos se asignan en el montón y los punteros a ellos se pueden pasar por cualquier lugar.</target>
        </trans-unit>
        <trans-unit id="87dea7220960a8d9957e82c5e7caf7ae67f5891a" translate="yes" xml:space="preserve">
          <source>Objects like lists are &lt;em&gt;mutable&lt;/em&gt;.  This means that the contents of the object can be changed by anything pointing to the object.  For example, &lt;code&gt;x = []; y = x; x.append(10); print y&lt;/code&gt; will print &lt;code&gt;[10]&lt;/code&gt;.  The empty list was created.  Both &quot;x&quot; and &quot;y&quot; point to the same list.  The &lt;em&gt;append&lt;/em&gt; method mutates (updates) the list object (like adding a record to a database) and the result is visible to both &quot;x&quot; and &quot;y&quot; (just as a database update would be visible to every connection to that database).</source>
          <target state="translated">Los objetos como las listas son &lt;em&gt;mutables&lt;/em&gt; . Esto significa que el contenido del objeto se puede cambiar por cualquier cosa que apunte al objeto. Por ejemplo, &lt;code&gt;x = []; y = x; x.append(10); print y&lt;/code&gt; y = x; x.append (10); print y imprimir&amp;aacute; &lt;code&gt;[10]&lt;/code&gt; . La lista vac&amp;iacute;a fue creada. Tanto &quot;x&quot; como &quot;y&quot; apuntan a la misma lista. El m&amp;eacute;todo &lt;em&gt;append&lt;/em&gt; muta (actualiza) el objeto de la lista (como agregar un registro a una base de datos) y el resultado es visible tanto para &quot;x&quot; como para &quot;y&quot; (tal como una actualizaci&amp;oacute;n de la base de datos ser&amp;iacute;a visible para cada conexi&amp;oacute;n a esa base de datos).</target>
        </trans-unit>
        <trans-unit id="4498e2a33a71723f43491095390bfa7816d3f75b" translate="yes" xml:space="preserve">
          <source>Objects like strings and integers are &lt;em&gt;immutable&lt;/em&gt;.  This simply means that there are no methods that can change the object after it has been created.  For example, once the integer object one-thousand is created, it will never change.  Math is done by creating new integer objects.</source>
          <target state="translated">Los objetos como cadenas y enteros son &lt;em&gt;inmutables&lt;/em&gt; . Esto simplemente significa que no hay m&amp;eacute;todos que puedan cambiar el objeto despu&amp;eacute;s de que se haya creado. Por ejemplo, una vez que se crea el objeto entero mil, nunca cambiar&amp;aacute;. La matem&amp;aacute;tica se realiza creando nuevos objetos enteros.</target>
        </trans-unit>
        <trans-unit id="27f285ca9e6dbf4bba0bcd6c449903172991d998" translate="yes" xml:space="preserve">
          <source>Obviously the above does not allow &lt;em&gt;reading&lt;/em&gt; the value, only updating it.</source>
          <target state="translated">Obviamente lo anterior no permite &lt;em&gt;leer&lt;/em&gt; el valor, solo actualizarlo.</target>
        </trans-unit>
        <trans-unit id="4751c7c9efc0a91758450a9fee280437f3b71a6f" translate="yes" xml:space="preserve">
          <source>One way is to use &lt;code&gt;global&lt;/code&gt; (for global variables) or &lt;code&gt;nonlocal&lt;/code&gt; (for local variables in a function) in a wrapper function.</source>
          <target state="translated">Una forma es usar &lt;code&gt;global&lt;/code&gt; (para variables globales) o &lt;code&gt;nonlocal&lt;/code&gt; (para variables locales en una funci&amp;oacute;n) en una funci&amp;oacute;n contenedora.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="c439d84dc5a961368d9307e0770827dfc4515420" translate="yes" xml:space="preserve">
          <source>Pass-By-Reference in Python is quite different from the concept of pass by reference in C++/Java.</source>
          <target state="translated">Pass-By-Reference en Python es bastante diferente del concepto de pass by reference en C++Java.</target>
        </trans-unit>
        <trans-unit id="68451aca93c616b65cb7c9047a81894d6b972f90" translate="yes" xml:space="preserve">
          <source>Passing 3 wrappers to access a variable is a bit unwieldy so those can be wrapped into a class that has a proxy attribute:</source>
          <target state="translated">Pasar 3 envoltorios para acceder a una variable es un poco difícil de manejar,así que esos pueden ser envueltos en una clase que tenga un atributo proxy:</target>
        </trans-unit>
        <trans-unit id="0827e8d71a8fb26dad798d59e58b5d9485ef355e" translate="yes" xml:space="preserve">
          <source>Passing an argument into a function also binds a name (the parameter name of the function) to an object.</source>
          <target state="translated">Pasar un argumento a una función también vincula un nombre (el nombre del parámetro de la función)a un objeto.</target>
        </trans-unit>
        <trans-unit id="c8afd49f905bfc9a3cb491f06eb314e73ee2416c" translate="yes" xml:space="preserve">
          <source>Python always uses pass-by-reference values. There isn't any exception. Any variable assignment means copying the reference value. No exception. Any variable is the name bound to the reference value. Always.</source>
          <target state="translated">Python siempre usa valores de referencia de paso.No hay ninguna excepción.Cualquier asignación de variables significa copiar el valor de referencia.No hay ninguna excepción.Cualquier variable es el nombre ligado al valor de referencia.Siempre.</target>
        </trans-unit>
        <trans-unit id="83861cb7e986e86de426cee8c30f2ed20d4ab7fd" translate="yes" xml:space="preserve">
          <source>Python has names and objects.</source>
          <target state="translated">Python tiene nombres y objetos.</target>
        </trans-unit>
        <trans-unit id="5fcbcd2747ab57ca64daa423ac6a3486436e1a62" translate="yes" xml:space="preserve">
          <source>Python&amp;rsquo;s pass-by-assignment scheme isn&amp;rsquo;t quite the same as C++&amp;rsquo;s reference parameters option, but it turns out to be very similar to the argument-passing model of the C language (and others) in practice:</source>
          <target state="translated">El esquema de paso por asignaci&amp;oacute;n de Python no es exactamente lo mismo que la opci&amp;oacute;n de par&amp;aacute;metros de referencia de C ++, pero resulta ser muy similar al modelo de paso de argumentos del lenguaje C (y otros) en la pr&amp;aacute;ctica:</target>
        </trans-unit>
        <trans-unit id="333f7d50ad7e0d3ef1d2d6e716803037e8f19596" translate="yes" xml:space="preserve">
          <source>Pythons &quot;reflection&quot; support makes it possible to get a object that is capable of reassigning a name/variable in a given scope without defining functions explicitly in that scope:</source>
          <target state="translated">El soporte de &quot;reflexión&quot; de las pitones permite obtener un objeto que es capaz de reasignar una variable de nombre en un ámbito determinado sin definir funciones explícitamente en ese ámbito:</target>
        </trans-unit>
        <trans-unit id="afbaddd3494c975f3248038d165efdcb7b42b91c" translate="yes" xml:space="preserve">
          <source>Reference values are hidden in Python. There isn't any explicit user type for storing the reference value. However, you can use a list element (or element in any other suitable container type) as the reference variable, because all containers do store the elements also as references to the target objects. In other words, elements are actually not contained inside the container -- only the references to elements are.</source>
          <target state="translated">Los valores de referencia están ocultos en Python.No hay ningún tipo de usuario explícito para almacenar el valor de referencia.Sin embargo,se puede utilizar un elemento de la lista (o un elemento en cualquier otro tipo de contenedor adecuado)como la variable de referencia,porque todos los contenedores almacenan los elementos también como referencias a los objetos de destino.En otras palabras,los elementos no están realmente contenidos dentro del contenedor,sólo lo están las referencias a los elementos.</target>
        </trans-unit>
        <trans-unit id="a16b36f9b22c19ae3e20f844261f568427971e02" translate="yes" xml:space="preserve">
          <source>See sections &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;3.1&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#naming-and-binding&quot;&gt;4.2&lt;/a&gt; in the Python 3 language reference.</source>
          <target state="translated">Consulte las secciones &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;3.1&lt;/a&gt; y &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#naming-and-binding&quot;&gt;4.2&lt;/a&gt; en la referencia del lenguaje Python 3.</target>
        </trans-unit>
        <trans-unit id="660da67960cf04fb1e0d059bd7853b4c03efc993" translate="yes" xml:space="preserve">
          <source>Since dictionaries are passed by reference, you can use a dict variable to store any referenced values inside it.</source>
          <target state="translated">Como los diccionarios se pasan por referencia,puedes usar una variable dict para almacenar cualquier valor de referencia dentro de ella.</target>
        </trans-unit>
        <trans-unit id="68d4a137bc67d697b621b97d6185016cdb4789cb" translate="yes" xml:space="preserve">
          <source>Since immutable types cannot be modified, they &lt;em&gt;seem&lt;/em&gt; like being passed by value - passing an int into a function means assigning the int to the function's parameter. You can only ever reassign that, but it won't change the original variables value.</source>
          <target state="translated">Dado que los tipos inmutables no pueden modificarse, &lt;em&gt;parecen&lt;/em&gt; pasar por valor: pasar un int a una funci&amp;oacute;n significa asignar el int al par&amp;aacute;metro de la funci&amp;oacute;n. Solo puede reasignar eso, pero no cambiar&amp;aacute; el valor de las variables originales.</target>
        </trans-unit>
        <trans-unit id="696917aad2c2b30ef73b056904aa4dea2ce6c676" translate="yes" xml:space="preserve">
          <source>Since it seems to be nowhere mentioned an approach to simulate references as known from e.g. C++ is to use an &quot;update&quot; function and pass that instead of the actual variable (or rather, &quot;name&quot;):</source>
          <target state="translated">Como parece que no se menciona en ninguna parte,un enfoque para simular referencias,como se conoce,por ejemplo,de C++,consiste en utilizar una función de &quot;actualización&quot; y pasarla en lugar de la variable real (o mejor dicho,&quot;nombre&quot;):</target>
        </trans-unit>
        <trans-unit id="5d727a1d706032a86c18b0a92e1ed2ead4954513" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;the_list&lt;/code&gt; parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The &lt;code&gt;the_list&lt;/code&gt; was a copy of the &lt;code&gt;outer_list&lt;/code&gt; reference, and we had &lt;code&gt;the_list&lt;/code&gt; point to a new list, but there was no way to change where &lt;code&gt;outer_list&lt;/code&gt; pointed.</source>
          <target state="translated">Como el par&amp;aacute;metro &lt;code&gt;the_list&lt;/code&gt; se pas&amp;oacute; por valor, asignarle una nueva lista no tuvo ning&amp;uacute;n efecto que el c&amp;oacute;digo fuera del m&amp;eacute;todo pudiera ver. &lt;code&gt;the_list&lt;/code&gt; era una copia de la referencia &lt;code&gt;outer_list&lt;/code&gt; , y ten&amp;iacute;amos que &lt;code&gt;the_list&lt;/code&gt; apuntaba a una nueva lista, pero no hab&amp;iacute;a forma de cambiar a d&amp;oacute;nde apuntaba &lt;code&gt;outer_list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36f7beed038b24998576a94eef27bf913f6ed625" translate="yes" xml:space="preserve">
          <source>Since the parameter passed in is a reference to &lt;code&gt;outer_list&lt;/code&gt;, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.</source>
          <target state="translated">Como el par&amp;aacute;metro pasado es una referencia a la lista &lt;code&gt;outer_list&lt;/code&gt; , no una copia de &amp;eacute;l, podemos usar los m&amp;eacute;todos de la lista de mutaciones para cambiarlo y hacer que los cambios se reflejen en el alcance externo.</target>
        </trans-unit>
        <trans-unit id="e6e9cfc9cdfcbeabab6f908af34edaef10d1407d" translate="yes" xml:space="preserve">
          <source>Since your example happens to be object-oriented, you could make the following change to achieve a similar result:</source>
          <target state="translated">Dado que su ejemplo está orientado a los objetos,podría hacer el siguiente cambio para lograr un resultado similar:</target>
        </trans-unit>
        <trans-unit id="c8af5c8a28c9b058781cfa18faaa84372e62a5df" translate="yes" xml:space="preserve">
          <source>So if the thing you want to change is a mutable object, there is no problem, as everything is effectively passed by reference.</source>
          <target state="translated">Así que si lo que quieres cambiar es un objeto mutable,no hay problema,ya que todo se pasa efectivamente por referencia.</target>
        </trans-unit>
        <trans-unit id="bf807aabb75019d89aff61af1c01d7c2a1d18f4d" translate="yes" xml:space="preserve">
          <source>So, when passing a list to a function/method, the list is assigned to the parameter name. Appending to the list will result in the list being modified. Reassigning the list &lt;em&gt;inside&lt;/em&gt; the function will not change the original list, since:</source>
          <target state="translated">Entonces, al pasar una lista a una funci&amp;oacute;n / m&amp;eacute;todo, la lista se asigna al nombre del par&amp;aacute;metro. Si se agrega a la lista, se modificar&amp;aacute; la lista. La reasignaci&amp;oacute;n de la lista &lt;em&gt;dentro de&lt;/em&gt; la funci&amp;oacute;n no cambiar&amp;aacute; la lista original, ya que:</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="d7a557055e4e02657c23b68f42103ada3c99dabb" translate="yes" xml:space="preserve">
          <source>String - an immutable type</source>
          <target state="translated">Cuerda-un tipo inmutable</target>
        </trans-unit>
        <trans-unit id="7c1fdc94b36a2d1a36919d71bce545b535714140" translate="yes" xml:space="preserve">
          <source>Technically, &lt;strong&gt;Python always uses pass by reference values&lt;/strong&gt;. I am going to repeat &lt;a href=&quot;https://stackoverflow.com/a/12438316/1346705&quot;&gt;my other answer&lt;/a&gt; to support my statement.</source>
          <target state="translated">T&amp;eacute;cnicamente, &lt;strong&gt;Python siempre usa el paso por valores de referencia&lt;/strong&gt; . Voy a repetir &lt;a href=&quot;https://stackoverflow.com/a/12438316/1346705&quot;&gt;mi otra respuesta&lt;/a&gt; para apoyar mi afirmaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="79c2b7cf71267d7a5e78f89f251fffbff74bb65a" translate="yes" xml:space="preserve">
          <source>That is all there is to it. Mutability is irrelevant for this question.</source>
          <target state="translated">Eso es todo lo que hay.La mutabilidad es irrelevante para esta pregunta.</target>
        </trans-unit>
        <trans-unit id="17becfeedaa8893ff84a47a35ec6e3e49715fa72" translate="yes" xml:space="preserve">
          <source>The Python documentation seems unclear about whether parameters are passed by reference or value, and the following code produces the unchanged value 'Original'</source>
          <target state="translated">La documentación de Python parece poco clara sobre si los parámetros se pasan por referencia o por valor,y el siguiente código produce el valor inalterado &quot;Original</target>
        </trans-unit>
        <trans-unit id="f2fff69c21168bf26f5b1e057e178f0b3f2e5e7c" translate="yes" xml:space="preserve">
          <source>The actual object - [0, 1] (which would be called a value in other programming languages) is being passed. So in fact the function &lt;code&gt;change_me&lt;/code&gt; will try to do something like:</source>
          <target state="translated">Se pasa el objeto real - [0, 1] (que se llamar&amp;iacute;a un valor en otros lenguajes de programaci&amp;oacute;n). Entonces, de hecho, la funci&amp;oacute;n &lt;code&gt;change_me&lt;/code&gt; intentar&amp;aacute; hacer algo como:</target>
        </trans-unit>
        <trans-unit id="a681daed3a2466279708eadd396f12d4619acbc1" translate="yes" xml:space="preserve">
          <source>The assignment to an global variable that is not declared global therefore creates a new local object and breaks the link to the original object.</source>
          <target state="translated">La asignación a una variable global que no es declarada global crea por lo tanto un nuevo objeto local y rompe el vínculo con el objeto original.</target>
        </trans-unit>
        <trans-unit id="dcf126983674f03f5b7e37d5d854435177547ce6" translate="yes" xml:space="preserve">
          <source>The basic idea is to have a function that can do that access and can be passed as object into other functions or stored in a class.</source>
          <target state="translated">La idea básica es tener una función que pueda hacer ese acceso y que pueda ser pasada como objeto a otras funciones o almacenada en una clase.</target>
        </trans-unit>
        <trans-unit id="0bc22d9160e54688c508487d4bc0a30f0fedfd8c" translate="yes" xml:space="preserve">
          <source>The key to understanding parameter passing is to stop thinking about &quot;variables&quot;. There are names and objects in Python and together they
appear like variables, but it is useful to always distinguish the three.</source>
          <target state="translated">La clave para entender el paso de parámetros es dejar de pensar en &quot;variables&quot;.Hay nombres y objetos en Python y juntos aparecen como variables,pero es útil distinguir siempre los tres.</target>
        </trans-unit>
        <trans-unit id="4ab82925dc8dd0f7cb7b601b15859baf0d62bc4d" translate="yes" xml:space="preserve">
          <source>The more &lt;a href=&quot;https://www.python.org/dev/peps/pep-0020/&quot;&gt;pythonic&lt;/a&gt; approach would be to introduce a trivial, one-attribute class. The function receives an instance of the class and manipulates the attribute.</source>
          <target state="translated">El enfoque m&amp;aacute;s &lt;a href=&quot;https://www.python.org/dev/peps/pep-0020/&quot;&gt;pit&amp;oacute;nico&lt;/a&gt; ser&amp;iacute;a introducir una clase trivial de un atributo. La funci&amp;oacute;n recibe una instancia de la clase y manipula el atributo.</target>
        </trans-unit>
        <trans-unit id="cc1762bcf99fc58408f1a9ef7986e8348ee28a58" translate="yes" xml:space="preserve">
          <source>The only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places.</source>
          <target state="translated">La única forma de evitar esto es pasar un objeto mutable.Debido a que ambas referencias se refieren al mismo objeto,cualquier cambio en el objeto se refleja en ambos lugares.</target>
        </trans-unit>
        <trans-unit id="6fad76f326204f89d7ac6ac50ce5db14000add4d" translate="yes" xml:space="preserve">
          <source>The problem comes from a misunderstanding of what variables are in Python. If you're used to most traditional languages, you have a mental model of what happens in the following sequence:</source>
          <target state="translated">El problema viene de un malentendido de qué variables hay en Python.Si estás acostumbrado a la mayoría de los lenguajes tradicionales,tienes un modelo mental de lo que sucede en la siguiente secuencia:</target>
        </trans-unit>
        <trans-unit id="84175dec5b4dc806baa482e3939f43855a2e8b04" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty solution for this is a one-element list (instead of &lt;code&gt;self.variable&lt;/code&gt;, pass &lt;code&gt;[self.variable]&lt;/code&gt; and in the function modify &lt;code&gt;var[0]&lt;/code&gt;).</source>
          <target state="translated">La soluci&amp;oacute;n r&amp;aacute;pida y sucia para esto es una lista de un elemento (en lugar de &lt;code&gt;self.variable&lt;/code&gt; , pase &lt;code&gt;[self.variable]&lt;/code&gt; y en la funci&amp;oacute;n modifique &lt;code&gt;var[0]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="13c1347e705ce1693fe7d2b8e953c905989ca4b8" translate="yes" xml:space="preserve">
          <source>The same idea works for reading and &lt;code&gt;del&lt;/code&gt;eting a variable.</source>
          <target state="translated">La misma idea funciona para leer y eliminar una variable.</target>
        </trans-unit>
        <trans-unit id="5db310989aa7591454c760958f2af239e823a8c7" translate="yes" xml:space="preserve">
          <source>Then the call would result in:</source>
          <target state="translated">Entonces la llamada resultaría:</target>
        </trans-unit>
        <trans-unit id="0105c63c552b46ed256ace297e33009660aef599" translate="yes" xml:space="preserve">
          <source>There are no variables in Python</source>
          <target state="translated">No hay variables en Python</target>
        </trans-unit>
        <trans-unit id="086a535eed287fb2a8da5e4f2b4da1059486d637" translate="yes" xml:space="preserve">
          <source>There is a little trick to pass an object by reference, even though the language doesn't make it possible. It works in Java too, it's the list with one item. ;-)</source>
          <target state="translated">Hay un pequeño truco para pasar un objeto por referencia,aunque el lenguaje no lo permita.Funciona en Java también,es la lista con un objeto.;-)</target>
        </trans-unit>
        <trans-unit id="b1c21ed6d2eec901faa433fdaff0e199b04f81af" translate="yes" xml:space="preserve">
          <source>Think of stuff being passed &lt;strong&gt;by assignment&lt;/strong&gt; instead of by reference/by value. That way, it is always clear, what is happening as long as you understand what happens during the normal assignment.</source>
          <target state="translated">Piense en cosas que se pasan &lt;strong&gt;por asignaci&amp;oacute;n en&lt;/strong&gt; lugar de por referencia / por valor. De esa manera, siempre est&amp;aacute; claro lo que est&amp;aacute; sucediendo siempre que comprenda lo que sucede durante la tarea normal.</target>
        </trans-unit>
        <trans-unit id="c5a5244ffa8b4f4ae77f3d588812cda61fa6be3d" translate="yes" xml:space="preserve">
          <source>This binds the name &lt;code&gt;a&lt;/code&gt; to an object of type integer that holds the value 1.</source>
          <target state="translated">Esto vincula el nombre &lt;code&gt;a&lt;/code&gt; a un objeto de tipo entero que contiene el valor 1.</target>
        </trans-unit>
        <trans-unit id="884b42766d553e6f4cff2ad92ade45f883bf6559" translate="yes" xml:space="preserve">
          <source>This binds the name &lt;code&gt;b&lt;/code&gt; to the same object that the name &lt;code&gt;x&lt;/code&gt; is currently bound to.
Afterwards, the name &lt;code&gt;b&lt;/code&gt; has nothing to do with the name &lt;code&gt;x&lt;/code&gt; any more.</source>
          <target state="translated">Esto vincula el nombre &lt;code&gt;b&lt;/code&gt; al mismo objeto al que est&amp;aacute; vinculado actualmente el nombre &lt;code&gt;x&lt;/code&gt; . Despu&amp;eacute;s, el nombre &lt;code&gt;b&lt;/code&gt; ya no tiene nada que ver con el nombre &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a0da37fa36be60c0aa098be25fccdb7e017ac1b" translate="yes" xml:space="preserve">
          <source>This is mostly useful for &quot;out-only references&quot; or in a situation with multiple threads / processes (by making the update function thread / multiprocessing safe).</source>
          <target state="translated">Esto es útil sobre todo para las &quot;referencias externas&quot; o en una situación con procesos de múltiples hilos (haciendo que la función de actualización de los hilos sea segura).</target>
        </trans-unit>
        <trans-unit id="2f1f28564cc17f4b95f8008ecbf300883f70aebb" translate="yes" xml:space="preserve">
          <source>To make it even more clear, let's have some examples.</source>
          <target state="translated">Para que quede aún más claro,pongamos algunos ejemplos.</target>
        </trans-unit>
        <trans-unit id="5623b8a007cec828bd71b838af98d8c9977c1510" translate="yes" xml:space="preserve">
          <source>To the extent that Python is pass by value, all languages are pass by value since some piece of data (be it a &quot;value&quot; or a &quot;reference&quot;) must be sent. However, that does not mean that Python is pass by value in the sense that a C programmer would think of it.</source>
          <target state="translated">En la medida en que Python se pasa de valor,todos los idiomas se pasan de valor ya que se debe enviar algún dato (ya sea un &quot;valor&quot; o una &quot;referencia&quot;).Sin embargo,eso no significa que Python sea un valor pass by en el sentido en que un programador de C lo pensaría.</target>
        </trans-unit>
        <trans-unit id="20555a4a440b0601df4fa798a89247c553a96ccf" translate="yes" xml:space="preserve">
          <source>When you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there's no way to update that reference and make it refer to a new object. In your example:</source>
          <target state="translated">Cuando se llama una función con un parámetro,se crea una nueva referencia que se refiere al objeto pasado.Esto es independiente de la referencia que se utilizó en la llamada de la función,por lo que no hay forma de actualizar esa referencia y hacer que se refiera a un nuevo objeto.En su ejemplo:</target>
        </trans-unit>
        <trans-unit id="bc3fa5ea94b2efd9143d2934a64ae051133be6ed" translate="yes" xml:space="preserve">
          <source>When you do a new assignment such as &lt;code&gt;y = x&lt;/code&gt;, a new dictionary entry &quot;y&quot; is created that points to the same object as the entry for &quot;x&quot;.</source>
          <target state="translated">Cuando realiza una nueva asignaci&amp;oacute;n, como &lt;code&gt;y = x&lt;/code&gt; , se crea una nueva entrada de diccionario &quot;y&quot; que apunta al mismo objeto que la entrada de &quot;x&quot;.</target>
        </trans-unit>
        <trans-unit id="a8ec35d9c1b72807f2ded385deffa6f8aa373d72" translate="yes" xml:space="preserve">
          <source>When you make an assignment such as &lt;code&gt;x = 1000&lt;/code&gt;, a dictionary entry is created that maps the string &quot;x&quot; in the current namespace to a pointer to the integer object containing one thousand.</source>
          <target state="translated">Cuando realiza una asignaci&amp;oacute;n como &lt;code&gt;x = 1000&lt;/code&gt; , se crea una entrada de diccionario que asigna la cadena &quot;x&quot; en el espacio de nombres actual a un puntero al objeto entero que contiene mil.</target>
        </trans-unit>
        <trans-unit id="e648dd9f3d5b78507aba8fd21719ec93fe30b1ca" translate="yes" xml:space="preserve">
          <source>When you update &quot;x&quot; with &lt;code&gt;x = 2000&lt;/code&gt;, a new integer object is created and the dictionary is updated to point at the new object.  The old one thousand object is unchanged (and may or may not be alive depending on whether anything else refers to the object).</source>
          <target state="translated">Cuando actualiza &quot;x&quot; con &lt;code&gt;x = 2000&lt;/code&gt; , se crea un nuevo objeto entero y el diccionario se actualiza para apuntar al nuevo objeto. El antiguo objeto mil no ha cambiado (y puede o no estar vivo dependiendo de si algo m&amp;aacute;s se refiere al objeto).</target>
        </trans-unit>
        <trans-unit id="13eb328770b9c46bbd56e2839f367e0a7b3f96db" translate="yes" xml:space="preserve">
          <source>Whenever you pass an object to the function, the object itself is passed (object in Python is actually what you'd call a value in other programming languages) not the reference to this object. In other words, when you call:</source>
          <target state="translated">Cada vez que se pasa un objeto a la función,se pasa el objeto en sí (el objeto en Python es en realidad lo que se llamaría un valor en otros lenguajes de programación)no la referencia a este objeto.En otras palabras,cuando llamas:</target>
        </trans-unit>
        <trans-unit id="6b4cb23677b917c5c42bbdb41b1590df3465a4db" translate="yes" xml:space="preserve">
          <source>While pass by reference is nothing that fits well into python and should be rarely used there are some workarounds that actually can work to get the object currently assigned to a local variable or even reassign a local variable from inside of a called function.</source>
          <target state="translated">Aunque el paso por referencia no es nada que encaje bien en la pitón y debería usarse raramente,hay algunas soluciones provisionales que pueden funcionar para conseguir que el objeto actualmente asignado a una variable local o incluso reasignar una variable local desde el interior de una función llamada.</target>
        </trans-unit>
        <trans-unit id="06ef8c07f183597c6357e8005336de31d41ec30c" translate="yes" xml:space="preserve">
          <source>You believe that &lt;code&gt;a&lt;/code&gt; is a memory location that stores the value &lt;code&gt;1&lt;/code&gt;, then is updated to store the value &lt;code&gt;2&lt;/code&gt;. That's not how things work in Python. Rather, &lt;code&gt;a&lt;/code&gt; starts as a reference to an object with the value &lt;code&gt;1&lt;/code&gt;, then gets reassigned as a reference to an object with the value &lt;code&gt;2&lt;/code&gt;. Those two objects may continue to coexist even though &lt;code&gt;a&lt;/code&gt; doesn't refer to the first one anymore; in fact they may be shared by any number of other references within the program.</source>
          <target state="translated">Cree que &lt;code&gt;a&lt;/code&gt; es una ubicaci&amp;oacute;n de memoria que almacena el valor &lt;code&gt;1&lt;/code&gt; , luego se actualiza para almacenar el valor &lt;code&gt;2&lt;/code&gt; . As&amp;iacute; no es como funcionan las cosas en Python. Por el contrario, &lt;code&gt;a&lt;/code&gt; comienza como una referencia a un objeto con el valor &lt;code&gt;1&lt;/code&gt; , luego se reasigna como referencia a un objeto con el valor &lt;code&gt;2&lt;/code&gt; . Esos dos objetos pueden continuar coexistiendo aunque &lt;code&gt;a&lt;/code&gt; ya no se refiera al primero; de hecho, pueden ser compartidos por cualquier n&amp;uacute;mero de otras referencias dentro del programa.</target>
        </trans-unit>
        <trans-unit id="6cbe72d4aff2f1d3e9fb3501cd97383b70fd44e7" translate="yes" xml:space="preserve">
          <source>You can merely use &lt;strong&gt;an empty class&lt;/strong&gt; as an instance to store reference objects because internally object attributes are stored in an instance dictionary. See the example.</source>
          <target state="translated">Simplemente puede usar &lt;strong&gt;una clase vac&amp;iacute;a&lt;/strong&gt; como una instancia para almacenar objetos de referencia porque internamente los atributos de los objetos se almacenan en un diccionario de instancias. Mira el ejemplo.</target>
        </trans-unit>
        <trans-unit id="9e395b0bd4b1dc1eea4d49d8e1f40c5347e0d5a1" translate="yes" xml:space="preserve">
          <source>You can think about a reference value as the address of the target object. The address is automatically dereferenced when used. This way, working with the reference value, it seems you work directly with the target object. But there always is a reference in between, one step more to jump to the target.</source>
          <target state="translated">Puedes pensar en un valor de referencia como la dirección del objeto objetivo.La dirección es automáticamente desreferenciada cuando se utiliza.De esta manera,trabajando con el valor de referencia,parece que se trabaja directamente con el objeto de destino.Pero siempre hay una referencia intermedia,un paso más para saltar al objetivo.</target>
        </trans-unit>
        <trans-unit id="233857d84270d4d4cf81d2ab105c0ebb1d786176" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://docs.python.org/3.3/library/functions.html#id&quot;&gt;&lt;code&gt;id()&lt;/code&gt;&lt;/a&gt; built-in function to learn what the reference value is (that is, the address of the target object).</source>
          <target state="translated">Puede usar la funci&amp;oacute;n incorporada &lt;a href=&quot;http://docs.python.org/3.3/library/functions.html#id&quot;&gt; &lt;code&gt;id()&lt;/code&gt; &lt;/a&gt; para saber cu&amp;aacute;l es el valor de referencia (es decir, la direcci&amp;oacute;n del objeto de destino).</target>
        </trans-unit>
        <trans-unit id="fee26813eb63428556d25e99b697066a5abee304" translate="yes" xml:space="preserve">
          <source>You got some really good answers here.</source>
          <target state="translated">Tienes muy buenas respuestas aquí.</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="ac2c0095bbd1e16c2e3606675ef16ab060af766f" translate="yes" xml:space="preserve">
          <source>given the way python handles values and references to them, the only way you can reference an arbitrary instance attribute is by name:</source>
          <target state="translated">Dada la forma en que Python maneja los valores y las referencias a los mismos,la única forma de referirse a un atributo de instancia arbitraria es por el nombre:</target>
        </trans-unit>
        <trans-unit id="5dcfdd557133c0be7c75544c8a554ac3a7ddef6a" translate="yes" xml:space="preserve">
          <source>gives:</source>
          <target state="translated">gives:</target>
        </trans-unit>
        <trans-unit id="31cef82f841f61f64a2b51817dadd21b57e78be6" translate="yes" xml:space="preserve">
          <source>in real code you would, of course, add error checking on the dict lookup.</source>
          <target state="translated">en código real,por supuesto,añadiría la comprobación de errores en la búsqueda de dictados.</target>
        </trans-unit>
        <trans-unit id="1d8a6a9487c9bd9e3711fa2119286c096444a2f6" translate="yes" xml:space="preserve">
          <source>some data types are mutable, but others aren't</source>
          <target state="translated">algunos tipos de datos son mutables,pero otros no lo son</target>
        </trans-unit>
        <trans-unit id="5f0f7656c197d2526aa255c56c1295fe45b9916d" translate="yes" xml:space="preserve">
          <source>the parameter passed in is actually a &lt;em&gt;reference&lt;/em&gt; to an object (but the reference is passed by value)</source>
          <target state="translated">el par&amp;aacute;metro pasado es en realidad una &lt;em&gt;referencia&lt;/em&gt; a un objeto (pero la referencia se pasa por valor)</target>
        </trans-unit>
        <trans-unit id="9789798d32b8f1cb1ca7e4b37e5b087b68d91f3c" translate="yes" xml:space="preserve">
          <source>which obviously will change the object. &lt;a href=&quot;https://stackoverflow.com/a/534509/831531&quot;&gt;This answer&lt;/a&gt; explains it well.</source>
          <target state="translated">que obviamente cambiar&amp;aacute; el objeto. &lt;a href=&quot;https://stackoverflow.com/a/534509/831531&quot;&gt;Esta respuesta lo&lt;/a&gt; explica bien.</target>
        </trans-unit>
        <trans-unit id="0a5dcf0aaba3d474366727f90d67aa1948bf146f" translate="yes" xml:space="preserve">
          <source>which obviously will not change the object passed to the function. If the function looked like this:</source>
          <target state="translated">que obviamente no cambiará el objeto pasado a la función.Si la función se viera así:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
