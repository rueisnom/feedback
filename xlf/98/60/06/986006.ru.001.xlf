<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/986006">
    <body>
      <group id="986006">
        <trans-unit id="a1b152a892ef513d9a4d8de1e227286558de128b" translate="yes" xml:space="preserve">
          <source>&quot;...variables [names] are &lt;em&gt;not&lt;/em&gt; objects; they cannot be denoted by other variables or referred to by objects.&quot;</source>
          <target state="translated">&amp;laquo;... переменные [имена] &lt;em&gt;не&lt;/em&gt; являются объектами; их нельзя обозначать другими переменными или ссылаться на объекты&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ec2f8b9ef1eca2860982704b2396e6f5e99305cc" translate="yes" xml:space="preserve">
          <source>&quot;In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a new value anywhere within the function&amp;rsquo;s body, it&amp;rsquo;s assumed to be a local. If a variable is ever assigned a new value inside the function, the variable is implicitly local, and you need to explicitly declare it as &amp;lsquo;global&amp;rsquo;.
Though a bit surprising at first, a moment&amp;rsquo;s consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, you&amp;rsquo;d be using global all the time. You&amp;rsquo;d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.&quot;</source>
          <target state="translated">&amp;laquo;В Python переменные, на которые ссылаются только внутри функции, неявно глобальны. Если переменной назначено новое значение где-либо в теле функции, она считается локальной. Если переменной когда-либо назначается новое значение внутри функции, переменная неявно локальна, и вам необходимо явно объявить ее как &amp;laquo;глобальную&amp;raquo;. Хотя сначала это немного удивляет, но это объясняется моментально. С одной стороны, требование глобальной переменной для назначенных переменных обеспечивает защиту от непреднамеренных побочных эффектов. с другой стороны, если бы глобальный требовался для всех глобальных ссылок, вы бы все время использовали глобальный. Вам пришлось бы объявлять как глобальные все ссылки на встроенную функцию или компонент импортируемого модуля. Этот беспорядок будет побеждать полезность глобальной декларации для выявления побочных эффектов &quot;.</target>
        </trans-unit>
        <trans-unit id="42c22aec244c5d347e54be65aaab6403cdf146a7" translate="yes" xml:space="preserve">
          <source>(Yeah I know this can be inconvenient, but sometimes it is simple enough to do this.)</source>
          <target state="translated">(Да,я знаю,что это может быть неудобно,но иногда это достаточно просто.)</target>
        </trans-unit>
        <trans-unit id="8a51a221218346c2c1772a44d0e7cc971cece6c5" translate="yes" xml:space="preserve">
          <source>(edit - Blair has updated his enormously popular answer so that it is now accurate)</source>
          <target state="translated">(редактирование-Блэр обновила свой невероятно популярный ответ,так что теперь он точный)</target>
        </trans-unit>
        <trans-unit id="a62a78c201c7282875384fa5a4bbe69e0365e928" translate="yes" xml:space="preserve">
          <source>(edit 2019-04-28)</source>
          <target state="translated">(редакция 2019-04-28)</target>
        </trans-unit>
        <trans-unit id="8b9f3efa3729cce732344f81bf8d7d82f28606bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self.variable&lt;/code&gt; is a reference to the string object &lt;code&gt;'Original'&lt;/code&gt;. When you call &lt;code&gt;Change&lt;/code&gt; you create a second reference &lt;code&gt;var&lt;/code&gt; to the object. Inside the function you reassign the reference &lt;code&gt;var&lt;/code&gt; to a different string object &lt;code&gt;'Changed'&lt;/code&gt;, but the reference &lt;code&gt;self.variable&lt;/code&gt; is separate and does not change.</source>
          <target state="translated">&lt;code&gt;self.variable&lt;/code&gt; является ссылкой на строковый объект &lt;code&gt;'Original'&lt;/code&gt; . Когда вы вызываете &lt;code&gt;Change&lt;/code&gt; , вы создаете вторую ссылку на объект. Внутри функции вы переназначаете ссылку &lt;code&gt;var&lt;/code&gt; на другой строковый объект &lt;code&gt;'Changed'&lt;/code&gt; , но ссылка &lt;code&gt;self.variable&lt;/code&gt; является отдельной и не изменяется.</target>
        </trans-unit>
        <trans-unit id="4229ed636553c69cfddd84246fc10b33ff69719b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++:&lt;/strong&gt; Both pass-by-reference or pass-by-value are allowed. If a parameter is passed by reference, you can either modify it or not depending upon whether the parameter was passed as const or not. However, const or not, the parameter maintains the reference to the object and reference cannot be assigned to point to a different object within the called function.</source>
          <target state="translated">&lt;strong&gt;C ++:&lt;/strong&gt; допускается как передача по ссылке, так и передача по значению. Если параметр передается по ссылке, вы можете изменить его или нет, в зависимости от того, был ли параметр передан как const или нет. Однако, const или нет, параметр поддерживает ссылку на объект, и ссылка не может быть назначена для указания на другой объект в вызываемой функции.</target>
        </trans-unit>
        <trans-unit id="b3be1ec03105d4972fcbe3fec3a499e2307f9ee7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; It's been noted that this doesn't answer the question that @David originally asked, &quot;Is there something I can do to pass the variable by actual reference?&quot;. Let's work on that.</source>
          <target state="translated">&lt;strong&gt;РЕДАКТИРОВАТЬ:&lt;/strong&gt; Было отмечено, что это не отвечает на вопрос, который первоначально задавал @David, &amp;laquo;Есть ли что-то, что я могу сделать, чтобы передать переменную по фактической ссылке?&amp;raquo;. Давайте работать над этим.</target>
        </trans-unit>
        <trans-unit id="d892af211725dce0575cd510d5913eae3f198cec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's immutable, so there's nothing we can do to change the contents of the string&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Он неизменен, поэтому мы ничего не можем сделать, чтобы изменить содержимое строки&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee9513e042a85a4c63813585beec33bd12875b0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java&amp;amp;C#:&lt;/strong&gt; primitive types(include string)pass by value(copy), Reference type is passed by reference(address copy) so all changes made in the parameter in the called function are visible to the caller.</source>
          <target state="translated">&lt;strong&gt;Java &amp;amp; C #:&lt;/strong&gt; типы примитивов (включая строку) передаются по значению (копия), тип ссылки передается по ссылке (копирование адреса), поэтому все изменения, внесенные в параметр в вызываемой функции, видны вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="b6bd3f4d372e7f7c7ecfb3b235bcc93f977ff2b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's try to modify the list that was passed to a method:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Давайте попробуем изменить список, который был передан методу:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be2b61cd76cc0ed218c950fa9a0f695fe658d0b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now let's see what happens when we try to change the reference that was passed in as a parameter:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Теперь давайте посмотрим, что происходит, когда мы пытаемся изменить ссылку, переданную в качестве параметра:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1bb1d2d46eeb3cfe61924c812bf981baeae0193b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now, let's try to change the reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Теперь давайте попробуем изменить ссылку&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5b90913af1169e0301615a93fc64f0e5b948b1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python:&lt;/strong&gt; 
Python is &amp;ldquo;pass-by-object-reference&amp;rdquo;, of which it is often said: &amp;ldquo;Object references are passed by value.&amp;rdquo;[Read here]&lt;a href=&quot;https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/&quot;&gt;1&lt;/a&gt;. Both the caller and the function refer to the same object but the parameter in the function is a new variable which is just holding a copy of the object in the caller. Like C++, a parameter can be either modified or not in function - This depends upon the type of object passed. eg; An immutable object type cannot be modified in the called function whereas a mutable object can be either updated or re-initialized. A crucial difference between updating or re-assigning/re-initializing the mutable variable is that updated value gets reflected back in the called function whereas the reinitialized value does not. Scope of any assignment of new object to a mutable variable is local to the function in the python. Examples provided by @blair-conrad are great to understand this.</source>
          <target state="translated">&lt;strong&gt;Python:&lt;/strong&gt; Python является &amp;laquo;передачей по ссылке на объект&amp;raquo;, о которой часто говорят: &amp;laquo;Ссылки на объекты передаются по значению&amp;raquo;. [Читать здесь] &lt;a href=&quot;https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/&quot;&gt;1&lt;/a&gt; . И вызывающая сторона, и функция ссылаются на один и тот же объект, но параметр в функции - это новая переменная, которая просто хранит копию объекта в вызывающей стороне. Как и в C ++, параметр может быть изменен или не изменен в функции - это зависит от типа передаваемого объекта. например; Тип неизменяемого объекта не может быть изменен в вызываемой функции, тогда как изменяемый объект может быть либо обновлен, либо повторно инициализирован. Принципиальное различие между обновлением или повторным назначением / повторной инициализацией изменяемой переменной заключается в том, что обновленное значение отражается обратно в вызываемой функции, а реинициализированное значение - нет. Область любого назначения нового объекта изменяемой переменной является локальной для функции в питоне. Примеры, предоставленные @ blair-conrad, прекрасно это понимают.</target>
        </trans-unit>
        <trans-unit id="9883e919e7997c4bcd00e7db78ba8af7ca037be6" translate="yes" xml:space="preserve">
          <source>A lot of insights in answers here, but i think an additional point is not clearly mentioned here explicitly.   Quoting from python documentation &lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&lt;/a&gt;</source>
          <target state="translated">Здесь есть много идей для ответов, но я думаю, что дополнительный момент здесь явно не упоминается. Цитирование из документации по Python &lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b9bc6a21011e77a1fc1acf4db17ae8c442f98ed" translate="yes" xml:space="preserve">
          <source>A simple trick I normally use is to just wrap it in a list:</source>
          <target state="translated">Простой трюк,который я обычно использую,это просто завернуть его в список:</target>
        </trans-unit>
        <trans-unit id="1c34629702aff601e9017462b805c4e1564c10a6" translate="yes" xml:space="preserve">
          <source>Again, since the &lt;code&gt;the_string&lt;/code&gt; parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The &lt;code&gt;the_string&lt;/code&gt; was a copy of the &lt;code&gt;outer_string&lt;/code&gt; reference, and we had &lt;code&gt;the_string&lt;/code&gt; point to a new string, but there was no way to change where &lt;code&gt;outer_string&lt;/code&gt; pointed.</source>
          <target state="translated">Опять же, поскольку параметр &lt;code&gt;the_string&lt;/code&gt; был передан по значению, присвоение ему новой строки не имело эффекта, который мог видеть код вне метода. &lt;code&gt;the_string&lt;/code&gt; была копией ссылки на &lt;code&gt;outer_string&lt;/code&gt; , и у нас была &lt;code&gt;the_string&lt;/code&gt; на новую строку, но не было никакого способа изменить &lt;code&gt;outer_string&lt;/code&gt; указывает external_string .</target>
        </trans-unit>
        <trans-unit id="c9e5405e129e476d3e0ef475249c330ed3f6dfb5" translate="yes" xml:space="preserve">
          <source>Although this seems a little cumbersome.</source>
          <target state="translated">Хотя это кажется немного громоздким.</target>
        </trans-unit>
        <trans-unit id="2d97b97ac2c4c28ba96535277dd72cff612ba228" translate="yes" xml:space="preserve">
          <source>Another solution would be to create a static method like this:</source>
          <target state="translated">Другим решением было бы создание статического метода,подобного этому:</target>
        </trans-unit>
        <trans-unit id="b0c7226e7708d9f8704f1ddf855b76d4d0e697d8" translate="yes" xml:space="preserve">
          <source>Arguments are &lt;a href=&quot;http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference&quot;&gt;passed by assignment&lt;/a&gt;. The rationale behind this is twofold:</source>
          <target state="translated">Аргументы &lt;a href=&quot;http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference&quot;&gt;передаются по назначению&lt;/a&gt; . Обоснование этого двоякое:</target>
        </trans-unit>
        <trans-unit id="57fce48e3511c0b229efd7be720f8de1904d6840" translate="yes" xml:space="preserve">
          <source>As @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out:</source>
          <target state="translated">Как показывает ответ @Andrea,вы можете вернуть новое значение.Это не меняет способ передачи вещей,но позволяет получить обратно нужную информацию:</target>
        </trans-unit>
        <trans-unit id="3fc39df4449e0220d47d2afd67496a6547200ecf" translate="yes" xml:space="preserve">
          <source>As you can state you need to have a mutable object, but let me suggest you to check over the global variables as they can help you or even solve this kind of issue!</source>
          <target state="translated">Как вы можете утверждать,вам нужен мутируемый объект,но позвольте мне предложить вам проверить глобальные переменные,так как они могут помочь вам или даже решить эту проблему!</target>
        </trans-unit>
        <trans-unit id="1173d3f94d407863d6672e2edbfad0d748c8d95e" translate="yes" xml:space="preserve">
          <source>Aside from all the great explanations on how this stuff works in Python, I don't see a simple suggestion for the problem. As you seem to do create objects and instances, the pythonic way of handling instance variables and changing them is the following:</source>
          <target state="translated">Помимо всех замечательных объяснений того,как эта штука работает на Python,я не вижу простого предложения по решению этой проблемы.Как вы,кажется,создаёте объекты и экземпляры,питонический способ работы с переменными экземпляров и их изменения заключается в следующем:</target>
        </trans-unit>
        <trans-unit id="955f20c5fd3d4cf266b4f4f30cefc9bede9bc806" translate="yes" xml:space="preserve">
          <source>Assignment binds a name to an object.</source>
          <target state="translated">Назначение привязывает имя к объекту.</target>
        </trans-unit>
        <trans-unit id="44eb458222e5cac4dd20238f7eb9ffa3a0a032f1" translate="yes" xml:space="preserve">
          <source>David Cournapeau's answer points to the real answer and explains why the behavior in Blair Conrad's post seems to be correct while the definitions are not.</source>
          <target state="translated">Ответ Дэвида Курнапо указывает на реальный ответ и объясняет,почему поведение в посте Блэр Конрад кажется правильным,а определения-нет.</target>
        </trans-unit>
        <trans-unit id="6ba040c2f2a2d80842507aa7fb2215325e5e6c43" translate="yes" xml:space="preserve">
          <source>Effbot (aka Fredrik Lundh) has described Python's variable passing style as call-by-object:  &lt;a href=&quot;http://effbot.org/zone/call-by-object.htm&quot;&gt;http://effbot.org/zone/call-by-object.htm&lt;/a&gt;</source>
          <target state="translated">Эффбот (он же Фредрик Лунд) описал стиль передачи переменных в Python как call-by-object: &lt;a href=&quot;http://effbot.org/zone/call-by-object.htm&quot;&gt;http://effbot.org/zone/call-by-object.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="feb265a8df8e110e2790224a1da7e1861c9fda44" translate="yes" xml:space="preserve">
          <source>Even when passing a mutable object to a function this still applies. And to me clearly explains the reason for the difference in behavior between assigning to the object and operating on the object in the function.</source>
          <target state="translated">Даже при передаче изменяемого объекта в функцию это все равно применяется.И мне ясно объясняет причину разницы в поведении между присвоением объекта и работой над объектом в функции.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="63aabb26e4f4644f4690795ae16738f9c1f5f4da" translate="yes" xml:space="preserve">
          <source>For just reading there is even a shorter way of just using &lt;code&gt;lambda: x&lt;/code&gt; which returns a callable that when called returns the current value of x. This is somewhat like &quot;call by name&quot; used in languages in the distant past.</source>
          <target state="translated">Для простого чтения есть еще более короткий способ использования &lt;code&gt;lambda: x&lt;/code&gt; который возвращает вызываемый объект, который при вызове возвращает текущее значение x. Это немного похоже на &amp;laquo;звонок по имени&amp;raquo;, используемый в языках далекого прошлого.</target>
        </trans-unit>
        <trans-unit id="a82f8b81c3ead144e50f2f04d42ea8cbd19c3b82" translate="yes" xml:space="preserve">
          <source>Here is a significant quote:</source>
          <target state="translated">Вот важная цитата:</target>
        </trans-unit>
        <trans-unit id="64605a5b8fffbc932d2851dd3c0a9a3b81ea1391" translate="yes" xml:space="preserve">
          <source>Here is the example that proves that Python uses passing by reference:</source>
          <target state="translated">Вот пример,который доказывает,что Python использует передачу по ссылке:</target>
        </trans-unit>
        <trans-unit id="4652a9a03eda229eaa585e4d8b3108f912ea3767" translate="yes" xml:space="preserve">
          <source>Here is the simple (I hope) explanation of the concept &lt;code&gt;pass by object&lt;/code&gt; used in Python.</source>
          <target state="translated">Вот простое (я надеюсь) объяснение концепции, &lt;code&gt;pass by object&lt;/code&gt; используемой в Python.</target>
        </trans-unit>
        <trans-unit id="48484f80102edbe70571bc88f85e228361438a9f" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;ByRef&lt;/code&gt; class wraps a dictionary access. So attribute access to &lt;code&gt;wrapped&lt;/code&gt; is translated to a item access in the passed dictionary. By passing the result of the builtin &lt;code&gt;locals&lt;/code&gt; and the name of a local variable this ends up accessing a local variable. The python documentation as of 3.5 advises that changing the dictionary might not work but it seems to work for me.</source>
          <target state="translated">Здесь класс &lt;code&gt;ByRef&lt;/code&gt; охватывает доступ к словарю. Таким образом, атрибут access to &lt;code&gt;wrapped&lt;/code&gt; переводится в элемент доступа в переданном словаре. Передав результат встроенных локальных переменных и имя локальной переменной, вы получите доступ к локальной переменной. Документация Python от 3.5 советует, что изменение словаря может не сработать, но мне кажется, что это работает.</target>
        </trans-unit>
        <trans-unit id="d0be6fb2e163967ac2361db4b4dde754f1a7b504" translate="yes" xml:space="preserve">
          <source>Hope that clarifies the issue for you.</source>
          <target state="translated">Надеюсь,это прояснит вам проблему.</target>
        </trans-unit>
        <trans-unit id="ac9f35a5c40f1a54d0e975658a953c9ccceb917a" translate="yes" xml:space="preserve">
          <source>How do I pass a variable by reference</source>
          <target state="translated">Как передать переменную по ссылке</target>
        </trans-unit>
        <trans-unit id="2635b21aa1a1e66c5ca7fed959d2e61ba0068f22" translate="yes" xml:space="preserve">
          <source>How do we get around this?</source>
          <target state="translated">Как нам это обойти?</target>
        </trans-unit>
        <trans-unit id="f2d3f338abd337442158a979a1f5de30af33097e" translate="yes" xml:space="preserve">
          <source>How to pass by reference</source>
          <target state="translated">Как пройти по ссылке</target>
        </trans-unit>
        <trans-unit id="072a54410009d923de415851395bc3f915f1966d" translate="yes" xml:space="preserve">
          <source>How to read the example in the question</source>
          <target state="translated">Как прочитать пример в вопросе</target>
        </trans-unit>
        <trans-unit id="f10e3c369b21afb8efe5cb8ff95bfee39a5c9ffa" translate="yes" xml:space="preserve">
          <source>I found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.</source>
          <target state="translated">Остальные ответы я нашел довольно длинными и сложными,поэтому я создал эту простую диаграмму,чтобы объяснить,как Python обращается с переменными и параметрами.</target>
        </trans-unit>
        <trans-unit id="3ca5711f1032450bdfe039601daafa6c14debe97" translate="yes" xml:space="preserve">
          <source>I hope this clears things up a little.</source>
          <target state="translated">Надеюсь,это немного прояснит ситуацию.</target>
        </trans-unit>
        <trans-unit id="779f081125662b16c96e53373144d42eb57b8923" translate="yes" xml:space="preserve">
          <source>I think it is important to note that the current post with the most votes (by Blair Conrad), while being correct with respect to its result, is misleading and is borderline incorrect based on its definitions.  While there are many languages (like C) that allow the user to either pass by reference or pass by value, Python is not one of them.</source>
          <target state="translated">Думаю,важно отметить,что текущий пост с наибольшим количеством голосов (по Блэру Конраду),хотя и является правильным с точки зрения его результата,но вводит в заблуждение и является пограничным,исходя из его определений.Несмотря на то,что существует множество языков (например,C),которые позволяют пользователю либо проходить по ссылке,либо проходить по значению,Python не является одним из них.</target>
        </trans-unit>
        <trans-unit id="1caf319e1b878a7a9add11ed6d02d3179fc2d9bb" translate="yes" xml:space="preserve">
          <source>I used the following method to quickly convert a couple of Fortran codes to Python.  True, it's not pass by reference as the original question was posed, but is a simple work around in some cases.</source>
          <target state="translated">Я использовал следующий метод для быстрого преобразования пары кодов Fortran на Python.Правда,он не проходит мимо ссылки,так как был задан исходный вопрос,но в некоторых случаях это простая работа.</target>
        </trans-unit>
        <trans-unit id="f8f3af9f0dc96665fb36e21e7dd8ea0010188a92" translate="yes" xml:space="preserve">
          <source>I'm sure someone else could clarify this further.</source>
          <target state="translated">Уверен,кто-нибудь еще может прояснить это.</target>
        </trans-unit>
        <trans-unit id="8fd3fb5434919f5765b442b73f1a2ea249604d75" translate="yes" xml:space="preserve">
          <source>If it is an &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;immutable&lt;/a&gt; object (e.g. a bool, number, string), the way to go is to wrap it in a mutable object.</source>
          <target state="translated">Если это &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;неизменяемый&lt;/a&gt; объект (например, bool, число, строка), способ состоит в том, чтобы обернуть его в изменяемый объект.</target>
        </trans-unit>
        <trans-unit id="e8ff937ee3cf391aa9369bcc79fcdbacd051a2eb" translate="yes" xml:space="preserve">
          <source>If the argument was passed by value, the outer &lt;code&gt;lst&lt;/code&gt; could not be modified. The green are the target objects (the black is the value stored inside, the red is the object type), the yellow is the memory with the reference value inside -- drawn as the arrow. The blue solid arrow is the reference value that was passed to the function (via the dashed blue arrow path). The ugly dark yellow is the internal dictionary. (It actually could be drawn also as a green ellipse. The colour and the shape only says it is internal.)</source>
          <target state="translated">Если аргумент был передан по значению, внешний &lt;code&gt;lst&lt;/code&gt; не может быть изменен. Зеленый - это целевые объекты (черный - это значение, хранящееся внутри, красный - это тип объекта), желтый - это память с эталонным значением внутри - нарисованная как стрелка. Синяя сплошная стрелка - это контрольное значение, которое было передано функции (через пунктирную синюю стрелку). Уродливый темно-желтый - это внутренний словарь. (На самом деле его можно нарисовать также в виде зеленого эллипса. Цвет и форма говорят только о том, что он внутренний.)</target>
        </trans-unit>
        <trans-unit id="0dd316a07900ad81da1e569611d0d7f972700c53" translate="yes" xml:space="preserve">
          <source>If you pass a &lt;em&gt;mutable&lt;/em&gt; object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object.</source>
          <target state="translated">Если вы передадите &lt;em&gt;изменяемый&lt;/em&gt; объект в метод, метод получит ссылку на этот же объект, и вы сможете изменить его на радость своего сердца, но если перепривязать ссылку в методе, внешняя область ничего не будет знать об этом, и после все готово, внешняя ссылка все еще будет указывать на исходный объект.</target>
        </trans-unit>
        <trans-unit id="6f1b4b35463994559a0edb1ad6a1b8357fb742a0" translate="yes" xml:space="preserve">
          <source>If you pass an &lt;em&gt;immutable&lt;/em&gt; object to a method, you still can't rebind the outer reference, and you can't even mutate the object.</source>
          <target state="translated">Если вы передадите &lt;em&gt;неизменный&lt;/em&gt; объект методу, вы все равно не сможете повторно привязать внешнюю ссылку и даже не можете изменить объект.</target>
        </trans-unit>
        <trans-unit id="bc1e60fe42ced701dd9148c0ff6beca470127f04" translate="yes" xml:space="preserve">
          <source>If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:</source>
          <target state="translated">Если вы действительно хотите избежать использования возвращаемого значения,вы можете создать класс,который будет хранить ваше значение и передавать его в функцию или использовать существующий класс,например,список:</target>
        </trans-unit>
        <trans-unit id="9688763625be69eed8ed0d10e131598208128be6" translate="yes" xml:space="preserve">
          <source>If you want the behavior, Blair Conrad's answer is fine.  But if you want to know the nuts and bolts of why Python is neither pass by value or pass by reference, read David Cournapeau's answer.</source>
          <target state="translated">Если тебе нужно поведение,ответ Блэр Конрад в порядке.Но если ты хочешь знать гайки и болты,почему Python не проходит ни по значению,ни по ссылке,прочитай ответ Дэвида Курнапо.</target>
        </trans-unit>
        <trans-unit id="e5596ea1ad94c7661a4350a8652098d786a4cc4b" translate="yes" xml:space="preserve">
          <source>Immutable arguments are effectively passed &amp;ldquo;&lt;strong&gt;by value&lt;/strong&gt;.&amp;rdquo; Objects such as integers and strings are passed by object reference instead of by copying, but because you can&amp;rsquo;t change immutable objects in place anyhow, the effect is much like making a copy.</source>
          <target state="translated">Неизменные аргументы эффективно передаются &amp;laquo; &lt;strong&gt;по значению&lt;/strong&gt; &amp;raquo;. Такие объекты, как целые числа и строки, передаются по ссылке на объект, а не путем копирования, но, поскольку вы не можете изменить неизменяемые объекты в любом случае, эффект очень похож на создание копии.</target>
        </trans-unit>
        <trans-unit id="6302f1ff1c0c2b90057d999e0b3858fc9d2a2e08" translate="yes" xml:space="preserve">
          <source>In compiled languages, a variable is a memory space that is able to capture the value of the type. In Python, a variable is a name (captured internally as a string) bound to the reference variable that holds the reference value to the target object. The name of the variable is the key in the internal dictionary, the value part of that dictionary item stores the reference value to the target.</source>
          <target state="translated">В скомпилированных языках переменная-это пространство памяти,которое способно захватить значение типа.На языке Python переменная-это имя (захваченное внутренне в виде строки),привязанное к переменной-справке,которая содержит значение ссылки на целевой объект.Имя переменной-это ключ во внутреннем словаре,часть значения этого элемента словаря хранит значение ссылки на целевой объект.</target>
        </trans-unit>
        <trans-unit id="271a2c315dedadaa6b644002264db432c9330e40" translate="yes" xml:space="preserve">
          <source>In instance methods, you normally refer to &lt;code&gt;self&lt;/code&gt; to access instance attributes. It is normal to set instance attributes in &lt;code&gt;__init__&lt;/code&gt; and read or change them in instance methods. That is also why you pass &lt;code&gt;self&lt;/code&gt; als the first argument to &lt;code&gt;def Change&lt;/code&gt;.</source>
          <target state="translated">В методах экземпляра вы обычно обращаетесь к &lt;code&gt;self&lt;/code&gt; для доступа к атрибутам экземпляра. Нормально устанавливать атрибуты экземпляра в &lt;code&gt;__init__&lt;/code&gt; и читать или изменять их в методах экземпляра. Вот почему вы передаете &lt;code&gt;self&lt;/code&gt; в качестве первого аргумента для &lt;code&gt;def Change&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fae6b090cdbf66824da7924b6168f4173a64868f" translate="yes" xml:space="preserve">
          <source>In the code shown in the question, the statement &lt;code&gt;self.Change(self.variable)&lt;/code&gt; binds the name &lt;code&gt;var&lt;/code&gt; (in the scope of function &lt;code&gt;Change&lt;/code&gt;) to the object that holds the value &lt;code&gt;'Original'&lt;/code&gt; and the assignment &lt;code&gt;var = 'Changed'&lt;/code&gt; (in the body of function &lt;code&gt;Change&lt;/code&gt;) assigns that same name again: to some other object (that happens to hold a string as well but could have been something else entirely).</source>
          <target state="translated">В коде, показанном в вопросе, оператор &lt;code&gt;self.Change(self.variable)&lt;/code&gt; связывает имя &lt;code&gt;var&lt;/code&gt; (в области действия &lt;code&gt;Change&lt;/code&gt; ) с объектом, который содержит значение &lt;code&gt;'Original'&lt;/code&gt; и присваивание &lt;code&gt;var = 'Changed'&lt;/code&gt; (в тело функции &lt;code&gt;Change&lt;/code&gt; ) снова присваивает то же имя: другому объекту (который также содержит строку, но мог бы быть чем-то другим).</target>
        </trans-unit>
        <trans-unit id="d174ebf38cb48196530f520173f23f96ee505c2d" translate="yes" xml:space="preserve">
          <source>In this case the variable titled &lt;code&gt;var&lt;/code&gt; in the method &lt;code&gt;Change&lt;/code&gt; is assigned a reference to &lt;code&gt;self.variable&lt;/code&gt;, and you immediately assign a string to &lt;code&gt;var&lt;/code&gt;. It's no longer pointing to &lt;code&gt;self.variable&lt;/code&gt;. The following code snippet shows what would happen if you modify the data structure pointed to by &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;self.variable&lt;/code&gt;, in this case a list:</source>
          <target state="translated">В этом случае переменной с &lt;code&gt;self.variable&lt;/code&gt; &lt;code&gt;var&lt;/code&gt; в методе &lt;code&gt;Change&lt;/code&gt; присваивается ссылка на self.variable , и вы немедленно присваиваете строку &lt;code&gt;var&lt;/code&gt; . Это больше не указывает на &lt;code&gt;self.variable&lt;/code&gt; . Следующий фрагмент кода показывает, что произойдет, если вы измените структуру данных, на которую указывают &lt;code&gt;var&lt;/code&gt; и &lt;code&gt;self.variable&lt;/code&gt; , в данном случае список:</target>
        </trans-unit>
        <trans-unit id="c93eaa9797f60173290b5121f5aebea5bd45b163" translate="yes" xml:space="preserve">
          <source>In your example, when the &lt;code&gt;Change&lt;/code&gt; method is called--a &lt;a href=&quot;http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces&quot;&gt;namespace&lt;/a&gt; is created for it; and &lt;code&gt;var&lt;/code&gt; becomes a name, within that namespace, for the string object &lt;code&gt;'Original'&lt;/code&gt;. That object then has a name in two namespaces. Next, &lt;code&gt;var = 'Changed'&lt;/code&gt; binds &lt;code&gt;var&lt;/code&gt; to a new string object, and thus the method's namespace forgets about &lt;code&gt;'Original'&lt;/code&gt;. Finally, that namespace is forgotten, and the string &lt;code&gt;'Changed'&lt;/code&gt; along with it.</source>
          <target state="translated">В вашем примере, когда вызывается метод &lt;code&gt;Change&lt;/code&gt; - для него создается &lt;a href=&quot;http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces&quot;&gt;пространство имен&lt;/a&gt; ; и &lt;code&gt;var&lt;/code&gt; становится именем в этом пространстве имен для строкового объекта &lt;code&gt;'Original'&lt;/code&gt; . Этот объект затем имеет имя в двух пространствах имен. Затем &lt;code&gt;var = 'Changed'&lt;/code&gt; связывает &lt;code&gt;var&lt;/code&gt; с новым строковым объектом, и, таким образом, пространство имен метода забывает о &lt;code&gt;'Original'&lt;/code&gt; . Наконец, это пространство имен забыто, и вместе с ним строка &lt;code&gt;'Changed'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb33c9ab807f193d39872eed5e22af0127a40637" translate="yes" xml:space="preserve">
          <source>Is there something I can do to pass the variable by actual reference?</source>
          <target state="translated">Могу ли я что-то сделать,чтобы передать переменную по фактической ссылке?</target>
        </trans-unit>
        <trans-unit id="d7e7bdb80421d5ef59aefc489f344f221587bba6" translate="yes" xml:space="preserve">
          <source>It is neither pass-by-value or pass-by-reference - it is call-by-object. See this, by Fredrik Lundh:</source>
          <target state="translated">Она не является ни передачей по значению,ни передачей по ссылке-она является передачей по запросу.Смотрите,Фредрик Ланд:</target>
        </trans-unit>
        <trans-unit id="48bb347a9d7faf829dae8ac2ec01719f82c86124" translate="yes" xml:space="preserve">
          <source>It's an ugly hack, but it works. ;-P</source>
          <target state="translated">Это уродливый хак,но он работает.;-P</target>
        </trans-unit>
        <trans-unit id="c4d93e3229bff3269f3ab05cdf6305855b9bc82f" translate="yes" xml:space="preserve">
          <source>List - a mutable type</source>
          <target state="translated">Список-мутируемый тип</target>
        </trans-unit>
        <trans-unit id="e145738e57fdf9ea90a9bfc63f28785068e9be9d" translate="yes" xml:space="preserve">
          <source>Mutable arguments are effectively passed &amp;ldquo;&lt;strong&gt;by pointer&lt;/strong&gt;.&amp;rdquo; Objects such as lists
and dictionaries are also passed by object reference, which is similar to the way C
passes arrays as pointers&amp;mdash;mutable objects can be changed in place in the function,
much like C arrays.</source>
          <target state="translated">Изменяемые аргументы эффективно передаются &amp;laquo; &lt;strong&gt;по указателю&lt;/strong&gt; &amp;raquo;. Такие объекты, как списки и словари, также передаются по ссылкам на объекты, что аналогично тому, как C передает массивы как указатели - изменяемые объекты могут быть изменены на месте в функции, так же, как массивы C.</target>
        </trans-unit>
        <trans-unit id="ed19ef46a33530a5532cfcd97126ae99cb3242a0" translate="yes" xml:space="preserve">
          <source>Objects are allocated on the heap and pointers to them can be passed around anywhere.</source>
          <target state="translated">Объекты распределяются по куче,и указатели на них могут передаваться куда угодно.</target>
        </trans-unit>
        <trans-unit id="87dea7220960a8d9957e82c5e7caf7ae67f5891a" translate="yes" xml:space="preserve">
          <source>Objects like lists are &lt;em&gt;mutable&lt;/em&gt;.  This means that the contents of the object can be changed by anything pointing to the object.  For example, &lt;code&gt;x = []; y = x; x.append(10); print y&lt;/code&gt; will print &lt;code&gt;[10]&lt;/code&gt;.  The empty list was created.  Both &quot;x&quot; and &quot;y&quot; point to the same list.  The &lt;em&gt;append&lt;/em&gt; method mutates (updates) the list object (like adding a record to a database) and the result is visible to both &quot;x&quot; and &quot;y&quot; (just as a database update would be visible to every connection to that database).</source>
          <target state="translated">Такие объекты, как списки, являются &lt;em&gt;изменчивыми&lt;/em&gt; . Это означает, что содержимое объекта может быть изменено любым указателем на объект. Например, &lt;code&gt;x = []; y = x; x.append(10); print y&lt;/code&gt; у = х; x.append (10); print y напечатает &lt;code&gt;[10]&lt;/code&gt; . Пустой список создан. И &amp;laquo;х&amp;raquo;, и &amp;laquo;у&amp;raquo; указывают на один и тот же список. Метод &lt;em&gt;append&lt;/em&gt; изменяет (обновляет) объект списка (например, добавляет запись в базу данных), и результат виден как &quot;x&quot;, так и &quot;y&quot; (точно так же, как обновление базы данных будет видно для каждого соединения с этой базой данных).</target>
        </trans-unit>
        <trans-unit id="4498e2a33a71723f43491095390bfa7816d3f75b" translate="yes" xml:space="preserve">
          <source>Objects like strings and integers are &lt;em&gt;immutable&lt;/em&gt;.  This simply means that there are no methods that can change the object after it has been created.  For example, once the integer object one-thousand is created, it will never change.  Math is done by creating new integer objects.</source>
          <target state="translated">Объекты, такие как строки и целые числа, являются &lt;em&gt;неизменными&lt;/em&gt; . Это просто означает, что нет методов, которые могут изменить объект после его создания. Например, когда создается целочисленный объект тысяча, он никогда не изменится. Математика делается путем создания новых целочисленных объектов.</target>
        </trans-unit>
        <trans-unit id="27f285ca9e6dbf4bba0bcd6c449903172991d998" translate="yes" xml:space="preserve">
          <source>Obviously the above does not allow &lt;em&gt;reading&lt;/em&gt; the value, only updating it.</source>
          <target state="translated">Очевидно, что вышеизложенное не позволяет &lt;em&gt;прочитать&lt;/em&gt; значение, а только обновить его.</target>
        </trans-unit>
        <trans-unit id="4751c7c9efc0a91758450a9fee280437f3b71a6f" translate="yes" xml:space="preserve">
          <source>One way is to use &lt;code&gt;global&lt;/code&gt; (for global variables) or &lt;code&gt;nonlocal&lt;/code&gt; (for local variables in a function) in a wrapper function.</source>
          <target state="translated">Одним из способов является использование &lt;code&gt;global&lt;/code&gt; (для глобальных переменных) или &lt;code&gt;nonlocal&lt;/code&gt; (для локальных переменных в функции) функций-оболочек.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="c439d84dc5a961368d9307e0770827dfc4515420" translate="yes" xml:space="preserve">
          <source>Pass-By-Reference in Python is quite different from the concept of pass by reference in C++/Java.</source>
          <target state="translated">Pass-By-Reference на Python сильно отличается от понятия pass by reference на C++Java.</target>
        </trans-unit>
        <trans-unit id="68451aca93c616b65cb7c9047a81894d6b972f90" translate="yes" xml:space="preserve">
          <source>Passing 3 wrappers to access a variable is a bit unwieldy so those can be wrapped into a class that has a proxy attribute:</source>
          <target state="translated">Передача 3-х оберток для доступа к переменной немного громоздка,поэтому их можно обернуть в класс,имеющий атрибут proxy:</target>
        </trans-unit>
        <trans-unit id="0827e8d71a8fb26dad798d59e58b5d9485ef355e" translate="yes" xml:space="preserve">
          <source>Passing an argument into a function also binds a name (the parameter name of the function) to an object.</source>
          <target state="translated">Передача аргумента в функцию также связывает имя (имя параметра функции)с объектом.</target>
        </trans-unit>
        <trans-unit id="c8afd49f905bfc9a3cb491f06eb314e73ee2416c" translate="yes" xml:space="preserve">
          <source>Python always uses pass-by-reference values. There isn't any exception. Any variable assignment means copying the reference value. No exception. Any variable is the name bound to the reference value. Always.</source>
          <target state="translated">Python всегда использует проходные значения.Исключений нет.Любое присваивание переменных означает копирование значения ссылки.Никаких исключений.Любая переменная-это имя,связанное со значением ссылки.Всегда.</target>
        </trans-unit>
        <trans-unit id="83861cb7e986e86de426cee8c30f2ed20d4ab7fd" translate="yes" xml:space="preserve">
          <source>Python has names and objects.</source>
          <target state="translated">У Пайтона есть имена и объекты.</target>
        </trans-unit>
        <trans-unit id="5fcbcd2747ab57ca64daa423ac6a3486436e1a62" translate="yes" xml:space="preserve">
          <source>Python&amp;rsquo;s pass-by-assignment scheme isn&amp;rsquo;t quite the same as C++&amp;rsquo;s reference parameters option, but it turns out to be very similar to the argument-passing model of the C language (and others) in practice:</source>
          <target state="translated">Схема передачи по присваиванию в Python не совсем совпадает с опцией параметров ссылок C ++, но на практике она очень похожа на модель передачи аргументов языка C (и других):</target>
        </trans-unit>
        <trans-unit id="333f7d50ad7e0d3ef1d2d6e716803037e8f19596" translate="yes" xml:space="preserve">
          <source>Pythons &quot;reflection&quot; support makes it possible to get a object that is capable of reassigning a name/variable in a given scope without defining functions explicitly in that scope:</source>
          <target state="translated">Поддержка &quot;отражения&quot; питонов позволяет получить объект,способный переназначать именную переменную в заданной области видимости без явного определения функций в этой области видимости:</target>
        </trans-unit>
        <trans-unit id="afbaddd3494c975f3248038d165efdcb7b42b91c" translate="yes" xml:space="preserve">
          <source>Reference values are hidden in Python. There isn't any explicit user type for storing the reference value. However, you can use a list element (or element in any other suitable container type) as the reference variable, because all containers do store the elements also as references to the target objects. In other words, elements are actually not contained inside the container -- only the references to elements are.</source>
          <target state="translated">Справочные значения скрыты на Питоне.Нет явного пользовательского типа для хранения ссылочного значения.Тем не менее,вы можете использовать элемент списка (или элемент в любом другом подходящем типе контейнера)в качестве переменной-справки,потому что все контейнеры хранят элементы также в виде ссылок на целевые объекты.Другими словами,элементы фактически не содержатся внутри контейнера-это только ссылки на элементы.</target>
        </trans-unit>
        <trans-unit id="a16b36f9b22c19ae3e20f844261f568427971e02" translate="yes" xml:space="preserve">
          <source>See sections &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;3.1&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#naming-and-binding&quot;&gt;4.2&lt;/a&gt; in the Python 3 language reference.</source>
          <target state="translated">Смотрите разделы &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;3.1&lt;/a&gt; и &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#naming-and-binding&quot;&gt;4.2&lt;/a&gt; в справочнике по языку Python 3.</target>
        </trans-unit>
        <trans-unit id="660da67960cf04fb1e0d059bd7853b4c03efc993" translate="yes" xml:space="preserve">
          <source>Since dictionaries are passed by reference, you can use a dict variable to store any referenced values inside it.</source>
          <target state="translated">Так как словари передаются по ссылке,вы можете использовать переменную dict для хранения в ней любых ссылочных значений.</target>
        </trans-unit>
        <trans-unit id="68d4a137bc67d697b621b97d6185016cdb4789cb" translate="yes" xml:space="preserve">
          <source>Since immutable types cannot be modified, they &lt;em&gt;seem&lt;/em&gt; like being passed by value - passing an int into a function means assigning the int to the function's parameter. You can only ever reassign that, but it won't change the original variables value.</source>
          <target state="translated">Поскольку неизменяемые типы не могут быть изменены, они, &lt;em&gt;похоже&lt;/em&gt; , передаются по значению - передача int в функцию означает присвоение int параметру функции. Вы можете только переназначить это, но это не изменит первоначальное значение переменных.</target>
        </trans-unit>
        <trans-unit id="696917aad2c2b30ef73b056904aa4dea2ce6c676" translate="yes" xml:space="preserve">
          <source>Since it seems to be nowhere mentioned an approach to simulate references as known from e.g. C++ is to use an &quot;update&quot; function and pass that instead of the actual variable (or rather, &quot;name&quot;):</source>
          <target state="translated">Так как,похоже,нигде не упоминается подход к моделированию ссылок,известный,например,из Си++,заключается в использовании функции &quot;update&quot; и передаче ее вместо фактической переменной (или,точнее,&quot;name&quot;):</target>
        </trans-unit>
        <trans-unit id="5d727a1d706032a86c18b0a92e1ed2ead4954513" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;the_list&lt;/code&gt; parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The &lt;code&gt;the_list&lt;/code&gt; was a copy of the &lt;code&gt;outer_list&lt;/code&gt; reference, and we had &lt;code&gt;the_list&lt;/code&gt; point to a new list, but there was no way to change where &lt;code&gt;outer_list&lt;/code&gt; pointed.</source>
          <target state="translated">Поскольку параметр &lt;code&gt;the_list&lt;/code&gt; был передан по значению, присвоение ему нового списка не имело эффекта, который мог видеть код вне метода. &lt;code&gt;the_list&lt;/code&gt; был копией ссылки на &lt;code&gt;outer_list&lt;/code&gt; , и у нас был &lt;code&gt;the_list&lt;/code&gt; на новый список, но не было никакого способа изменить то, куда указывал &lt;code&gt;outer_list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36f7beed038b24998576a94eef27bf913f6ed625" translate="yes" xml:space="preserve">
          <source>Since the parameter passed in is a reference to &lt;code&gt;outer_list&lt;/code&gt;, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.</source>
          <target state="translated">Поскольку переданный параметр является ссылкой на &lt;code&gt;outer_list&lt;/code&gt; , а не его копией, мы можем использовать методы списка мутаций, чтобы изменить его и отразить изменения во внешней области видимости.</target>
        </trans-unit>
        <trans-unit id="e6e9cfc9cdfcbeabab6f908af34edaef10d1407d" translate="yes" xml:space="preserve">
          <source>Since your example happens to be object-oriented, you could make the following change to achieve a similar result:</source>
          <target state="translated">Поскольку ваш пример случайно окажется объектно-ориентированным,вы можете внести следующие изменения для достижения аналогичного результата:</target>
        </trans-unit>
        <trans-unit id="c8af5c8a28c9b058781cfa18faaa84372e62a5df" translate="yes" xml:space="preserve">
          <source>So if the thing you want to change is a mutable object, there is no problem, as everything is effectively passed by reference.</source>
          <target state="translated">Так что если вещь,которую вы хотите изменить,является мутируемым объектом,нет никаких проблем,так как все фактически передается по ссылке.</target>
        </trans-unit>
        <trans-unit id="bf807aabb75019d89aff61af1c01d7c2a1d18f4d" translate="yes" xml:space="preserve">
          <source>So, when passing a list to a function/method, the list is assigned to the parameter name. Appending to the list will result in the list being modified. Reassigning the list &lt;em&gt;inside&lt;/em&gt; the function will not change the original list, since:</source>
          <target state="translated">Таким образом, при передаче списка в функцию / метод, список присваивается имени параметра. Добавление к списку приведет к изменению списка. Переназначение списка &lt;em&gt;внутри&lt;/em&gt; функции не изменит первоначальный список, поскольку:</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="d7a557055e4e02657c23b68f42103ada3c99dabb" translate="yes" xml:space="preserve">
          <source>String - an immutable type</source>
          <target state="translated">Струна-непреложный тип</target>
        </trans-unit>
        <trans-unit id="7c1fdc94b36a2d1a36919d71bce545b535714140" translate="yes" xml:space="preserve">
          <source>Technically, &lt;strong&gt;Python always uses pass by reference values&lt;/strong&gt;. I am going to repeat &lt;a href=&quot;https://stackoverflow.com/a/12438316/1346705&quot;&gt;my other answer&lt;/a&gt; to support my statement.</source>
          <target state="translated">Технически, &lt;strong&gt;Python всегда использует передачу по ссылочным значениям&lt;/strong&gt; . Я собираюсь повторить &lt;a href=&quot;https://stackoverflow.com/a/12438316/1346705&quot;&gt;мой другой ответ,&lt;/a&gt; чтобы поддержать мое утверждение.</target>
        </trans-unit>
        <trans-unit id="79c2b7cf71267d7a5e78f89f251fffbff74bb65a" translate="yes" xml:space="preserve">
          <source>That is all there is to it. Mutability is irrelevant for this question.</source>
          <target state="translated">Это все,что есть.Подвижность не имеет значения для этого вопроса.</target>
        </trans-unit>
        <trans-unit id="17becfeedaa8893ff84a47a35ec6e3e49715fa72" translate="yes" xml:space="preserve">
          <source>The Python documentation seems unclear about whether parameters are passed by reference or value, and the following code produces the unchanged value 'Original'</source>
          <target state="translated">Документация на Python кажется неясной,передаются ли параметры по ссылке или по значению,и следующий код выдает неизменное значение 'Original'.</target>
        </trans-unit>
        <trans-unit id="f2fff69c21168bf26f5b1e057e178f0b3f2e5e7c" translate="yes" xml:space="preserve">
          <source>The actual object - [0, 1] (which would be called a value in other programming languages) is being passed. So in fact the function &lt;code&gt;change_me&lt;/code&gt; will try to do something like:</source>
          <target state="translated">Фактический объект - [0, 1] (который будет называться значением в других языках программирования) передается. Так что на самом деле функция &lt;code&gt;change_me&lt;/code&gt; попытается сделать что-то вроде:</target>
        </trans-unit>
        <trans-unit id="a681daed3a2466279708eadd396f12d4619acbc1" translate="yes" xml:space="preserve">
          <source>The assignment to an global variable that is not declared global therefore creates a new local object and breaks the link to the original object.</source>
          <target state="translated">Присвоение глобальной переменной,не объявленной глобальной,создает,таким образом,новый локальный объект и разрывает связь с исходным объектом.</target>
        </trans-unit>
        <trans-unit id="dcf126983674f03f5b7e37d5d854435177547ce6" translate="yes" xml:space="preserve">
          <source>The basic idea is to have a function that can do that access and can be passed as object into other functions or stored in a class.</source>
          <target state="translated">Основная идея заключается в том,чтобы иметь функцию,которая может делать такой доступ и может быть передана как объект в другие функции или сохранена в классе.</target>
        </trans-unit>
        <trans-unit id="0bc22d9160e54688c508487d4bc0a30f0fedfd8c" translate="yes" xml:space="preserve">
          <source>The key to understanding parameter passing is to stop thinking about &quot;variables&quot;. There are names and objects in Python and together they
appear like variables, but it is useful to always distinguish the three.</source>
          <target state="translated">Ключ к пониманию передачи параметра-перестать думать о &quot;переменных&quot;.На Python есть имена и объекты,и вместе они выглядят как переменные,но полезно всегда различать их.</target>
        </trans-unit>
        <trans-unit id="4ab82925dc8dd0f7cb7b601b15859baf0d62bc4d" translate="yes" xml:space="preserve">
          <source>The more &lt;a href=&quot;https://www.python.org/dev/peps/pep-0020/&quot;&gt;pythonic&lt;/a&gt; approach would be to introduce a trivial, one-attribute class. The function receives an instance of the class and manipulates the attribute.</source>
          <target state="translated">Более &lt;a href=&quot;https://www.python.org/dev/peps/pep-0020/&quot;&gt;питонический&lt;/a&gt; подход состоял бы в том, чтобы ввести тривиальный класс с одним атрибутом. Функция получает экземпляр класса и манипулирует атрибутом.</target>
        </trans-unit>
        <trans-unit id="cc1762bcf99fc58408f1a9ef7986e8348ee28a58" translate="yes" xml:space="preserve">
          <source>The only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places.</source>
          <target state="translated">Единственный способ обойти это-передать мутирующий объект.Поскольку обе ссылки относятся к одному и тому же объекту,любые изменения объекта отражаются в обоих местах.</target>
        </trans-unit>
        <trans-unit id="6fad76f326204f89d7ac6ac50ce5db14000add4d" translate="yes" xml:space="preserve">
          <source>The problem comes from a misunderstanding of what variables are in Python. If you're used to most traditional languages, you have a mental model of what happens in the following sequence:</source>
          <target state="translated">Проблема заключается в непонимании того,какие переменные находятся на Python.Если вы привыкли к большинству традиционных языков,у вас есть ментальная модель того,что происходит в следующей последовательности:</target>
        </trans-unit>
        <trans-unit id="84175dec5b4dc806baa482e3939f43855a2e8b04" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty solution for this is a one-element list (instead of &lt;code&gt;self.variable&lt;/code&gt;, pass &lt;code&gt;[self.variable]&lt;/code&gt; and in the function modify &lt;code&gt;var[0]&lt;/code&gt;).</source>
          <target state="translated">Быстрое решение для этого - одноэлементный список (вместо &lt;code&gt;self.variable&lt;/code&gt; , pass &lt;code&gt;[self.variable]&lt;/code&gt; и в функции modify &lt;code&gt;var[0]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="13c1347e705ce1693fe7d2b8e953c905989ca4b8" translate="yes" xml:space="preserve">
          <source>The same idea works for reading and &lt;code&gt;del&lt;/code&gt;eting a variable.</source>
          <target state="translated">Та же идея работает для чтения и удаления переменной.</target>
        </trans-unit>
        <trans-unit id="5db310989aa7591454c760958f2af239e823a8c7" translate="yes" xml:space="preserve">
          <source>Then the call would result in:</source>
          <target state="translated">Тогда звонок бы закончился:</target>
        </trans-unit>
        <trans-unit id="0105c63c552b46ed256ace297e33009660aef599" translate="yes" xml:space="preserve">
          <source>There are no variables in Python</source>
          <target state="translated">На Питоне нет переменных</target>
        </trans-unit>
        <trans-unit id="086a535eed287fb2a8da5e4f2b4da1059486d637" translate="yes" xml:space="preserve">
          <source>There is a little trick to pass an object by reference, even though the language doesn't make it possible. It works in Java too, it's the list with one item. ;-)</source>
          <target state="translated">Есть небольшая хитрость передать объект по ссылке,даже если язык не делает это возможным.Это работает и на Java,это список с одним пунктом ;-).</target>
        </trans-unit>
        <trans-unit id="b1c21ed6d2eec901faa433fdaff0e199b04f81af" translate="yes" xml:space="preserve">
          <source>Think of stuff being passed &lt;strong&gt;by assignment&lt;/strong&gt; instead of by reference/by value. That way, it is always clear, what is happening as long as you understand what happens during the normal assignment.</source>
          <target state="translated">Думайте о вещах, передаваемых &lt;strong&gt;по присваиванию,&lt;/strong&gt; а не по ссылке / по значению. Таким образом, всегда ясно, что происходит, пока вы понимаете, что происходит во время обычного задания.</target>
        </trans-unit>
        <trans-unit id="c5a5244ffa8b4f4ae77f3d588812cda61fa6be3d" translate="yes" xml:space="preserve">
          <source>This binds the name &lt;code&gt;a&lt;/code&gt; to an object of type integer that holds the value 1.</source>
          <target state="translated">Это связывает имя &lt;code&gt;a&lt;/code&gt; с объектом типа integer, который содержит значение 1.</target>
        </trans-unit>
        <trans-unit id="884b42766d553e6f4cff2ad92ade45f883bf6559" translate="yes" xml:space="preserve">
          <source>This binds the name &lt;code&gt;b&lt;/code&gt; to the same object that the name &lt;code&gt;x&lt;/code&gt; is currently bound to.
Afterwards, the name &lt;code&gt;b&lt;/code&gt; has nothing to do with the name &lt;code&gt;x&lt;/code&gt; any more.</source>
          <target state="translated">Это связывает имя &lt;code&gt;b&lt;/code&gt; с тем же объектом, с которым в настоящее время связано имя &lt;code&gt;x&lt;/code&gt; . Впоследствии имя &lt;code&gt;b&lt;/code&gt; больше не имеет ничего общего с именем &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a0da37fa36be60c0aa098be25fccdb7e017ac1b" translate="yes" xml:space="preserve">
          <source>This is mostly useful for &quot;out-only references&quot; or in a situation with multiple threads / processes (by making the update function thread / multiprocessing safe).</source>
          <target state="translated">Это,в основном,полезно для &quot;только для ссылок&quot; или в ситуации с многопоточными процессами (делая функцию обновления многопоточной обработки безопасным).</target>
        </trans-unit>
        <trans-unit id="2f1f28564cc17f4b95f8008ecbf300883f70aebb" translate="yes" xml:space="preserve">
          <source>To make it even more clear, let's have some examples.</source>
          <target state="translated">Чтобы все прояснить,давайте приведем несколько примеров.</target>
        </trans-unit>
        <trans-unit id="5623b8a007cec828bd71b838af98d8c9977c1510" translate="yes" xml:space="preserve">
          <source>To the extent that Python is pass by value, all languages are pass by value since some piece of data (be it a &quot;value&quot; or a &quot;reference&quot;) must be sent. However, that does not mean that Python is pass by value in the sense that a C programmer would think of it.</source>
          <target state="translated">В той степени,в которой Python передаётся по значению,все языки передаются по значению,так как часть данных (будь то &quot;значение&quot; или &quot;ссылка&quot;)должна быть отправлена.Однако это не значит,что Python передаётся по значению в том смысле,в каком это придумал бы программист на Си.</target>
        </trans-unit>
        <trans-unit id="20555a4a440b0601df4fa798a89247c553a96ccf" translate="yes" xml:space="preserve">
          <source>When you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there's no way to update that reference and make it refer to a new object. In your example:</source>
          <target state="translated">При вызове функции с параметром создается новая ссылка,которая ссылается на переданный объект.Она отделена от ссылки,которая использовалась при вызове функции,поэтому нет возможности обновить эту ссылку и заставить ее ссылаться на новый объект.В вашем примере:</target>
        </trans-unit>
        <trans-unit id="bc3fa5ea94b2efd9143d2934a64ae051133be6ed" translate="yes" xml:space="preserve">
          <source>When you do a new assignment such as &lt;code&gt;y = x&lt;/code&gt;, a new dictionary entry &quot;y&quot; is created that points to the same object as the entry for &quot;x&quot;.</source>
          <target state="translated">Когда вы делаете новое присваивание, такое как &lt;code&gt;y = x&lt;/code&gt; , создается новая словарная запись &quot;y&quot;, которая указывает на тот же объект, что и запись для &quot;x&quot;.</target>
        </trans-unit>
        <trans-unit id="a8ec35d9c1b72807f2ded385deffa6f8aa373d72" translate="yes" xml:space="preserve">
          <source>When you make an assignment such as &lt;code&gt;x = 1000&lt;/code&gt;, a dictionary entry is created that maps the string &quot;x&quot; in the current namespace to a pointer to the integer object containing one thousand.</source>
          <target state="translated">Когда вы делаете присвоение, такое как &lt;code&gt;x = 1000&lt;/code&gt; , создается словарная запись, которая отображает строку &amp;laquo;x&amp;raquo; в текущем пространстве имен на указатель на целочисленный объект, содержащий тысячу.</target>
        </trans-unit>
        <trans-unit id="e648dd9f3d5b78507aba8fd21719ec93fe30b1ca" translate="yes" xml:space="preserve">
          <source>When you update &quot;x&quot; with &lt;code&gt;x = 2000&lt;/code&gt;, a new integer object is created and the dictionary is updated to point at the new object.  The old one thousand object is unchanged (and may or may not be alive depending on whether anything else refers to the object).</source>
          <target state="translated">Когда вы обновляете &amp;laquo;x&amp;raquo; с &lt;code&gt;x = 2000&lt;/code&gt; , создается новый целочисленный объект, и словарь обновляется, чтобы указывать на новый объект. Старый объект тысяча неизменен (и может или не может быть живым в зависимости от того, относится ли что-либо еще к объекту).</target>
        </trans-unit>
        <trans-unit id="13eb328770b9c46bbd56e2839f367e0a7b3f96db" translate="yes" xml:space="preserve">
          <source>Whenever you pass an object to the function, the object itself is passed (object in Python is actually what you'd call a value in other programming languages) not the reference to this object. In other words, when you call:</source>
          <target state="translated">Всякий раз,когда вы передаете объект в функцию,передаётся сам объект (объект на Python-это на самом деле то,что вы называете значением в других языках программирования),а не ссылка на этот объект.Другими словами,когда вы вызываете:</target>
        </trans-unit>
        <trans-unit id="6b4cb23677b917c5c42bbdb41b1590df3465a4db" translate="yes" xml:space="preserve">
          <source>While pass by reference is nothing that fits well into python and should be rarely used there are some workarounds that actually can work to get the object currently assigned to a local variable or even reassign a local variable from inside of a called function.</source>
          <target state="translated">Хотя передача по ссылке-это ничто,что хорошо вписывается в питон и редко должно использоваться,есть некоторые обходные пути,которые на самом деле могут работать,чтобы получить объект,который в данный момент назначен локальной переменной или даже переназначить локальную переменную изнутри вызываемой функции.</target>
        </trans-unit>
        <trans-unit id="06ef8c07f183597c6357e8005336de31d41ec30c" translate="yes" xml:space="preserve">
          <source>You believe that &lt;code&gt;a&lt;/code&gt; is a memory location that stores the value &lt;code&gt;1&lt;/code&gt;, then is updated to store the value &lt;code&gt;2&lt;/code&gt;. That's not how things work in Python. Rather, &lt;code&gt;a&lt;/code&gt; starts as a reference to an object with the value &lt;code&gt;1&lt;/code&gt;, then gets reassigned as a reference to an object with the value &lt;code&gt;2&lt;/code&gt;. Those two objects may continue to coexist even though &lt;code&gt;a&lt;/code&gt; doesn't refer to the first one anymore; in fact they may be shared by any number of other references within the program.</source>
          <target state="translated">Вы полагаете, что &lt;code&gt;a&lt;/code&gt; - это область памяти, в которой хранится значение &lt;code&gt;1&lt;/code&gt; , а затем обновляется для сохранения значения &lt;code&gt;2&lt;/code&gt; . Это не так, как все работает в Python. Скорее, &lt;code&gt;a&lt;/code&gt; начинается как ссылка на объект со значением &lt;code&gt;1&lt;/code&gt; , а затем переназначается как ссылка на объект со значением &lt;code&gt;2&lt;/code&gt; . Эти два объекта могут продолжать сосуществовать, даже если &lt;code&gt;a&lt;/code&gt; больше не ссылается на первый; фактически они могут быть разделены любым количеством других ссылок в программе.</target>
        </trans-unit>
        <trans-unit id="6cbe72d4aff2f1d3e9fb3501cd97383b70fd44e7" translate="yes" xml:space="preserve">
          <source>You can merely use &lt;strong&gt;an empty class&lt;/strong&gt; as an instance to store reference objects because internally object attributes are stored in an instance dictionary. See the example.</source>
          <target state="translated">Вы можете просто использовать &lt;strong&gt;пустой класс&lt;/strong&gt; в качестве экземпляра для хранения ссылочных объектов, поскольку внутренние атрибуты объекта хранятся в словаре экземпляра. Смотрите пример.</target>
        </trans-unit>
        <trans-unit id="9e395b0bd4b1dc1eea4d49d8e1f40c5347e0d5a1" translate="yes" xml:space="preserve">
          <source>You can think about a reference value as the address of the target object. The address is automatically dereferenced when used. This way, working with the reference value, it seems you work directly with the target object. But there always is a reference in between, one step more to jump to the target.</source>
          <target state="translated">Вы можете думать об опорном значении как об адресе целевого объекта.Адрес автоматически разыменовывается при использовании.Таким образом,работая со значением ссылки,создается впечатление,что вы работаете непосредственно с целевым объектом.Но между ними всегда есть ссылка,еще один шаг,чтобы перейти к цели.</target>
        </trans-unit>
        <trans-unit id="233857d84270d4d4cf81d2ab105c0ebb1d786176" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://docs.python.org/3.3/library/functions.html#id&quot;&gt;&lt;code&gt;id()&lt;/code&gt;&lt;/a&gt; built-in function to learn what the reference value is (that is, the address of the target object).</source>
          <target state="translated">Вы можете использовать встроенную функцию &lt;a href=&quot;http://docs.python.org/3.3/library/functions.html#id&quot;&gt; &lt;code&gt;id()&lt;/code&gt; &lt;/a&gt; чтобы узнать, каково значение ссылки (то есть адрес целевого объекта).</target>
        </trans-unit>
        <trans-unit id="fee26813eb63428556d25e99b697066a5abee304" translate="yes" xml:space="preserve">
          <source>You got some really good answers here.</source>
          <target state="translated">У тебя тут очень хорошие ответы.</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="ac2c0095bbd1e16c2e3606675ef16ab060af766f" translate="yes" xml:space="preserve">
          <source>given the way python handles values and references to them, the only way you can reference an arbitrary instance attribute is by name:</source>
          <target state="translated">Учитывая то,как питон обрабатывает значения и ссылки на них,единственный способ ссылки на произвольный атрибут экземпляра-по имени:</target>
        </trans-unit>
        <trans-unit id="5dcfdd557133c0be7c75544c8a554ac3a7ddef6a" translate="yes" xml:space="preserve">
          <source>gives:</source>
          <target state="translated">gives:</target>
        </trans-unit>
        <trans-unit id="31cef82f841f61f64a2b51817dadd21b57e78be6" translate="yes" xml:space="preserve">
          <source>in real code you would, of course, add error checking on the dict lookup.</source>
          <target state="translated">в реальном коде вы,конечно,добавили бы проверку на ошибки при поиске диктатуры.</target>
        </trans-unit>
        <trans-unit id="1d8a6a9487c9bd9e3711fa2119286c096444a2f6" translate="yes" xml:space="preserve">
          <source>some data types are mutable, but others aren't</source>
          <target state="translated">некоторые типы данных мутируются,но другие нет.</target>
        </trans-unit>
        <trans-unit id="5f0f7656c197d2526aa255c56c1295fe45b9916d" translate="yes" xml:space="preserve">
          <source>the parameter passed in is actually a &lt;em&gt;reference&lt;/em&gt; to an object (but the reference is passed by value)</source>
          <target state="translated">переданный параметр на самом деле является &lt;em&gt;ссылкой&lt;/em&gt; на объект (но ссылка передается по значению)</target>
        </trans-unit>
        <trans-unit id="9789798d32b8f1cb1ca7e4b37e5b087b68d91f3c" translate="yes" xml:space="preserve">
          <source>which obviously will change the object. &lt;a href=&quot;https://stackoverflow.com/a/534509/831531&quot;&gt;This answer&lt;/a&gt; explains it well.</source>
          <target state="translated">что, очевидно, изменит объект. &lt;a href=&quot;https://stackoverflow.com/a/534509/831531&quot;&gt;Этот ответ&lt;/a&gt; объясняет это хорошо.</target>
        </trans-unit>
        <trans-unit id="0a5dcf0aaba3d474366727f90d67aa1948bf146f" translate="yes" xml:space="preserve">
          <source>which obviously will not change the object passed to the function. If the function looked like this:</source>
          <target state="translated">что,очевидно,не изменит объект,переданный в функцию.Если функция выглядит так:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
