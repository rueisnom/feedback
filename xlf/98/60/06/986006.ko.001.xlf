<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/986006">
    <body>
      <group id="986006">
        <trans-unit id="a1b152a892ef513d9a4d8de1e227286558de128b" translate="yes" xml:space="preserve">
          <source>&quot;...variables [names] are &lt;em&gt;not&lt;/em&gt; objects; they cannot be denoted by other variables or referred to by objects.&quot;</source>
          <target state="translated">&quot;... 변수 [이름]은 객체가 &lt;em&gt;아닙니다&lt;/em&gt; . 다른 변수로 표시하거나 객체가 참조 할 수 없습니다.&quot;</target>
        </trans-unit>
        <trans-unit id="ec2f8b9ef1eca2860982704b2396e6f5e99305cc" translate="yes" xml:space="preserve">
          <source>&quot;In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a new value anywhere within the function&amp;rsquo;s body, it&amp;rsquo;s assumed to be a local. If a variable is ever assigned a new value inside the function, the variable is implicitly local, and you need to explicitly declare it as &amp;lsquo;global&amp;rsquo;.
Though a bit surprising at first, a moment&amp;rsquo;s consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, you&amp;rsquo;d be using global all the time. You&amp;rsquo;d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.&quot;</source>
          <target state="translated">&quot;파이썬에서 함수 안에서만 참조되는 변수는 암시 적으로 전역 적입니다. 변수가 함수 본문의 어느 곳에 나 새로운 값이 할당되면 로컬로 간주됩니다. 변수가 함수 내부에 새로운 값을 할당하면 변수는 암시 적으로 지역적이며 명시 적으로 '글로벌'로 선언해야합니다. 처음에는 조금 놀랍지 만 잠시 고려해야 할 사항이 있습니다. 할당 된 변수에 전역을 요구하면 의도하지 않은 부작용에 대한 막대가 생깁니다. 반면에 모든 전역 참조에 전역이 필요한 경우 항상 전역을 사용하게되며 내장 함수 또는 가져온 모듈의 구성 요소에 대한 모든 참조를 전역으로 선언해야합니다. 부작용을 식별하기위한 글로벌 선언의 유용성을 무너 뜨릴 것입니다. &quot;</target>
        </trans-unit>
        <trans-unit id="42c22aec244c5d347e54be65aaab6403cdf146a7" translate="yes" xml:space="preserve">
          <source>(Yeah I know this can be inconvenient, but sometimes it is simple enough to do this.)</source>
          <target state="translated">(예, 이것이 불편할 수 있음을 알고 있지만 때로는 그렇게하기에 충분히 간단합니다.)</target>
        </trans-unit>
        <trans-unit id="8a51a221218346c2c1772a44d0e7cc971cece6c5" translate="yes" xml:space="preserve">
          <source>(edit - Blair has updated his enormously popular answer so that it is now accurate)</source>
          <target state="translated">(편집-블레어는 현재 가장 정확한 답변을 업데이트했습니다.</target>
        </trans-unit>
        <trans-unit id="a62a78c201c7282875384fa5a4bbe69e0365e928" translate="yes" xml:space="preserve">
          <source>(edit 2019-04-28)</source>
          <target state="translated">(2019-04-28 편집)</target>
        </trans-unit>
        <trans-unit id="8b9f3efa3729cce732344f81bf8d7d82f28606bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self.variable&lt;/code&gt; is a reference to the string object &lt;code&gt;'Original'&lt;/code&gt;. When you call &lt;code&gt;Change&lt;/code&gt; you create a second reference &lt;code&gt;var&lt;/code&gt; to the object. Inside the function you reassign the reference &lt;code&gt;var&lt;/code&gt; to a different string object &lt;code&gt;'Changed'&lt;/code&gt;, but the reference &lt;code&gt;self.variable&lt;/code&gt; is separate and does not change.</source>
          <target state="translated">&lt;code&gt;self.variable&lt;/code&gt; 은 문자열 객체 &lt;code&gt;'Original'&lt;/code&gt; 에 대한 참조입니다. &lt;code&gt;Change&lt;/code&gt; 를 호출하면 객체에 대한 두 번째 참조 &lt;code&gt;var&lt;/code&gt; 가 작성됩니다. 함수 내에서 참조 &lt;code&gt;var&lt;/code&gt; 를 다른 문자열 객체 &lt;code&gt;'Changed'&lt;/code&gt; 에 다시 할당하지만 참조 &lt;code&gt;self.variable&lt;/code&gt; 은 분리되어 있으며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4229ed636553c69cfddd84246fc10b33ff69719b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++:&lt;/strong&gt; Both pass-by-reference or pass-by-value are allowed. If a parameter is passed by reference, you can either modify it or not depending upon whether the parameter was passed as const or not. However, const or not, the parameter maintains the reference to the object and reference cannot be assigned to point to a different object within the called function.</source>
          <target state="translated">&lt;strong&gt;C ++ :&lt;/strong&gt; 기준 별 통과 또는 값별 통과가 모두 허용됩니다. 매개 변수가 참조로 전달 된 경우 매개 변수가 const로 전달되었는지 여부에 따라 매개 변수를 수정하거나 수정할 수 없습니다. 그러나 const 또는 not 매개 변수는 객체에 대한 참조를 유지하며 호출 된 함수 내에서 다른 객체를 가리 키도록 참조를 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b3be1ec03105d4972fcbe3fec3a499e2307f9ee7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; It's been noted that this doesn't answer the question that @David originally asked, &quot;Is there something I can do to pass the variable by actual reference?&quot;. Let's work on that.</source>
          <target state="translated">&lt;strong&gt;편집 :&lt;/strong&gt; 이것은 @David가 처음에 &quot;실제 참조로 변수를 전달하기 위해 할 수있는 일이 있습니까?&quot;라는 질문에 대답하지는 않습니다. 그 일을 해보자.</target>
        </trans-unit>
        <trans-unit id="d892af211725dce0575cd510d5913eae3f198cec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's immutable, so there's nothing we can do to change the contents of the string&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;불변이므로 문자열의 내용을 변경하기 위해 할 수있는 일은 없습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee9513e042a85a4c63813585beec33bd12875b0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java&amp;amp;C#:&lt;/strong&gt; primitive types(include string)pass by value(copy), Reference type is passed by reference(address copy) so all changes made in the parameter in the called function are visible to the caller.</source>
          <target state="translated">&lt;strong&gt;Java &amp;amp; C # :&lt;/strong&gt; 기본 유형 (문자열 포함) 값으로 전달 (복사), 참조 유형은 참조 (주소 사본)로 전달되므로 호출 된 함수의 매개 변수에서 &lt;strong&gt;작성된&lt;/strong&gt; 모든 변경 사항은 호출자에게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b6bd3f4d372e7f7c7ecfb3b235bcc93f977ff2b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's try to modify the list that was passed to a method:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;메소드에 전달 된 목록을 수정 해 봅시다 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be2b61cd76cc0ed218c950fa9a0f695fe658d0b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now let's see what happens when we try to change the reference that was passed in as a parameter:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이제 매개 변수로 전달 된 참조를 변경하려고 할 때 어떤 일이 발생하는지 봅시다 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1bb1d2d46eeb3cfe61924c812bf981baeae0193b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now, let's try to change the reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이제 참조를 변경해 봅시다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5b90913af1169e0301615a93fc64f0e5b948b1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python:&lt;/strong&gt; 
Python is &amp;ldquo;pass-by-object-reference&amp;rdquo;, of which it is often said: &amp;ldquo;Object references are passed by value.&amp;rdquo;[Read here]&lt;a href=&quot;https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/&quot;&gt;1&lt;/a&gt;. Both the caller and the function refer to the same object but the parameter in the function is a new variable which is just holding a copy of the object in the caller. Like C++, a parameter can be either modified or not in function - This depends upon the type of object passed. eg; An immutable object type cannot be modified in the called function whereas a mutable object can be either updated or re-initialized. A crucial difference between updating or re-assigning/re-initializing the mutable variable is that updated value gets reflected back in the called function whereas the reinitialized value does not. Scope of any assignment of new object to a mutable variable is local to the function in the python. Examples provided by @blair-conrad are great to understand this.</source>
          <target state="translated">&lt;strong&gt;파이썬 :&lt;/strong&gt; 파이썬은 &quot;객체 참조에 의한 통과&quot;이며, &quot;오브젝트 참조는 값으로 전달됩니다.&quot;[읽기] &lt;a href=&quot;https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/&quot;&gt;1&lt;/a&gt; . 호출자와 함수는 모두 동일한 객체를 참조하지만 함수의 매개 변수는 호출자의 객체 사본을 보유하는 새로운 변수입니다. C ++과 마찬가지로 매개 변수는 수정되거나 기능하지 않을 수 있습니다. 이는 전달 된 객체의 유형에 따라 다릅니다. 예를 들어; 불변 객체 유형은 호출 된 함수에서 수정할 수 없지만 변경 가능한 객체는 업데이트하거나 다시 초기화 할 수 있습니다. 변경 가능한 변수를 업데이트하거나 재 할당 / 재 초기화하는 것의 중요한 차이점은 업데이트 된 값은 호출 된 함수에 다시 반영되지만 다시 초기화 된 값은 그렇지 않습니다. 새로운 객체를 변경 가능한 변수에 할당하는 범위는 파이썬의 함수에 국한됩니다. @ blair-conrad가 제공 한 예는 이것을 이해하는 데 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9883e919e7997c4bcd00e7db78ba8af7ca037be6" translate="yes" xml:space="preserve">
          <source>A lot of insights in answers here, but i think an additional point is not clearly mentioned here explicitly.   Quoting from python documentation &lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&lt;/a&gt;</source>
          <target state="translated">여기에 대한 답변에 대한 많은 통찰력이 있지만 여기에 추가 요점이 명확하게 언급되어 있지 않다고 생각합니다. 파이썬 문서에서 인용 &lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b9bc6a21011e77a1fc1acf4db17ae8c442f98ed" translate="yes" xml:space="preserve">
          <source>A simple trick I normally use is to just wrap it in a list:</source>
          <target state="translated">내가 일반적으로 사용하는 간단한 트릭은 목록으로 감싸는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1c34629702aff601e9017462b805c4e1564c10a6" translate="yes" xml:space="preserve">
          <source>Again, since the &lt;code&gt;the_string&lt;/code&gt; parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The &lt;code&gt;the_string&lt;/code&gt; was a copy of the &lt;code&gt;outer_string&lt;/code&gt; reference, and we had &lt;code&gt;the_string&lt;/code&gt; point to a new string, but there was no way to change where &lt;code&gt;outer_string&lt;/code&gt; pointed.</source>
          <target state="translated">&lt;code&gt;the_string&lt;/code&gt; 매개 변수가 값으로 전달 되었으므로 새 문자열을 할당해도 메서드 외부의 코드에서 볼 수 없었습니다. &lt;code&gt;the_string&lt;/code&gt; 은 &lt;code&gt;outer_string&lt;/code&gt; 참조의 복사본이며, 우리는 &lt;code&gt;the_string&lt;/code&gt; 이 새로운 문자열을 가리 키도록하지만 &lt;code&gt;outer_string&lt;/code&gt; 이 가리키는 위치를 변경할 방법이 없었습니다.</target>
        </trans-unit>
        <trans-unit id="c9e5405e129e476d3e0ef475249c330ed3f6dfb5" translate="yes" xml:space="preserve">
          <source>Although this seems a little cumbersome.</source>
          <target state="translated">비록 조금 성가신 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d97b97ac2c4c28ba96535277dd72cff612ba228" translate="yes" xml:space="preserve">
          <source>Another solution would be to create a static method like this:</source>
          <target state="translated">또 다른 해결책은 다음과 같은 정적 메소드를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b0c7226e7708d9f8704f1ddf855b76d4d0e697d8" translate="yes" xml:space="preserve">
          <source>Arguments are &lt;a href=&quot;http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference&quot;&gt;passed by assignment&lt;/a&gt;. The rationale behind this is twofold:</source>
          <target state="translated">인수는 &lt;a href=&quot;http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference&quot;&gt;할당에 의해 전달됩니다&lt;/a&gt; . 이것의 근거는 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="57fce48e3511c0b229efd7be720f8de1904d6840" translate="yes" xml:space="preserve">
          <source>As @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out:</source>
          <target state="translated">@Andrea의 답변에서 알 수 있듯이 새로운 값을 반환 할 수 있습니다. 이것은 물건이 전달되는 방식을 바꾸지는 않지만 원하는 정보를 다시 가져올 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="3fc39df4449e0220d47d2afd67496a6547200ecf" translate="yes" xml:space="preserve">
          <source>As you can state you need to have a mutable object, but let me suggest you to check over the global variables as they can help you or even solve this kind of issue!</source>
          <target state="translated">알 수 있듯이 변경 가능한 객체가 필요하지만 전역 변수가 도움이되거나 이러한 종류의 문제를 해결할 수 있으므로 전역 변수를 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1173d3f94d407863d6672e2edbfad0d748c8d95e" translate="yes" xml:space="preserve">
          <source>Aside from all the great explanations on how this stuff works in Python, I don't see a simple suggestion for the problem. As you seem to do create objects and instances, the pythonic way of handling instance variables and changing them is the following:</source>
          <target state="translated">파이썬 에서이 기능이 어떻게 작동하는지에 대한 모든 훌륭한 설명 외에도 문제에 대한 간단한 제안은 보이지 않습니다. 객체와 인스턴스를 만드는 것처럼 보이지만 인스턴스 변수를 처리하고 변경하는 pythonic 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="955f20c5fd3d4cf266b4f4f30cefc9bede9bc806" translate="yes" xml:space="preserve">
          <source>Assignment binds a name to an object.</source>
          <target state="translated">할당은 이름을 객체에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="44eb458222e5cac4dd20238f7eb9ffa3a0a032f1" translate="yes" xml:space="preserve">
          <source>David Cournapeau's answer points to the real answer and explains why the behavior in Blair Conrad's post seems to be correct while the definitions are not.</source>
          <target state="translated">David Cournapeau의 답변은 실제 답변을 가리키며 Blair Conrad의 게시물의 동작이 왜 정확하지 않은지 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6ba040c2f2a2d80842507aa7fb2215325e5e6c43" translate="yes" xml:space="preserve">
          <source>Effbot (aka Fredrik Lundh) has described Python's variable passing style as call-by-object:  &lt;a href=&quot;http://effbot.org/zone/call-by-object.htm&quot;&gt;http://effbot.org/zone/call-by-object.htm&lt;/a&gt;</source>
          <target state="translated">Effbot (일명 Fredrik Lundh)은 Python의 변수 전달 스타일을 객체 별 호출로 설명했습니다. &lt;a href=&quot;http://effbot.org/zone/call-by-object.htm&quot;&gt;http://effbot.org/zone/call-by-object.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="feb265a8df8e110e2790224a1da7e1861c9fda44" translate="yes" xml:space="preserve">
          <source>Even when passing a mutable object to a function this still applies. And to me clearly explains the reason for the difference in behavior between assigning to the object and operating on the object in the function.</source>
          <target state="translated">변경 가능한 객체를 함수에 전달할 때도 여전히 적용됩니다. 그리고 객체에 할당하는 것과 함수의 객체에서 작동하는 것 사이의 행동 차이가 나는 이유를 분명히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="63aabb26e4f4644f4690795ae16738f9c1f5f4da" translate="yes" xml:space="preserve">
          <source>For just reading there is even a shorter way of just using &lt;code&gt;lambda: x&lt;/code&gt; which returns a callable that when called returns the current value of x. This is somewhat like &quot;call by name&quot; used in languages in the distant past.</source>
          <target state="translated">단지 읽기 위해서는 &lt;code&gt;lambda: x&lt;/code&gt; 사용하는 더 짧은 방법이 있습니다 : x 는 호출 할 때 호출 할 수있는 x 를 반환하는 호출 가능한 것을 반환합니다. 이것은 먼 옛날 언어에서 사용 된 &quot;이름으로 전화&quot;와 다소 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="a82f8b81c3ead144e50f2f04d42ea8cbd19c3b82" translate="yes" xml:space="preserve">
          <source>Here is a significant quote:</source>
          <target state="translated">중요한 인용문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64605a5b8fffbc932d2851dd3c0a9a3b81ea1391" translate="yes" xml:space="preserve">
          <source>Here is the example that proves that Python uses passing by reference:</source>
          <target state="translated">다음은 파이썬이 참조로 전달을 사용한다는 것을 증명하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="4652a9a03eda229eaa585e4d8b3108f912ea3767" translate="yes" xml:space="preserve">
          <source>Here is the simple (I hope) explanation of the concept &lt;code&gt;pass by object&lt;/code&gt; used in Python.</source>
          <target state="translated">다음은 파이썬에서 사용 &lt;code&gt;pass by object&lt;/code&gt; 개념 전달에 대한 간단한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="48484f80102edbe70571bc88f85e228361438a9f" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;ByRef&lt;/code&gt; class wraps a dictionary access. So attribute access to &lt;code&gt;wrapped&lt;/code&gt; is translated to a item access in the passed dictionary. By passing the result of the builtin &lt;code&gt;locals&lt;/code&gt; and the name of a local variable this ends up accessing a local variable. The python documentation as of 3.5 advises that changing the dictionary might not work but it seems to work for me.</source>
          <target state="translated">여기서 &lt;code&gt;ByRef&lt;/code&gt; 클래스는 사전 액세스를 래핑합니다. &lt;code&gt;wrapped&lt;/code&gt; 속성 액세스는 전달 된 사전의 항목 액세스로 변환됩니다. 내장 &lt;code&gt;locals&lt;/code&gt; 의 결과와 로컬 변수의 이름을 전달하면 로컬 변수에 액세스하게됩니다. 3.5의 python 문서는 사전을 변경하면 작동하지 않을 수 있지만 나에게 도움이되는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="d0be6fb2e163967ac2361db4b4dde754f1a7b504" translate="yes" xml:space="preserve">
          <source>Hope that clarifies the issue for you.</source>
          <target state="translated">그것이 당신을 위해 문제를 분명히하기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="ac9f35a5c40f1a54d0e975658a953c9ccceb917a" translate="yes" xml:space="preserve">
          <source>How do I pass a variable by reference</source>
          <target state="translated">참조로 변수를 전달하는 방법</target>
        </trans-unit>
        <trans-unit id="2635b21aa1a1e66c5ca7fed959d2e61ba0068f22" translate="yes" xml:space="preserve">
          <source>How do we get around this?</source>
          <target state="translated">우리는 어떻게이 문제를 해결합니까?</target>
        </trans-unit>
        <trans-unit id="f2d3f338abd337442158a979a1f5de30af33097e" translate="yes" xml:space="preserve">
          <source>How to pass by reference</source>
          <target state="translated">참조로 전달하는 방법</target>
        </trans-unit>
        <trans-unit id="072a54410009d923de415851395bc3f915f1966d" translate="yes" xml:space="preserve">
          <source>How to read the example in the question</source>
          <target state="translated">질문에서 예를 읽는 방법</target>
        </trans-unit>
        <trans-unit id="f10e3c369b21afb8efe5cb8ff95bfee39a5c9ffa" translate="yes" xml:space="preserve">
          <source>I found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.</source>
          <target state="translated">다른 답변은 다소 길고 복잡하다는 것을 알았 으므로이 간단한 다이어그램을 작성하여 Python이 변수 및 매개 변수를 처리하는 방식을 설명했습니다.</target>
        </trans-unit>
        <trans-unit id="3ca5711f1032450bdfe039601daafa6c14debe97" translate="yes" xml:space="preserve">
          <source>I hope this clears things up a little.</source>
          <target state="translated">나는 이것이 약간의 문제를 해결하기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="779f081125662b16c96e53373144d42eb57b8923" translate="yes" xml:space="preserve">
          <source>I think it is important to note that the current post with the most votes (by Blair Conrad), while being correct with respect to its result, is misleading and is borderline incorrect based on its definitions.  While there are many languages (like C) that allow the user to either pass by reference or pass by value, Python is not one of them.</source>
          <target state="translated">블레어 콘래드 (Blair Conrad)에 의해 가장 많은 표를 얻은 현재 게시물은 그 결과와 관련하여 정확하지만 오해의 소지가 있으며 그 정의에 따라 경계선이 잘못되었다는 점에 주목해야합니다. 사용자가 참조로 전달하거나 값으로 전달할 수있는 많은 언어 (C와 같은)가 있지만 Python은 그중 하나가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1caf319e1b878a7a9add11ed6d02d3179fc2d9bb" translate="yes" xml:space="preserve">
          <source>I used the following method to quickly convert a couple of Fortran codes to Python.  True, it's not pass by reference as the original question was posed, but is a simple work around in some cases.</source>
          <target state="translated">다음 방법을 사용하여 두 개의 포트란 코드를 Python으로 빠르게 변환했습니다. 사실, 원래의 질문이 제기되었을 때 참조로 전달되지는 않지만 경우에 따라 간단한 해결 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f8f3af9f0dc96665fb36e21e7dd8ea0010188a92" translate="yes" xml:space="preserve">
          <source>I'm sure someone else could clarify this further.</source>
          <target state="translated">다른 사람이 이것을 더 명확히 할 수 있다고 확신합니다.</target>
        </trans-unit>
        <trans-unit id="8fd3fb5434919f5765b442b73f1a2ea249604d75" translate="yes" xml:space="preserve">
          <source>If it is an &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;immutable&lt;/a&gt; object (e.g. a bool, number, string), the way to go is to wrap it in a mutable object.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;불변&lt;/a&gt; 객체 (예 : 부울, 숫자, 문자열) 인 경우 변경 가능한 객체로 감싸는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e8ff937ee3cf391aa9369bcc79fcdbacd051a2eb" translate="yes" xml:space="preserve">
          <source>If the argument was passed by value, the outer &lt;code&gt;lst&lt;/code&gt; could not be modified. The green are the target objects (the black is the value stored inside, the red is the object type), the yellow is the memory with the reference value inside -- drawn as the arrow. The blue solid arrow is the reference value that was passed to the function (via the dashed blue arrow path). The ugly dark yellow is the internal dictionary. (It actually could be drawn also as a green ellipse. The colour and the shape only says it is internal.)</source>
          <target state="translated">인수가 값으로 전달되면 외부 &lt;code&gt;lst&lt;/code&gt; 를 수정할 수 없습니다. 녹색은 대상 객체 (검정은 내부에 저장된 값, 빨간색은 객체 유형), 노란색은 참조 값이 내부에있는 메모리이며 화살표로 표시됩니다. 파란색 실선 화살표는 파선으로 된 파란색 화살표 경로를 통해 함수에 전달 된 참조 값입니다. 못생긴 짙은 노란색은 내부 사전입니다. (실제로 녹색 타원으로 그릴 수도 있습니다. 색상과 모양은 내부라고 말합니다.)</target>
        </trans-unit>
        <trans-unit id="0dd316a07900ad81da1e569611d0d7f972700c53" translate="yes" xml:space="preserve">
          <source>If you pass a &lt;em&gt;mutable&lt;/em&gt; object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object.</source>
          <target state="translated">&lt;em&gt;변경 가능한&lt;/em&gt; 객체를 메소드에 전달하면 메소드는 동일한 객체에 대한 참조를 가져와 마음에 맞게 변경할 수 있지만 메소드에서 참조를 리 바인드하면 외부 범위는 아무것도 알지 못합니다. 완료되었으므로 외부 참조는 여전히 원래 객체를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="6f1b4b35463994559a0edb1ad6a1b8357fb742a0" translate="yes" xml:space="preserve">
          <source>If you pass an &lt;em&gt;immutable&lt;/em&gt; object to a method, you still can't rebind the outer reference, and you can't even mutate the object.</source>
          <target state="translated">&lt;em&gt;변경할 수없는&lt;/em&gt; 객체를 메서드에 전달하면 여전히 외부 참조를 리 바인드 할 수 없으며 객체를 &lt;em&gt;변경할&lt;/em&gt; 수도 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc1e60fe42ced701dd9148c0ff6beca470127f04" translate="yes" xml:space="preserve">
          <source>If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:</source>
          <target state="translated">반환 값을 사용하지 않으려는 경우 값을 보유하고 함수에 전달하거나 목록과 같은 기존 클래스를 사용하는 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9688763625be69eed8ed0d10e131598208128be6" translate="yes" xml:space="preserve">
          <source>If you want the behavior, Blair Conrad's answer is fine.  But if you want to know the nuts and bolts of why Python is neither pass by value or pass by reference, read David Cournapeau's answer.</source>
          <target state="translated">당신이 행동을 원한다면 Blair Conrad의 대답은 괜찮습니다. 그러나 파이썬이 가치를 지니지 않거나 참조로 전달되지 않는 이유의 요점을 알고 싶다면 David Cournapeau의 대답을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="e5596ea1ad94c7661a4350a8652098d786a4cc4b" translate="yes" xml:space="preserve">
          <source>Immutable arguments are effectively passed &amp;ldquo;&lt;strong&gt;by value&lt;/strong&gt;.&amp;rdquo; Objects such as integers and strings are passed by object reference instead of by copying, but because you can&amp;rsquo;t change immutable objects in place anyhow, the effect is much like making a copy.</source>
          <target state="translated">불변 인수는 효과적으로 &quot; &lt;strong&gt;가치 별&lt;/strong&gt; &quot; &lt;strong&gt;으로&lt;/strong&gt; 전달 &lt;strong&gt;됩니다&lt;/strong&gt; . 정수 및 문자열과 같은 객체는 복사하는 대신 객체 참조로 전달되지만 변경 불가능한 객체를 변경할 수 없기 때문에 결과는 복사하는 것과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="6302f1ff1c0c2b90057d999e0b3858fc9d2a2e08" translate="yes" xml:space="preserve">
          <source>In compiled languages, a variable is a memory space that is able to capture the value of the type. In Python, a variable is a name (captured internally as a string) bound to the reference variable that holds the reference value to the target object. The name of the variable is the key in the internal dictionary, the value part of that dictionary item stores the reference value to the target.</source>
          <target state="translated">컴파일 된 언어에서 변수는 유형의 값을 캡처 할 수있는 메모리 공간입니다. Python에서 변수는 대상 객체에 대한 참조 값을 보유하는 참조 변수에 바인딩 된 이름 (내부적으로 문자열로 캡처 됨)입니다. 변수의 이름은 내부 사전의 키이며 해당 사전 항목의 값 부분은 참조 값을 대상에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="271a2c315dedadaa6b644002264db432c9330e40" translate="yes" xml:space="preserve">
          <source>In instance methods, you normally refer to &lt;code&gt;self&lt;/code&gt; to access instance attributes. It is normal to set instance attributes in &lt;code&gt;__init__&lt;/code&gt; and read or change them in instance methods. That is also why you pass &lt;code&gt;self&lt;/code&gt; als the first argument to &lt;code&gt;def Change&lt;/code&gt;.</source>
          <target state="translated">인스턴스 메소드에서는 일반적으로 인스턴스 속성에 액세스하기 위해 &lt;code&gt;self&lt;/code&gt; 를 참조합니다. &lt;code&gt;__init__&lt;/code&gt; 에서 인스턴스 속성을 설정하고 인스턴스 메소드에서 읽거나 변경하는 것이 일반적입니다. 따라서 &lt;code&gt;def Change&lt;/code&gt; 의 첫 번째 인수를 &lt;code&gt;self&lt;/code&gt; als에 전달하는 이유도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fae6b090cdbf66824da7924b6168f4173a64868f" translate="yes" xml:space="preserve">
          <source>In the code shown in the question, the statement &lt;code&gt;self.Change(self.variable)&lt;/code&gt; binds the name &lt;code&gt;var&lt;/code&gt; (in the scope of function &lt;code&gt;Change&lt;/code&gt;) to the object that holds the value &lt;code&gt;'Original'&lt;/code&gt; and the assignment &lt;code&gt;var = 'Changed'&lt;/code&gt; (in the body of function &lt;code&gt;Change&lt;/code&gt;) assigns that same name again: to some other object (that happens to hold a string as well but could have been something else entirely).</source>
          <target state="translated">질문에 표시된 코드에서 &lt;code&gt;self.Change(self.variable)&lt;/code&gt; 문은 이름 &lt;code&gt;var&lt;/code&gt; ( &lt;code&gt;Change&lt;/code&gt; 기능 범위에서) 값을 &lt;code&gt;'Original'&lt;/code&gt; 값과 &lt;code&gt;var = 'Changed'&lt;/code&gt; (in) 값을 보유한 객체에 바인딩합니다. &lt;code&gt;Change&lt;/code&gt; 함수의 본문은 동일한 이름을 다시 다른 객체에 할당합니다 (문자열을 유지하지만 완전히 다른 것일 수 있음).</target>
        </trans-unit>
        <trans-unit id="d174ebf38cb48196530f520173f23f96ee505c2d" translate="yes" xml:space="preserve">
          <source>In this case the variable titled &lt;code&gt;var&lt;/code&gt; in the method &lt;code&gt;Change&lt;/code&gt; is assigned a reference to &lt;code&gt;self.variable&lt;/code&gt;, and you immediately assign a string to &lt;code&gt;var&lt;/code&gt;. It's no longer pointing to &lt;code&gt;self.variable&lt;/code&gt;. The following code snippet shows what would happen if you modify the data structure pointed to by &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;self.variable&lt;/code&gt;, in this case a list:</source>
          <target state="translated">이 경우 &lt;code&gt;Change&lt;/code&gt; 메서드에서 &lt;code&gt;var&lt;/code&gt; 라는 변수에 &lt;code&gt;self.variable&lt;/code&gt; 에 대한 참조가 할당되고 즉시 &lt;code&gt;var&lt;/code&gt; 에 문자열을 할당합니다. 더 이상 &lt;code&gt;self.variable&lt;/code&gt; 을 가리 키지 않습니다. 다음 코드 스 니펫은 &lt;code&gt;var&lt;/code&gt; 및 &lt;code&gt;self.variable&lt;/code&gt; 이 가리키는 데이터 구조 (이 경우 목록)를 수정하면 어떻게되는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c93eaa9797f60173290b5121f5aebea5bd45b163" translate="yes" xml:space="preserve">
          <source>In your example, when the &lt;code&gt;Change&lt;/code&gt; method is called--a &lt;a href=&quot;http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces&quot;&gt;namespace&lt;/a&gt; is created for it; and &lt;code&gt;var&lt;/code&gt; becomes a name, within that namespace, for the string object &lt;code&gt;'Original'&lt;/code&gt;. That object then has a name in two namespaces. Next, &lt;code&gt;var = 'Changed'&lt;/code&gt; binds &lt;code&gt;var&lt;/code&gt; to a new string object, and thus the method's namespace forgets about &lt;code&gt;'Original'&lt;/code&gt;. Finally, that namespace is forgotten, and the string &lt;code&gt;'Changed'&lt;/code&gt; along with it.</source>
          <target state="translated">예를 들어, &lt;code&gt;Change&lt;/code&gt; 메소드가 호출되면 &lt;a href=&quot;http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces&quot;&gt;네임 스페이스&lt;/a&gt; 가 작성됩니다. &lt;code&gt;var&lt;/code&gt; 는 해당 네임 스페이스 내에서 문자열 객체 &lt;code&gt;'Original'&lt;/code&gt; 의 이름이 됩니다. 그런 다음 해당 개체는 두 개의 네임 스페이스에 이름을 갖습니다. 다음으로 &lt;code&gt;var = 'Changed'&lt;/code&gt; 를 새 문자열 객체에 바인딩하므로 메서드의 네임 스페이스는 &lt;code&gt;'Original'&lt;/code&gt; 을 잊어 버립니다. 마지막으로, 해당 네임 스페이스가 잊혀지고 문자열과 함께 &lt;code&gt;'Changed'&lt;/code&gt; 가 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="bb33c9ab807f193d39872eed5e22af0127a40637" translate="yes" xml:space="preserve">
          <source>Is there something I can do to pass the variable by actual reference?</source>
          <target state="translated">실제 참조로 변수를 전달하기 위해 할 수있는 일이 있습니까?</target>
        </trans-unit>
        <trans-unit id="d7e7bdb80421d5ef59aefc489f344f221587bba6" translate="yes" xml:space="preserve">
          <source>It is neither pass-by-value or pass-by-reference - it is call-by-object. See this, by Fredrik Lundh:</source>
          <target state="translated">값으로 전달 또는 참조로 전달되지 않습니다. 개체 별 호출입니다. Fredrik Lundh의 이것을보십시오 :</target>
        </trans-unit>
        <trans-unit id="48bb347a9d7faf829dae8ac2ec01719f82c86124" translate="yes" xml:space="preserve">
          <source>It's an ugly hack, but it works. ;-P</source>
          <target state="translated">추악한 해킹이지만 작동합니다. ;-피</target>
        </trans-unit>
        <trans-unit id="c4d93e3229bff3269f3ab05cdf6305855b9bc82f" translate="yes" xml:space="preserve">
          <source>List - a mutable type</source>
          <target state="translated">리스트-가변 타입</target>
        </trans-unit>
        <trans-unit id="e145738e57fdf9ea90a9bfc63f28785068e9be9d" translate="yes" xml:space="preserve">
          <source>Mutable arguments are effectively passed &amp;ldquo;&lt;strong&gt;by pointer&lt;/strong&gt;.&amp;rdquo; Objects such as lists
and dictionaries are also passed by object reference, which is similar to the way C
passes arrays as pointers&amp;mdash;mutable objects can be changed in place in the function,
much like C arrays.</source>
          <target state="translated">가변 인수는 효과적으로 &quot; &lt;strong&gt;포인터로&lt;/strong&gt; &quot;전달 &lt;strong&gt;됩니다&lt;/strong&gt; . 목록 및 사전과 같은 객체도 객체 참조를 통해 전달되는데, 이는 C가 포인터를 배열로 전달하는 방식과 유사합니다. C 객체와 같이 변경 가능한 객체는 함수에서 대신 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed19ef46a33530a5532cfcd97126ae99cb3242a0" translate="yes" xml:space="preserve">
          <source>Objects are allocated on the heap and pointers to them can be passed around anywhere.</source>
          <target state="translated">객체는 힙에 할당되며 포인터는 어디에서나 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87dea7220960a8d9957e82c5e7caf7ae67f5891a" translate="yes" xml:space="preserve">
          <source>Objects like lists are &lt;em&gt;mutable&lt;/em&gt;.  This means that the contents of the object can be changed by anything pointing to the object.  For example, &lt;code&gt;x = []; y = x; x.append(10); print y&lt;/code&gt; will print &lt;code&gt;[10]&lt;/code&gt;.  The empty list was created.  Both &quot;x&quot; and &quot;y&quot; point to the same list.  The &lt;em&gt;append&lt;/em&gt; method mutates (updates) the list object (like adding a record to a database) and the result is visible to both &quot;x&quot; and &quot;y&quot; (just as a database update would be visible to every connection to that database).</source>
          <target state="translated">리스트와 같은 객체는 &lt;em&gt;변경 가능&lt;/em&gt; 합니다. 이것은 객체의 내용이 객체를 가리키는 것으로 변경 될 수 있음을 의미합니다. 예를 들어, &lt;code&gt;x = []; y = x; x.append(10); print y&lt;/code&gt; y = x; x.append (10); y 인쇄는 &lt;code&gt;[10]&lt;/code&gt; 을 인쇄합니다. 빈 목록이 작성되었습니다. &quot;x&quot;와 &quot;y&quot;는 모두 동일한 목록을 가리 킵니다. &lt;em&gt;append&lt;/em&gt; 메소드는 데이터베이스에 레코드를 추가하는 것과 같이 목록 오브젝트를 변경 (업데이트)하고 결과는 &quot;x&quot;및 &quot;y&quot;모두에 표시됩니다 (데이터베이스 업데이트가 해당 데이터베이스에 대한 모든 연결에 표시되는 것처럼).</target>
        </trans-unit>
        <trans-unit id="4498e2a33a71723f43491095390bfa7816d3f75b" translate="yes" xml:space="preserve">
          <source>Objects like strings and integers are &lt;em&gt;immutable&lt;/em&gt;.  This simply means that there are no methods that can change the object after it has been created.  For example, once the integer object one-thousand is created, it will never change.  Math is done by creating new integer objects.</source>
          <target state="translated">문자열 및 정수와 같은 객체는 &lt;em&gt;변경할 수 없습니다&lt;/em&gt; . 이것은 객체를 만든 후에 변경할 수있는 메소드가 없다는 것을 의미합니다. 예를 들어, 정수 객체가 천 번 생성되면 절대 변경되지 않습니다. 수학은 새로운 정수 객체를 생성하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="27f285ca9e6dbf4bba0bcd6c449903172991d998" translate="yes" xml:space="preserve">
          <source>Obviously the above does not allow &lt;em&gt;reading&lt;/em&gt; the value, only updating it.</source>
          <target state="translated">분명히 위의 값을 &lt;em&gt;읽을&lt;/em&gt; 수 없으며 업데이트 만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4751c7c9efc0a91758450a9fee280437f3b71a6f" translate="yes" xml:space="preserve">
          <source>One way is to use &lt;code&gt;global&lt;/code&gt; (for global variables) or &lt;code&gt;nonlocal&lt;/code&gt; (for local variables in a function) in a wrapper function.</source>
          <target state="translated">한 가지 방법은 랩퍼 함수에서 &lt;code&gt;global&lt;/code&gt; (글로벌 변수의 경우) 또는 &lt;code&gt;nonlocal&lt;/code&gt; (함수의 로컬 변수의 경우)을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="c439d84dc5a961368d9307e0770827dfc4515420" translate="yes" xml:space="preserve">
          <source>Pass-By-Reference in Python is quite different from the concept of pass by reference in C++/Java.</source>
          <target state="translated">Python의 Pass-By-Reference는 C ++ / Java의 참조에 의한 pass의 개념과는 상당히 다릅니다.</target>
        </trans-unit>
        <trans-unit id="68451aca93c616b65cb7c9047a81894d6b972f90" translate="yes" xml:space="preserve">
          <source>Passing 3 wrappers to access a variable is a bit unwieldy so those can be wrapped into a class that has a proxy attribute:</source>
          <target state="translated">변수에 액세스하기 위해 3 개의 래퍼를 전달하는 것은 다소 까다로워서 프록시 속성이있는 클래스로 래핑 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0827e8d71a8fb26dad798d59e58b5d9485ef355e" translate="yes" xml:space="preserve">
          <source>Passing an argument into a function also binds a name (the parameter name of the function) to an object.</source>
          <target state="translated">함수에 인수를 전달하면 이름 (함수의 매개 변수 이름)도 객체에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="c8afd49f905bfc9a3cb491f06eb314e73ee2416c" translate="yes" xml:space="preserve">
          <source>Python always uses pass-by-reference values. There isn't any exception. Any variable assignment means copying the reference value. No exception. Any variable is the name bound to the reference value. Always.</source>
          <target state="translated">파이썬은 항상 참조로 전달 값을 사용합니다. 예외는 없습니다. 모든 변수 할당은 참조 값을 복사하는 것을 의미합니다. 예외 없음. 모든 변수는 참조 값에 바인딩 된 이름입니다. 항상.</target>
        </trans-unit>
        <trans-unit id="83861cb7e986e86de426cee8c30f2ed20d4ab7fd" translate="yes" xml:space="preserve">
          <source>Python has names and objects.</source>
          <target state="translated">파이썬에는 이름과 객체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fcbcd2747ab57ca64daa423ac6a3486436e1a62" translate="yes" xml:space="preserve">
          <source>Python&amp;rsquo;s pass-by-assignment scheme isn&amp;rsquo;t quite the same as C++&amp;rsquo;s reference parameters option, but it turns out to be very similar to the argument-passing model of the C language (and others) in practice:</source>
          <target state="translated">파이썬의 할당 별 체계는 C ++의 참조 매개 변수 옵션과 완전히 동일하지 않지만 실제로는 C 언어 (및 기타)의 인수 전달 모델과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="333f7d50ad7e0d3ef1d2d6e716803037e8f19596" translate="yes" xml:space="preserve">
          <source>Pythons &quot;reflection&quot; support makes it possible to get a object that is capable of reassigning a name/variable in a given scope without defining functions explicitly in that scope:</source>
          <target state="translated">파이썬의 &quot;반사&quot;지원을 통해 해당 범위에서 명시 적으로 함수를 정의하지 않고도 주어진 범위에서 이름 / 변수를 재 할당 할 수있는 객체를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afbaddd3494c975f3248038d165efdcb7b42b91c" translate="yes" xml:space="preserve">
          <source>Reference values are hidden in Python. There isn't any explicit user type for storing the reference value. However, you can use a list element (or element in any other suitable container type) as the reference variable, because all containers do store the elements also as references to the target objects. In other words, elements are actually not contained inside the container -- only the references to elements are.</source>
          <target state="translated">파이썬에서는 참조 값이 숨겨져 있습니다. 참조 값을 저장하기위한 명시적인 사용자 유형이 없습니다. 그러나 모든 컨테이너가 요소를 대상 객체에 대한 참조로도 저장하기 때문에 목록 요소 (또는 다른 적합한 컨테이너 유형의 요소)를 참조 변수로 사용할 수 있습니다. 즉, 요소는 실제로 컨테이너 안에 포함되지 않으며 요소에 대한 참조 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="a16b36f9b22c19ae3e20f844261f568427971e02" translate="yes" xml:space="preserve">
          <source>See sections &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;3.1&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#naming-and-binding&quot;&gt;4.2&lt;/a&gt; in the Python 3 language reference.</source>
          <target state="translated">Python 3 언어 참조의 &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;3.1&lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#naming-and-binding&quot;&gt;4.2&lt;/a&gt; 단원을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="660da67960cf04fb1e0d059bd7853b4c03efc993" translate="yes" xml:space="preserve">
          <source>Since dictionaries are passed by reference, you can use a dict variable to store any referenced values inside it.</source>
          <target state="translated">사전은 참조로 전달되므로 dict 변수를 사용하여 참조 된 값을 그 안에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68d4a137bc67d697b621b97d6185016cdb4789cb" translate="yes" xml:space="preserve">
          <source>Since immutable types cannot be modified, they &lt;em&gt;seem&lt;/em&gt; like being passed by value - passing an int into a function means assigning the int to the function's parameter. You can only ever reassign that, but it won't change the original variables value.</source>
          <target state="translated">불변 유형은 수정할 수 없으므로 값으로 전달되는 &lt;em&gt;것처럼 보입니다&lt;/em&gt; . int를 함수에 전달하면 int를 함수의 매개 변수에 지정하는 것입니다. 다시 할당 할 수는 있지만 원래 변수 값은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="696917aad2c2b30ef73b056904aa4dea2ce6c676" translate="yes" xml:space="preserve">
          <source>Since it seems to be nowhere mentioned an approach to simulate references as known from e.g. C++ is to use an &quot;update&quot; function and pass that instead of the actual variable (or rather, &quot;name&quot;):</source>
          <target state="translated">예를 들어 C ++에서 알려진 것처럼 참조를 시뮬레이션하는 방법은 &quot;update&quot;함수를 사용하여 실제 변수 (또는 &quot;name&quot;) 대신 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5d727a1d706032a86c18b0a92e1ed2ead4954513" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;the_list&lt;/code&gt; parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The &lt;code&gt;the_list&lt;/code&gt; was a copy of the &lt;code&gt;outer_list&lt;/code&gt; reference, and we had &lt;code&gt;the_list&lt;/code&gt; point to a new list, but there was no way to change where &lt;code&gt;outer_list&lt;/code&gt; pointed.</source>
          <target state="translated">&lt;code&gt;the_list&lt;/code&gt; 매개 변수가 값으로 전달 되었으므로 새 목록을 지정하면 메소드 외부의 코드에서 볼 수있는 효과가 없습니다. &lt;code&gt;the_list&lt;/code&gt; 는 &lt;code&gt;outer_list&lt;/code&gt; 참조의 사본이며, 우리는 &lt;code&gt;the_list&lt;/code&gt; 가 새로운 목록을 가리 키도록하지만 &lt;code&gt;outer_list&lt;/code&gt; 가 가리키는 위치를 변경할 방법이 없었습니다.</target>
        </trans-unit>
        <trans-unit id="36f7beed038b24998576a94eef27bf913f6ed625" translate="yes" xml:space="preserve">
          <source>Since the parameter passed in is a reference to &lt;code&gt;outer_list&lt;/code&gt;, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.</source>
          <target state="translated">전달 된 매개 변수는 복사본이 아닌 &lt;code&gt;outer_list&lt;/code&gt; 에 대한 참조 이므로 변경 목록 메소드를 사용하여 변경하고 외부 범위에 변경 사항을 반영 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6e9cfc9cdfcbeabab6f908af34edaef10d1407d" translate="yes" xml:space="preserve">
          <source>Since your example happens to be object-oriented, you could make the following change to achieve a similar result:</source>
          <target state="translated">예제는 객체 지향적이므로 비슷한 결과를 얻기 위해 다음과 같이 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8af5c8a28c9b058781cfa18faaa84372e62a5df" translate="yes" xml:space="preserve">
          <source>So if the thing you want to change is a mutable object, there is no problem, as everything is effectively passed by reference.</source>
          <target state="translated">따라서 변경하려는 것이 변경 가능한 객체이면 모든 것이 참조로 효과적으로 전달되므로 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf807aabb75019d89aff61af1c01d7c2a1d18f4d" translate="yes" xml:space="preserve">
          <source>So, when passing a list to a function/method, the list is assigned to the parameter name. Appending to the list will result in the list being modified. Reassigning the list &lt;em&gt;inside&lt;/em&gt; the function will not change the original list, since:</source>
          <target state="translated">따라서리스트를 함수 / 메소드에 전달할 때리스트는 매개 변수 이름에 할당됩니다. 목록에 추가하면 목록이 수정됩니다. 함수 &lt;em&gt;내&lt;/em&gt; 에서 목록을 다시 할당하면 다음과 같은 이유로 원래 목록이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="d7a557055e4e02657c23b68f42103ada3c99dabb" translate="yes" xml:space="preserve">
          <source>String - an immutable type</source>
          <target state="translated">문자열-불변의 타입</target>
        </trans-unit>
        <trans-unit id="7c1fdc94b36a2d1a36919d71bce545b535714140" translate="yes" xml:space="preserve">
          <source>Technically, &lt;strong&gt;Python always uses pass by reference values&lt;/strong&gt;. I am going to repeat &lt;a href=&quot;https://stackoverflow.com/a/12438316/1346705&quot;&gt;my other answer&lt;/a&gt; to support my statement.</source>
          <target state="translated">기술적으로 &lt;strong&gt;파이썬은 항상 pass by reference values를 사용합니다&lt;/strong&gt; . 본인의 진술을 뒷받침하기 위해 &lt;a href=&quot;https://stackoverflow.com/a/12438316/1346705&quot;&gt;다른 답변&lt;/a&gt; 을 반복하겠습니다.</target>
        </trans-unit>
        <trans-unit id="79c2b7cf71267d7a5e78f89f251fffbff74bb65a" translate="yes" xml:space="preserve">
          <source>That is all there is to it. Mutability is irrelevant for this question.</source>
          <target state="translated">그것이 전부입니다. 돌연변이는이 질문과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="17becfeedaa8893ff84a47a35ec6e3e49715fa72" translate="yes" xml:space="preserve">
          <source>The Python documentation seems unclear about whether parameters are passed by reference or value, and the following code produces the unchanged value 'Original'</source>
          <target state="translated">파이썬 문서는 매개 변수가 참조 또는 값으로 전달되는지 여부가 명확하지 않은 것으로 보이며 다음 코드는 변경되지 않은 값 'Original'을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f2fff69c21168bf26f5b1e057e178f0b3f2e5e7c" translate="yes" xml:space="preserve">
          <source>The actual object - [0, 1] (which would be called a value in other programming languages) is being passed. So in fact the function &lt;code&gt;change_me&lt;/code&gt; will try to do something like:</source>
          <target state="translated">실제 객체-[0, 1] (다른 프로그래밍 언어에서는 값이라고 함)이 전달되고 있습니다. 실제로 &lt;code&gt;change_me&lt;/code&gt; 함수는 다음과 같은 작업을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="a681daed3a2466279708eadd396f12d4619acbc1" translate="yes" xml:space="preserve">
          <source>The assignment to an global variable that is not declared global therefore creates a new local object and breaks the link to the original object.</source>
          <target state="translated">따라서 전역으로 선언되지 않은 전역 변수에 할당하면 새 로컬 객체가 생성되고 원래 객체에 대한 링크가 끊어집니다.</target>
        </trans-unit>
        <trans-unit id="dcf126983674f03f5b7e37d5d854435177547ce6" translate="yes" xml:space="preserve">
          <source>The basic idea is to have a function that can do that access and can be passed as object into other functions or stored in a class.</source>
          <target state="translated">기본 아이디어는 액세스를 수행 할 수 있고 다른 함수에 객체로 전달되거나 클래스에 저장 될 수있는 함수를 갖는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0bc22d9160e54688c508487d4bc0a30f0fedfd8c" translate="yes" xml:space="preserve">
          <source>The key to understanding parameter passing is to stop thinking about &quot;variables&quot;. There are names and objects in Python and together they
appear like variables, but it is useful to always distinguish the three.</source>
          <target state="translated">매개 변수 전달을 이해하는 열쇠는 &quot;변수&quot;에 대한 생각을 멈추는 것입니다. 파이썬에는 이름과 객체가 있으며 함께 변수처럼 보이지만 항상 세 가지를 구별하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4ab82925dc8dd0f7cb7b601b15859baf0d62bc4d" translate="yes" xml:space="preserve">
          <source>The more &lt;a href=&quot;https://www.python.org/dev/peps/pep-0020/&quot;&gt;pythonic&lt;/a&gt; approach would be to introduce a trivial, one-attribute class. The function receives an instance of the class and manipulates the attribute.</source>
          <target state="translated">더 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0020/&quot;&gt;pythonic&lt;/a&gt; 접근법은 사소한 일 속성 클래스를 도입하는 것입니다. 이 함수는 클래스의 인스턴스를 수신하고 속성을 조작합니다.</target>
        </trans-unit>
        <trans-unit id="cc1762bcf99fc58408f1a9ef7986e8348ee28a58" translate="yes" xml:space="preserve">
          <source>The only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places.</source>
          <target state="translated">이를 해결하는 유일한 방법은 변경 가능한 객체를 전달하는 것입니다. 두 참조 모두 동일한 객체를 참조하므로 객체에 대한 모든 변경 사항이 두 곳에 모두 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="6fad76f326204f89d7ac6ac50ce5db14000add4d" translate="yes" xml:space="preserve">
          <source>The problem comes from a misunderstanding of what variables are in Python. If you're used to most traditional languages, you have a mental model of what happens in the following sequence:</source>
          <target state="translated">파이썬에서 변수가 무엇인지에 대한 오해에서 문제가 발생합니다. 대부분의 전통적인 언어에 익숙하다면 다음 순서로 일어나는 일에 대한 정신적 모델이 있습니다.</target>
        </trans-unit>
        <trans-unit id="84175dec5b4dc806baa482e3939f43855a2e8b04" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty solution for this is a one-element list (instead of &lt;code&gt;self.variable&lt;/code&gt;, pass &lt;code&gt;[self.variable]&lt;/code&gt; and in the function modify &lt;code&gt;var[0]&lt;/code&gt;).</source>
          <target state="translated">이것에 대한 빠르고 해결책은 하나의 요소 목록입니다 ( &lt;code&gt;self.variable&lt;/code&gt; 대신 &lt;code&gt;[self.variable]&lt;/code&gt; 을 전달하고 함수 &lt;code&gt;var[0]&lt;/code&gt; 수정).</target>
        </trans-unit>
        <trans-unit id="13c1347e705ce1693fe7d2b8e953c905989ca4b8" translate="yes" xml:space="preserve">
          <source>The same idea works for reading and &lt;code&gt;del&lt;/code&gt;eting a variable.</source>
          <target state="translated">변수를 읽고 정의 할 때도 동일한 아이디어가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5db310989aa7591454c760958f2af239e823a8c7" translate="yes" xml:space="preserve">
          <source>Then the call would result in:</source>
          <target state="translated">그러면 전화 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0105c63c552b46ed256ace297e33009660aef599" translate="yes" xml:space="preserve">
          <source>There are no variables in Python</source>
          <target state="translated">파이썬에는 변수가 없습니다</target>
        </trans-unit>
        <trans-unit id="086a535eed287fb2a8da5e4f2b4da1059486d637" translate="yes" xml:space="preserve">
          <source>There is a little trick to pass an object by reference, even though the language doesn't make it possible. It works in Java too, it's the list with one item. ;-)</source>
          <target state="translated">언어로 인해 가능하지는 않지만 참조로 객체를 전달하는 약간의 트릭이 있습니다. Java에서도 작동하며 하나의 항목이있는 목록입니다. ;-)</target>
        </trans-unit>
        <trans-unit id="b1c21ed6d2eec901faa433fdaff0e199b04f81af" translate="yes" xml:space="preserve">
          <source>Think of stuff being passed &lt;strong&gt;by assignment&lt;/strong&gt; instead of by reference/by value. That way, it is always clear, what is happening as long as you understand what happens during the normal assignment.</source>
          <target state="translated">참조 / 가치 대신 &lt;strong&gt;할당&lt;/strong&gt; 으로 전달 &lt;strong&gt;되는&lt;/strong&gt; 것을 생각하십시오. 그렇게하면 정규 과제 동안 어떤 일이 발생하는지 이해하는 한 항상 명확합니다.</target>
        </trans-unit>
        <trans-unit id="c5a5244ffa8b4f4ae77f3d588812cda61fa6be3d" translate="yes" xml:space="preserve">
          <source>This binds the name &lt;code&gt;a&lt;/code&gt; to an object of type integer that holds the value 1.</source>
          <target state="translated">이것은 이름 &lt;code&gt;a&lt;/code&gt; 를 값 1을 보유한 정수 유형의 오브젝트에 바인드합니다.</target>
        </trans-unit>
        <trans-unit id="884b42766d553e6f4cff2ad92ade45f883bf6559" translate="yes" xml:space="preserve">
          <source>This binds the name &lt;code&gt;b&lt;/code&gt; to the same object that the name &lt;code&gt;x&lt;/code&gt; is currently bound to.
Afterwards, the name &lt;code&gt;b&lt;/code&gt; has nothing to do with the name &lt;code&gt;x&lt;/code&gt; any more.</source>
          <target state="translated">이것은 이름 &lt;code&gt;b&lt;/code&gt; 를 이름 &lt;code&gt;x&lt;/code&gt; 가 현재 바인드 된 동일한 오브젝트에 바인드합니다. 나중에 이름 &lt;code&gt;b&lt;/code&gt; 는 더 이상 이름 &lt;code&gt;x&lt;/code&gt; 와 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a0da37fa36be60c0aa098be25fccdb7e017ac1b" translate="yes" xml:space="preserve">
          <source>This is mostly useful for &quot;out-only references&quot; or in a situation with multiple threads / processes (by making the update function thread / multiprocessing safe).</source>
          <target state="translated">이는 &quot;아웃-아웃 참조&quot;또는 여러 스레드 / 프로세스가있는 상황 (업데이트 기능 스레드 / 멀티 프로세싱을 안전하게 함)에 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2f1f28564cc17f4b95f8008ecbf300883f70aebb" translate="yes" xml:space="preserve">
          <source>To make it even more clear, let's have some examples.</source>
          <target state="translated">더 명확하게하기 위해 몇 가지 예를 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="5623b8a007cec828bd71b838af98d8c9977c1510" translate="yes" xml:space="preserve">
          <source>To the extent that Python is pass by value, all languages are pass by value since some piece of data (be it a &quot;value&quot; or a &quot;reference&quot;) must be sent. However, that does not mean that Python is pass by value in the sense that a C programmer would think of it.</source>
          <target state="translated">파이썬이 값으로 전달되는 한, 일부 데이터 ( &quot;값&quot;또는 &quot;참조&quot;)가 전송되어야하기 때문에 모든 언어는 값으로 전달됩니다. 그러나 이것이 C 프로그래머가 그것을 생각한다는 의미에서 파이썬이 가치를 지니고 있다는 것을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="20555a4a440b0601df4fa798a89247c553a96ccf" translate="yes" xml:space="preserve">
          <source>When you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there's no way to update that reference and make it refer to a new object. In your example:</source>
          <target state="translated">매개 변수를 사용하여 함수를 호출하면 전달 된 객체를 참조하는 새 참조가 작성됩니다. 이는 함수 호출에 사용 된 참조와 별개이므로 해당 참조를 업데이트하고 참조를 참조 할 수있는 방법이 없습니다. 새로운 객체. 귀하의 예에서 :</target>
        </trans-unit>
        <trans-unit id="bc3fa5ea94b2efd9143d2934a64ae051133be6ed" translate="yes" xml:space="preserve">
          <source>When you do a new assignment such as &lt;code&gt;y = x&lt;/code&gt;, a new dictionary entry &quot;y&quot; is created that points to the same object as the entry for &quot;x&quot;.</source>
          <target state="translated">&lt;code&gt;y = x&lt;/code&gt; 와 같은 새 할당을 수행하면 &quot;x&quot;에 대한 항목과 동일한 객체를 가리키는 새 사전 항목 &quot;y&quot;가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a8ec35d9c1b72807f2ded385deffa6f8aa373d72" translate="yes" xml:space="preserve">
          <source>When you make an assignment such as &lt;code&gt;x = 1000&lt;/code&gt;, a dictionary entry is created that maps the string &quot;x&quot; in the current namespace to a pointer to the integer object containing one thousand.</source>
          <target state="translated">&lt;code&gt;x = 1000&lt;/code&gt; 과 같은 할당을 수행하면 현재 네임 스페이스의 &quot;x&quot;문자열을 천을 포함하는 정수 객체에 대한 포인터에 매핑하는 사전 항목이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e648dd9f3d5b78507aba8fd21719ec93fe30b1ca" translate="yes" xml:space="preserve">
          <source>When you update &quot;x&quot; with &lt;code&gt;x = 2000&lt;/code&gt;, a new integer object is created and the dictionary is updated to point at the new object.  The old one thousand object is unchanged (and may or may not be alive depending on whether anything else refers to the object).</source>
          <target state="translated">&lt;code&gt;x = 2000&lt;/code&gt; &quot;x&quot;를 업데이트하면 새로운 정수 객체가 생성되고 사전이 새로운 객체를 가리 키도록 업데이트됩니다. 오래된 천 개체는 변경되지 않습니다 (그리고 다른 것이 개체를 참조하는지 여부에 따라 살아 있거나 없을 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="13eb328770b9c46bbd56e2839f367e0a7b3f96db" translate="yes" xml:space="preserve">
          <source>Whenever you pass an object to the function, the object itself is passed (object in Python is actually what you'd call a value in other programming languages) not the reference to this object. In other words, when you call:</source>
          <target state="translated">객체를 함수에 전달할 때마다 객체 자체가 전달됩니다 (파이썬의 객체는 실제로 다른 프로그래밍 언어에서 값을 호출하는 것입니다).이 객체에 대한 참조는 아닙니다. 다시 말해, 전화 할 때 :</target>
        </trans-unit>
        <trans-unit id="6b4cb23677b917c5c42bbdb41b1590df3465a4db" translate="yes" xml:space="preserve">
          <source>While pass by reference is nothing that fits well into python and should be rarely used there are some workarounds that actually can work to get the object currently assigned to a local variable or even reassign a local variable from inside of a called function.</source>
          <target state="translated">참조로 전달하는 것은 파이썬에 잘 맞지 않으며 거의 ​​사용되지 않아야하지만 실제로는 로컬 변수에 할당 된 객체를 가져 오거나 호출 된 함수 내부에서 로컬 변수를 다시 할당하기 위해 실제로 작동 할 수있는 해결 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="06ef8c07f183597c6357e8005336de31d41ec30c" translate="yes" xml:space="preserve">
          <source>You believe that &lt;code&gt;a&lt;/code&gt; is a memory location that stores the value &lt;code&gt;1&lt;/code&gt;, then is updated to store the value &lt;code&gt;2&lt;/code&gt;. That's not how things work in Python. Rather, &lt;code&gt;a&lt;/code&gt; starts as a reference to an object with the value &lt;code&gt;1&lt;/code&gt;, then gets reassigned as a reference to an object with the value &lt;code&gt;2&lt;/code&gt;. Those two objects may continue to coexist even though &lt;code&gt;a&lt;/code&gt; doesn't refer to the first one anymore; in fact they may be shared by any number of other references within the program.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 는 값 &lt;code&gt;1&lt;/code&gt; 을 저장하는 메모리 위치라고 생각하고 값 &lt;code&gt;2&lt;/code&gt; 를 저장하도록 업데이트됩니다. 그것이 파이썬에서 일하는 방식이 아닙니다. 오히려 &lt;code&gt;a&lt;/code&gt; 는 값이 &lt;code&gt;1&lt;/code&gt; 인 객체에 대한 참조로 시작한 다음 값이 &lt;code&gt;2&lt;/code&gt; 인 객체에 대한 참조로 다시 할당됩니다. 이 두 객체는 ​​더 이상 첫 번째 객체를 참조하지 않더라도 계속 공존 할 수 있습니다. 실제로 그것들은 프로그램 내에서 다른 많은 참조에 의해 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cbe72d4aff2f1d3e9fb3501cd97383b70fd44e7" translate="yes" xml:space="preserve">
          <source>You can merely use &lt;strong&gt;an empty class&lt;/strong&gt; as an instance to store reference objects because internally object attributes are stored in an instance dictionary. See the example.</source>
          <target state="translated">내부적으로 객체 속성이 인스턴스 사전에 저장되므로 참조 객체를 저장하기 &lt;strong&gt;위해 빈 클래스&lt;/strong&gt; 를 인스턴스로 사용할 수 있습니다. 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9e395b0bd4b1dc1eea4d49d8e1f40c5347e0d5a1" translate="yes" xml:space="preserve">
          <source>You can think about a reference value as the address of the target object. The address is automatically dereferenced when used. This way, working with the reference value, it seems you work directly with the target object. But there always is a reference in between, one step more to jump to the target.</source>
          <target state="translated">참조 값을 대상 개체의 주소로 생각할 수 있습니다. 사용하면 주소가 자동으로 역 참조됩니다. 이런 식으로 참조 값으로 작업하면 대상 객체로 직접 작업하는 것처럼 보입니다. 그러나 목표를 향해 한 걸음 더 나아가는 것 사이에는 항상 참조가 있습니다.</target>
        </trans-unit>
        <trans-unit id="233857d84270d4d4cf81d2ab105c0ebb1d786176" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://docs.python.org/3.3/library/functions.html#id&quot;&gt;&lt;code&gt;id()&lt;/code&gt;&lt;/a&gt; built-in function to learn what the reference value is (that is, the address of the target object).</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/3.3/library/functions.html#id&quot;&gt; &lt;code&gt;id()&lt;/code&gt; &lt;/a&gt; 내장 함수를 사용하여 참조 값이 무엇인지 (즉, 대상 객체의 주소) 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fee26813eb63428556d25e99b697066a5abee304" translate="yes" xml:space="preserve">
          <source>You got some really good answers here.</source>
          <target state="translated">여기에 정말 좋은 답변이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="ac2c0095bbd1e16c2e3606675ef16ab060af766f" translate="yes" xml:space="preserve">
          <source>given the way python handles values and references to them, the only way you can reference an arbitrary instance attribute is by name:</source>
          <target state="translated">파이썬이 값과 그에 대한 참조를 처리하는 방식에서 임의의 인스턴스 속성을 참조 할 수있는 유일한 방법은 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5dcfdd557133c0be7c75544c8a554ac3a7ddef6a" translate="yes" xml:space="preserve">
          <source>gives:</source>
          <target state="translated">gives:</target>
        </trans-unit>
        <trans-unit id="31cef82f841f61f64a2b51817dadd21b57e78be6" translate="yes" xml:space="preserve">
          <source>in real code you would, of course, add error checking on the dict lookup.</source>
          <target state="translated">실제 코드에서는 물론 dict 조회에 오류 검사를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1d8a6a9487c9bd9e3711fa2119286c096444a2f6" translate="yes" xml:space="preserve">
          <source>some data types are mutable, but others aren't</source>
          <target state="translated">일부 데이터 형식은 변경 가능하지만 다른 데이터 형식은 변경 불가능</target>
        </trans-unit>
        <trans-unit id="5f0f7656c197d2526aa255c56c1295fe45b9916d" translate="yes" xml:space="preserve">
          <source>the parameter passed in is actually a &lt;em&gt;reference&lt;/em&gt; to an object (but the reference is passed by value)</source>
          <target state="translated">전달 된 매개 변수는 실제로 객체에 대한 참조입니다 (그러나 참조는 값으로 전달됩니다)</target>
        </trans-unit>
        <trans-unit id="9789798d32b8f1cb1ca7e4b37e5b087b68d91f3c" translate="yes" xml:space="preserve">
          <source>which obviously will change the object. &lt;a href=&quot;https://stackoverflow.com/a/534509/831531&quot;&gt;This answer&lt;/a&gt; explains it well.</source>
          <target state="translated">분명히 개체가 변경됩니다. &lt;a href=&quot;https://stackoverflow.com/a/534509/831531&quot;&gt;이 답변이&lt;/a&gt; 잘 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a5dcf0aaba3d474366727f90d67aa1948bf146f" translate="yes" xml:space="preserve">
          <source>which obviously will not change the object passed to the function. If the function looked like this:</source>
          <target state="translated">분명히 함수에 전달 된 객체는 변경되지 않습니다. 함수가 다음과 같은 경우 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
