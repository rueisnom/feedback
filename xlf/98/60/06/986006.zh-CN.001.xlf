<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/986006">
    <body>
      <group id="986006">
        <trans-unit id="a1b152a892ef513d9a4d8de1e227286558de128b" translate="yes" xml:space="preserve">
          <source>&quot;...variables [names] are &lt;em&gt;not&lt;/em&gt; objects; they cannot be denoted by other variables or referred to by objects.&quot;</source>
          <target state="translated">&amp;ldquo; ...变量[名称] &lt;em&gt;不是&lt;/em&gt;对象；它们不能由其他变量表示或由对象引用。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="ec2f8b9ef1eca2860982704b2396e6f5e99305cc" translate="yes" xml:space="preserve">
          <source>&quot;In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a new value anywhere within the function&amp;rsquo;s body, it&amp;rsquo;s assumed to be a local. If a variable is ever assigned a new value inside the function, the variable is implicitly local, and you need to explicitly declare it as &amp;lsquo;global&amp;rsquo;.
Though a bit surprising at first, a moment&amp;rsquo;s consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, you&amp;rsquo;d be using global all the time. You&amp;rsquo;d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.&quot;</source>
          <target state="translated">&amp;ldquo;在Python中，仅在函数内部引用的变量是隐式全局的。如果在函数体内的任何位置为变量分配了新值，则假定该变量是局部的。如果在函数内部分配了新值，该变量是隐式局部变量，您需要将其显式声明为&amp;ldquo;全局变量&amp;rdquo;，尽管起初有些令人惊讶，但片刻的考虑可以解释这一点：一方面，要求全局变量赋值可防止意外副作用。另一方面，如果所有全局引用都需要使用global，那么您将一直使用global。您必须将对内置函数或导入模块的组件的每个引用声明为Global。将破坏全球宣言对确定副作用的有用性。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="42c22aec244c5d347e54be65aaab6403cdf146a7" translate="yes" xml:space="preserve">
          <source>(Yeah I know this can be inconvenient, but sometimes it is simple enough to do this.)</source>
          <target state="translated">(是的,我知道这样做可能会很不方便,但有时这样做也很简单)。</target>
        </trans-unit>
        <trans-unit id="8a51a221218346c2c1772a44d0e7cc971cece6c5" translate="yes" xml:space="preserve">
          <source>(edit - Blair has updated his enormously popular answer so that it is now accurate)</source>
          <target state="translated">(编辑 ----布莱尔更新了他那广为人知的答案,所以现在是准确的)</target>
        </trans-unit>
        <trans-unit id="a62a78c201c7282875384fa5a4bbe69e0365e928" translate="yes" xml:space="preserve">
          <source>(edit 2019-04-28)</source>
          <target state="translated">(编辑 2019-04-28)</target>
        </trans-unit>
        <trans-unit id="8b9f3efa3729cce732344f81bf8d7d82f28606bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self.variable&lt;/code&gt; is a reference to the string object &lt;code&gt;'Original'&lt;/code&gt;. When you call &lt;code&gt;Change&lt;/code&gt; you create a second reference &lt;code&gt;var&lt;/code&gt; to the object. Inside the function you reassign the reference &lt;code&gt;var&lt;/code&gt; to a different string object &lt;code&gt;'Changed'&lt;/code&gt;, but the reference &lt;code&gt;self.variable&lt;/code&gt; is separate and does not change.</source>
          <target state="translated">&lt;code&gt;self.variable&lt;/code&gt; 是对字符串对象 &lt;code&gt;'Original'&lt;/code&gt; 的引用。 当您调用 &lt;code&gt;Change&lt;/code&gt; 时,将创建该对象的第二个引用 &lt;code&gt;var&lt;/code&gt; 。 在函数内部，您将引用 &lt;code&gt;var&lt;/code&gt; 重新分配给另一个字符串对象 &lt;code&gt;'Changed'&lt;/code&gt; ，但是引用 &lt;code&gt;self.variable&lt;/code&gt; 是单独的并且不会更改。</target>
        </trans-unit>
        <trans-unit id="4229ed636553c69cfddd84246fc10b33ff69719b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++:&lt;/strong&gt; Both pass-by-reference or pass-by-value are allowed. If a parameter is passed by reference, you can either modify it or not depending upon whether the parameter was passed as const or not. However, const or not, the parameter maintains the reference to the object and reference cannot be assigned to point to a different object within the called function.</source>
          <target state="translated">&lt;strong&gt;C ++：&lt;/strong&gt;允许按引用传递或按值传递。 如果参数是通过引用传递的，则可以根据是否以const形式传递参数来对其进行修改。 但是，无论是否为const，该参数都将保留对对象的引用，并且无法将引用分配为指向所调用函数内的另一个对象。</target>
        </trans-unit>
        <trans-unit id="b3be1ec03105d4972fcbe3fec3a499e2307f9ee7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; It's been noted that this doesn't answer the question that @David originally asked, &quot;Is there something I can do to pass the variable by actual reference?&quot;. Let's work on that.</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;注意到这并不能回答@David最初问的问题，&amp;ldquo;我可以做些什么来通过实际引用传递变量吗？&amp;rdquo;。 让我们继续努力。</target>
        </trans-unit>
        <trans-unit id="d892af211725dce0575cd510d5913eae3f198cec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's immutable, so there's nothing we can do to change the contents of the string&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;它是不可变的，因此我们无能为力，无法更改字符串的内容&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee9513e042a85a4c63813585beec33bd12875b0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java&amp;amp;C#:&lt;/strong&gt; primitive types(include string)pass by value(copy), Reference type is passed by reference(address copy) so all changes made in the parameter in the called function are visible to the caller.</source>
          <target state="translated">&lt;strong&gt;Java＆C＃：&lt;/strong&gt;原始类型（包括字符串）通过值（副本）传递，引用类型通过引用（地址副本）传递，因此调用者可以看到在被调用函数中对参数所做的所有更改。</target>
        </trans-unit>
        <trans-unit id="b6bd3f4d372e7f7c7ecfb3b235bcc93f977ff2b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's try to modify the list that was passed to a method:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;让我们尝试修改传递给方法的列表：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be2b61cd76cc0ed218c950fa9a0f695fe658d0b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now let's see what happens when we try to change the reference that was passed in as a parameter:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;现在让我们看看当尝试更改作为参数传入的引用时会发生什么：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1bb1d2d46eeb3cfe61924c812bf981baeae0193b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now, let's try to change the reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;现在，让我们尝试更改参考&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5b90913af1169e0301615a93fc64f0e5b948b1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python:&lt;/strong&gt; 
Python is &amp;ldquo;pass-by-object-reference&amp;rdquo;, of which it is often said: &amp;ldquo;Object references are passed by value.&amp;rdquo;[Read here]&lt;a href=&quot;https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/&quot;&gt;1&lt;/a&gt;. Both the caller and the function refer to the same object but the parameter in the function is a new variable which is just holding a copy of the object in the caller. Like C++, a parameter can be either modified or not in function - This depends upon the type of object passed. eg; An immutable object type cannot be modified in the called function whereas a mutable object can be either updated or re-initialized. A crucial difference between updating or re-assigning/re-initializing the mutable variable is that updated value gets reflected back in the called function whereas the reinitialized value does not. Scope of any assignment of new object to a mutable variable is local to the function in the python. Examples provided by @blair-conrad are great to understand this.</source>
          <target state="translated">&lt;strong&gt;Python：&lt;/strong&gt; Python是&amp;ldquo;按对象传递引用&amp;rdquo;，通常这样说：&amp;ldquo;对象引用按值传递。&amp;rdquo; [阅读此处] &lt;a href=&quot;https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/&quot;&gt;1&lt;/a&gt; 。 调用者和函数都引用同一个对象，但是函数中的参数是一个新变量，它仅在调用者中保存对象的副本。 像C ++一样，可以在函数中修改或不修改参数-这取决于传递的对象的类型。 例如; 不变的对象类型不能在调用的函数中修改，而可变的对象可以更新或重新初始化。 更新或重新分配/重新初始化可变变量之间的关键区别在于，更新后的值会反映在被调用函数中，而重新初始化后的值不会反映出来。 将新对象分配给可变变量的范围是python中函数的局部范围。 @ blair-conrad提供的示例很好地理解了这一点。</target>
        </trans-unit>
        <trans-unit id="9883e919e7997c4bcd00e7db78ba8af7ca037be6" translate="yes" xml:space="preserve">
          <source>A lot of insights in answers here, but i think an additional point is not clearly mentioned here explicitly.   Quoting from python documentation &lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&lt;/a&gt;</source>
          <target state="translated">答案中有很多见解，但我认为此处没有明确提及其他要点。 引用python文档&lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b9bc6a21011e77a1fc1acf4db17ae8c442f98ed" translate="yes" xml:space="preserve">
          <source>A simple trick I normally use is to just wrap it in a list:</source>
          <target state="translated">我通常使用的一个简单的技巧是,直接把它包在一个列表里。</target>
        </trans-unit>
        <trans-unit id="1c34629702aff601e9017462b805c4e1564c10a6" translate="yes" xml:space="preserve">
          <source>Again, since the &lt;code&gt;the_string&lt;/code&gt; parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The &lt;code&gt;the_string&lt;/code&gt; was a copy of the &lt;code&gt;outer_string&lt;/code&gt; reference, and we had &lt;code&gt;the_string&lt;/code&gt; point to a new string, but there was no way to change where &lt;code&gt;outer_string&lt;/code&gt; pointed.</source>
          <target state="translated">同样，由于 &lt;code&gt;the_string&lt;/code&gt; 参数是通过值传递的，因此为其分配新的字符串不会影响方法外部的代码。 &lt;code&gt;the_string&lt;/code&gt; 是 &lt;code&gt;outer_string&lt;/code&gt; 引用的副本，我们有 &lt;code&gt;the_string&lt;/code&gt; 指向新字符串，但是无法更改 &lt;code&gt;outer_string&lt;/code&gt; 指向的位置。</target>
        </trans-unit>
        <trans-unit id="c9e5405e129e476d3e0ef475249c330ed3f6dfb5" translate="yes" xml:space="preserve">
          <source>Although this seems a little cumbersome.</source>
          <target state="translated">虽然这似乎有点麻烦。</target>
        </trans-unit>
        <trans-unit id="2d97b97ac2c4c28ba96535277dd72cff612ba228" translate="yes" xml:space="preserve">
          <source>Another solution would be to create a static method like this:</source>
          <target state="translated">另一个解决方案是创建一个像这样的静态方法。</target>
        </trans-unit>
        <trans-unit id="b0c7226e7708d9f8704f1ddf855b76d4d0e697d8" translate="yes" xml:space="preserve">
          <source>Arguments are &lt;a href=&quot;http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference&quot;&gt;passed by assignment&lt;/a&gt;. The rationale behind this is twofold:</source>
          <target state="translated">参数&lt;a href=&quot;http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference&quot;&gt;通过赋值传递&lt;/a&gt; 。 其背后的理由是双重的：</target>
        </trans-unit>
        <trans-unit id="57fce48e3511c0b229efd7be720f8de1904d6840" translate="yes" xml:space="preserve">
          <source>As @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out:</source>
          <target state="translated">正如@Andrea的回答所示,你可以返回新值。这并没有改变传入的方式,但确实可以让你得到你想要的信息。</target>
        </trans-unit>
        <trans-unit id="3fc39df4449e0220d47d2afd67496a6547200ecf" translate="yes" xml:space="preserve">
          <source>As you can state you need to have a mutable object, but let me suggest you to check over the global variables as they can help you or even solve this kind of issue!</source>
          <target state="translated">正如你可以说的那样,你需要一个可变的对象,但我建议你检查一下全局变量,因为它们可以帮助你甚至解决这种问题</target>
        </trans-unit>
        <trans-unit id="1173d3f94d407863d6672e2edbfad0d748c8d95e" translate="yes" xml:space="preserve">
          <source>Aside from all the great explanations on how this stuff works in Python, I don't see a simple suggestion for the problem. As you seem to do create objects and instances, the pythonic way of handling instance variables and changing them is the following:</source>
          <target state="translated">除了在Python中对这些东西的工作原理进行了大量的解释之外,我没有看到一个简单的建议来解决这个问题。因为你似乎是在创建对象和实例,所以Python的处理实例变量和改变实例变量的方法如下。</target>
        </trans-unit>
        <trans-unit id="955f20c5fd3d4cf266b4f4f30cefc9bede9bc806" translate="yes" xml:space="preserve">
          <source>Assignment binds a name to an object.</source>
          <target state="translated">Assignment将名称与对象绑定。</target>
        </trans-unit>
        <trans-unit id="44eb458222e5cac4dd20238f7eb9ffa3a0a032f1" translate="yes" xml:space="preserve">
          <source>David Cournapeau's answer points to the real answer and explains why the behavior in Blair Conrad's post seems to be correct while the definitions are not.</source>
          <target state="translated">David Cournapeau的回答指出了真正的答案,并解释了为什么Blair Conrad帖子中的行为似乎是正确的,而定义却不正确。</target>
        </trans-unit>
        <trans-unit id="6ba040c2f2a2d80842507aa7fb2215325e5e6c43" translate="yes" xml:space="preserve">
          <source>Effbot (aka Fredrik Lundh) has described Python's variable passing style as call-by-object:  &lt;a href=&quot;http://effbot.org/zone/call-by-object.htm&quot;&gt;http://effbot.org/zone/call-by-object.htm&lt;/a&gt;</source>
          <target state="translated">Effbot（又名Fredrik Lundh）将Python的变量传递样式描述为按对象调用： &lt;a href=&quot;http://effbot.org/zone/call-by-object.htm&quot;&gt;http&lt;/a&gt; : //effbot.org/zone/call-by-object.htm</target>
        </trans-unit>
        <trans-unit id="feb265a8df8e110e2790224a1da7e1861c9fda44" translate="yes" xml:space="preserve">
          <source>Even when passing a mutable object to a function this still applies. And to me clearly explains the reason for the difference in behavior between assigning to the object and operating on the object in the function.</source>
          <target state="translated">即使是传递一个可变对象到函数中,这一点仍然适用。而对我来说,这也清楚地解释了在函数中分配对象和操作对象之间行为差异的原因。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="63aabb26e4f4644f4690795ae16738f9c1f5f4da" translate="yes" xml:space="preserve">
          <source>For just reading there is even a shorter way of just using &lt;code&gt;lambda: x&lt;/code&gt; which returns a callable that when called returns the current value of x. This is somewhat like &quot;call by name&quot; used in languages in the distant past.</source>
          <target state="translated">对于刚刚阅读，甚至有一种更短的使用 &lt;code&gt;lambda: x&lt;/code&gt; 返回一个可调用的对象，调用时返回x的当前值。 这有点像遥远的过去在语言中使用的&amp;ldquo;按名称呼叫&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a82f8b81c3ead144e50f2f04d42ea8cbd19c3b82" translate="yes" xml:space="preserve">
          <source>Here is a significant quote:</source>
          <target state="translated">这里有一句很重要的话。</target>
        </trans-unit>
        <trans-unit id="64605a5b8fffbc932d2851dd3c0a9a3b81ea1391" translate="yes" xml:space="preserve">
          <source>Here is the example that proves that Python uses passing by reference:</source>
          <target state="translated">下面是一个证明Python使用引用传递的例子。</target>
        </trans-unit>
        <trans-unit id="4652a9a03eda229eaa585e4d8b3108f912ea3767" translate="yes" xml:space="preserve">
          <source>Here is the simple (I hope) explanation of the concept &lt;code&gt;pass by object&lt;/code&gt; used in Python.</source>
          <target state="translated">这是Python中使用的 &lt;code&gt;pass by object&lt;/code&gt; 概念的简单说明（我希望如此）。</target>
        </trans-unit>
        <trans-unit id="48484f80102edbe70571bc88f85e228361438a9f" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;ByRef&lt;/code&gt; class wraps a dictionary access. So attribute access to &lt;code&gt;wrapped&lt;/code&gt; is translated to a item access in the passed dictionary. By passing the result of the builtin &lt;code&gt;locals&lt;/code&gt; and the name of a local variable this ends up accessing a local variable. The python documentation as of 3.5 advises that changing the dictionary might not work but it seems to work for me.</source>
          <target state="translated">在此， &lt;code&gt;ByRef&lt;/code&gt; 类包装了字典访问权限。 因此，对 &lt;code&gt;wrapped&lt;/code&gt; 属性访问将转换为所传递字典中的项目访问。 通过传递内置的本地变量的结果和本地变量的名称，最终将访问本地变量。 从3.5版开始的python文档建议更改字典可能不起作用，但似乎对我有用。</target>
        </trans-unit>
        <trans-unit id="d0be6fb2e163967ac2361db4b4dde754f1a7b504" translate="yes" xml:space="preserve">
          <source>Hope that clarifies the issue for you.</source>
          <target state="translated">希望能为你澄清这个问题。</target>
        </trans-unit>
        <trans-unit id="ac9f35a5c40f1a54d0e975658a953c9ccceb917a" translate="yes" xml:space="preserve">
          <source>How do I pass a variable by reference</source>
          <target state="translated">如何通过引用传递一个变量</target>
        </trans-unit>
        <trans-unit id="2635b21aa1a1e66c5ca7fed959d2e61ba0068f22" translate="yes" xml:space="preserve">
          <source>How do we get around this?</source>
          <target state="translated">我们该如何绕开这个问题?</target>
        </trans-unit>
        <trans-unit id="f2d3f338abd337442158a979a1f5de30af33097e" translate="yes" xml:space="preserve">
          <source>How to pass by reference</source>
          <target state="translated">如何通过参考资料</target>
        </trans-unit>
        <trans-unit id="072a54410009d923de415851395bc3f915f1966d" translate="yes" xml:space="preserve">
          <source>How to read the example in the question</source>
          <target state="translated">如何阅读题中的例子</target>
        </trans-unit>
        <trans-unit id="f10e3c369b21afb8efe5cb8ff95bfee39a5c9ffa" translate="yes" xml:space="preserve">
          <source>I found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.</source>
          <target state="translated">我发现其他的答案比较长,也比较复杂,所以我制作了这个简单的图来解释Python处理变量和参数的方式。</target>
        </trans-unit>
        <trans-unit id="3ca5711f1032450bdfe039601daafa6c14debe97" translate="yes" xml:space="preserve">
          <source>I hope this clears things up a little.</source>
          <target state="translated">我希望这能把事情弄清楚一点。</target>
        </trans-unit>
        <trans-unit id="779f081125662b16c96e53373144d42eb57b8923" translate="yes" xml:space="preserve">
          <source>I think it is important to note that the current post with the most votes (by Blair Conrad), while being correct with respect to its result, is misleading and is borderline incorrect based on its definitions.  While there are many languages (like C) that allow the user to either pass by reference or pass by value, Python is not one of them.</source>
          <target state="translated">我认为有一点很重要,那就是目前投票最多的帖子(Blair Conrad),虽然它的结果是正确的,但根据它的定义,它是有误导性的,而且是错误的。虽然有很多语言 (比如 C 语言)允许用户通过引用传递或通过值传递,但 Python 并不是其中之一。</target>
        </trans-unit>
        <trans-unit id="1caf319e1b878a7a9add11ed6d02d3179fc2d9bb" translate="yes" xml:space="preserve">
          <source>I used the following method to quickly convert a couple of Fortran codes to Python.  True, it's not pass by reference as the original question was posed, but is a simple work around in some cases.</source>
          <target state="translated">我用下面的方法将几个Fortran代码快速转换为Python。诚然,这并不是像原来的问题那样通过引用来传递,但在某些情况下是一个简单的工作方法。</target>
        </trans-unit>
        <trans-unit id="f8f3af9f0dc96665fb36e21e7dd8ea0010188a92" translate="yes" xml:space="preserve">
          <source>I'm sure someone else could clarify this further.</source>
          <target state="translated">我相信还有人可以进一步澄清。</target>
        </trans-unit>
        <trans-unit id="8fd3fb5434919f5765b442b73f1a2ea249604d75" translate="yes" xml:space="preserve">
          <source>If it is an &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;immutable&lt;/a&gt; object (e.g. a bool, number, string), the way to go is to wrap it in a mutable object.</source>
          <target state="translated">如果它是一个&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;不变的&lt;/a&gt;对象（例如，布尔值，数字，字符串），则将其包装在一个可变的对象中。</target>
        </trans-unit>
        <trans-unit id="e8ff937ee3cf391aa9369bcc79fcdbacd051a2eb" translate="yes" xml:space="preserve">
          <source>If the argument was passed by value, the outer &lt;code&gt;lst&lt;/code&gt; could not be modified. The green are the target objects (the black is the value stored inside, the red is the object type), the yellow is the memory with the reference value inside -- drawn as the arrow. The blue solid arrow is the reference value that was passed to the function (via the dashed blue arrow path). The ugly dark yellow is the internal dictionary. (It actually could be drawn also as a green ellipse. The colour and the shape only says it is internal.)</source>
          <target state="translated">如果参数通过值传递，则外部 &lt;code&gt;lst&lt;/code&gt; 无法修改。 绿色是目标对象（黑色是内部存储的值，红色是对象类型），黄色是内部具有参考值的存储器-绘制为箭头。 蓝色实心箭头是传递给函数的参考值（通过虚线蓝色箭头路径）。 丑陋的深黄色是内部词典。 （实际上也可以将其绘制为绿色椭圆形。颜色和形状仅表示它是内部的。）</target>
        </trans-unit>
        <trans-unit id="0dd316a07900ad81da1e569611d0d7f972700c53" translate="yes" xml:space="preserve">
          <source>If you pass a &lt;em&gt;mutable&lt;/em&gt; object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object.</source>
          <target state="translated">如果将&lt;em&gt;可变&lt;/em&gt;对象传递给方法，则该方法将获得对该对象的引用，并且可以对其进行突变，但是如果您将该引用重新绑定到该方法中，则外部作用域对此一无所知完成后，外部参考仍将指向原始对象。</target>
        </trans-unit>
        <trans-unit id="6f1b4b35463994559a0edb1ad6a1b8357fb742a0" translate="yes" xml:space="preserve">
          <source>If you pass an &lt;em&gt;immutable&lt;/em&gt; object to a method, you still can't rebind the outer reference, and you can't even mutate the object.</source>
          <target state="translated">如果将&lt;em&gt;不可变&lt;/em&gt;对象传递给方法，则仍然无法重新绑定外部引用，甚至无法使对象发生突变。</target>
        </trans-unit>
        <trans-unit id="bc1e60fe42ced701dd9148c0ff6beca470127f04" translate="yes" xml:space="preserve">
          <source>If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:</source>
          <target state="translated">如果你真的想避免使用返回值,你可以创建一个类来保持你的值,然后将其传递到函数中,或者使用一个现有的类,比如一个列表。</target>
        </trans-unit>
        <trans-unit id="9688763625be69eed8ed0d10e131598208128be6" translate="yes" xml:space="preserve">
          <source>If you want the behavior, Blair Conrad's answer is fine.  But if you want to know the nuts and bolts of why Python is neither pass by value or pass by reference, read David Cournapeau's answer.</source>
          <target state="translated">如果你想知道这个行为,Blair Conrad的答案是可以的。但是,如果你想知道Python为什么既不通过值传递,也不通过引用传递,那么请看David Cournapeau的答案。</target>
        </trans-unit>
        <trans-unit id="e5596ea1ad94c7661a4350a8652098d786a4cc4b" translate="yes" xml:space="preserve">
          <source>Immutable arguments are effectively passed &amp;ldquo;&lt;strong&gt;by value&lt;/strong&gt;.&amp;rdquo; Objects such as integers and strings are passed by object reference instead of by copying, but because you can&amp;rsquo;t change immutable objects in place anyhow, the effect is much like making a copy.</source>
          <target state="translated">不变的参数有效地&amp;ldquo; &lt;strong&gt;按值&lt;/strong&gt; &amp;rdquo;传递。 诸如整数和字符串之类的对象是通过对象引用而不是通过复制传递的，但是由于您无论如何都不能就地更改不可变对象，因此效果很像复制。</target>
        </trans-unit>
        <trans-unit id="6302f1ff1c0c2b90057d999e0b3858fc9d2a2e08" translate="yes" xml:space="preserve">
          <source>In compiled languages, a variable is a memory space that is able to capture the value of the type. In Python, a variable is a name (captured internally as a string) bound to the reference variable that holds the reference value to the target object. The name of the variable is the key in the internal dictionary, the value part of that dictionary item stores the reference value to the target.</source>
          <target state="translated">在编译语言中,变量是一个能够捕获类型值的内存空间。在Python中,变量是一个名称(内部捕获为字符串),它是绑定在持有目标对象的引用变量上的引用值。变量的名称是内部字典中的键,该字典项的值部分存储着目标对象的引用值。</target>
        </trans-unit>
        <trans-unit id="271a2c315dedadaa6b644002264db432c9330e40" translate="yes" xml:space="preserve">
          <source>In instance methods, you normally refer to &lt;code&gt;self&lt;/code&gt; to access instance attributes. It is normal to set instance attributes in &lt;code&gt;__init__&lt;/code&gt; and read or change them in instance methods. That is also why you pass &lt;code&gt;self&lt;/code&gt; als the first argument to &lt;code&gt;def Change&lt;/code&gt;.</source>
          <target state="translated">在实例方法中，通常使用 &lt;code&gt;self&lt;/code&gt; 来访问实例属性。 通常在 &lt;code&gt;__init__&lt;/code&gt; 中设置实例属性，然后在实例方法中读取或更改它们。 这就是为什么您将 &lt;code&gt;self&lt;/code&gt; 传递给 &lt;code&gt;def Change&lt;/code&gt; 的第一个参数的原因。</target>
        </trans-unit>
        <trans-unit id="fae6b090cdbf66824da7924b6168f4173a64868f" translate="yes" xml:space="preserve">
          <source>In the code shown in the question, the statement &lt;code&gt;self.Change(self.variable)&lt;/code&gt; binds the name &lt;code&gt;var&lt;/code&gt; (in the scope of function &lt;code&gt;Change&lt;/code&gt;) to the object that holds the value &lt;code&gt;'Original'&lt;/code&gt; and the assignment &lt;code&gt;var = 'Changed'&lt;/code&gt; (in the body of function &lt;code&gt;Change&lt;/code&gt;) assigns that same name again: to some other object (that happens to hold a string as well but could have been something else entirely).</source>
          <target state="translated">在问题所示的代码中，语句 &lt;code&gt;self.Change(self.variable)&lt;/code&gt; 将名称 &lt;code&gt;var&lt;/code&gt; （在 &lt;code&gt;Change&lt;/code&gt; 函数的范围内）绑定到持有值 &lt;code&gt;'Original'&lt;/code&gt; 和赋值 &lt;code&gt;var = 'Changed'&lt;/code&gt; （在函数体 &lt;code&gt;Change&lt;/code&gt; ）再次为该对象分配了相同的名称：另一个对象（碰巧也包含一个字符串，但可能完全是其他东西）。</target>
        </trans-unit>
        <trans-unit id="d174ebf38cb48196530f520173f23f96ee505c2d" translate="yes" xml:space="preserve">
          <source>In this case the variable titled &lt;code&gt;var&lt;/code&gt; in the method &lt;code&gt;Change&lt;/code&gt; is assigned a reference to &lt;code&gt;self.variable&lt;/code&gt;, and you immediately assign a string to &lt;code&gt;var&lt;/code&gt;. It's no longer pointing to &lt;code&gt;self.variable&lt;/code&gt;. The following code snippet shows what would happen if you modify the data structure pointed to by &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;self.variable&lt;/code&gt;, in this case a list:</source>
          <target state="translated">在这种情况下，为 &lt;code&gt;Change&lt;/code&gt; 方法中名为 &lt;code&gt;var&lt;/code&gt; 的变量分配了对 &lt;code&gt;self.variable&lt;/code&gt; 的引用，然后您立即为 &lt;code&gt;var&lt;/code&gt; 分配了一个字符串。 它不再指向 &lt;code&gt;self.variable&lt;/code&gt; 。 以下代码段显示了如果修改 &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;self.variable&lt;/code&gt; 指向的数据结构（在本例中为列表）会发生什么情况：</target>
        </trans-unit>
        <trans-unit id="c93eaa9797f60173290b5121f5aebea5bd45b163" translate="yes" xml:space="preserve">
          <source>In your example, when the &lt;code&gt;Change&lt;/code&gt; method is called--a &lt;a href=&quot;http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces&quot;&gt;namespace&lt;/a&gt; is created for it; and &lt;code&gt;var&lt;/code&gt; becomes a name, within that namespace, for the string object &lt;code&gt;'Original'&lt;/code&gt;. That object then has a name in two namespaces. Next, &lt;code&gt;var = 'Changed'&lt;/code&gt; binds &lt;code&gt;var&lt;/code&gt; to a new string object, and thus the method's namespace forgets about &lt;code&gt;'Original'&lt;/code&gt;. Finally, that namespace is forgotten, and the string &lt;code&gt;'Changed'&lt;/code&gt; along with it.</source>
          <target state="translated">在您的示例中，调用 &lt;code&gt;Change&lt;/code&gt; 方法时-为它创建一个&lt;a href=&quot;http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces&quot;&gt;名称空间&lt;/a&gt; ； &lt;code&gt;var&lt;/code&gt; 成为该名称空间中字符串对象 &lt;code&gt;'Original'&lt;/code&gt; 的名称 。 然后，该对象在两个名称空间中都有一个名称。 接下来， &lt;code&gt;var = 'Changed'&lt;/code&gt; 将 &lt;code&gt;var&lt;/code&gt; 绑定到新的字符串对象，因此该方法的名称空间忘记了 &lt;code&gt;'Original'&lt;/code&gt; 。 最后，忘记了该名称空间，以及字符串 &lt;code&gt;'Changed'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb33c9ab807f193d39872eed5e22af0127a40637" translate="yes" xml:space="preserve">
          <source>Is there something I can do to pass the variable by actual reference?</source>
          <target state="translated">有什么办法可以通过实际引用来传递变量吗?</target>
        </trans-unit>
        <trans-unit id="d7e7bdb80421d5ef59aefc489f344f221587bba6" translate="yes" xml:space="preserve">
          <source>It is neither pass-by-value or pass-by-reference - it is call-by-object. See this, by Fredrik Lundh:</source>
          <target state="translated">它既不是逐值传递,也不是逐值传递,而是逐对象调用。请看这篇,作者是Fredrik Lundh。</target>
        </trans-unit>
        <trans-unit id="48bb347a9d7faf829dae8ac2ec01719f82c86124" translate="yes" xml:space="preserve">
          <source>It's an ugly hack, but it works. ;-P</source>
          <target state="translated">这是个丑陋的黑客,但很管用。</target>
        </trans-unit>
        <trans-unit id="c4d93e3229bff3269f3ab05cdf6305855b9bc82f" translate="yes" xml:space="preserve">
          <source>List - a mutable type</source>
          <target state="translated">列表-可变类型</target>
        </trans-unit>
        <trans-unit id="e145738e57fdf9ea90a9bfc63f28785068e9be9d" translate="yes" xml:space="preserve">
          <source>Mutable arguments are effectively passed &amp;ldquo;&lt;strong&gt;by pointer&lt;/strong&gt;.&amp;rdquo; Objects such as lists
and dictionaries are also passed by object reference, which is similar to the way C
passes arrays as pointers&amp;mdash;mutable objects can be changed in place in the function,
much like C arrays.</source>
          <target state="translated">可变参数有效地&amp;ldquo; &lt;strong&gt;通过指针&lt;/strong&gt; &amp;rdquo;传递。 诸如列表和字典之类的对象也通过对象引用传递，这类似于C将数组作为指针传递的方式&amp;mdash;可变对象可以在函数中就地更改，就像C数组一样。</target>
        </trans-unit>
        <trans-unit id="ed19ef46a33530a5532cfcd97126ae99cb3242a0" translate="yes" xml:space="preserve">
          <source>Objects are allocated on the heap and pointers to them can be passed around anywhere.</source>
          <target state="translated">对象被分配到堆上,而指向它们的指针可以在任何地方传递。</target>
        </trans-unit>
        <trans-unit id="87dea7220960a8d9957e82c5e7caf7ae67f5891a" translate="yes" xml:space="preserve">
          <source>Objects like lists are &lt;em&gt;mutable&lt;/em&gt;.  This means that the contents of the object can be changed by anything pointing to the object.  For example, &lt;code&gt;x = []; y = x; x.append(10); print y&lt;/code&gt; will print &lt;code&gt;[10]&lt;/code&gt;.  The empty list was created.  Both &quot;x&quot; and &quot;y&quot; point to the same list.  The &lt;em&gt;append&lt;/em&gt; method mutates (updates) the list object (like adding a record to a database) and the result is visible to both &quot;x&quot; and &quot;y&quot; (just as a database update would be visible to every connection to that database).</source>
          <target state="translated">像列表这样的对象是&lt;em&gt;可变的&lt;/em&gt; 。 这意味着可以通过指向该对象的任何内容来更改该对象的内容。 例如， &lt;code&gt;x = []; y = x; x.append(10); print y&lt;/code&gt; y = x; x.append（10）; 打印y将打印 &lt;code&gt;[10]&lt;/code&gt; 。 空列表已创建。 &amp;ldquo; x&amp;rdquo;和&amp;ldquo; y&amp;rdquo;都指向同一列表。 &lt;em&gt;append&lt;/em&gt;方法更改（更新）列表对象（例如向数据库中添加记录），并且结果对于&amp;ldquo; x&amp;rdquo;和&amp;ldquo; y&amp;rdquo;都是可见的（就像数据库更新对于该数据库的每个连接都是可见的一样）。</target>
        </trans-unit>
        <trans-unit id="4498e2a33a71723f43491095390bfa7816d3f75b" translate="yes" xml:space="preserve">
          <source>Objects like strings and integers are &lt;em&gt;immutable&lt;/em&gt;.  This simply means that there are no methods that can change the object after it has been created.  For example, once the integer object one-thousand is created, it will never change.  Math is done by creating new integer objects.</source>
          <target state="translated">诸如字符串和整数之类的对象是&lt;em&gt;不可变的&lt;/em&gt; 。 这仅表示没有任何方法可以在创建对象后更改该对象。 例如，一旦创建了整数对象1000，它就永远不会改变。 数学是通过创建新的整数对象完成的。</target>
        </trans-unit>
        <trans-unit id="27f285ca9e6dbf4bba0bcd6c449903172991d998" translate="yes" xml:space="preserve">
          <source>Obviously the above does not allow &lt;em&gt;reading&lt;/em&gt; the value, only updating it.</source>
          <target state="translated">显然，以上内容不允许&lt;em&gt;读取&lt;/em&gt;值，而只能对其进行更新。</target>
        </trans-unit>
        <trans-unit id="4751c7c9efc0a91758450a9fee280437f3b71a6f" translate="yes" xml:space="preserve">
          <source>One way is to use &lt;code&gt;global&lt;/code&gt; (for global variables) or &lt;code&gt;nonlocal&lt;/code&gt; (for local variables in a function) in a wrapper function.</source>
          <target state="translated">一种方法是在包装函数中使用 &lt;code&gt;global&lt;/code&gt; （对于全局变量）或非 &lt;code&gt;nonlocal&lt;/code&gt; （对于函数中的局部变量）。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="c439d84dc5a961368d9307e0770827dfc4515420" translate="yes" xml:space="preserve">
          <source>Pass-By-Reference in Python is quite different from the concept of pass by reference in C++/Java.</source>
          <target state="translated">Python中的Pass-By-Reference与C++Java中的Pass-By-Reference的概念有很大的区别。</target>
        </trans-unit>
        <trans-unit id="68451aca93c616b65cb7c9047a81894d6b972f90" translate="yes" xml:space="preserve">
          <source>Passing 3 wrappers to access a variable is a bit unwieldy so those can be wrapped into a class that has a proxy attribute:</source>
          <target state="translated">传递3个封装器来访问一个变量有点不方便,所以可以把这些封装到一个有代理属性的类中。</target>
        </trans-unit>
        <trans-unit id="0827e8d71a8fb26dad798d59e58b5d9485ef355e" translate="yes" xml:space="preserve">
          <source>Passing an argument into a function also binds a name (the parameter name of the function) to an object.</source>
          <target state="translated">在函数中传递一个参数也可以将一个名称(函数的参数名)绑定到一个对象上。</target>
        </trans-unit>
        <trans-unit id="c8afd49f905bfc9a3cb491f06eb314e73ee2416c" translate="yes" xml:space="preserve">
          <source>Python always uses pass-by-reference values. There isn't any exception. Any variable assignment means copying the reference value. No exception. Any variable is the name bound to the reference value. Always.</source>
          <target state="translated">Python总是使用通过引用值来传递。不存在任何例外。任何变量赋值都意味着复制引用值。没有任何例外。任何变量都是与引用值绑定的名称。始终如此。</target>
        </trans-unit>
        <trans-unit id="83861cb7e986e86de426cee8c30f2ed20d4ab7fd" translate="yes" xml:space="preserve">
          <source>Python has names and objects.</source>
          <target state="translated">Python有名字和对象。</target>
        </trans-unit>
        <trans-unit id="5fcbcd2747ab57ca64daa423ac6a3486436e1a62" translate="yes" xml:space="preserve">
          <source>Python&amp;rsquo;s pass-by-assignment scheme isn&amp;rsquo;t quite the same as C++&amp;rsquo;s reference parameters option, but it turns out to be very similar to the argument-passing model of the C language (and others) in practice:</source>
          <target state="translated">Python的传递分配方案与C ++的引用参数选项不太相同，但实际上它与C语言（及其他语言）的参数传递模型非常相似：</target>
        </trans-unit>
        <trans-unit id="333f7d50ad7e0d3ef1d2d6e716803037e8f19596" translate="yes" xml:space="preserve">
          <source>Pythons &quot;reflection&quot; support makes it possible to get a object that is capable of reassigning a name/variable in a given scope without defining functions explicitly in that scope:</source>
          <target state="translated">Pythons对 &quot;反射 &quot;的支持使我们可以获得一个对象,该对象能够在给定的范围内重新分配一个nameevariable,而不需要在该范围内明确定义函数。</target>
        </trans-unit>
        <trans-unit id="afbaddd3494c975f3248038d165efdcb7b42b91c" translate="yes" xml:space="preserve">
          <source>Reference values are hidden in Python. There isn't any explicit user type for storing the reference value. However, you can use a list element (or element in any other suitable container type) as the reference variable, because all containers do store the elements also as references to the target objects. In other words, elements are actually not contained inside the container -- only the references to elements are.</source>
          <target state="translated">参考值在Python中是隐藏的。没有任何显式的用户类型来存储引用值。但是,你可以使用 list 元素 (或任何其他合适的容器类型的元素)作为引用变量,因为所有的容器都会把元素作为目标对象的引用来存储。换句话说,元素实际上并不包含在容器中,只有元素的引用才包含在容器中。</target>
        </trans-unit>
        <trans-unit id="a16b36f9b22c19ae3e20f844261f568427971e02" translate="yes" xml:space="preserve">
          <source>See sections &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;3.1&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#naming-and-binding&quot;&gt;4.2&lt;/a&gt; in the Python 3 language reference.</source>
          <target state="translated">请参阅Python 3语言参考中的&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;3.1&lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#naming-and-binding&quot;&gt;4.2&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="660da67960cf04fb1e0d059bd7853b4c03efc993" translate="yes" xml:space="preserve">
          <source>Since dictionaries are passed by reference, you can use a dict variable to store any referenced values inside it.</source>
          <target state="translated">因为字典是通过引用传递的,所以可以使用dict变量来存储任何被引用的值。</target>
        </trans-unit>
        <trans-unit id="68d4a137bc67d697b621b97d6185016cdb4789cb" translate="yes" xml:space="preserve">
          <source>Since immutable types cannot be modified, they &lt;em&gt;seem&lt;/em&gt; like being passed by value - passing an int into a function means assigning the int to the function's parameter. You can only ever reassign that, but it won't change the original variables value.</source>
          <target state="translated">由于不可变类型无法修改，因此它们&lt;em&gt;看起来&lt;/em&gt;像是通过值传递-将int传递给函数意味着将int分配给函数的参数。 您只能重新分配它，但不会更改原始变量的值。</target>
        </trans-unit>
        <trans-unit id="696917aad2c2b30ef73b056904aa4dea2ce6c676" translate="yes" xml:space="preserve">
          <source>Since it seems to be nowhere mentioned an approach to simulate references as known from e.g. C++ is to use an &quot;update&quot; function and pass that instead of the actual variable (or rather, &quot;name&quot;):</source>
          <target state="translated">由于这里似乎没有提到一个模拟引用的方法,例如C++中提到的模拟引用的方法是使用一个 &quot;update &quot;函数,并传递这个函数来代替实际的变量(或者说是 &quot;name&quot;)。</target>
        </trans-unit>
        <trans-unit id="5d727a1d706032a86c18b0a92e1ed2ead4954513" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;the_list&lt;/code&gt; parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The &lt;code&gt;the_list&lt;/code&gt; was a copy of the &lt;code&gt;outer_list&lt;/code&gt; reference, and we had &lt;code&gt;the_list&lt;/code&gt; point to a new list, but there was no way to change where &lt;code&gt;outer_list&lt;/code&gt; pointed.</source>
          <target state="translated">由于 &lt;code&gt;the_list&lt;/code&gt; 参数是按值传递的，因此为其分配一个新列表不会影响方法外部的代码。 &lt;code&gt;the_list&lt;/code&gt; 是 &lt;code&gt;outer_list&lt;/code&gt; 引用的副本，我们让 &lt;code&gt;the_list&lt;/code&gt; 指向一个新列表，但是没有办法更改 &lt;code&gt;outer_list&lt;/code&gt; 指向的位置。</target>
        </trans-unit>
        <trans-unit id="36f7beed038b24998576a94eef27bf913f6ed625" translate="yes" xml:space="preserve">
          <source>Since the parameter passed in is a reference to &lt;code&gt;outer_list&lt;/code&gt;, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.</source>
          <target state="translated">由于传入的参数是对 &lt;code&gt;outer_list&lt;/code&gt; 的引用，而不是其副本，因此我们可以使用mutating list方法对其进行更改，并使更改反映在外部作用域中。</target>
        </trans-unit>
        <trans-unit id="e6e9cfc9cdfcbeabab6f908af34edaef10d1407d" translate="yes" xml:space="preserve">
          <source>Since your example happens to be object-oriented, you could make the following change to achieve a similar result:</source>
          <target state="translated">因为你的例子刚好是面向对象的,所以你可以做下面的修改来实现类似的结果。</target>
        </trans-unit>
        <trans-unit id="c8af5c8a28c9b058781cfa18faaa84372e62a5df" translate="yes" xml:space="preserve">
          <source>So if the thing you want to change is a mutable object, there is no problem, as everything is effectively passed by reference.</source>
          <target state="translated">所以,如果你想改变的东西是一个可变对象,那就没有问题,因为所有的东西都是通过引用有效地传递。</target>
        </trans-unit>
        <trans-unit id="bf807aabb75019d89aff61af1c01d7c2a1d18f4d" translate="yes" xml:space="preserve">
          <source>So, when passing a list to a function/method, the list is assigned to the parameter name. Appending to the list will result in the list being modified. Reassigning the list &lt;em&gt;inside&lt;/em&gt; the function will not change the original list, since:</source>
          <target state="translated">因此，当将列表传递给函数/方法时，该列表将分配给参数名称。 追加到列表将导致列表被修改。 在函数&lt;em&gt;内&lt;/em&gt;重新分配列表不会更改原始列表，因为：</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="d7a557055e4e02657c23b68f42103ada3c99dabb" translate="yes" xml:space="preserve">
          <source>String - an immutable type</source>
          <target state="translated">字符串-一个不可更改的类型</target>
        </trans-unit>
        <trans-unit id="7c1fdc94b36a2d1a36919d71bce545b535714140" translate="yes" xml:space="preserve">
          <source>Technically, &lt;strong&gt;Python always uses pass by reference values&lt;/strong&gt;. I am going to repeat &lt;a href=&quot;https://stackoverflow.com/a/12438316/1346705&quot;&gt;my other answer&lt;/a&gt; to support my statement.</source>
          <target state="translated">从技术上讲， &lt;strong&gt;Python始终使用按引用传递值&lt;/strong&gt; 。 我将重复&lt;a href=&quot;https://stackoverflow.com/a/12438316/1346705&quot;&gt;我的其他回答&lt;/a&gt;以支持我的发言。</target>
        </trans-unit>
        <trans-unit id="79c2b7cf71267d7a5e78f89f251fffbff74bb65a" translate="yes" xml:space="preserve">
          <source>That is all there is to it. Mutability is irrelevant for this question.</source>
          <target state="translated">这就是它的全部内容。互换性与这个问题无关。</target>
        </trans-unit>
        <trans-unit id="17becfeedaa8893ff84a47a35ec6e3e49715fa72" translate="yes" xml:space="preserve">
          <source>The Python documentation seems unclear about whether parameters are passed by reference or value, and the following code produces the unchanged value 'Original'</source>
          <target state="translated">Python 文档中似乎不清楚参数是通过引用还是值传递,下面的代码产生的是不变的值'Original'。</target>
        </trans-unit>
        <trans-unit id="f2fff69c21168bf26f5b1e057e178f0b3f2e5e7c" translate="yes" xml:space="preserve">
          <source>The actual object - [0, 1] (which would be called a value in other programming languages) is being passed. So in fact the function &lt;code&gt;change_me&lt;/code&gt; will try to do something like:</source>
          <target state="translated">正在传递实际对象[0，1]（在其他编程语言中将其称为值）。 所以实际上，函数 &lt;code&gt;change_me&lt;/code&gt; 将尝试执行以下操作：</target>
        </trans-unit>
        <trans-unit id="a681daed3a2466279708eadd396f12d4619acbc1" translate="yes" xml:space="preserve">
          <source>The assignment to an global variable that is not declared global therefore creates a new local object and breaks the link to the original object.</source>
          <target state="translated">因此,对一个未声明为全局变量的赋值,会创建一个新的本地对象,并断开与原对象的链接。</target>
        </trans-unit>
        <trans-unit id="dcf126983674f03f5b7e37d5d854435177547ce6" translate="yes" xml:space="preserve">
          <source>The basic idea is to have a function that can do that access and can be passed as object into other functions or stored in a class.</source>
          <target state="translated">基本的想法是要有一个可以做这个访问的函数,可以作为对象传入其他函数或存储在类中。</target>
        </trans-unit>
        <trans-unit id="0bc22d9160e54688c508487d4bc0a30f0fedfd8c" translate="yes" xml:space="preserve">
          <source>The key to understanding parameter passing is to stop thinking about &quot;variables&quot;. There are names and objects in Python and together they
appear like variables, but it is useful to always distinguish the three.</source>
          <target state="translated">理解参数传递的关键在于停止对 &quot;变量 &quot;的思考。在Python中,有名字和对象,它们在一起看起来就像变量一样,但总是把这三者区分开来是很有用的。</target>
        </trans-unit>
        <trans-unit id="4ab82925dc8dd0f7cb7b601b15859baf0d62bc4d" translate="yes" xml:space="preserve">
          <source>The more &lt;a href=&quot;https://www.python.org/dev/peps/pep-0020/&quot;&gt;pythonic&lt;/a&gt; approach would be to introduce a trivial, one-attribute class. The function receives an instance of the class and manipulates the attribute.</source>
          <target state="translated">更加&lt;a href=&quot;https://www.python.org/dev/peps/pep-0020/&quot;&gt;Python化的&lt;/a&gt;方法是引入一个琐碎的，一属性类。 该函数接收该类的实例并操纵该属性。</target>
        </trans-unit>
        <trans-unit id="cc1762bcf99fc58408f1a9ef7986e8348ee28a58" translate="yes" xml:space="preserve">
          <source>The only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places.</source>
          <target state="translated">唯一的办法就是传递一个可变对象。因为这两个引用都是指同一个对象,所以对象的任何变化都会在这两个地方反映出来。</target>
        </trans-unit>
        <trans-unit id="6fad76f326204f89d7ac6ac50ce5db14000add4d" translate="yes" xml:space="preserve">
          <source>The problem comes from a misunderstanding of what variables are in Python. If you're used to most traditional languages, you have a mental model of what happens in the following sequence:</source>
          <target state="translated">这个问题来自于对Python中什么是变量的误解。如果你已经习惯了大多数传统语言,你会有一个心理模型,知道下面的顺序是什么。</target>
        </trans-unit>
        <trans-unit id="84175dec5b4dc806baa482e3939f43855a2e8b04" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty solution for this is a one-element list (instead of &lt;code&gt;self.variable&lt;/code&gt;, pass &lt;code&gt;[self.variable]&lt;/code&gt; and in the function modify &lt;code&gt;var[0]&lt;/code&gt;).</source>
          <target state="translated">对此的快速解决方案是一个元素列表（而不是 &lt;code&gt;self.variable&lt;/code&gt; ，传递 &lt;code&gt;[self.variable]&lt;/code&gt; 并在函数中修改 &lt;code&gt;var[0]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="13c1347e705ce1693fe7d2b8e953c905989ca4b8" translate="yes" xml:space="preserve">
          <source>The same idea works for reading and &lt;code&gt;del&lt;/code&gt;eting a variable.</source>
          <target state="translated">相同的想法适用于读取和定义变量。</target>
        </trans-unit>
        <trans-unit id="5db310989aa7591454c760958f2af239e823a8c7" translate="yes" xml:space="preserve">
          <source>Then the call would result in:</source>
          <target state="translated">那么调用的结果就是:</target>
        </trans-unit>
        <trans-unit id="0105c63c552b46ed256ace297e33009660aef599" translate="yes" xml:space="preserve">
          <source>There are no variables in Python</source>
          <target state="translated">Python中没有变量</target>
        </trans-unit>
        <trans-unit id="086a535eed287fb2a8da5e4f2b4da1059486d637" translate="yes" xml:space="preserve">
          <source>There is a little trick to pass an object by reference, even though the language doesn't make it possible. It works in Java too, it's the list with one item. ;-)</source>
          <target state="translated">有一个小技巧,可以通过引用传递对象,尽管语言中没有做到这一点。它在Java中也可以用,就是用一个项目的列表。;-)</target>
        </trans-unit>
        <trans-unit id="b1c21ed6d2eec901faa433fdaff0e199b04f81af" translate="yes" xml:space="preserve">
          <source>Think of stuff being passed &lt;strong&gt;by assignment&lt;/strong&gt; instead of by reference/by value. That way, it is always clear, what is happening as long as you understand what happens during the normal assignment.</source>
          <target state="translated">考虑一下&lt;strong&gt;通过分配&lt;/strong&gt;而不是通过引用/按值传递的内容。 这样，就很清楚，只要您了解正常分配过程中发生了什么，就会发生什么情况。</target>
        </trans-unit>
        <trans-unit id="c5a5244ffa8b4f4ae77f3d588812cda61fa6be3d" translate="yes" xml:space="preserve">
          <source>This binds the name &lt;code&gt;a&lt;/code&gt; to an object of type integer that holds the value 1.</source>
          <target state="translated">这会将名称 &lt;code&gt;a&lt;/code&gt; 绑定到具有值1的整数类型的对象。</target>
        </trans-unit>
        <trans-unit id="884b42766d553e6f4cff2ad92ade45f883bf6559" translate="yes" xml:space="preserve">
          <source>This binds the name &lt;code&gt;b&lt;/code&gt; to the same object that the name &lt;code&gt;x&lt;/code&gt; is currently bound to.
Afterwards, the name &lt;code&gt;b&lt;/code&gt; has nothing to do with the name &lt;code&gt;x&lt;/code&gt; any more.</source>
          <target state="translated">这会将名称 &lt;code&gt;b&lt;/code&gt; 绑定到名称 &lt;code&gt;x&lt;/code&gt; 当前绑定到的同一对象。 此后，名称 &lt;code&gt;b&lt;/code&gt; 与名称 &lt;code&gt;x&lt;/code&gt; 无关。</target>
        </trans-unit>
        <trans-unit id="3a0da37fa36be60c0aa098be25fccdb7e017ac1b" translate="yes" xml:space="preserve">
          <source>This is mostly useful for &quot;out-only references&quot; or in a situation with multiple threads / processes (by making the update function thread / multiprocessing safe).</source>
          <target state="translated">这主要是在 &quot;仅有的引用 &quot;或有多个线程进程的情况下有用(通过使更新函数线程多处理安全)。</target>
        </trans-unit>
        <trans-unit id="2f1f28564cc17f4b95f8008ecbf300883f70aebb" translate="yes" xml:space="preserve">
          <source>To make it even more clear, let's have some examples.</source>
          <target state="translated">为了让大家更清楚,我们举几个例子。</target>
        </trans-unit>
        <trans-unit id="5623b8a007cec828bd71b838af98d8c9977c1510" translate="yes" xml:space="preserve">
          <source>To the extent that Python is pass by value, all languages are pass by value since some piece of data (be it a &quot;value&quot; or a &quot;reference&quot;) must be sent. However, that does not mean that Python is pass by value in the sense that a C programmer would think of it.</source>
          <target state="translated">就 Python 是通过值传递的程度而言,所有的语言都是通过值传递的,因为必须发送一些数据 (无论是 &quot;值 &quot;还是 &quot;引用&quot;)。然而,这并不意味着Python就是一个C语言程序员所认为的 &quot;值传递&quot;。</target>
        </trans-unit>
        <trans-unit id="20555a4a440b0601df4fa798a89247c553a96ccf" translate="yes" xml:space="preserve">
          <source>When you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there's no way to update that reference and make it refer to a new object. In your example:</source>
          <target state="translated">当你调用一个带参数的函数时,会创建一个新的引用来引用所传入的对象。这与函数调用中使用的引用是分开的,所以没有办法更新这个引用并使其引用到一个新的对象。在你的例子中。</target>
        </trans-unit>
        <trans-unit id="bc3fa5ea94b2efd9143d2934a64ae051133be6ed" translate="yes" xml:space="preserve">
          <source>When you do a new assignment such as &lt;code&gt;y = x&lt;/code&gt;, a new dictionary entry &quot;y&quot; is created that points to the same object as the entry for &quot;x&quot;.</source>
          <target state="translated">当您进行新的赋值（例如 &lt;code&gt;y = x&lt;/code&gt; ，将创建一个新的词典条目&amp;ldquo; y&amp;rdquo;，该条目指向与&amp;ldquo; x&amp;rdquo;条目相同的对象。</target>
        </trans-unit>
        <trans-unit id="a8ec35d9c1b72807f2ded385deffa6f8aa373d72" translate="yes" xml:space="preserve">
          <source>When you make an assignment such as &lt;code&gt;x = 1000&lt;/code&gt;, a dictionary entry is created that maps the string &quot;x&quot; in the current namespace to a pointer to the integer object containing one thousand.</source>
          <target state="translated">当您进行 &lt;code&gt;x = 1000&lt;/code&gt; 类的赋值时，将创建一个字典条目，该条目将当前名称空间中的字符串&amp;ldquo; x&amp;rdquo;映射到一个指向包含1000的整数对象的指针。</target>
        </trans-unit>
        <trans-unit id="e648dd9f3d5b78507aba8fd21719ec93fe30b1ca" translate="yes" xml:space="preserve">
          <source>When you update &quot;x&quot; with &lt;code&gt;x = 2000&lt;/code&gt;, a new integer object is created and the dictionary is updated to point at the new object.  The old one thousand object is unchanged (and may or may not be alive depending on whether anything else refers to the object).</source>
          <target state="translated">当使用 &lt;code&gt;x = 2000&lt;/code&gt; 更新&amp;ldquo; x&amp;rdquo;时，将创建一个新的整数对象，并且字典将更新为指向该新对象。 旧的一千个对象保持不变（取决于其他是否引用了该对象，该对象是否可能还活着）。</target>
        </trans-unit>
        <trans-unit id="13eb328770b9c46bbd56e2839f367e0a7b3f96db" translate="yes" xml:space="preserve">
          <source>Whenever you pass an object to the function, the object itself is passed (object in Python is actually what you'd call a value in other programming languages) not the reference to this object. In other words, when you call:</source>
          <target state="translated">每当你向函数传递一个对象时,就会传递对象本身 (object 在 Python 中实际上就是其他编程语言中的值),而不是对这个对象的引用。换句话说,当你调用。</target>
        </trans-unit>
        <trans-unit id="6b4cb23677b917c5c42bbdb41b1590df3465a4db" translate="yes" xml:space="preserve">
          <source>While pass by reference is nothing that fits well into python and should be rarely used there are some workarounds that actually can work to get the object currently assigned to a local variable or even reassign a local variable from inside of a called function.</source>
          <target state="translated">虽然Pass by reference并不适合在Python中使用,而且应该很少使用,但是有一些变通的方法,实际上可以从被调用的函数中获取当前分配给本地变量的对象,甚至可以从被调用的函数内部重新分配一个本地变量。</target>
        </trans-unit>
        <trans-unit id="06ef8c07f183597c6357e8005336de31d41ec30c" translate="yes" xml:space="preserve">
          <source>You believe that &lt;code&gt;a&lt;/code&gt; is a memory location that stores the value &lt;code&gt;1&lt;/code&gt;, then is updated to store the value &lt;code&gt;2&lt;/code&gt;. That's not how things work in Python. Rather, &lt;code&gt;a&lt;/code&gt; starts as a reference to an object with the value &lt;code&gt;1&lt;/code&gt;, then gets reassigned as a reference to an object with the value &lt;code&gt;2&lt;/code&gt;. Those two objects may continue to coexist even though &lt;code&gt;a&lt;/code&gt; doesn't refer to the first one anymore; in fact they may be shared by any number of other references within the program.</source>
          <target state="translated">您认为 &lt;code&gt;a&lt;/code&gt; 是存储值 &lt;code&gt;1&lt;/code&gt; 的存储位置，然后被更新为存储值 &lt;code&gt;2&lt;/code&gt; 。 那不是Python中的工作方式。 相反， &lt;code&gt;a&lt;/code&gt; 开头是对值为 &lt;code&gt;1&lt;/code&gt; 的对象的引用，然后被重新分配为对值为 &lt;code&gt;2&lt;/code&gt; 的对象的引用。 即使 &lt;code&gt;a&lt;/code&gt; 不再引用第一个对象，这两个对象也可能继续存在。 实际上，它们可以被程序中的许多其他引用共享。</target>
        </trans-unit>
        <trans-unit id="6cbe72d4aff2f1d3e9fb3501cd97383b70fd44e7" translate="yes" xml:space="preserve">
          <source>You can merely use &lt;strong&gt;an empty class&lt;/strong&gt; as an instance to store reference objects because internally object attributes are stored in an instance dictionary. See the example.</source>
          <target state="translated">您只能使用&lt;strong&gt;空类&lt;/strong&gt;作为实例来存储引用对象，因为内部对象属性存储在实例字典中。 参见示例。</target>
        </trans-unit>
        <trans-unit id="9e395b0bd4b1dc1eea4d49d8e1f40c5347e0d5a1" translate="yes" xml:space="preserve">
          <source>You can think about a reference value as the address of the target object. The address is automatically dereferenced when used. This way, working with the reference value, it seems you work directly with the target object. But there always is a reference in between, one step more to jump to the target.</source>
          <target state="translated">你可以把引用值想成目标对象的地址。在使用时,该地址会被自动去掉引用。这样一来,用引用值工作,似乎你就直接和目标对象一起工作了。但中间总有一个引用,多一步跳转到目标对象。</target>
        </trans-unit>
        <trans-unit id="233857d84270d4d4cf81d2ab105c0ebb1d786176" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://docs.python.org/3.3/library/functions.html#id&quot;&gt;&lt;code&gt;id()&lt;/code&gt;&lt;/a&gt; built-in function to learn what the reference value is (that is, the address of the target object).</source>
          <target state="translated">您可以使用&lt;a href=&quot;http://docs.python.org/3.3/library/functions.html#id&quot;&gt; &lt;code&gt;id()&lt;/code&gt; &lt;/a&gt;内置函数来了解参考值是什么（即目标对象的地址）。</target>
        </trans-unit>
        <trans-unit id="fee26813eb63428556d25e99b697066a5abee304" translate="yes" xml:space="preserve">
          <source>You got some really good answers here.</source>
          <target state="translated">你在这里得到了一些非常好的答案。</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="ac2c0095bbd1e16c2e3606675ef16ab060af766f" translate="yes" xml:space="preserve">
          <source>given the way python handles values and references to them, the only way you can reference an arbitrary instance attribute is by name:</source>
          <target state="translated">考虑到python处理值和引用的方式,你可以引用任意实例属性的唯一方式就是通过名字来引用。</target>
        </trans-unit>
        <trans-unit id="5dcfdd557133c0be7c75544c8a554ac3a7ddef6a" translate="yes" xml:space="preserve">
          <source>gives:</source>
          <target state="translated">gives:</target>
        </trans-unit>
        <trans-unit id="31cef82f841f61f64a2b51817dadd21b57e78be6" translate="yes" xml:space="preserve">
          <source>in real code you would, of course, add error checking on the dict lookup.</source>
          <target state="translated">在真正的代码中,你当然会在dict查找中添加错误检查。</target>
        </trans-unit>
        <trans-unit id="1d8a6a9487c9bd9e3711fa2119286c096444a2f6" translate="yes" xml:space="preserve">
          <source>some data types are mutable, but others aren't</source>
          <target state="translated">有些数据类型是可以变异的,但有些数据类型是不可以变异的。</target>
        </trans-unit>
        <trans-unit id="5f0f7656c197d2526aa255c56c1295fe45b9916d" translate="yes" xml:space="preserve">
          <source>the parameter passed in is actually a &lt;em&gt;reference&lt;/em&gt; to an object (but the reference is passed by value)</source>
          <target state="translated">传入的参数实际上是&lt;em&gt;对&lt;/em&gt;对象的引用（但引用是通过值传递的）</target>
        </trans-unit>
        <trans-unit id="9789798d32b8f1cb1ca7e4b37e5b087b68d91f3c" translate="yes" xml:space="preserve">
          <source>which obviously will change the object. &lt;a href=&quot;https://stackoverflow.com/a/534509/831531&quot;&gt;This answer&lt;/a&gt; explains it well.</source>
          <target state="translated">这显然会改变对象。 &lt;a href=&quot;https://stackoverflow.com/a/534509/831531&quot;&gt;这个答案&lt;/a&gt;很好地解释了。</target>
        </trans-unit>
        <trans-unit id="0a5dcf0aaba3d474366727f90d67aa1948bf146f" translate="yes" xml:space="preserve">
          <source>which obviously will not change the object passed to the function. If the function looked like this:</source>
          <target state="translated">显然不会改变传递给该函数的对象。如果这个函数是这样的,那么</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
