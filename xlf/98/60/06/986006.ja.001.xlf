<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/986006">
    <body>
      <group id="986006">
        <trans-unit id="a1b152a892ef513d9a4d8de1e227286558de128b" translate="yes" xml:space="preserve">
          <source>&quot;...variables [names] are &lt;em&gt;not&lt;/em&gt; objects; they cannot be denoted by other variables or referred to by objects.&quot;</source>
          <target state="translated">「...変数[名前]はオブジェクトではあり&lt;em&gt;ません&lt;/em&gt; 。他の変数で表したり、オブジェクトで参照したりすることはできません。」</target>
        </trans-unit>
        <trans-unit id="ec2f8b9ef1eca2860982704b2396e6f5e99305cc" translate="yes" xml:space="preserve">
          <source>&quot;In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a new value anywhere within the function&amp;rsquo;s body, it&amp;rsquo;s assumed to be a local. If a variable is ever assigned a new value inside the function, the variable is implicitly local, and you need to explicitly declare it as &amp;lsquo;global&amp;rsquo;.
Though a bit surprising at first, a moment&amp;rsquo;s consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, you&amp;rsquo;d be using global all the time. You&amp;rsquo;d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.&quot;</source>
          <target state="translated">「Pythonでは、関数内でのみ参照される変数は暗黙的にグローバルです。変数に関数の本体内の任意の場所に新しい値が割り当てられている場合、その変数はローカルであると見なされます。変数に関数内で新しい値が割り当てられている場合、変数は暗黙的にローカルであり、 'グローバル'として明示的に宣言する必要があります。最初は少し意外ですが、ちょっと考えてみるとこれが説明されます。一方で、割り当てられた変数にグローバルを要求すると、意図しない副作用を防ぐことができます。一方、すべてのグローバル参照にグローバルが必要な場合は、常にグローバルを使用します。組み込み関数またはインポートされたモジュールのコンポーネントへのすべての参照をグローバルとして宣言する必要があります。副作用を特定するためのグローバル宣言の有用性を無効にするでしょう。」</target>
        </trans-unit>
        <trans-unit id="42c22aec244c5d347e54be65aaab6403cdf146a7" translate="yes" xml:space="preserve">
          <source>(Yeah I know this can be inconvenient, but sometimes it is simple enough to do this.)</source>
          <target state="translated">(ああ、これは不便だとは思うが、たまには簡単にできることもある)</target>
        </trans-unit>
        <trans-unit id="8a51a221218346c2c1772a44d0e7cc971cece6c5" translate="yes" xml:space="preserve">
          <source>(edit - Blair has updated his enormously popular answer so that it is now accurate)</source>
          <target state="translated">(編集-ブレアは非常に人気のある彼の答えを更新したので、現在は正確です)</target>
        </trans-unit>
        <trans-unit id="a62a78c201c7282875384fa5a4bbe69e0365e928" translate="yes" xml:space="preserve">
          <source>(edit 2019-04-28)</source>
          <target state="translated">(編集 2019-04-28)</target>
        </trans-unit>
        <trans-unit id="8b9f3efa3729cce732344f81bf8d7d82f28606bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self.variable&lt;/code&gt; is a reference to the string object &lt;code&gt;'Original'&lt;/code&gt;. When you call &lt;code&gt;Change&lt;/code&gt; you create a second reference &lt;code&gt;var&lt;/code&gt; to the object. Inside the function you reassign the reference &lt;code&gt;var&lt;/code&gt; to a different string object &lt;code&gt;'Changed'&lt;/code&gt;, but the reference &lt;code&gt;self.variable&lt;/code&gt; is separate and does not change.</source>
          <target state="translated">&lt;code&gt;self.variable&lt;/code&gt; は、文字列オブジェクト &lt;code&gt;'Original'&lt;/code&gt; への参照です。 &lt;code&gt;Change&lt;/code&gt; を呼び出すと、オブジェクトへの2番目の参照 &lt;code&gt;var&lt;/code&gt; が作成されます。 関数内で、参照 &lt;code&gt;var&lt;/code&gt; を別の文字列オブジェクト &lt;code&gt;'Changed'&lt;/code&gt; に再割り当てしますが、参照 &lt;code&gt;self.variable&lt;/code&gt; は独立しており、変更されません。</target>
        </trans-unit>
        <trans-unit id="4229ed636553c69cfddd84246fc10b33ff69719b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++:&lt;/strong&gt; Both pass-by-reference or pass-by-value are allowed. If a parameter is passed by reference, you can either modify it or not depending upon whether the parameter was passed as const or not. However, const or not, the parameter maintains the reference to the object and reference cannot be assigned to point to a different object within the called function.</source>
          <target state="translated">&lt;strong&gt;C ++：&lt;/strong&gt;参照渡しまたは値渡しの両方が許可されます。 パラメータが参照によって渡される場合、パラメータがconstとして渡されたかどうかに応じて、パラメータを変更することもしないこともできます。 ただし、constかどうかに関係なく、パラメーターはオブジェクトへの参照を維持し、呼び出された関数内の別のオブジェクトを指すように参照を割り当てることはできません。</target>
        </trans-unit>
        <trans-unit id="b3be1ec03105d4972fcbe3fec3a499e2307f9ee7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; It's been noted that this doesn't answer the question that @David originally asked, &quot;Is there something I can do to pass the variable by actual reference?&quot;. Let's work on that.</source>
          <target state="translated">&lt;strong&gt;編集：&lt;/strong&gt;これは@Davidが最初に尋ねた「実際の参照によって変数を渡すために何かできることはありますか？」という質問に答えないことが指摘されています。 それに取り組みましょう。</target>
        </trans-unit>
        <trans-unit id="d892af211725dce0575cd510d5913eae3f198cec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's immutable, so there's nothing we can do to change the contents of the string&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;それは不変なので、文字列の内容を変更するために私たちにできることは何もありません&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee9513e042a85a4c63813585beec33bd12875b0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java&amp;amp;C#:&lt;/strong&gt; primitive types(include string)pass by value(copy), Reference type is passed by reference(address copy) so all changes made in the parameter in the called function are visible to the caller.</source>
          <target state="translated">&lt;strong&gt;Java＆C＃：&lt;/strong&gt;プリミティブ型（文字列を含む）値渡し（コピー）、参照型は参照渡し（アドレスコピー）で、呼び出された関数のパラメーターで行われたすべての変更が呼び出し元に表示されます。</target>
        </trans-unit>
        <trans-unit id="b6bd3f4d372e7f7c7ecfb3b235bcc93f977ff2b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's try to modify the list that was passed to a method:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;メソッドに渡されたリストを変更してみましょう：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be2b61cd76cc0ed218c950fa9a0f695fe658d0b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now let's see what happens when we try to change the reference that was passed in as a parameter:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;次に、パラメーターとして渡された参照を変更しようとするとどうなるかを見てみましょう。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1bb1d2d46eeb3cfe61924c812bf981baeae0193b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now, let's try to change the reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;では、参照を変更してみましょう&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5b90913af1169e0301615a93fc64f0e5b948b1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python:&lt;/strong&gt; 
Python is &amp;ldquo;pass-by-object-reference&amp;rdquo;, of which it is often said: &amp;ldquo;Object references are passed by value.&amp;rdquo;[Read here]&lt;a href=&quot;https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/&quot;&gt;1&lt;/a&gt;. Both the caller and the function refer to the same object but the parameter in the function is a new variable which is just holding a copy of the object in the caller. Like C++, a parameter can be either modified or not in function - This depends upon the type of object passed. eg; An immutable object type cannot be modified in the called function whereas a mutable object can be either updated or re-initialized. A crucial difference between updating or re-assigning/re-initializing the mutable variable is that updated value gets reflected back in the called function whereas the reinitialized value does not. Scope of any assignment of new object to a mutable variable is local to the function in the python. Examples provided by @blair-conrad are great to understand this.</source>
          <target state="translated">&lt;strong&gt;Python：&lt;/strong&gt; Pythonは「オブジェクト参照による受け渡し」であり、「オブジェクト参照は値によって受け渡される」とよく言われます。[ここを読む] &lt;a href=&quot;https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/&quot;&gt;1&lt;/a&gt; 。 呼び出し元と関数の両方が同じオブジェクトを参照していますが、関数のパラメーターは、呼び出し元のオブジェクトのコピーを保持している新しい変数です。 C ++と同様に、パラメーターは変更することも、関数内で変更しないこともできます。これは、渡されるオブジェクトのタイプによって異なります。 例えば; 不変オブジェクトタイプは、呼び出された関数では変更できませんが、可変オブジェクトは更新または再初期化できます。 可変変数の更新または再割り当て/再初期化の決定的な違いは、更新された値は呼び出された関数に反映されますが、再初期化された値は反映されないことです。 可変変数への新しいオブジェクトの割り当てのスコープは、Pythonの関数に対してローカルです。 @ blair-conradが提供する例は、これを理解するのに最適です。</target>
        </trans-unit>
        <trans-unit id="9883e919e7997c4bcd00e7db78ba8af7ca037be6" translate="yes" xml:space="preserve">
          <source>A lot of insights in answers here, but i think an additional point is not clearly mentioned here explicitly.   Quoting from python documentation &lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&lt;/a&gt;</source>
          <target state="translated">ここで答えの洞察はたくさんありますが、追加のポイントはここでは明示的に明確に述べられていないと思います。 Pythonドキュメントからの引用&lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b9bc6a21011e77a1fc1acf4db17ae8c442f98ed" translate="yes" xml:space="preserve">
          <source>A simple trick I normally use is to just wrap it in a list:</source>
          <target state="translated">私が普段使っている簡単なコツは、リストにまとめるだけです。</target>
        </trans-unit>
        <trans-unit id="1c34629702aff601e9017462b805c4e1564c10a6" translate="yes" xml:space="preserve">
          <source>Again, since the &lt;code&gt;the_string&lt;/code&gt; parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The &lt;code&gt;the_string&lt;/code&gt; was a copy of the &lt;code&gt;outer_string&lt;/code&gt; reference, and we had &lt;code&gt;the_string&lt;/code&gt; point to a new string, but there was no way to change where &lt;code&gt;outer_string&lt;/code&gt; pointed.</source>
          <target state="translated">繰り返しに &lt;code&gt;the_string&lt;/code&gt; ますが、 the_stringパラメータは値で渡されるため、新しい文字列をそれに割り当てても、メソッドの外部のコードが認識できる効果はありませんでした。 &lt;code&gt;the_string&lt;/code&gt; は &lt;code&gt;outer_string&lt;/code&gt; 参照のコピーであり、 the_stringが新しい文字列を指すようにしましたが、 &lt;code&gt;outer_string&lt;/code&gt; が指す場所を変更する方法がありませんでした 。</target>
        </trans-unit>
        <trans-unit id="c9e5405e129e476d3e0ef475249c330ed3f6dfb5" translate="yes" xml:space="preserve">
          <source>Although this seems a little cumbersome.</source>
          <target state="translated">ちょっと面倒くさそうですが。</target>
        </trans-unit>
        <trans-unit id="2d97b97ac2c4c28ba96535277dd72cff612ba228" translate="yes" xml:space="preserve">
          <source>Another solution would be to create a static method like this:</source>
          <target state="translated">もう一つの解決策は、このような静的メソッドを作成することでしょう。</target>
        </trans-unit>
        <trans-unit id="b0c7226e7708d9f8704f1ddf855b76d4d0e697d8" translate="yes" xml:space="preserve">
          <source>Arguments are &lt;a href=&quot;http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference&quot;&gt;passed by assignment&lt;/a&gt;. The rationale behind this is twofold:</source>
          <target state="translated">引数は&lt;a href=&quot;http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference&quot;&gt;代入によって渡され&lt;/a&gt;ます。 この背後にある理論的根拠は2つあります。</target>
        </trans-unit>
        <trans-unit id="57fce48e3511c0b229efd7be720f8de1904d6840" translate="yes" xml:space="preserve">
          <source>As @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out:</source>
          <target state="translated">Andreaさんの回答が示すように、新しい値を返すことができます。この方法では、渡された情報を変更することはできませんが、必要な情報を取得することができます。</target>
        </trans-unit>
        <trans-unit id="3fc39df4449e0220d47d2afd67496a6547200ecf" translate="yes" xml:space="preserve">
          <source>As you can state you need to have a mutable object, but let me suggest you to check over the global variables as they can help you or even solve this kind of issue!</source>
          <target state="translated">しかし、グローバル変数をチェックしてみることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1173d3f94d407863d6672e2edbfad0d748c8d95e" translate="yes" xml:space="preserve">
          <source>Aside from all the great explanations on how this stuff works in Python, I don't see a simple suggestion for the problem. As you seem to do create objects and instances, the pythonic way of handling instance variables and changing them is the following:</source>
          <target state="translated">このようなものがPythonでどのように動作するかについての素晴らしい説明はさておき、私は問題のための簡単な提案を見ていません。オブジェクトやインスタンスを作成しているようなので、インスタンス変数の扱いや変更はPython的には以下のようになります。</target>
        </trans-unit>
        <trans-unit id="955f20c5fd3d4cf266b4f4f30cefc9bede9bc806" translate="yes" xml:space="preserve">
          <source>Assignment binds a name to an object.</source>
          <target state="translated">割り当ては、名前をオブジェクトにバインドします。</target>
        </trans-unit>
        <trans-unit id="44eb458222e5cac4dd20238f7eb9ffa3a0a032f1" translate="yes" xml:space="preserve">
          <source>David Cournapeau's answer points to the real answer and explains why the behavior in Blair Conrad's post seems to be correct while the definitions are not.</source>
          <target state="translated">デビッド・クルナポーの回答は本当の答えを指し示しており、ブレア・コンラッドの投稿にある行動が正しいように見える一方で、定義が正しくない理由を説明しています。</target>
        </trans-unit>
        <trans-unit id="6ba040c2f2a2d80842507aa7fb2215325e5e6c43" translate="yes" xml:space="preserve">
          <source>Effbot (aka Fredrik Lundh) has described Python's variable passing style as call-by-object:  &lt;a href=&quot;http://effbot.org/zone/call-by-object.htm&quot;&gt;http://effbot.org/zone/call-by-object.htm&lt;/a&gt;</source>
          <target state="translated">Effbot（別名Fredrik Lundh）は、Pythonの変数受け渡しスタイルをcall-by-objectとして説明しています： &lt;a href=&quot;http://effbot.org/zone/call-by-object.htm&quot;&gt;http&lt;/a&gt; : //effbot.org/zone/call-by-object.htm</target>
        </trans-unit>
        <trans-unit id="feb265a8df8e110e2790224a1da7e1861c9fda44" translate="yes" xml:space="preserve">
          <source>Even when passing a mutable object to a function this still applies. And to me clearly explains the reason for the difference in behavior between assigning to the object and operating on the object in the function.</source>
          <target state="translated">関数にミュータブルオブジェクトを渡す場合でも、これは適用されます。そして、私には、オブジェクトへの代入と関数内のオブジェクトの操作の間の動作の違いの理由が明確に説明されています。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="63aabb26e4f4644f4690795ae16738f9c1f5f4da" translate="yes" xml:space="preserve">
          <source>For just reading there is even a shorter way of just using &lt;code&gt;lambda: x&lt;/code&gt; which returns a callable that when called returns the current value of x. This is somewhat like &quot;call by name&quot; used in languages in the distant past.</source>
          <target state="translated">読み取るだけの場合、 &lt;code&gt;lambda: x&lt;/code&gt; を使用するより短い方法があります。これは、呼び出し時にxの現在の値を返す呼び出し可能オブジェクトを返します。 これは、昔の言語で使用されていた「名前で呼び出す」のようなものです。</target>
        </trans-unit>
        <trans-unit id="a82f8b81c3ead144e50f2f04d42ea8cbd19c3b82" translate="yes" xml:space="preserve">
          <source>Here is a significant quote:</source>
          <target state="translated">ここに重要な引用があります。</target>
        </trans-unit>
        <trans-unit id="64605a5b8fffbc932d2851dd3c0a9a3b81ea1391" translate="yes" xml:space="preserve">
          <source>Here is the example that proves that Python uses passing by reference:</source>
          <target state="translated">Pythonが参照によるパッシングを使っていることを証明する例を紹介します。</target>
        </trans-unit>
        <trans-unit id="4652a9a03eda229eaa585e4d8b3108f912ea3767" translate="yes" xml:space="preserve">
          <source>Here is the simple (I hope) explanation of the concept &lt;code&gt;pass by object&lt;/code&gt; used in Python.</source>
          <target state="translated">Pythonで使用さ &lt;code&gt;pass by object&lt;/code&gt; 概念パスの簡単な（私はそう思います）説明です。</target>
        </trans-unit>
        <trans-unit id="48484f80102edbe70571bc88f85e228361438a9f" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;ByRef&lt;/code&gt; class wraps a dictionary access. So attribute access to &lt;code&gt;wrapped&lt;/code&gt; is translated to a item access in the passed dictionary. By passing the result of the builtin &lt;code&gt;locals&lt;/code&gt; and the name of a local variable this ends up accessing a local variable. The python documentation as of 3.5 advises that changing the dictionary might not work but it seems to work for me.</source>
          <target state="translated">ここで、 &lt;code&gt;ByRef&lt;/code&gt; クラスは辞書アクセスをラップします。 したがって、 &lt;code&gt;wrapped&lt;/code&gt; への属性アクセスは、渡されたディクショナリのアイテムアクセスに変換されます。 組み込み &lt;code&gt;locals&lt;/code&gt; 結果とローカル変数の名前を渡すことにより、ローカル変数にアクセスすることになります。 3.5の時点でのpythonのドキュメントでは、辞書の変更は機能しない可能性があるが、私にとっては機能するようです。</target>
        </trans-unit>
        <trans-unit id="d0be6fb2e163967ac2361db4b4dde754f1a7b504" translate="yes" xml:space="preserve">
          <source>Hope that clarifies the issue for you.</source>
          <target state="translated">これで問題が解決することを願っています。</target>
        </trans-unit>
        <trans-unit id="ac9f35a5c40f1a54d0e975658a953c9ccceb917a" translate="yes" xml:space="preserve">
          <source>How do I pass a variable by reference</source>
          <target state="translated">参照で変数を渡すには</target>
        </trans-unit>
        <trans-unit id="2635b21aa1a1e66c5ca7fed959d2e61ba0068f22" translate="yes" xml:space="preserve">
          <source>How do we get around this?</source>
          <target state="translated">どうやって回避するの?</target>
        </trans-unit>
        <trans-unit id="f2d3f338abd337442158a979a1f5de30af33097e" translate="yes" xml:space="preserve">
          <source>How to pass by reference</source>
          <target state="translated">参考にして合格する方法</target>
        </trans-unit>
        <trans-unit id="072a54410009d923de415851395bc3f915f1966d" translate="yes" xml:space="preserve">
          <source>How to read the example in the question</source>
          <target state="translated">問題の例文の読み方</target>
        </trans-unit>
        <trans-unit id="f10e3c369b21afb8efe5cb8ff95bfee39a5c9ffa" translate="yes" xml:space="preserve">
          <source>I found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.</source>
          <target state="translated">他の回答はかなり長くて複雑だったので、Pythonの変数やパラメータの扱い方を説明するために、このような簡単な図を作ってみました。</target>
        </trans-unit>
        <trans-unit id="3ca5711f1032450bdfe039601daafa6c14debe97" translate="yes" xml:space="preserve">
          <source>I hope this clears things up a little.</source>
          <target state="translated">これで少しはスッキリしたかな?</target>
        </trans-unit>
        <trans-unit id="779f081125662b16c96e53373144d42eb57b8923" translate="yes" xml:space="preserve">
          <source>I think it is important to note that the current post with the most votes (by Blair Conrad), while being correct with respect to its result, is misleading and is borderline incorrect based on its definitions.  While there are many languages (like C) that allow the user to either pass by reference or pass by value, Python is not one of them.</source>
          <target state="translated">最も多くの票を獲得した現在の投稿(Blair Conradによる)は、その結果に関しては正しいのですが、誤解を招きやすく、その定義に基づいて不正確な境界線上にあることに注意することが重要だと思います。参照によるパスと値によるパスのどちらかを可能にする言語は(C言語のように)たくさんありますが、Pythonはその中の一つではありません。</target>
        </trans-unit>
        <trans-unit id="1caf319e1b878a7a9add11ed6d02d3179fc2d9bb" translate="yes" xml:space="preserve">
          <source>I used the following method to quickly convert a couple of Fortran codes to Python.  True, it's not pass by reference as the original question was posed, but is a simple work around in some cases.</source>
          <target state="translated">私は以下の方法を使って、いくつかのFortranコードを素早くPythonに変換しました。確かに、元の質問のように参照によるパスではありませんが、いくつかのケースでは簡単な回避策になります。</target>
        </trans-unit>
        <trans-unit id="f8f3af9f0dc96665fb36e21e7dd8ea0010188a92" translate="yes" xml:space="preserve">
          <source>I'm sure someone else could clarify this further.</source>
          <target state="translated">これをもっと明確にしてくれる人がいるのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="8fd3fb5434919f5765b442b73f1a2ea249604d75" translate="yes" xml:space="preserve">
          <source>If it is an &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;immutable&lt;/a&gt; object (e.g. a bool, number, string), the way to go is to wrap it in a mutable object.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;不変&lt;/a&gt;オブジェクト（ブール、数値、文字列など）の場合は、変更可能なオブジェクトにラップする方法があります。</target>
        </trans-unit>
        <trans-unit id="e8ff937ee3cf391aa9369bcc79fcdbacd051a2eb" translate="yes" xml:space="preserve">
          <source>If the argument was passed by value, the outer &lt;code&gt;lst&lt;/code&gt; could not be modified. The green are the target objects (the black is the value stored inside, the red is the object type), the yellow is the memory with the reference value inside -- drawn as the arrow. The blue solid arrow is the reference value that was passed to the function (via the dashed blue arrow path). The ugly dark yellow is the internal dictionary. (It actually could be drawn also as a green ellipse. The colour and the shape only says it is internal.)</source>
          <target state="translated">引数が値で渡された場合、外側の &lt;code&gt;lst&lt;/code&gt; は変更できませんでした。 緑はターゲットオブジェクト（黒は内部に格納された値、赤はオブジェクトタイプです）、黄色は内部に参照値があるメモリです-矢印として描画されます。 青い実線の矢印は、（青い破線の矢印パスを介して）関数に渡された参照値です。 醜い濃い黄色は内部辞書です。 （実際には、緑色の楕円としても描画できます。色と形は、それが内部であることを示しているだけです。）</target>
        </trans-unit>
        <trans-unit id="0dd316a07900ad81da1e569611d0d7f972700c53" translate="yes" xml:space="preserve">
          <source>If you pass a &lt;em&gt;mutable&lt;/em&gt; object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object.</source>
          <target state="translated">&lt;em&gt;変更可能な&lt;/em&gt;オブジェクトをメソッドに渡すと、メソッドはその同じオブジェクトへの参照を取得し、喜んでそれを変更できますが、メソッドで参照を再バインドすると、外側のスコープはそれについて何も知りません。完了しても、外部参照はまだ元のオブジェクトを指しています。</target>
        </trans-unit>
        <trans-unit id="6f1b4b35463994559a0edb1ad6a1b8357fb742a0" translate="yes" xml:space="preserve">
          <source>If you pass an &lt;em&gt;immutable&lt;/em&gt; object to a method, you still can't rebind the outer reference, and you can't even mutate the object.</source>
          <target state="translated">&lt;em&gt;不変&lt;/em&gt;オブジェクトをメソッドに渡しても、外部参照を再バインドすることはできず、オブジェクトを変更することもできません。</target>
        </trans-unit>
        <trans-unit id="bc1e60fe42ced701dd9148c0ff6beca470127f04" translate="yes" xml:space="preserve">
          <source>If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:</source>
          <target state="translated">どうしても戻り値の使用を避けたいのであれば、値を保持するクラスを作成して関数に渡すか、リストのような既存のクラスを使用することができます。</target>
        </trans-unit>
        <trans-unit id="9688763625be69eed8ed0d10e131598208128be6" translate="yes" xml:space="preserve">
          <source>If you want the behavior, Blair Conrad's answer is fine.  But if you want to know the nuts and bolts of why Python is neither pass by value or pass by reference, read David Cournapeau's answer.</source>
          <target state="translated">挙動を知りたいのであれば、Blair Conradの答えは問題ありません。しかし、Pythonがなぜ値渡しでも参照渡しでもないのか、という根幹の部分を知りたいのであれば、David Cournapeauの答えを読んでください。</target>
        </trans-unit>
        <trans-unit id="e5596ea1ad94c7661a4350a8652098d786a4cc4b" translate="yes" xml:space="preserve">
          <source>Immutable arguments are effectively passed &amp;ldquo;&lt;strong&gt;by value&lt;/strong&gt;.&amp;rdquo; Objects such as integers and strings are passed by object reference instead of by copying, but because you can&amp;rsquo;t change immutable objects in place anyhow, the effect is much like making a copy.</source>
          <target state="translated">不変の引数は、「 &lt;strong&gt;値によって&lt;/strong&gt; 」効果的に渡さ&lt;strong&gt;れます&lt;/strong&gt; 。 整数や文字列などのオブジェクトは、コピーではなくオブジェクト参照によって渡されますが、不変のオブジェクトをその場で変更することはできないため、効果はコピーを作成するのとよく似ています。</target>
        </trans-unit>
        <trans-unit id="6302f1ff1c0c2b90057d999e0b3858fc9d2a2e08" translate="yes" xml:space="preserve">
          <source>In compiled languages, a variable is a memory space that is able to capture the value of the type. In Python, a variable is a name (captured internally as a string) bound to the reference variable that holds the reference value to the target object. The name of the variable is the key in the internal dictionary, the value part of that dictionary item stores the reference value to the target.</source>
          <target state="translated">コンパイルされた言語では、変数は型の値を取り込むことができるメモリ空間です。Pythonでは、変数は、ターゲットオブジェクトへの参照値を保持する参照変数にバインドされた名前(内部的には文字列としてキャプチャされています)です。変数名は内部辞書のキーであり、その辞書項目の値部分はターゲットへの参照値を格納します。</target>
        </trans-unit>
        <trans-unit id="271a2c315dedadaa6b644002264db432c9330e40" translate="yes" xml:space="preserve">
          <source>In instance methods, you normally refer to &lt;code&gt;self&lt;/code&gt; to access instance attributes. It is normal to set instance attributes in &lt;code&gt;__init__&lt;/code&gt; and read or change them in instance methods. That is also why you pass &lt;code&gt;self&lt;/code&gt; als the first argument to &lt;code&gt;def Change&lt;/code&gt;.</source>
          <target state="translated">インスタンスメソッドでは、通常、インスタンス属性にアクセスするために &lt;code&gt;self&lt;/code&gt; を参照します。 &lt;code&gt;__init__&lt;/code&gt; でインスタンス属性を設定し、インスタンスメソッドでそれらを読み取りまたは変更するのは通常のことです。 それはまた、 &lt;code&gt;self&lt;/code&gt; 最初の引数として &lt;code&gt;def Change&lt;/code&gt; に渡す理由でもあります。</target>
        </trans-unit>
        <trans-unit id="fae6b090cdbf66824da7924b6168f4173a64868f" translate="yes" xml:space="preserve">
          <source>In the code shown in the question, the statement &lt;code&gt;self.Change(self.variable)&lt;/code&gt; binds the name &lt;code&gt;var&lt;/code&gt; (in the scope of function &lt;code&gt;Change&lt;/code&gt;) to the object that holds the value &lt;code&gt;'Original'&lt;/code&gt; and the assignment &lt;code&gt;var = 'Changed'&lt;/code&gt; (in the body of function &lt;code&gt;Change&lt;/code&gt;) assigns that same name again: to some other object (that happens to hold a string as well but could have been something else entirely).</source>
          <target state="translated">質問に示されているコードでは、ステートメント &lt;code&gt;self.Change(self.variable)&lt;/code&gt; は、名前 &lt;code&gt;var&lt;/code&gt; （関数 &lt;code&gt;Change&lt;/code&gt; のスコープ内）を、値 &lt;code&gt;'Original'&lt;/code&gt; および割り当て &lt;code&gt;var = 'Changed'&lt;/code&gt; （in関数の本体 &lt;code&gt;Change&lt;/code&gt; ）は、同じ名前を別のオブジェクトに割り当てます（偶然に文字列を保持しているが、まったく別のオブジェクトであった可能性もあります）。</target>
        </trans-unit>
        <trans-unit id="d174ebf38cb48196530f520173f23f96ee505c2d" translate="yes" xml:space="preserve">
          <source>In this case the variable titled &lt;code&gt;var&lt;/code&gt; in the method &lt;code&gt;Change&lt;/code&gt; is assigned a reference to &lt;code&gt;self.variable&lt;/code&gt;, and you immediately assign a string to &lt;code&gt;var&lt;/code&gt;. It's no longer pointing to &lt;code&gt;self.variable&lt;/code&gt;. The following code snippet shows what would happen if you modify the data structure pointed to by &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;self.variable&lt;/code&gt;, in this case a list:</source>
          <target state="translated">この場合、メソッド &lt;code&gt;Change&lt;/code&gt; で &lt;code&gt;var&lt;/code&gt; という変数に &lt;code&gt;self.variable&lt;/code&gt; への参照が割り当てられ、文字列を &lt;code&gt;var&lt;/code&gt; にすぐに割り当てます。 それはもはや &lt;code&gt;self.variable&lt;/code&gt; を指していません。 次のコードスニペットは、 &lt;code&gt;var&lt;/code&gt; と &lt;code&gt;self.variable&lt;/code&gt; が指すデータ構造、この場合はリストを変更するとどうなるかを示しています。</target>
        </trans-unit>
        <trans-unit id="c93eaa9797f60173290b5121f5aebea5bd45b163" translate="yes" xml:space="preserve">
          <source>In your example, when the &lt;code&gt;Change&lt;/code&gt; method is called--a &lt;a href=&quot;http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces&quot;&gt;namespace&lt;/a&gt; is created for it; and &lt;code&gt;var&lt;/code&gt; becomes a name, within that namespace, for the string object &lt;code&gt;'Original'&lt;/code&gt;. That object then has a name in two namespaces. Next, &lt;code&gt;var = 'Changed'&lt;/code&gt; binds &lt;code&gt;var&lt;/code&gt; to a new string object, and thus the method's namespace forgets about &lt;code&gt;'Original'&lt;/code&gt;. Finally, that namespace is forgotten, and the string &lt;code&gt;'Changed'&lt;/code&gt; along with it.</source>
          <target state="translated">あなたの例では、 &lt;code&gt;Change&lt;/code&gt; メソッドが呼び出されると、 &lt;a href=&quot;http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces&quot;&gt;名前空間&lt;/a&gt;が作成されます。 &lt;code&gt;var&lt;/code&gt; は、その名前空間内で、文字列オブジェクト &lt;code&gt;'Original'&lt;/code&gt; の名前になります。 そのオブジェクトは、2つの名前空間に名前を持ちます。 次に、 &lt;code&gt;var = 'Changed'&lt;/code&gt; は &lt;code&gt;var&lt;/code&gt; を新しい文字列オブジェクトにバインドし、メソッドの名前空間は &lt;code&gt;'Original'&lt;/code&gt; を忘れます。 最後に、その名前空間は忘れられ、文字列 &lt;code&gt;'Changed'&lt;/code&gt; 一緒に忘れられます。</target>
        </trans-unit>
        <trans-unit id="bb33c9ab807f193d39872eed5e22af0127a40637" translate="yes" xml:space="preserve">
          <source>Is there something I can do to pass the variable by actual reference?</source>
          <target state="translated">実際の参照で変数を渡すために何かできることはありますか?</target>
        </trans-unit>
        <trans-unit id="d7e7bdb80421d5ef59aefc489f344f221587bba6" translate="yes" xml:space="preserve">
          <source>It is neither pass-by-value or pass-by-reference - it is call-by-object. See this, by Fredrik Lundh:</source>
          <target state="translated">それは、値ごとに渡すことでも、参照ごとに渡すことでもありません。Fredrik Lundhによるこれを参照してください。</target>
        </trans-unit>
        <trans-unit id="48bb347a9d7faf829dae8ac2ec01719f82c86124" translate="yes" xml:space="preserve">
          <source>It's an ugly hack, but it works. ;-P</source>
          <target state="translated">醜いハックですが、うまくいきます。</target>
        </trans-unit>
        <trans-unit id="c4d93e3229bff3269f3ab05cdf6305855b9bc82f" translate="yes" xml:space="preserve">
          <source>List - a mutable type</source>
          <target state="translated">リスト-変形可能な型</target>
        </trans-unit>
        <trans-unit id="e145738e57fdf9ea90a9bfc63f28785068e9be9d" translate="yes" xml:space="preserve">
          <source>Mutable arguments are effectively passed &amp;ldquo;&lt;strong&gt;by pointer&lt;/strong&gt;.&amp;rdquo; Objects such as lists
and dictionaries are also passed by object reference, which is similar to the way C
passes arrays as pointers&amp;mdash;mutable objects can be changed in place in the function,
much like C arrays.</source>
          <target state="translated">可変引数は「 &lt;strong&gt;ポインタによって&lt;/strong&gt; 」効果的に渡さ&lt;strong&gt;れます&lt;/strong&gt; 。 リストや辞書などのオブジェクトもオブジェクト参照によって渡されます。これは、Cが配列をポインターとして渡す方法と同様です。可変オブジェクトは、C配列と同様に、関数内で変更できます。</target>
        </trans-unit>
        <trans-unit id="ed19ef46a33530a5532cfcd97126ae99cb3242a0" translate="yes" xml:space="preserve">
          <source>Objects are allocated on the heap and pointers to them can be passed around anywhere.</source>
          <target state="translated">オブジェクトはヒープ上に割り当てられ、そのポインタはどこにでも渡すことができます。</target>
        </trans-unit>
        <trans-unit id="87dea7220960a8d9957e82c5e7caf7ae67f5891a" translate="yes" xml:space="preserve">
          <source>Objects like lists are &lt;em&gt;mutable&lt;/em&gt;.  This means that the contents of the object can be changed by anything pointing to the object.  For example, &lt;code&gt;x = []; y = x; x.append(10); print y&lt;/code&gt; will print &lt;code&gt;[10]&lt;/code&gt;.  The empty list was created.  Both &quot;x&quot; and &quot;y&quot; point to the same list.  The &lt;em&gt;append&lt;/em&gt; method mutates (updates) the list object (like adding a record to a database) and the result is visible to both &quot;x&quot; and &quot;y&quot; (just as a database update would be visible to every connection to that database).</source>
          <target state="translated">リストのようなオブジェクトは&lt;em&gt;変更可能&lt;/em&gt;です。 つまり、オブジェクトを指すものは何でもオブジェクトの内容を変更できます。 たとえば、 &lt;code&gt;x = []; y = x; x.append(10); print y&lt;/code&gt; y = x; x.append（10）; print yは &lt;code&gt;[10]&lt;/code&gt; を出力します。 空のリストが作成されました。 「x」と「y」はどちらも同じリストを指します。 &lt;em&gt;append&lt;/em&gt;メソッドは（データベースへのレコードの追加のように）リストオブジェクトを変更（更新）し、その結果は &quot;x&quot;と &quot;y&quot;の両方に表示されます（データベースの更新がそのデータベースへのすべての接続で表示されるように）。</target>
        </trans-unit>
        <trans-unit id="4498e2a33a71723f43491095390bfa7816d3f75b" translate="yes" xml:space="preserve">
          <source>Objects like strings and integers are &lt;em&gt;immutable&lt;/em&gt;.  This simply means that there are no methods that can change the object after it has been created.  For example, once the integer object one-thousand is created, it will never change.  Math is done by creating new integer objects.</source>
          <target state="translated">文字列や整数のようなオブジェクトは&lt;em&gt;不変&lt;/em&gt;です。 これは単に、オブジェクトの作成後にオブジェクトを変更できるメソッドがないことを意味します。 たとえば、整数オブジェクト1000が作成されると、変更されることはありません。 数学は、新しい整数オブジェクトを作成することによって行われます。</target>
        </trans-unit>
        <trans-unit id="27f285ca9e6dbf4bba0bcd6c449903172991d998" translate="yes" xml:space="preserve">
          <source>Obviously the above does not allow &lt;em&gt;reading&lt;/em&gt; the value, only updating it.</source>
          <target state="translated">明らかに、上記は値の&lt;em&gt;読み取りを&lt;/em&gt;許可せず、更新のみを行います。</target>
        </trans-unit>
        <trans-unit id="4751c7c9efc0a91758450a9fee280437f3b71a6f" translate="yes" xml:space="preserve">
          <source>One way is to use &lt;code&gt;global&lt;/code&gt; (for global variables) or &lt;code&gt;nonlocal&lt;/code&gt; (for local variables in a function) in a wrapper function.</source>
          <target state="translated">1つの方法は、ラッパー関数で &lt;code&gt;global&lt;/code&gt; （グローバル変数の場合）または &lt;code&gt;nonlocal&lt;/code&gt; （関数のローカル変数の場合）を使用することです。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="c439d84dc5a961368d9307e0770827dfc4515420" translate="yes" xml:space="preserve">
          <source>Pass-By-Reference in Python is quite different from the concept of pass by reference in C++/Java.</source>
          <target state="translated">PythonのPass-By-Referenceは、C++JavaのPass-By-Referenceの概念とは全く異なります。</target>
        </trans-unit>
        <trans-unit id="68451aca93c616b65cb7c9047a81894d6b972f90" translate="yes" xml:space="preserve">
          <source>Passing 3 wrappers to access a variable is a bit unwieldy so those can be wrapped into a class that has a proxy attribute:</source>
          <target state="translated">変数にアクセスするために3つのラッパーを渡すのは少し扱いづらいので、それらをproxy属性を持つクラスにラップすることができます。</target>
        </trans-unit>
        <trans-unit id="0827e8d71a8fb26dad798d59e58b5d9485ef355e" translate="yes" xml:space="preserve">
          <source>Passing an argument into a function also binds a name (the parameter name of the function) to an object.</source>
          <target state="translated">関数に引数を渡すと、名前(関数のパラメータ名)をオブジェクトにバインドすることもできます。</target>
        </trans-unit>
        <trans-unit id="c8afd49f905bfc9a3cb491f06eb314e73ee2416c" translate="yes" xml:space="preserve">
          <source>Python always uses pass-by-reference values. There isn't any exception. Any variable assignment means copying the reference value. No exception. Any variable is the name bound to the reference value. Always.</source>
          <target state="translated">Pythonは常にパスバイ参照値を使用します。例外はありません。どのような変数の代入も参照値のコピーを意味します。例外はありません。任意の変数は、参照値にバインドされた名前です。常にです。</target>
        </trans-unit>
        <trans-unit id="83861cb7e986e86de426cee8c30f2ed20d4ab7fd" translate="yes" xml:space="preserve">
          <source>Python has names and objects.</source>
          <target state="translated">Pythonには名前とオブジェクトがあります。</target>
        </trans-unit>
        <trans-unit id="5fcbcd2747ab57ca64daa423ac6a3486436e1a62" translate="yes" xml:space="preserve">
          <source>Python&amp;rsquo;s pass-by-assignment scheme isn&amp;rsquo;t quite the same as C++&amp;rsquo;s reference parameters option, but it turns out to be very similar to the argument-passing model of the C language (and others) in practice:</source>
          <target state="translated">Pythonの代入渡しスキームは、C ++の参照パラメーターオプションとまったく同じではありませんが、実際にはC言語（およびその他）の引数渡しモデルと非常によく似ています。</target>
        </trans-unit>
        <trans-unit id="333f7d50ad7e0d3ef1d2d6e716803037e8f19596" translate="yes" xml:space="preserve">
          <source>Pythons &quot;reflection&quot; support makes it possible to get a object that is capable of reassigning a name/variable in a given scope without defining functions explicitly in that scope:</source>
          <target state="translated">Pythons の &quot;reflection&quot; サポートにより、スコープ内で明示的に関数を定義することなく、与えられたスコープ内の名前変数を再割り当てできるオブジェクトを取得することが可能になります。</target>
        </trans-unit>
        <trans-unit id="afbaddd3494c975f3248038d165efdcb7b42b91c" translate="yes" xml:space="preserve">
          <source>Reference values are hidden in Python. There isn't any explicit user type for storing the reference value. However, you can use a list element (or element in any other suitable container type) as the reference variable, because all containers do store the elements also as references to the target objects. In other words, elements are actually not contained inside the container -- only the references to elements are.</source>
          <target state="translated">参照値はPythonでは隠されています。参照値を格納するための明示的なユーザ型はありません。しかし、すべてのコンテナはターゲットオブジェクトへの参照として要素を格納するので、リスト要素(または他の適切なコンテナ型の要素)を参照変数として使用することができます。言い換えれば、要素は実際にはコンテナ内には含まれていません --要素への参照のみが含まれています。</target>
        </trans-unit>
        <trans-unit id="a16b36f9b22c19ae3e20f844261f568427971e02" translate="yes" xml:space="preserve">
          <source>See sections &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;3.1&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#naming-and-binding&quot;&gt;4.2&lt;/a&gt; in the Python 3 language reference.</source>
          <target state="translated">Python 3言語リファレンスのセクション&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#objects-values-and-types&quot;&gt;3.1&lt;/a&gt;と&lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#naming-and-binding&quot;&gt;4.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="660da67960cf04fb1e0d059bd7853b4c03efc993" translate="yes" xml:space="preserve">
          <source>Since dictionaries are passed by reference, you can use a dict variable to store any referenced values inside it.</source>
          <target state="translated">辞書は参照によって渡されるので、dict変数を使用して、参照された値をその中に格納することができます。</target>
        </trans-unit>
        <trans-unit id="68d4a137bc67d697b621b97d6185016cdb4789cb" translate="yes" xml:space="preserve">
          <source>Since immutable types cannot be modified, they &lt;em&gt;seem&lt;/em&gt; like being passed by value - passing an int into a function means assigning the int to the function's parameter. You can only ever reassign that, but it won't change the original variables value.</source>
          <target state="translated">不変タイプは変更できないため、値によって渡さ&lt;em&gt;れる&lt;/em&gt;ように&lt;em&gt;見え&lt;/em&gt;ます。intを関数に渡すことは、intを関数のパラメーターに割り当てることを意味します。 再割り当てのみが可能ですが、元の変数値は変更されません。</target>
        </trans-unit>
        <trans-unit id="696917aad2c2b30ef73b056904aa4dea2ce6c676" translate="yes" xml:space="preserve">
          <source>Since it seems to be nowhere mentioned an approach to simulate references as known from e.g. C++ is to use an &quot;update&quot; function and pass that instead of the actual variable (or rather, &quot;name&quot;):</source>
          <target state="translated">どこにも言及されていないようなので、C++などで知られている参照をシミュレートするアプローチは、&quot;update &quot;関数を使用して、実際の変数(というよりは &quot;名前&quot;)の代わりにそれを渡すことです。</target>
        </trans-unit>
        <trans-unit id="5d727a1d706032a86c18b0a92e1ed2ead4954513" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;the_list&lt;/code&gt; parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The &lt;code&gt;the_list&lt;/code&gt; was a copy of the &lt;code&gt;outer_list&lt;/code&gt; reference, and we had &lt;code&gt;the_list&lt;/code&gt; point to a new list, but there was no way to change where &lt;code&gt;outer_list&lt;/code&gt; pointed.</source>
          <target state="translated">&lt;code&gt;the_list&lt;/code&gt; パラメータは値で渡されたため、新しいリストを割り当てても、メソッドの外部のコードが見ることができませんでした。 &lt;code&gt;the_list&lt;/code&gt; は &lt;code&gt;outer_list&lt;/code&gt; 参照のコピーであり、 the_listが新しいリストを指すようにしましたが、 &lt;code&gt;outer_list&lt;/code&gt; が指す場所を変更する方法がありませんでした 。</target>
        </trans-unit>
        <trans-unit id="36f7beed038b24998576a94eef27bf913f6ed625" translate="yes" xml:space="preserve">
          <source>Since the parameter passed in is a reference to &lt;code&gt;outer_list&lt;/code&gt;, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.</source>
          <target state="translated">渡されたパラメーターはそのコピーではなく &lt;code&gt;outer_list&lt;/code&gt; への参照であるため、変更リストメソッドを使用してパラメーターを変更し、変更を外部スコープに反映させることができます。</target>
        </trans-unit>
        <trans-unit id="e6e9cfc9cdfcbeabab6f908af34edaef10d1407d" translate="yes" xml:space="preserve">
          <source>Since your example happens to be object-oriented, you could make the following change to achieve a similar result:</source>
          <target state="translated">あなたの例はオブジェクト指向なので、次のように変更して同様の結果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="c8af5c8a28c9b058781cfa18faaa84372e62a5df" translate="yes" xml:space="preserve">
          <source>So if the thing you want to change is a mutable object, there is no problem, as everything is effectively passed by reference.</source>
          <target state="translated">そのため、変更したいものが変更可能なオブジェクトであれば、すべてが実質的に参照で渡されるので問題はありません。</target>
        </trans-unit>
        <trans-unit id="bf807aabb75019d89aff61af1c01d7c2a1d18f4d" translate="yes" xml:space="preserve">
          <source>So, when passing a list to a function/method, the list is assigned to the parameter name. Appending to the list will result in the list being modified. Reassigning the list &lt;em&gt;inside&lt;/em&gt; the function will not change the original list, since:</source>
          <target state="translated">したがって、リストを関数/メソッドに渡すとき、リストはパラメーター名に割り当てられます。 リストに追加すると、リストが変更されます。 関数&lt;em&gt;内で&lt;/em&gt;リスト&lt;em&gt;を&lt;/em&gt;再割り当てしても、元のリストは変更されません。</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="d7a557055e4e02657c23b68f42103ada3c99dabb" translate="yes" xml:space="preserve">
          <source>String - an immutable type</source>
          <target state="translated">String-不変型</target>
        </trans-unit>
        <trans-unit id="7c1fdc94b36a2d1a36919d71bce545b535714140" translate="yes" xml:space="preserve">
          <source>Technically, &lt;strong&gt;Python always uses pass by reference values&lt;/strong&gt;. I am going to repeat &lt;a href=&quot;https://stackoverflow.com/a/12438316/1346705&quot;&gt;my other answer&lt;/a&gt; to support my statement.</source>
          <target state="translated">技術的には、 &lt;strong&gt;Pythonは常に参照渡しの値を使用します&lt;/strong&gt; 。 私の発言を裏付けるために、 &lt;a href=&quot;https://stackoverflow.com/a/12438316/1346705&quot;&gt;他の答え&lt;/a&gt;を繰り返します。</target>
        </trans-unit>
        <trans-unit id="79c2b7cf71267d7a5e78f89f251fffbff74bb65a" translate="yes" xml:space="preserve">
          <source>That is all there is to it. Mutability is irrelevant for this question.</source>
          <target state="translated">それが全てです。変異性はこの質問には無関係だ</target>
        </trans-unit>
        <trans-unit id="17becfeedaa8893ff84a47a35ec6e3e49715fa72" translate="yes" xml:space="preserve">
          <source>The Python documentation seems unclear about whether parameters are passed by reference or value, and the following code produces the unchanged value 'Original'</source>
          <target state="translated">Python のドキュメントでは、パラメータが参照で渡されるのか値で渡されるのかが不明瞭なようで、以下のコードでは変更されない値 'Original' を生成しています。</target>
        </trans-unit>
        <trans-unit id="f2fff69c21168bf26f5b1e057e178f0b3f2e5e7c" translate="yes" xml:space="preserve">
          <source>The actual object - [0, 1] (which would be called a value in other programming languages) is being passed. So in fact the function &lt;code&gt;change_me&lt;/code&gt; will try to do something like:</source>
          <target state="translated">実際のオブジェクト-[0、1]（他のプログラミング言語では値と呼ばれる）が渡されています。 したがって、実際には関数 &lt;code&gt;change_me&lt;/code&gt; は次のようなことを試みます。</target>
        </trans-unit>
        <trans-unit id="a681daed3a2466279708eadd396f12d4619acbc1" translate="yes" xml:space="preserve">
          <source>The assignment to an global variable that is not declared global therefore creates a new local object and breaks the link to the original object.</source>
          <target state="translated">グローバル宣言されていないグローバル変数への代入は、新しいローカルオブジェクトを作成し、元のオブジェクトへのリンクを解除します。</target>
        </trans-unit>
        <trans-unit id="dcf126983674f03f5b7e37d5d854435177547ce6" translate="yes" xml:space="preserve">
          <source>The basic idea is to have a function that can do that access and can be passed as object into other functions or stored in a class.</source>
          <target state="translated">基本的な考え方としては、そのアクセスを行うことができる関数を持ち、オブジェクトとして他の関数に渡したり、クラスに格納したりすることができます。</target>
        </trans-unit>
        <trans-unit id="0bc22d9160e54688c508487d4bc0a30f0fedfd8c" translate="yes" xml:space="preserve">
          <source>The key to understanding parameter passing is to stop thinking about &quot;variables&quot;. There are names and objects in Python and together they
appear like variables, but it is useful to always distinguish the three.</source>
          <target state="translated">パラメータパッシングを理解する上で重要なのは、「変数」を考えるのをやめることです。Pythonには名前とオブジェクトがあり、それらを一緒にすると変数のように見えますが、この3つを常に区別しておくと便利です。</target>
        </trans-unit>
        <trans-unit id="4ab82925dc8dd0f7cb7b601b15859baf0d62bc4d" translate="yes" xml:space="preserve">
          <source>The more &lt;a href=&quot;https://www.python.org/dev/peps/pep-0020/&quot;&gt;pythonic&lt;/a&gt; approach would be to introduce a trivial, one-attribute class. The function receives an instance of the class and manipulates the attribute.</source>
          <target state="translated">より&lt;a href=&quot;https://www.python.org/dev/peps/pep-0020/&quot;&gt;パイソン&lt;/a&gt;的なアプローチは、ささいな1属性クラスを導入することです。 関数はクラスのインスタンスを受け取り、属性を操作します。</target>
        </trans-unit>
        <trans-unit id="cc1762bcf99fc58408f1a9ef7986e8348ee28a58" translate="yes" xml:space="preserve">
          <source>The only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places.</source>
          <target state="translated">これを回避する唯一の方法は、変更可能なオブジェクトを渡すことです。両方の参照が同じオブジェクトを参照しているので、オブジェクトへの変更は両方の場所に反映されます。</target>
        </trans-unit>
        <trans-unit id="6fad76f326204f89d7ac6ac50ce5db14000add4d" translate="yes" xml:space="preserve">
          <source>The problem comes from a misunderstanding of what variables are in Python. If you're used to most traditional languages, you have a mental model of what happens in the following sequence:</source>
          <target state="translated">この問題は、Pythonにおける変数とは何かという誤解から来ています。ほとんどの伝統的な言語に慣れている人は、次のような順序で何が起こるかのメンタルモデルを持っています。</target>
        </trans-unit>
        <trans-unit id="84175dec5b4dc806baa482e3939f43855a2e8b04" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty solution for this is a one-element list (instead of &lt;code&gt;self.variable&lt;/code&gt;, pass &lt;code&gt;[self.variable]&lt;/code&gt; and in the function modify &lt;code&gt;var[0]&lt;/code&gt;).</source>
          <target state="translated">このための迅速で汚い解決策は、1要素のリストです（ &lt;code&gt;self.variable&lt;/code&gt; の代わりに、 &lt;code&gt;[self.variable]&lt;/code&gt; を渡し、関数で &lt;code&gt;var[0]&lt;/code&gt; 変更します ）。</target>
        </trans-unit>
        <trans-unit id="13c1347e705ce1693fe7d2b8e953c905989ca4b8" translate="yes" xml:space="preserve">
          <source>The same idea works for reading and &lt;code&gt;del&lt;/code&gt;eting a variable.</source>
          <target state="translated">同じ考え方が変数の読み取りと削除にも有効です。</target>
        </trans-unit>
        <trans-unit id="5db310989aa7591454c760958f2af239e823a8c7" translate="yes" xml:space="preserve">
          <source>Then the call would result in:</source>
          <target state="translated">そうすると、その呼び出しは結果的に</target>
        </trans-unit>
        <trans-unit id="0105c63c552b46ed256ace297e33009660aef599" translate="yes" xml:space="preserve">
          <source>There are no variables in Python</source>
          <target state="translated">Pythonには変数がありません</target>
        </trans-unit>
        <trans-unit id="086a535eed287fb2a8da5e4f2b4da1059486d637" translate="yes" xml:space="preserve">
          <source>There is a little trick to pass an object by reference, even though the language doesn't make it possible. It works in Java too, it's the list with one item. ;-)</source>
          <target state="translated">言語がそれを可能にしていなくても、参照でオブジェクトを渡すにはちょっとしたコツがあります。Javaでも動作します、1つの項目を持つリストです。)</target>
        </trans-unit>
        <trans-unit id="b1c21ed6d2eec901faa433fdaff0e199b04f81af" translate="yes" xml:space="preserve">
          <source>Think of stuff being passed &lt;strong&gt;by assignment&lt;/strong&gt; instead of by reference/by value. That way, it is always clear, what is happening as long as you understand what happens during the normal assignment.</source>
          <target state="translated">参照渡しや値渡しで&lt;strong&gt;は&lt;/strong&gt;なく、 &lt;strong&gt;代入&lt;/strong&gt;渡し&lt;strong&gt;される&lt;/strong&gt;ものを考えてください。 そうすれば、通常の割り当て中に何が起こるかを理解している限り、何が起こっているかが常に明確になります。</target>
        </trans-unit>
        <trans-unit id="c5a5244ffa8b4f4ae77f3d588812cda61fa6be3d" translate="yes" xml:space="preserve">
          <source>This binds the name &lt;code&gt;a&lt;/code&gt; to an object of type integer that holds the value 1.</source>
          <target state="translated">これは、名前 &lt;code&gt;a&lt;/code&gt; を、値1を保持する整数型のオブジェクトにバインドします。</target>
        </trans-unit>
        <trans-unit id="884b42766d553e6f4cff2ad92ade45f883bf6559" translate="yes" xml:space="preserve">
          <source>This binds the name &lt;code&gt;b&lt;/code&gt; to the same object that the name &lt;code&gt;x&lt;/code&gt; is currently bound to.
Afterwards, the name &lt;code&gt;b&lt;/code&gt; has nothing to do with the name &lt;code&gt;x&lt;/code&gt; any more.</source>
          <target state="translated">これにより、名前 &lt;code&gt;b&lt;/code&gt; が名前 &lt;code&gt;x&lt;/code&gt; が現在バインドされているオブジェクトと同じオブジェクトにバインドされます。 その後、名前 &lt;code&gt;b&lt;/code&gt; は名前 &lt;code&gt;x&lt;/code&gt; とは無関係になります。</target>
        </trans-unit>
        <trans-unit id="3a0da37fa36be60c0aa098be25fccdb7e017ac1b" translate="yes" xml:space="preserve">
          <source>This is mostly useful for &quot;out-only references&quot; or in a situation with multiple threads / processes (by making the update function thread / multiprocessing safe).</source>
          <target state="translated">これは、&quot;アウトオンリーの参照 &quot;や、複数のスレッドプロセスが存在する状況で(更新関数のスレッドの多重処理を安全にすることで)ほとんどの場合に便利です。</target>
        </trans-unit>
        <trans-unit id="2f1f28564cc17f4b95f8008ecbf300883f70aebb" translate="yes" xml:space="preserve">
          <source>To make it even more clear, let's have some examples.</source>
          <target state="translated">さらにわかりやすくするために、いくつか例を挙げてみましょう。</target>
        </trans-unit>
        <trans-unit id="5623b8a007cec828bd71b838af98d8c9977c1510" translate="yes" xml:space="preserve">
          <source>To the extent that Python is pass by value, all languages are pass by value since some piece of data (be it a &quot;value&quot; or a &quot;reference&quot;) must be sent. However, that does not mean that Python is pass by value in the sense that a C programmer would think of it.</source>
          <target state="translated">Pythonがpass by valueである限り、すべての言語はpass by valueであり、何らかのデータ(&quot;値 &quot;であれ &quot;参照 &quot;であれ)を送信しなければなりません。しかし、C言語のプログラマが考えるような意味では、Pythonはパス・バイ・バリューではありません。</target>
        </trans-unit>
        <trans-unit id="20555a4a440b0601df4fa798a89247c553a96ccf" translate="yes" xml:space="preserve">
          <source>When you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there's no way to update that reference and make it refer to a new object. In your example:</source>
          <target state="translated">パラメータを指定して関数を呼び出すと、渡されたオブジェクトを参照する新しい参照が作成されます。これは、関数呼び出しで使用された参照とは別のものなので、その参照を更新して新しいオブジェクトを参照させる方法はありません。あなたの例では</target>
        </trans-unit>
        <trans-unit id="bc3fa5ea94b2efd9143d2934a64ae051133be6ed" translate="yes" xml:space="preserve">
          <source>When you do a new assignment such as &lt;code&gt;y = x&lt;/code&gt;, a new dictionary entry &quot;y&quot; is created that points to the same object as the entry for &quot;x&quot;.</source>
          <target state="translated">&lt;code&gt;y = x&lt;/code&gt; などの新しい割り当てを行うと、「x」のエントリと同じオブジェクトを指す新しい辞書エントリ「y」が作成されます。</target>
        </trans-unit>
        <trans-unit id="a8ec35d9c1b72807f2ded385deffa6f8aa373d72" translate="yes" xml:space="preserve">
          <source>When you make an assignment such as &lt;code&gt;x = 1000&lt;/code&gt;, a dictionary entry is created that maps the string &quot;x&quot; in the current namespace to a pointer to the integer object containing one thousand.</source>
          <target state="translated">&lt;code&gt;x = 1000&lt;/code&gt; などの割り当てを行うと、現在のネームスペースの文字列 &quot;x&quot;を、1,000を含む整数オブジェクトへのポインタにマップする辞書エントリが作成されます。</target>
        </trans-unit>
        <trans-unit id="e648dd9f3d5b78507aba8fd21719ec93fe30b1ca" translate="yes" xml:space="preserve">
          <source>When you update &quot;x&quot; with &lt;code&gt;x = 2000&lt;/code&gt;, a new integer object is created and the dictionary is updated to point at the new object.  The old one thousand object is unchanged (and may or may not be alive depending on whether anything else refers to the object).</source>
          <target state="translated">「x」を &lt;code&gt;x = 2000&lt;/code&gt; で更新すると、新しい整数オブジェクトが作成され、新しいオブジェクトを指すようにディクショナリが更新されます。 古い千のオブジェクトは変更されていません（オブジェクトが他に参照されているかどうかによって、生存しているかどうかは不明です）。</target>
        </trans-unit>
        <trans-unit id="13eb328770b9c46bbd56e2839f367e0a7b3f96db" translate="yes" xml:space="preserve">
          <source>Whenever you pass an object to the function, the object itself is passed (object in Python is actually what you'd call a value in other programming languages) not the reference to this object. In other words, when you call:</source>
          <target state="translated">オブジェクトを関数に渡すときは、オブジェクト自体が渡されます(Pythonではオブジェクトは他のプログラミング言語では値と呼ばれています)が、このオブジェクトへの参照は渡されません。つまり、呼び出したときに</target>
        </trans-unit>
        <trans-unit id="6b4cb23677b917c5c42bbdb41b1590df3465a4db" translate="yes" xml:space="preserve">
          <source>While pass by reference is nothing that fits well into python and should be rarely used there are some workarounds that actually can work to get the object currently assigned to a local variable or even reassign a local variable from inside of a called function.</source>
          <target state="translated">参照によるパスバイレファレンスは、Pythonには馴染まないもので、ほとんど使われることはありませんが、現在ローカル変数に代入されているオブジェクトを取得したり、呼び出された関数の内部からローカル変数を再代入したりすることができる回避策がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="06ef8c07f183597c6357e8005336de31d41ec30c" translate="yes" xml:space="preserve">
          <source>You believe that &lt;code&gt;a&lt;/code&gt; is a memory location that stores the value &lt;code&gt;1&lt;/code&gt;, then is updated to store the value &lt;code&gt;2&lt;/code&gt;. That's not how things work in Python. Rather, &lt;code&gt;a&lt;/code&gt; starts as a reference to an object with the value &lt;code&gt;1&lt;/code&gt;, then gets reassigned as a reference to an object with the value &lt;code&gt;2&lt;/code&gt;. Those two objects may continue to coexist even though &lt;code&gt;a&lt;/code&gt; doesn't refer to the first one anymore; in fact they may be shared by any number of other references within the program.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; は値 &lt;code&gt;1&lt;/code&gt; を格納するメモリ位置であり、値 &lt;code&gt;2&lt;/code&gt; を格納するように更新されると考えています。 これはPythonでの動作方法ではありません。 むしろ、 &lt;code&gt;a&lt;/code&gt; は値 &lt;code&gt;1&lt;/code&gt; のオブジェクトへの参照として始まり、次に値 &lt;code&gt;2&lt;/code&gt; のオブジェクトへの参照として再割り当てされます。 &lt;code&gt;a&lt;/code&gt; が最初のオブジェクトを参照しなくなっても、これらの2つのオブジェクトは共存し続ける場合があります。 実際、それらはプログラム内の他の参照でいくつでも共有できます。</target>
        </trans-unit>
        <trans-unit id="6cbe72d4aff2f1d3e9fb3501cd97383b70fd44e7" translate="yes" xml:space="preserve">
          <source>You can merely use &lt;strong&gt;an empty class&lt;/strong&gt; as an instance to store reference objects because internally object attributes are stored in an instance dictionary. See the example.</source>
          <target state="translated">内部的にオブジェクト属性はインスタンスディクショナリに格納されているため、参照オブジェクトを格納するためのインスタンスとして&lt;strong&gt;空のクラス&lt;/strong&gt;を使用&lt;strong&gt;する&lt;/strong&gt;だけで済みます。 例を参照してください。</target>
        </trans-unit>
        <trans-unit id="9e395b0bd4b1dc1eea4d49d8e1f40c5347e0d5a1" translate="yes" xml:space="preserve">
          <source>You can think about a reference value as the address of the target object. The address is automatically dereferenced when used. This way, working with the reference value, it seems you work directly with the target object. But there always is a reference in between, one step more to jump to the target.</source>
          <target state="translated">参照値は、ターゲットオブジェクトのアドレスと考えることができます。アドレスは、使用されると自動的に参照が解除されます。このように、参照値を使って作業すると、ターゲットオブジェクトを直接操作しているように見えます。しかし、その間には必ず参照があり、ターゲットにジャンプするためにはもう一歩踏み込んでいます。</target>
        </trans-unit>
        <trans-unit id="233857d84270d4d4cf81d2ab105c0ebb1d786176" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://docs.python.org/3.3/library/functions.html#id&quot;&gt;&lt;code&gt;id()&lt;/code&gt;&lt;/a&gt; built-in function to learn what the reference value is (that is, the address of the target object).</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/3.3/library/functions.html#id&quot;&gt; &lt;code&gt;id()&lt;/code&gt; &lt;/a&gt;組み込み関数を使用して、参照値が何であるか（つまり、ターゲットオブジェクトのアドレス）を知ることができます。</target>
        </trans-unit>
        <trans-unit id="fee26813eb63428556d25e99b697066a5abee304" translate="yes" xml:space="preserve">
          <source>You got some really good answers here.</source>
          <target state="translated">本当に良い答えが出てきましたね。</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="ac2c0095bbd1e16c2e3606675ef16ab060af766f" translate="yes" xml:space="preserve">
          <source>given the way python handles values and references to them, the only way you can reference an arbitrary instance attribute is by name:</source>
          <target state="translated">pythonが値とその参照を扱う方法を考えると、任意のインスタンス属性を参照できるのは名前だけです。</target>
        </trans-unit>
        <trans-unit id="5dcfdd557133c0be7c75544c8a554ac3a7ddef6a" translate="yes" xml:space="preserve">
          <source>gives:</source>
          <target state="translated">gives:</target>
        </trans-unit>
        <trans-unit id="31cef82f841f61f64a2b51817dadd21b57e78be6" translate="yes" xml:space="preserve">
          <source>in real code you would, of course, add error checking on the dict lookup.</source>
          <target state="translated">実際のコードでは、もちろんdictのルックアップにエラーチェックを追加します。</target>
        </trans-unit>
        <trans-unit id="1d8a6a9487c9bd9e3711fa2119286c096444a2f6" translate="yes" xml:space="preserve">
          <source>some data types are mutable, but others aren't</source>
          <target state="translated">変異可能なデータ型もあれば、そうでないデータ型もあります。</target>
        </trans-unit>
        <trans-unit id="5f0f7656c197d2526aa255c56c1295fe45b9916d" translate="yes" xml:space="preserve">
          <source>the parameter passed in is actually a &lt;em&gt;reference&lt;/em&gt; to an object (but the reference is passed by value)</source>
          <target state="translated">渡されたパラメータは実際にはオブジェクトへの参照です（ただし、参照は値で渡されます）</target>
        </trans-unit>
        <trans-unit id="9789798d32b8f1cb1ca7e4b37e5b087b68d91f3c" translate="yes" xml:space="preserve">
          <source>which obviously will change the object. &lt;a href=&quot;https://stackoverflow.com/a/534509/831531&quot;&gt;This answer&lt;/a&gt; explains it well.</source>
          <target state="translated">これは明らかにオブジェクトを変更します。 &lt;a href=&quot;https://stackoverflow.com/a/534509/831531&quot;&gt;この答え&lt;/a&gt;はそれをよく説明しています。</target>
        </trans-unit>
        <trans-unit id="0a5dcf0aaba3d474366727f90d67aa1948bf146f" translate="yes" xml:space="preserve">
          <source>which obviously will not change the object passed to the function. If the function looked like this:</source>
          <target state="translated">これは明らかに関数に渡されたオブジェクトを変更することはありません。関数が次のように見えたとします。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
