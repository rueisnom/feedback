<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/98650">
    <body>
      <group id="98650">
        <trans-unit id="8bc9a3751448b75c95d0c09be39874a54d59dbbc" translate="yes" xml:space="preserve">
          <source>&quot;Strict aliasing is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias each other.)&quot;</source>
          <target state="translated">&quot;El alias estricto es una suposición,hecha por el compilador C (o C++),de que los punteros de referencia a objetos de diferentes tipos nunca se referirán a la misma ubicación de memoria (es decir,se alias entre sí)&quot;.</target>
        </trans-unit>
        <trans-unit id="7cf3442516aaa5d6749824461a7def10a1b8f03a" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a character type.</source>
          <target state="translated">- un tipo de personaje.</target>
        </trans-unit>
        <trans-unit id="16d9cec79491cede88fd0ddafcbdb33b1a1dc888" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a qualified version of a type compatible with the effective type of the object,</source>
          <target state="translated">- una versi&amp;oacute;n calificada de un tipo compatible con el tipo efectivo del objeto,</target>
        </trans-unit>
        <trans-unit id="13d94646e2432e838a724c25f7870cb8f332c869" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,</source>
          <target state="translated">- un tipo que es el tipo con signo o sin signo correspondiente a una versi&amp;oacute;n calificada del tipo efectivo del objeto,</target>
        </trans-unit>
        <trans-unit id="4b87e5428fe7d01a75c7838ed5347266005ed316" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to the effective type of the object,</source>
          <target state="translated">- un tipo que es el tipo con signo o sin signo correspondiente al tipo efectivo del objeto,</target>
        </trans-unit>
        <trans-unit id="62996c58c76d88b909b477d85de32e4c8a0be22f" translate="yes" xml:space="preserve">
          <source>&amp;mdash; an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or</source>
          <target state="translated">- un tipo agregado o de uni&amp;oacute;n que incluye uno de los tipos antes mencionados entre sus miembros (incluido, recursivamente, un miembro de una uni&amp;oacute;n agregada o contenida), o</target>
        </trans-unit>
        <trans-unit id="7682f0746a360de4bef474dee1888984c6d26a7c" translate="yes" xml:space="preserve">
          <source>(11.2) &amp;mdash; a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">(11.2) - una versi&amp;oacute;n calificada por cv del tipo din&amp;aacute;mico del objeto,</target>
        </trans-unit>
        <trans-unit id="2b7ebc143440433f6bcf7a57744dbff09cce4f85" translate="yes" xml:space="preserve">
          <source>(11.3) &amp;mdash; a type similar (as defined in 7.5) to the dynamic type of the object,</source>
          <target state="translated">(11.3) - un tipo similar (como se define en 7.5) al tipo din&amp;aacute;mico del objeto,</target>
        </trans-unit>
        <trans-unit id="492220375e27ebfd7903993e017101c0d85ec3e0" translate="yes" xml:space="preserve">
          <source>(11.4) &amp;mdash; a type that is the signed or unsigned type corresponding to the dynamic type of the object,</source>
          <target state="translated">(11.4) - un tipo que es el tipo con signo o sin signo correspondiente al tipo din&amp;aacute;mico del objeto,</target>
        </trans-unit>
        <trans-unit id="2d718b5cc47d538f62e075e1c68512349385137b" translate="yes" xml:space="preserve">
          <source>(11.5) &amp;mdash; a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">(11.5) - un tipo que es el tipo con signo o sin signo correspondiente a una versi&amp;oacute;n calificada por cv del tipo din&amp;aacute;mico del objeto,</target>
        </trans-unit>
        <trans-unit id="9dc6ec3bc2c4acd3e7938a177187de9946d3fbac" translate="yes" xml:space="preserve">
          <source>(11.6) &amp;mdash; an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</source>
          <target state="translated">(11.6) - un tipo de agregado o uni&amp;oacute;n que incluye uno de los tipos antes mencionados entre sus elementos o miembros de datos no est&amp;aacute;ticos (incluido, recursivamente, un elemento o miembro de datos no est&amp;aacute;tico de un subaggregado o uni&amp;oacute;n contenida),</target>
        </trans-unit>
        <trans-unit id="0833cab4a3d7c43325017982c60dd1a9524db49f" translate="yes" xml:space="preserve">
          <source>(11.7) &amp;mdash; a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</source>
          <target state="translated">(11.7) - un tipo que es un tipo de clase base (posiblemente calificado por cv) del tipo din&amp;aacute;mico del objeto,</target>
        </trans-unit>
        <trans-unit id="007312b7d7fe81dfd0e93a7cbbe02ace56aa2f12" translate="yes" xml:space="preserve">
          <source>(11.8) &amp;mdash; a char, unsigned char, or std::byte type.</source>
          <target state="translated">(11.8): un tipo char, unsigned char o std :: byte.</target>
        </trans-unit>
        <trans-unit id="a6ae166834f7950f65a4a0e2017c5da76406a59c" translate="yes" xml:space="preserve">
          <source>(GCC appears somewhat inconsistent in its ability to give aliasing warnings, sometimes giving us a friendly warning and sometimes not.)</source>
          <target state="translated">(El GCC parece algo inconsistente en su capacidad de dar advertencias de alias,a veces dándonos una advertencia amistosa y a veces no).</target>
        </trans-unit>
        <trans-unit id="dbb9367a16f124a22e627722082fe38579194d80" translate="yes" xml:space="preserve">
          <source>(save from CPU register to the memory and load from the memory to the CPU register).</source>
          <target state="translated">(guardar desde el registro de la CPU a la memoria y cargar desde la memoria al registro de la CPU).</target>
        </trans-unit>
        <trans-unit id="9cc95d274f988057b458e8bbc62596b0bfd62e5a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;This article&lt;/a&gt; should help you understand the issue in full detail.</source>
          <target state="translated">&lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;Este art&amp;iacute;culo&lt;/a&gt; deber&amp;iacute;a ayudarlo a comprender el problema con todo detalle.</target>
        </trans-unit>
        <trans-unit id="db4e37199ce7a26e530372127092a913fd8e827e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_punning&quot;&gt;Type punning&lt;/a&gt; via pointer casts (as opposed to using a union) is a major example of breaking strict aliasing.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_punning&quot;&gt;La escritura de tipos&lt;/a&gt; mediante el uso de punteros (en lugar de utilizar una uni&amp;oacute;n) es un ejemplo importante de ruptura de alias estricto.</target>
        </trans-unit>
        <trans-unit id="0f648f766517c522d736c21acf06a661385f3de0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://twitter.com/shafikyaghmour/status/957702383810658304&quot;&gt;gcc/clang has an extension&lt;/a&gt; and &lt;a href=&quot;https://gcc.gnu.org/ml/gcc/2003-10/msg00184.html&quot;&gt;also&lt;/a&gt; that allows assigning &lt;em&gt;unsigned int*&lt;/em&gt; to &lt;em&gt;int*&lt;/em&gt; even though they are not compatible types.</source>
          <target state="translated">&lt;a href=&quot;https://twitter.com/shafikyaghmour/status/957702383810658304&quot;&gt;gcc / clang tiene una extensi&amp;oacute;n&lt;/a&gt; y &lt;a href=&quot;https://gcc.gnu.org/ml/gcc/2003-10/msg00184.html&quot;&gt;tambi&amp;eacute;n&lt;/a&gt; que permite asignar &lt;em&gt;int * sin firmar&lt;/em&gt; a &lt;em&gt;int *&lt;/em&gt; aunque no sean tipos compatibles.</target>
        </trans-unit>
        <trans-unit id="01b0f2dd13e6673c4bc6a8d017a4466b2eae23b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;a type similar (as defined in 4.4) to the dynamic type of the object,&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;un tipo similar (como se define en 4.4) al tipo din&amp;aacute;mico del objeto,&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57fbd0f13eb9b51fcea11056b2017576feba86c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Beginner beware&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Principiante ten cuidado&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="196bcd48f2a7e66de892eaf11cbe2d9cab7cc750" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11&lt;/strong&gt; and &lt;strong&gt;C++14&lt;/strong&gt; wording (changes emphasized):</source>
          <target state="translated">&lt;strong&gt;Texto de C ++ 11&lt;/strong&gt; y &lt;strong&gt;C ++ 14&lt;/strong&gt; (cambios enfatizados):</target>
        </trans-unit>
        <trans-unit id="f83c36172e98a9c03aa145ce635aa0f76fe4904e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For example&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Por ejemplo&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="decc5376f183538b5fe7739f22bb8eb4f49596b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So how do I get around this?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Entonces, &amp;iquest;c&amp;oacute;mo puedo evitar esto?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d25be7fbd9e3672275a9ff1b70188a72553da35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;save&lt;/strong&gt;&lt;code&gt;b&lt;/code&gt; and &lt;strong&gt;reload&lt;/strong&gt;&lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;guardar&lt;/strong&gt; &lt;code&gt;b&lt;/code&gt; y &lt;strong&gt;recargar&lt;/strong&gt; &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b61bc9f66e53d7bd6c6cb170cf39fc609c4079f3" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt; 73) or 88)&lt;/sup&gt; The intent of this list is to specify those circumstances in which an object may or may not be aliased.</source>
          <target state="translated">&lt;sup&gt;73) u 88)&lt;/sup&gt; La intenci&amp;oacute;n de esta lista es especificar aquellas circunstancias en las que un objeto puede tener o no un alias.</target>
        </trans-unit>
        <trans-unit id="e6cbeecf47c0b79acdf7d07e84cc9b5e6b8e569d" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt; The types that C 2011 6.5 7 allows an lvalue to access are:</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; Los tipos a los que C 2011 6.5 7 le permite acceder a un valor son:</target>
        </trans-unit>
        <trans-unit id="297342af50ab471e2b4d57de560278e8dd7b88e6" translate="yes" xml:space="preserve">
          <source>A glvalue is an expression whose evaluation determines the identity of
  an object, (...snip)</source>
          <target state="translated">Un glvalue es una expresión cuya evaluación determina la identidad de un objeto,(...snip)</target>
        </trans-unit>
        <trans-unit id="8e98f088bc239e2fa9b5abf6318d366712f8212b" translate="yes" xml:space="preserve">
          <source>A typical situation you encounter strict aliasing problems is when overlaying a struct (like a device/network msg) onto a buffer of the word size of your system (like a pointer to &lt;code&gt;uint32_t&lt;/code&gt;s or &lt;code&gt;uint16_t&lt;/code&gt;s). When you overlay a struct onto such a buffer, or a buffer onto such a struct through pointer casting you can easily violate strict aliasing rules.</source>
          <target state="translated">Una situaci&amp;oacute;n t&amp;iacute;pica en la que se encuentran problemas de alias estrictos es cuando se superpone una estructura (como un mensaje de dispositivo / red) en un b&amp;uacute;fer del tama&amp;ntilde;o de palabra de su sistema (como un puntero a &lt;code&gt;uint32_t&lt;/code&gt; &lt;code&gt;uint16_t&lt;/code&gt; s). Cuando superpone una estructura en dicho b&amp;uacute;fer, o un b&amp;uacute;fer en dicha estructura a trav&amp;eacute;s de la conversi&amp;oacute;n del puntero, puede violar f&amp;aacute;cilmente las estrictas reglas de alias.</target>
        </trans-unit>
        <trans-unit id="a9dc4be413dae8efeb97923c710712f4df67ca23" translate="yes" xml:space="preserve">
          <source>According to the C89 rationale, the authors of the Standard did not want to require that compilers given code like:</source>
          <target state="translated">Según el razonamiento del C89,los autores de la Norma no quisieron exigir que los compiladores dieran código como:</target>
        </trans-unit>
        <trans-unit id="a1e350b0f7d46240fa54c7300839cc8197daad50" translate="yes" xml:space="preserve">
          <source>After reading many of the answers, I feel the need to add something:</source>
          <target state="translated">Después de leer muchas de las respuestas,siento la necesidad de añadir algo:</target>
        </trans-unit>
        <trans-unit id="6ef0f09f189d7f527f3216249c8e7b8d66de7464" translate="yes" xml:space="preserve">
          <source>Also from &lt;a href=&quot;http://eel.is/c++draft/basic.lval#1.1&quot;&gt;the definition of glvalue&lt;/a&gt;</source>
          <target state="translated">Tambi&amp;eacute;n de &lt;a href=&quot;http://eel.is/c++draft/basic.lval#1.1&quot;&gt;la definici&amp;oacute;n de glvalue&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f9a518e55a06337a7d067a77249a742f4d1724e" translate="yes" xml:space="preserve">
          <source>Also the &lt;strong&gt;C&lt;/strong&gt; wording (C99; ISO/IEC 9899:1999 6.5/7; the exact same wording is used in ISO/IEC 9899:2011 &amp;sect;6.5 &amp;para;7):</source>
          <target state="translated">Tambi&amp;eacute;n la redacci&amp;oacute;n &lt;strong&gt;C&lt;/strong&gt; (C99; ISO / IEC 9899: 1999 6.5 / 7; exactamente la misma redacci&amp;oacute;n se utiliza en ISO / IEC 9899: 2011 &amp;sect;6.5 &amp;para;7):</target>
        </trans-unit>
        <trans-unit id="2985fc30fb7352cc194dd6d4058223c195eec0a4" translate="yes" xml:space="preserve">
          <source>Although clang allows these flags it apparently does not actually implement the warnings.</source>
          <target state="translated">Aunque el clang permite estas banderas,aparentemente no implementa las advertencias.</target>
        </trans-unit>
        <trans-unit id="26a14dfaa9199838addf36131d31232c359747d1" translate="yes" xml:space="preserve">
          <source>An object shall have its stored value accessed only by an lvalue
  expression that has one of the following types &lt;sup&gt; 73) or 88)&lt;/sup&gt;:</source>
          <target state="translated">Un objeto almacenado tendr&amp;aacute; acceso a su valor almacenado solo mediante una expresi&amp;oacute;n lvalue que tenga uno de los siguientes tipos &lt;sup&gt;73) u 88)&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="e89f2c7845b5b0b9f99fb0df9e776bf697055362" translate="yes" xml:space="preserve">
          <source>An object shall have its stored value accessed only by an lvalue expression that has one of the following types:&lt;sup&gt;88)&lt;/sup&gt;
  &amp;mdash; a type compatible with the effective type of the object,</source>
          <target state="translated">Un objeto tendr&amp;aacute; acceso a su valor almacenado solo mediante una expresi&amp;oacute;n lvalue que tenga uno de los siguientes tipos: &lt;sup&gt;88)&lt;/sup&gt; - un tipo compatible con el tipo efectivo del objeto,</target>
        </trans-unit>
        <trans-unit id="8d09e17c7fa91deb529a7711698d487fd214027c" translate="yes" xml:space="preserve">
          <source>And rewrote our earlier loop to take advantage of this convenient function</source>
          <target state="translated">Y reescribimos nuestro bucle anterior para aprovechar esta conveniente función</target>
        </trans-unit>
        <trans-unit id="0f5d219e3940c12eb3895d8e75d8bb99c681600b" translate="yes" xml:space="preserve">
          <source>Another tool we have available to us is ASan which can catch misaligned loads and stores. Although these are not directly strict aliasing violations they are a common result of strict aliasing violations. For example the following cases will generate runtime errors when built with clang using &lt;strong&gt;-fsanitize=address&lt;/strong&gt;</source>
          <target state="translated">Otra herramienta que tenemos disponible para nosotros es ASan, que puede detectar cargas y tiendas desalineadas. Aunque estas no son violaciones de alias estrictamente directas, son un resultado com&amp;uacute;n de violaciones de alias estrictas. Por ejemplo, los siguientes casos generar&amp;aacute;n errores de tiempo de ejecuci&amp;oacute;n cuando se crean con clang usando &lt;strong&gt;-fsanitize = address&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c9f941d78e7fc8fb359e7fb4d08c3662e735d087" translate="yes" xml:space="preserve">
          <source>As addendum to what Doug T. already wrote, here
is a simple test case which probably triggers it with gcc :</source>
          <target state="translated">Como adición a lo que Doug T.ya escribió,aquí hay un simple caso de prueba que probablemente lo desencadene con gcc :</target>
        </trans-unit>
        <trans-unit id="10728f2d66e27dcf628afc3fd6a3a60abc38f514" translate="yes" xml:space="preserve">
          <source>As we have seen earlier this is not a valid aliasing, so we are invoking undefined behavior. But traditionally compilers did not take advantage of strict aliasing rules and this type of code usually just worked, developers have unfortunately gotten used to doing things this way. A common alternate method for type punning is through unions, which is valid in C but &lt;em&gt;undefined behavior&lt;/em&gt; in C++ (&lt;a href=&quot;https://wandbox.org/permlink/oOf9bPlcWDYrYqPF&quot;&gt;see live example&lt;/a&gt;):</source>
          <target state="translated">Como hemos visto anteriormente, este no es un alias v&amp;aacute;lido, por lo que estamos invocando un comportamiento indefinido. Pero tradicionalmente los compiladores no aprovechaban las estrictas reglas de alias y este tipo de c&amp;oacute;digo generalmente funcionaba, desafortunadamente los desarrolladores se han acostumbrado a hacer las cosas de esta manera. Un m&amp;eacute;todo alternativo com&amp;uacute;n para el tipo de punteo es a trav&amp;eacute;s de uniones, que es v&amp;aacute;lido en C pero &lt;em&gt;comportamiento indefinido&lt;/em&gt; en C ++ ( &lt;a href=&quot;https://wandbox.org/permlink/oOf9bPlcWDYrYqPF&quot;&gt;ver ejemplo en vivo&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="31703841448c40ed3e7edbb4a235ea2f940df90f" translate="yes" xml:space="preserve">
          <source>At a sufficient optimization level any decent modern compiler generates identical code to the previously mentioned &lt;strong&gt;reinterpret_cast&lt;/strong&gt; method or &lt;em&gt;union&lt;/em&gt; method for &lt;em&gt;type punning&lt;/em&gt;. Examining the generated code we see it uses just register mov (&lt;a href=&quot;https://godbolt.org/g/BfZGwX&quot;&gt;live Compiler Explorer Example&lt;/a&gt;).</source>
          <target state="translated">A un nivel de optimizaci&amp;oacute;n suficiente, cualquier compilador moderno decente genera un c&amp;oacute;digo id&amp;eacute;ntico al m&amp;eacute;todo &lt;strong&gt;reinterpret_cast&lt;/strong&gt; mencionado anteriormente o al m&amp;eacute;todo de &lt;em&gt;uni&amp;oacute;n&lt;/em&gt; para el &lt;em&gt;punteo de tipos&lt;/em&gt; . Examinando el c&amp;oacute;digo generado, vemos que usa solo registrar mov ( &lt;a href=&quot;https://godbolt.org/g/BfZGwX&quot;&gt;ejemplo de Live Compiler Explorer&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6b40922067f3852129b802e5ea9ad27f2b9e841c" translate="yes" xml:space="preserve">
          <source>C++20 and bit_cast</source>
          <target state="translated">C++20 y bit_cast</target>
        </trans-unit>
        <trans-unit id="d0218f26139d8420689d4b0863aae73b36ebb0d3" translate="yes" xml:space="preserve">
          <source>Catching Strict Aliasing Violations</source>
          <target state="translated">Capturar las violaciones estrictas de los alias</target>
        </trans-unit>
        <trans-unit id="1770c1d3a13b57ff8c334a5bc651892e9928636f" translate="yes" xml:space="preserve">
          <source>Compile with &lt;code&gt;gcc -O2 -o check check.c&lt;/code&gt; .
Usually (with most gcc versions I tried) this outputs &quot;strict aliasing problem&quot;, because the compiler assumes that &quot;h&quot; cannot be the same address as &quot;k&quot; in the &quot;check&quot; function. Because of that the compiler optimizes the &lt;code&gt;if (*h == 5)&lt;/code&gt; away and always calls the printf.</source>
          <target state="translated">Compile con &lt;code&gt;gcc -O2 -o check check.c&lt;/code&gt; . Por lo general (con la mayor&amp;iacute;a de las versiones de gcc que prob&amp;eacute;) esto genera un &quot;problema de alias estricto&quot;, porque el compilador supone que &quot;h&quot; no puede ser la misma direcci&amp;oacute;n que &quot;k&quot; en la funci&amp;oacute;n &quot;verificar&quot;. Por eso, el compilador optimiza el &lt;code&gt;if (*h == 5)&lt;/code&gt; y siempre llama a printf.</target>
        </trans-unit>
        <trans-unit id="53c22f9842dfbbfd7ce868f16027320909192af5" translate="yes" xml:space="preserve">
          <source>Defect Report #28 states that the program invokes Undefined Behavior because the action of writing a union member of type &quot;double&quot; and reading one of type &quot;int&quot; invokes Implementation-Defined behavior.  Such reasoning is nonsensical, but forms the basis for the Effective Type rules which needlessly complicate the language while doing nothing to address the original problem.</source>
          <target state="translated">El Informe de Defectos #28 establece que el programa invoca el Comportamiento No Definido porque la acción de escribir a un miembro del sindicato de tipo &quot;doble&quot; y leer uno de tipo &quot;int&quot; invoca el Comportamiento Definido por la Implementación.Tal razonamiento no tiene sentido,pero forma la base de las reglas del Tipo Efectivo que complican innecesariamente el lenguaje sin hacer nada para resolver el problema original.</target>
        </trans-unit>
        <trans-unit id="7470e0123159d8ce20fb052f5950c0742dcfc961" translate="yes" xml:space="preserve">
          <source>Finally there is &lt;a href=&quot;https://www.youtube.com/watch?v=vAXJeN7k32Y&quot;&gt;TySan&lt;/a&gt; which is currently in development. This sanitizer adds type checking information in a shadow memory segment and checks accesses to see if they violate aliasing rules. The tool potentially should be able to catch all aliasing violations but may have a large run-time overhead.</source>
          <target state="translated">Finalmente est&amp;aacute; &lt;a href=&quot;https://www.youtube.com/watch?v=vAXJeN7k32Y&quot;&gt;TySan,&lt;/a&gt; que actualmente est&amp;aacute; en desarrollo. Este desinfectante agrega informaci&amp;oacute;n de verificaci&amp;oacute;n de tipo en un segmento de memoria secundaria y verifica los accesos para ver si violan las reglas de alias. La herramienta deber&amp;iacute;a poder detectar todas las infracciones de alias, pero puede tener una gran sobrecarga de tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="40e31a210a1913fd0a8b28b892780996d154c70d" translate="yes" xml:space="preserve">
          <source>Footnote</source>
          <target state="translated">Footnote</target>
        </trans-unit>
        <trans-unit id="f2e444e508c3340837f99f92afb5d8d282d725cc" translate="yes" xml:space="preserve">
          <source>For C we have all the tools already covered and we also have tis-interpreter, a static analyzer that exhaustively analyzes a program for a large subset of the C language. Given a C verions of the  earlier example where using &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; misses one case (&lt;a href=&quot;https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY&quot;&gt;see it live&lt;/a&gt;)</source>
          <target state="translated">Para C tenemos todas las herramientas ya cubiertas y tambi&amp;eacute;n tenemos tis-interpreter, un analizador est&amp;aacute;tico que analiza exhaustivamente un programa para un gran subconjunto del lenguaje C. Dada una versi&amp;oacute;n en C del ejemplo anterior donde el uso de &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; pierde un caso ( &lt;a href=&quot;https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY&quot;&gt;verlo en vivo&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="9ead309bf16c2a5aba6251f6671c48b68c88f5ee" translate="yes" xml:space="preserve">
          <source>For those who are interested here is the x64 assembler code, produced by gcc 4.6.3, running on ubuntu 12.04.2 for x64:</source>
          <target state="translated">Para los interesados aquí está el código ensamblador de x64,producido por gcc 4.6.3,corriendo en ubuntu 12.04.2 para x64:</target>
        </trans-unit>
        <trans-unit id="eef7c5809b1e5a8ae1c2904d803bf0988e0597e2" translate="yes" xml:space="preserve">
          <source>From the article:</source>
          <target state="translated">Del artículo:</target>
        </trans-unit>
        <trans-unit id="c9937d5f217a938cee9523df51e9f8f215d05426" translate="yes" xml:space="preserve">
          <source>Had Defect Report 028 said the original example invoked UB because of the overlap between the creation and use of the two pointers, that would have made things a lot more clear without having to add &quot;Effective Types&quot; or other such complexity.</source>
          <target state="translated">Si el Informe de Defectos 028 hubiera dicho que el ejemplo original invocaba el LU debido a la superposición entre la creación y el uso de los dos punteros,eso habría aclarado mucho más las cosas sin tener que añadir &quot;Tipos efectivos&quot; u otra complejidad de ese tipo.</target>
        </trans-unit>
        <trans-unit id="cacd74e6fcf654b36a1d1e2975d8c5a7ad506007" translate="yes" xml:space="preserve">
          <source>Here, there is an aliasing conflict between &lt;code&gt;p&lt;/code&gt; and the access to &lt;code&gt;s.x&lt;/code&gt; on the marked line because at that point in execution another reference exists &lt;em&gt;that will be used to access the same storage&lt;/em&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, existe un conflicto de alias entre &lt;code&gt;p&lt;/code&gt; y el acceso a &lt;code&gt;s.x&lt;/code&gt; en la l&amp;iacute;nea marcada porque en ese punto de ejecuci&amp;oacute;n existe otra referencia &lt;em&gt;que se utilizar&amp;aacute; para acceder al mismo almacenamiento&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="33dc7f4dd2ec6bc77310a0b059a423d8f65352d8" translate="yes" xml:space="preserve">
          <source>How do we Type Pun correctly?</source>
          <target state="translated">¿Cómo escribimos correctamente el juego de palabras?</target>
        </trans-unit>
        <trans-unit id="4e0983c0e8fab722fa11f33077148a6fa369c40d" translate="yes" xml:space="preserve">
          <source>If a compiler notices that two pointers point to different types (for example, an &lt;code&gt;int *&lt;/code&gt; and a &lt;code&gt;float *&lt;/code&gt;), it will assume the memory address is different and it &lt;strong&gt;will not&lt;/strong&gt; protect against memory address collisions, resulting in faster machine code.</source>
          <target state="translated">Si un compilador nota que dos punteros apuntan a diferentes tipos (por ejemplo, un &lt;code&gt;int *&lt;/code&gt; y un &lt;code&gt;float *&lt;/code&gt; ), asumir&amp;aacute; que la direcci&amp;oacute;n de memoria es diferente y &lt;strong&gt;no&lt;/strong&gt; proteger&amp;aacute; contra colisiones de direcciones de memoria, lo que resulta en un c&amp;oacute;digo de m&amp;aacute;quina m&amp;aacute;s r&amp;aacute;pido.</target>
        </trans-unit>
        <trans-unit id="e33bcaeae41be78c102c11d9ce6bff1ab9700bea" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through a &lt;em&gt;glvalue&lt;/em&gt; of other than one of the following types the behavior is undefined:</source>
          <target state="translated">Si un programa intenta acceder al valor almacenado de un objeto a trav&amp;eacute;s de un valor &lt;em&gt;gl&lt;/em&gt; diferente de uno de los siguientes tipos, el comportamiento no est&amp;aacute; definido:</target>
        </trans-unit>
        <trans-unit id="a1ad9d68fd05386372885ebe000df27028379d8d" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:&lt;sup&gt;63&lt;/sup&gt;
  (11.1) &amp;mdash; the dynamic type of the object,</source>
          <target state="translated">Si un programa intenta acceder al valor almacenado de un objeto a trav&amp;eacute;s de un valor gl distinto de uno de los siguientes tipos, el comportamiento no est&amp;aacute; definido: &lt;sup&gt;63&lt;/sup&gt; (11.1): el tipo din&amp;aacute;mico del objeto,</target>
        </trans-unit>
        <trans-unit id="186894b2031b450693c2e08ce7146e1a9f218d92" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined:</source>
          <target state="translated">Si un programa intenta acceder al valor almacenado de un objeto a través de un valor l distinto de uno de los siguientes tipos,el comportamiento es indefinido:</target>
        </trans-unit>
        <trans-unit id="c58ff6992c8aa3747c4710bda431e84ee2b32d03" translate="yes" xml:space="preserve">
          <source>If data in two different CPU registers will be written to the same memory space, &lt;strong&gt;we can't predict which data will &quot;survive&quot;&lt;/strong&gt; when we code in C.</source>
          <target state="translated">Si los datos en dos registros de CPU diferentes se escribir&amp;aacute;n en el mismo espacio de memoria, &lt;strong&gt;no podemos predecir qu&amp;eacute; datos &quot;sobrevivir&amp;aacute;n&quot;&lt;/strong&gt; cuando codifiquemos en C.</target>
        </trans-unit>
        <trans-unit id="7a0013265978c8a291d1a659ebe89febc56bb358" translate="yes" xml:space="preserve">
          <source>If the code were changed slightly...</source>
          <target state="translated">Si el código se cambiara ligeramente...</target>
        </trans-unit>
        <trans-unit id="0b4c6074b02b2e16ccba9dd1023db8c912e4726d" translate="yes" xml:space="preserve">
          <source>In C and C++ aliasing has to do with what expression types we are allowed to access stored values through. In both C and C++ the standard specifies which expression types are allowed to alias which types. The compiler and optimizer are allowed to assume we follow the aliasing rules strictly, hence the term &lt;em&gt;strict aliasing rule&lt;/em&gt;. If we attempt to access a value using a type not allowed it is classified as &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/ub&quot;&gt;undefined behavior&lt;/a&gt;(&lt;strong&gt;UB&lt;/strong&gt;). Once we have undefined behavior all bets are off, the results of our program are no longer reliable.</source>
          <target state="translated">En C y C ++, el alias tiene que ver con qu&amp;eacute; tipos de expresi&amp;oacute;n se nos permite acceder a los valores almacenados. Tanto en C como en C ++, el est&amp;aacute;ndar especifica qu&amp;eacute; tipos de expresi&amp;oacute;n est&amp;aacute;n autorizados a alias qu&amp;eacute; tipos. El compilador y el optimizador pueden asumir que seguimos estrictamente las reglas de alias, de ah&amp;iacute; el t&amp;eacute;rmino &lt;em&gt;regla de alias estricto&lt;/em&gt; . Si intentamos acceder a un valor utilizando un tipo no permitido, se clasifica como &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/ub&quot;&gt;comportamiento indefinido&lt;/a&gt; ( &lt;strong&gt;UB&lt;/strong&gt; ). Una vez que tenemos un comportamiento indefinido, todas las apuestas se cancelan, los resultados de nuestro programa ya no son confiables.</target>
        </trans-unit>
        <trans-unit id="5c8e94cbd15bdd54a4fb204f2d1514b6f794ce32" translate="yes" xml:space="preserve">
          <source>In C++20 we may gain &lt;strong&gt;bit_cast&lt;/strong&gt; (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html&quot;&gt;implementation available in link from proposal&lt;/a&gt;) which gives a simple and safe way to type-pun as well as being usable in a constexpr context.</source>
          <target state="translated">En C ++ 20 podemos obtener &lt;strong&gt;bit_cast&lt;/strong&gt; ( &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html&quot;&gt;implementaci&amp;oacute;n disponible en el enlace de la propuesta&lt;/a&gt; ) que brinda una forma simple y segura de escribir juegos de palabras, adem&amp;aacute;s de ser utilizable en un contexto constexpr.</target>
        </trans-unit>
        <trans-unit id="30d64c522aac604d7e48c4556b8d77b5be2eeb6e" translate="yes" xml:space="preserve">
          <source>In assembly, where we code the loading and unloading of CPU registers manually, we will know which data remains intact. But C (thankfully) abstracts this detail away.</source>
          <target state="translated">En el ensamblaje,donde codificamos la carga y descarga de los registros de la CPU manualmente,sabremos qué datos permanecen intactos.Pero C (afortunadamente)abstrae este detalle.</target>
        </trans-unit>
        <trans-unit id="1098f88dd457b5be2f2059df57bcf4338d706f24" translate="yes" xml:space="preserve">
          <source>In fact, by adding the &lt;code&gt;restrict&lt;/code&gt; keyword, the whole function could be optimized to:</source>
          <target state="translated">De hecho, al agregar la palabra clave &lt;code&gt;restrict&lt;/code&gt; , toda la funci&amp;oacute;n podr&amp;iacute;a optimizarse para:</target>
        </trans-unit>
        <trans-unit id="f5757f1784e296249565c7c4929c37f6183ec27c" translate="yes" xml:space="preserve">
          <source>In order to handle the case in which &lt;code&gt;a == b&lt;/code&gt; (both pointers point to the same memory), we need to order and test the way we load data from the memory to the CPU registers, so the code might end up like this:</source>
          <target state="translated">Para manejar el caso en el que &lt;code&gt;a == b&lt;/code&gt; (ambos punteros apuntan a la misma memoria), necesitamos ordenar y probar la forma en que cargamos datos de la memoria a los registros de la CPU, por lo que el c&amp;oacute;digo podr&amp;iacute;a terminar as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="edbd3b6b40a8cde551f4ffba070d64d6c6313a52" translate="yes" xml:space="preserve">
          <source>In the case where &lt;em&gt;To&lt;/em&gt; and &lt;em&gt;From&lt;/em&gt; types don't have the same size, it requires us to use an intermediate struct15. We will use a struct containing a &lt;strong&gt;sizeof( unsigned int )&lt;/strong&gt; character array (&lt;em&gt;assumes 4 byte unsigned int&lt;/em&gt;) to be the &lt;em&gt;From&lt;/em&gt; type and &lt;em&gt;unsigned int&lt;/em&gt; as the &lt;em&gt;To&lt;/em&gt; type.:</source>
          <target state="translated">En el caso de que los tipos &lt;em&gt;To&lt;/em&gt; y &lt;em&gt;From&lt;/em&gt; no tengan el mismo tama&amp;ntilde;o, requiere que usemos una estructura intermedia15. Usaremos una estructura que contenga una matriz de caracteres &lt;strong&gt;sizeof (unsigned int)&lt;/strong&gt; (se &lt;em&gt;supone que 4 bytes unsigned int&lt;/em&gt; ) es el tipo &lt;em&gt;From&lt;/em&gt; y &lt;em&gt;unsigned int&lt;/em&gt; como el tipo &lt;em&gt;To .&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="d116eeee6f567bfeb6ee6948778e1441846b7681" translate="yes" xml:space="preserve">
          <source>In the function &lt;strong&gt;foo&lt;/strong&gt; we take an &lt;em&gt;int*&lt;/em&gt; and a &lt;em&gt;float*&lt;/em&gt;, in this example we call &lt;strong&gt;foo&lt;/strong&gt; and set both parameters to point to the same memory location which in this example contains an &lt;em&gt;int&lt;/em&gt;. Note, the &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; is telling the compiler to treat the the expression as if it had the type specificed by its template parameter. In this case we are telling it to treat the expression &lt;strong&gt;&amp;amp;x&lt;/strong&gt; as if it had type &lt;em&gt;float*&lt;/em&gt;. We may naively expect the result of the second &lt;strong&gt;cout&lt;/strong&gt; to be &lt;strong&gt;0&lt;/strong&gt; but with optimization enabled using &lt;strong&gt;-O2&lt;/strong&gt; both gcc and clang produce the following result:</source>
          <target state="translated">En la funci&amp;oacute;n &lt;strong&gt;foo&lt;/strong&gt; tomamos un &lt;em&gt;int *&lt;/em&gt; y un &lt;em&gt;float *&lt;/em&gt; , en este ejemplo llamamos a &lt;strong&gt;foo&lt;/strong&gt; y configuramos ambos par&amp;aacute;metros para que apunten a la misma ubicaci&amp;oacute;n de memoria que en este ejemplo contiene un &lt;em&gt;int&lt;/em&gt; . Tenga en cuenta que &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; le dice al compilador que trate la expresi&amp;oacute;n como si tuviera el tipo especificado por su par&amp;aacute;metro de plantilla. En este caso, le estamos diciendo que trate la expresi&amp;oacute;n &lt;strong&gt;&amp;amp; x&lt;/strong&gt; como si tuviera el tipo &lt;em&gt;float *&lt;/em&gt; . Podemos esperar ingenuamente que el resultado del segundo &lt;strong&gt;cout&lt;/strong&gt; sea &lt;strong&gt;0&lt;/strong&gt; pero con la optimizaci&amp;oacute;n habilitada usando &lt;strong&gt;-O2,&lt;/strong&gt; tanto gcc como clang producen el siguiente resultado:</target>
        </trans-unit>
        <trans-unit id="d68abdd18fdbebaf82ef26f4a744ddcd23eee685" translate="yes" xml:space="preserve">
          <source>It is unfortunate that we need this intermediate type but that is the current constraint of &lt;strong&gt;bit_cast&lt;/strong&gt;.</source>
          <target state="translated">Es lamentable que necesitemos este tipo intermedio, pero esa es la restricci&amp;oacute;n actual de &lt;strong&gt;bit_cast&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="da92ddda51dcc47ff0f56cb81c8d27a13de9b35f" translate="yes" xml:space="preserve">
          <source>Keep in mind, if you think the example is contrived, this might even happen if you're passing a buffer to another function doing the sending for you, if instead you have.</source>
          <target state="translated">Ten en cuenta que si crees que el ejemplo es artificioso,esto puede ocurrir incluso si pasas un búfer a otra función que haga el envío por ti,si en cambio lo has hecho.</target>
        </trans-unit>
        <trans-unit id="aa2a2cd3b185c908c2467f71930ddb0e035406e3" translate="yes" xml:space="preserve">
          <source>Let's look at some examples, then we can talk about exactly what the standard(s) say, examine some further examples and then see how to avoid strict aliasing and catch violations we missed. Here is an example that should not be surprising (&lt;a href=&quot;https://wandbox.org/permlink/7sCJTAyrifZ0zfFA&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">Veamos algunos ejemplos, luego podemos hablar sobre exactamente lo que dicen los est&amp;aacute;ndares, examinar algunos ejemplos adicionales y luego ver c&amp;oacute;mo evitar el alias estricto y detectar las violaciones que pasamos por alto. Aqu&amp;iacute; hay un ejemplo que no deber&amp;iacute;a sorprender ( &lt;a href=&quot;https://wandbox.org/permlink/7sCJTAyrifZ0zfFA&quot;&gt;ejemplo en vivo&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="036ae8cbf7c3814fcac323366fb44ffbfacfa142" translate="yes" xml:space="preserve">
          <source>Lets assume the following function:</source>
          <target state="translated">Asumamos la siguiente función:</target>
        </trans-unit>
        <trans-unit id="6866b7efbb6193426e6184afeb038e84825105d8" translate="yes" xml:space="preserve">
          <source>Memory access can be expensive (performance wise), which is why &lt;strong&gt;data is manipulated in CPU registers&lt;/strong&gt; before being written back to the physical memory.</source>
          <target state="translated">El acceso a la memoria puede ser costoso (en cuanto al rendimiento), por lo que los &lt;strong&gt;datos se manipulan en los registros de la CPU&lt;/strong&gt; antes de volver a escribirse en la memoria f&amp;iacute;sica.</target>
        </trans-unit>
        <trans-unit id="9992043f68467a20f1d79f1ccb74a9265be5e20c" translate="yes" xml:space="preserve">
          <source>Much of the problem is a result of Defect Report #028, which asked about the behavior of a program like:</source>
          <target state="translated">Gran parte del problema es el resultado del Informe de Defectos #028,que preguntaba sobre el comportamiento de un programa como:</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="5650248b0b69558ceb303fc582535c5dbae34409" translate="yes" xml:space="preserve">
          <source>Note the definition of indirection (&lt;a href=&quot;http://eel.is/c++draft/expr.unary.op#def:indirection&quot;&gt;* operator&lt;/a&gt;):</source>
          <target state="translated">Tenga en cuenta la definici&amp;oacute;n de indirecci&amp;oacute;n ( &lt;a href=&quot;http://eel.is/c++draft/expr.unary.op#def:indirection&quot;&gt;* operador&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="00e406f7a5b6352740c9e91b4d2959a865ade69d" translate="yes" xml:space="preserve">
          <source>Now, by satisfying the Strict Aliasing rule, step 3 can be avoided and the code will run significantly faster.</source>
          <target state="translated">Ahora,satisfaciendo la regla de Alias Estricto,el paso 3 puede ser evitado y el código correrá significativamente más rápido.</target>
        </trans-unit>
        <trans-unit id="24f4a3365263f6701ca3e6f9cc300671fef25d11" translate="yes" xml:space="preserve">
          <source>Now, to the Rule-Book</source>
          <target state="translated">Ahora,al libro de reglas</target>
        </trans-unit>
        <trans-unit id="00f2110e4b85aedc83fe7286d38033b5fadad084" translate="yes" xml:space="preserve">
          <source>Preliminary examples</source>
          <target state="translated">Ejemplos preliminares</target>
        </trans-unit>
        <trans-unit id="1a68967890ea62e6416814f2cd9ae705194f7f5a" translate="yes" xml:space="preserve">
          <source>Since two pointers can point to the same location in the memory, this could result in &lt;strong&gt;complex code that handles possible collisions&lt;/strong&gt;.</source>
          <target state="translated">Dado que dos punteros pueden apuntar a la misma ubicaci&amp;oacute;n en la memoria, esto podr&amp;iacute;a resultar en &lt;strong&gt;un c&amp;oacute;digo complejo que maneja posibles colisiones&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e831ce62bacf79dafcd6bc9e83656cfee8fb782d" translate="yes" xml:space="preserve">
          <source>So basically if you have an &lt;code&gt;int*&lt;/code&gt; pointing to some memory containing an &lt;code&gt;int&lt;/code&gt; and then you point a &lt;code&gt;float*&lt;/code&gt; to that memory and use it as a &lt;code&gt;float&lt;/code&gt; you break the rule. If your code does not respect this, then the compiler's optimizer will most likely break your code.</source>
          <target state="translated">B&amp;aacute;sicamente, si tiene un &lt;code&gt;int*&lt;/code&gt; que apunta a alguna memoria que contiene un &lt;code&gt;int&lt;/code&gt; y luego se&amp;ntilde;ala un &lt;code&gt;float*&lt;/code&gt; a esa memoria y lo usa como &lt;code&gt;float&lt;/code&gt; , infringe la regla. Si su c&amp;oacute;digo no respeta esto, entonces el optimizador del compilador probablemente romper&amp;aacute; su c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="e527630d421fb5eeeebbd1a1fc94426badbe336a" translate="yes" xml:space="preserve">
          <source>So in any well defined program trace, a glvalue refers to an object. &lt;strong&gt;So the so called strict aliasing rule doesn't apply, ever.&lt;/strong&gt; This may not be what the designers wanted.</source>
          <target state="translated">Entonces, en cualquier rastreo de programa bien definido, un valor de gl se refiere a un objeto. &lt;strong&gt;Por lo tanto, la llamada regla de alias estricto no se aplica, nunca.&lt;/strong&gt; Esto puede no ser lo que los dise&amp;ntilde;adores quer&amp;iacute;an.</target>
        </trans-unit>
        <trans-unit id="deed8318c0841e594ef317b02788fe411e71c755" translate="yes" xml:space="preserve">
          <source>So in this kind of setup, if I want to send a message to something I'd have to have two incompatible pointers pointing to the same chunk of memory. I might then naively code something like this (on a system with &lt;code&gt;sizeof(int) == 2&lt;/code&gt;):</source>
          <target state="translated">Entonces, en este tipo de configuraci&amp;oacute;n, si quiero enviar un mensaje a algo, tendr&amp;iacute;a que tener dos punteros incompatibles apuntando a la misma porci&amp;oacute;n de memoria. Entonces podr&amp;iacute;a codificar ingenuamente algo como esto (en un sistema con &lt;code&gt;sizeof(int) == 2&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="aafc604e71041d21e6cb4b116236a68fac502d6a" translate="yes" xml:space="preserve">
          <source>So the if condition is completely gone from the assembler code.</source>
          <target state="translated">Así que la condición &quot;si&quot; ha desaparecido completamente del código del ensamblador.</target>
        </trans-unit>
        <trans-unit id="be497017b70114a5fa54de0086695c60b70ce08f" translate="yes" xml:space="preserve">
          <source>Sometimes we want to circumvent the type system and interpret an object as a different type. This is called &lt;em&gt;type punning&lt;/em&gt;, to reinterpret a segment of memory as another type. &lt;em&gt;Type punning&lt;/em&gt; is useful for tasks that want access to the underlying representation of an object to view, transport or manipulate. Typical areas we find type punning being used are compilers, serialization, networking code, etc&amp;hellip;</source>
          <target state="translated">A veces queremos eludir el sistema de tipos e interpretar un objeto como un tipo diferente. Esto se denomina &lt;em&gt;punteo de tipo&lt;/em&gt; , para reinterpretar un segmento de memoria como otro tipo. &lt;em&gt;La escritura de tipos&lt;/em&gt; es &amp;uacute;til para tareas que desean acceder a la representaci&amp;oacute;n subyacente de un objeto para ver, transportar o manipular. Las &amp;aacute;reas t&amp;iacute;picas que encontramos que se utilizan son los compiladores, la serializaci&amp;oacute;n, el c&amp;oacute;digo de red, etc.</target>
        </trans-unit>
        <trans-unit id="0e41cb1a9e14feeabe231350d4a98b43b5438b1e" translate="yes" xml:space="preserve">
          <source>Step 3 is very slow because it needs to access the physical memory. However, it's required to protect against instances where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; point to the same memory address.</source>
          <target state="translated">El paso 3 es muy lento porque necesita acceder a la memoria f&amp;iacute;sica. Sin embargo, se requiere para proteger contra instancias donde &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; apuntan a la misma direcci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="6950bbb2a5fc815374e2b4c9fe07f848dcde484e" translate="yes" xml:space="preserve">
          <source>Strict aliasing (which I'll describe in a bit) &lt;strong&gt;is important because&lt;/strong&gt;:</source>
          <target state="translated">El alias estricto (que describir&amp;eacute; en un momento) &lt;strong&gt;es importante porque&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="7b097276866172c8f0649d49560868d6d4cb3def" translate="yes" xml:space="preserve">
          <source>Strict aliasing doesn't refer only to pointers, it affects references as well, I wrote a paper about it for the boost developer wiki and it was so well received that I turned it into a page on my consulting web site.  It explains completely what it is, why it confuses people so much and what to do about it. &lt;a href=&quot;http://dbp-consulting.com/tutorials/StrictAliasing.html&quot;&gt;Strict Aliasing White Paper&lt;/a&gt;.  In particular it explains why unions are risky behavior for C++, and why using memcpy is the only fix portable across both C and C++.  Hope this is helpful.</source>
          <target state="translated">El alias estricto no se refiere solo a los punteros, sino que tambi&amp;eacute;n afecta a las referencias, escrib&amp;iacute; un art&amp;iacute;culo al respecto para la wiki de desarrollador de impulso y fue tan bien recibido que lo convert&amp;iacute; en una p&amp;aacute;gina en mi sitio web de consultor&amp;iacute;a. Explica completamente qu&amp;eacute; es, por qu&amp;eacute; confunde tanto a las personas y qu&amp;eacute; hacer al respecto. &lt;a href=&quot;http://dbp-consulting.com/tutorials/StrictAliasing.html&quot;&gt;Libro blanco de alias estricto&lt;/a&gt; . En particular, explica por qu&amp;eacute; las uniones son un comportamiento arriesgado para C ++ y por qu&amp;eacute; usar memcpy es la &amp;uacute;nica soluci&amp;oacute;n port&amp;aacute;til en C y C ++. Espero que esto sea &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="ed51e87442d0b7d44562385cb2eaa5830e3da786" translate="yes" xml:space="preserve">
          <source>Strict aliasing is not allowing different pointer types to the same data.</source>
          <target state="translated">El alias estricto es no permitir diferentes tipos de punteros a los mismos datos.</target>
        </trans-unit>
        <trans-unit id="08f4008712546a2f35d451915a75c5ce6707541f" translate="yes" xml:space="preserve">
          <source>Strict aliasing would allow us to prevent this by telling the compiler that these memory addresses are distinctly different (which, in this case, will allow even further optimization which can't be performed if the pointers share a memory address).</source>
          <target state="translated">Un alias estricto nos permitiría evitarlo diciéndole al compilador que estas direcciones de memoria son claramente diferentes (lo que,en este caso,permitirá una optimización aún mayor que no puede realizarse si los punteros comparten una dirección de memoria).</target>
        </trans-unit>
        <trans-unit id="3de059986d55a4c9204e0422ce6405ee0f2fae76" translate="yes" xml:space="preserve">
          <source>Technically in C++, the strict aliasing rule is probably never applicable.</source>
          <target state="translated">Técnicamente en C++,la estricta regla del alias probablemente nunca sea aplicable.</target>
        </trans-unit>
        <trans-unit id="907bce6add949792da1d5d77350df907126f6c70" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;C11&lt;/strong&gt; standard says the following in section &lt;em&gt;6.5 Expressions paragraph 7&lt;/em&gt;:</source>
          <target state="translated">El est&amp;aacute;ndar &lt;strong&gt;C11&lt;/strong&gt; dice lo siguiente en la secci&amp;oacute;n &lt;em&gt;6.5 Expresiones p&amp;aacute;rrafo 7&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="bfd25f24e236cc975bc1fefb913df995d3049915" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Strict aliasing rule allows us to avoid redundant machine code&lt;/strong&gt; in cases in which it &lt;em&gt;should be&lt;/em&gt; safe to assume that two pointers don't point to the same memory block (see also the &lt;code&gt;restrict&lt;/code&gt; keyword).</source>
          <target state="translated">La &lt;strong&gt;regla de alias estricto nos permite evitar el c&amp;oacute;digo de m&amp;aacute;quina redundante&lt;/strong&gt; en los casos en que &lt;em&gt;deber&amp;iacute;a ser&lt;/em&gt; seguro suponer que dos punteros no apuntan al mismo bloque de memoria (ver tambi&amp;eacute;n la palabra clave &lt;code&gt;restrict&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8c06897729db17629b567058f47bdaf4c4318b26" translate="yes" xml:space="preserve">
          <source>The C++17 draft standard in section &lt;em&gt;[basic.lval] paragraph 11&lt;/em&gt; says:</source>
          <target state="translated">El borrador del est&amp;aacute;ndar C ++ 17 en la secci&amp;oacute;n &lt;em&gt;[basic.lval] p&amp;aacute;rrafo 11&lt;/em&gt; dice:</target>
        </trans-unit>
        <trans-unit id="9bc4e143126dccfdfaa1a458c40e03e32eb19eb7" translate="yes" xml:space="preserve">
          <source>The Strict aliasing states it's safe to assume that pointers to different types point to different locations in the memory.</source>
          <target state="translated">El Alias estricto establece que es seguro asumir que los punteros de diferentes tipos apuntan a diferentes lugares de la memoria.</target>
        </trans-unit>
        <trans-unit id="7928780bf9e4496f92d12638d4fa464749948340" translate="yes" xml:space="preserve">
          <source>The best explanation I have found is by Mike Acton, &lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;Understanding Strict Aliasing&lt;/a&gt;. It's focused a little on PS3 development, but that's basically just GCC.</source>
          <target state="translated">La mejor explicaci&amp;oacute;n que he encontrado es Mike Acton, &lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;Understanding Strict Aliasing&lt;/a&gt; . Se centra un poco en el desarrollo de PS3, pero eso es b&amp;aacute;sicamente solo GCC.</target>
        </trans-unit>
        <trans-unit id="49c47e96747dd9ea774b5bc163ec15c244b5f868" translate="yes" xml:space="preserve">
          <source>The best way to resolve the original problem would probably be to treat the
footnote about the purpose of the rule as though it were normative, and made
the rule unenforceable except in cases which actually involve conflicting accesses using aliases.  Given something like:</source>
          <target state="translated">La mejor manera de resolver el problema original sería probablemente tratar la nota de pie de página sobre el propósito de la regla como si fuera normativa,y hacer que la regla fuera inaplicable excepto en los casos que realmente impliquen accesos conflictivos utilizando alias.Dado algo así como:</target>
        </trans-unit>
        <trans-unit id="85b689b0761df13dcd7da661f9fdf03565c0a4a1" translate="yes" xml:space="preserve">
          <source>The compiler may or may not be able to or smart enough to try to inline SendMessage and it may or may not decide to load or not load buff again. If &lt;code&gt;SendMessage&lt;/code&gt; is part of another API that's compiled separately, it probably has instructions to load buff's contents. Then again, maybe you're in C++ and this is some templated header only implementation that the compiler thinks it can inline. Or maybe it's just something you wrote in your .c file for your own convenience. Anyway undefined behavior might still ensue. Even when we know some of what's happening under the hood, it's still a violation of the rule so no well defined behavior is guaranteed. So just by wrapping in a function that takes our word delimited buffer doesn't necessarily help.</source>
          <target state="translated">El compilador puede o no ser capaz o lo suficientemente inteligente como para intentar enviar SendMessage en l&amp;iacute;nea y puede o no decidir cargar o no cargar buff nuevamente. Si &lt;code&gt;SendMessage&lt;/code&gt; es parte de otra API que se compila por separado, probablemente tenga instrucciones para cargar el contenido de buff. Por otra parte, tal vez est&amp;eacute; en C ++ y esta es una implementaci&amp;oacute;n de solo encabezado con plantilla que el compilador cree que puede en l&amp;iacute;nea. O tal vez es algo que escribi&amp;oacute; en su archivo .c para su propia conveniencia. De todos modos, todav&amp;iacute;a podr&amp;iacute;a seguir un comportamiento indefinido. Incluso cuando sabemos algo de lo que sucede debajo del cap&amp;oacute;, sigue siendo una violaci&amp;oacute;n de la regla, por lo que no se garantiza un comportamiento bien definido. Entonces, simplemente envolviendo una funci&amp;oacute;n que toma nuestro b&amp;uacute;fer delimitado por palabras no necesariamente ayuda.</target>
        </trans-unit>
        <trans-unit id="185da178ba74f21fd6fbee6fc9a19c180251420b" translate="yes" xml:space="preserve">
          <source>The exception to the rule is a &lt;code&gt;char*&lt;/code&gt;, which is allowed to point to any type.</source>
          <target state="translated">La excepci&amp;oacute;n a la regla es un &lt;code&gt;char*&lt;/code&gt; , que puede apuntar a cualquier tipo.</target>
        </trans-unit>
        <trans-unit id="e6deb33976faa98a7a8b3f350b9d49c319c195cd" translate="yes" xml:space="preserve">
          <source>The following is an example of how to use &lt;strong&gt;bit_cast&lt;/strong&gt; to type pun a &lt;em&gt;unsigned int&lt;/em&gt; to &lt;em&gt;float&lt;/em&gt;, (&lt;a href=&quot;https://wandbox.org/permlink/i5l0g4IYuCFgLzzl&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">El siguiente es un ejemplo de c&amp;oacute;mo usar &lt;strong&gt;bit_cast&lt;/strong&gt; para escribir pun un &lt;em&gt;int no firmado&lt;/em&gt; para &lt;em&gt;flotar&lt;/em&gt; , ( &lt;a href=&quot;https://wandbox.org/permlink/i5l0g4IYuCFgLzzl&quot;&gt;verlo en vivo&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="bc2fdca487b4e3f2274bf45676f76859149d4991" translate="yes" xml:space="preserve">
          <source>The last tool I will recommend is C++ specific and not strictly a tool but a coding practice, don't allow C-style casts. Both gcc and clang will produce a diagnostic for C-style casts using &lt;strong&gt;-Wold-style-cast&lt;/strong&gt;. This will force any undefined type puns to use reinterpret_cast, in general reinterpret_cast should be a flag for closer code review. It is also easier to search your code base for reinterpret_cast to perform an audit.</source>
          <target state="translated">La &amp;uacute;ltima herramienta que recomendar&amp;eacute; es espec&amp;iacute;fica de C ++ y no estrictamente una herramienta, sino una pr&amp;aacute;ctica de codificaci&amp;oacute;n, no permita conversiones de estilo C. Tanto gcc como clang producir&amp;aacute;n un diagn&amp;oacute;stico para los lanzamientos de estilo C usando &lt;strong&gt;-Wold-style-cast&lt;/strong&gt; . Esto forzar&amp;aacute; a los juegos de palabras de tipo indefinido a usar reinterpret_cast, en general reinterpret_cast deber&amp;iacute;a ser un indicador para una revisi&amp;oacute;n m&amp;aacute;s detallada del c&amp;oacute;digo. Tambi&amp;eacute;n es m&amp;aacute;s f&amp;aacute;cil buscar en su base de c&amp;oacute;digo reinterpret_cast para realizar una auditor&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="d6426a86b973a6cec74fb415633b300e0a37c506" translate="yes" xml:space="preserve">
          <source>The next example shows aliasing that leads to undefined behavior (&lt;a href=&quot;https://wandbox.org/permlink/8qA8JyJRVHtS9LPf&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">El siguiente ejemplo muestra alias que conduce a un comportamiento indefinido ( &lt;a href=&quot;https://wandbox.org/permlink/8qA8JyJRVHtS9LPf&quot;&gt;ejemplo en vivo&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="5e5d6deec660f2c03a74983d7e1f704f0a612063" translate="yes" xml:space="preserve">
          <source>The optimizer using &lt;a href=&quot;http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm&quot;&gt;Type-Based Alias Analysis (TBAA)&lt;/a&gt; assumes &lt;strong&gt;1&lt;/strong&gt; will be returned and directly moves the constant value into register &lt;strong&gt;eax&lt;/strong&gt; which carries the return value. TBAA uses the languages rules about what types are allowed to alias to optimize loads and stores. In this case TBAA knows that a &lt;em&gt;float&lt;/em&gt; can not alias and &lt;em&gt;int&lt;/em&gt; and optimizes away the load of &lt;strong&gt;i&lt;/strong&gt;.</source>
          <target state="translated">El optimizador que utiliza el &lt;a href=&quot;http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm&quot;&gt;An&amp;aacute;lisis de alias basado en tipo (TBAA)&lt;/a&gt; asume que &lt;strong&gt;1&lt;/strong&gt; ser&amp;aacute; devuelto y mueve directamente el valor constante al registro &lt;strong&gt;eax&lt;/strong&gt; que lleva el valor de retorno. TBAA usa las reglas de idiomas sobre qu&amp;eacute; tipos est&amp;aacute;n permitidos para alias para optimizar cargas y tiendas. En este caso, TBAA sabe que un &lt;em&gt;flotante&lt;/em&gt; no puede alias e &lt;em&gt;int&lt;/em&gt; y optimiza la carga de &lt;strong&gt;i&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="eb988ee6dabc3ef8446376c66441177c2cd532a0" translate="yes" xml:space="preserve">
          <source>The standard method for &lt;em&gt;type punning&lt;/em&gt; in both C and C++ is &lt;strong&gt;memcpy&lt;/strong&gt;. This may seem a little heavy handed but the optimizer should recognize the use of &lt;strong&gt;memcpy&lt;/strong&gt; for &lt;em&gt;type punning&lt;/em&gt; and optimize it away and generate a register to register move. For example if we know &lt;em&gt;int64_t&lt;/em&gt; is the same size as &lt;em&gt;double&lt;/em&gt;:</source>
          <target state="translated">El m&amp;eacute;todo est&amp;aacute;ndar para la &lt;em&gt;escritura de tipos&lt;/em&gt; en C y C ++ es &lt;strong&gt;memcpy&lt;/strong&gt; . Esto puede parecer un poco pesado, pero el optimizador debe reconocer el uso de &lt;strong&gt;memcpy&lt;/strong&gt; para la &lt;strong&gt;escritura&lt;/strong&gt; de &lt;em&gt;tipo&lt;/em&gt; y optimizarlo y generar un registro para registrar el movimiento. Por ejemplo, si sabemos que &lt;em&gt;int64_t&lt;/em&gt; tiene el mismo tama&amp;ntilde;o que el &lt;em&gt;doble&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="08b2135b25032781b64ff4c52a4bdd14662d43d7" translate="yes" xml:space="preserve">
          <source>The strict aliasing rule makes this setup illegal: dereferencing a pointer that aliases an object that is not of a &lt;a href=&quot;http://en.cppreference.com/w/c/language/type&quot;&gt;compatible type&lt;/a&gt; or one of the other types allowed by C 2011 6.5 paragraph 7&lt;sup&gt;1&lt;/sup&gt; is undefined behavior. Unfortunately, you can still code this way, &lt;em&gt;maybe&lt;/em&gt; get some warnings, have it compile fine, only to have weird unexpected behavior when you run the code.</source>
          <target state="translated">La estricta regla de alias hace que esta configuraci&amp;oacute;n sea ilegal: desreferenciar un puntero que alias un objeto que no es de un &lt;a href=&quot;http://en.cppreference.com/w/c/language/type&quot;&gt;tipo compatible&lt;/a&gt; o uno de los otros tipos permitidos por C 2011 6.5 p&amp;aacute;rrafo 7 &lt;sup&gt;1&lt;/sup&gt; es un comportamiento indefinido. Desafortunadamente, a&amp;uacute;n puede codificar de esta manera, &lt;em&gt;tal vez&lt;/em&gt; obtener algunas advertencias, compilarlo bien, solo para tener un comportamiento extra&amp;ntilde;o e inesperado cuando ejecuta el c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="bd0246c8dec2dd6e8cc0d773260f9ddcf056333b" translate="yes" xml:space="preserve">
          <source>The third change makes a stronger guarantee (relaxes the strong aliasing rule): The new concept of &lt;em&gt;similar types&lt;/em&gt; that are now safe to alias.</source>
          <target state="translated">El tercer cambio ofrece una garant&amp;iacute;a m&amp;aacute;s s&amp;oacute;lida (relaja la fuerte regla de alias): el nuevo concepto de &lt;em&gt;tipos similares&lt;/em&gt; que ahora son seguros para el alias.</target>
        </trans-unit>
        <trans-unit id="428a7cf24521c1266f3851b503c14cb107e579a2" translate="yes" xml:space="preserve">
          <source>The unary * operator performs indirection: the expression to which it
  is applied shall be a pointer to an object type, or a pointer to a
  function type and &lt;strong&gt;the result is an lvalue referring to the object&lt;/strong&gt; or
  function &lt;strong&gt;to which the expression points&lt;/strong&gt;.</source>
          <target state="translated">El operador unario * realiza indirectamente: la expresi&amp;oacute;n a la que se aplica ser&amp;aacute; un puntero a un tipo de objeto, o un puntero a un tipo de funci&amp;oacute;n y &lt;strong&gt;el resultado es un valor l que se refiere al objeto&lt;/strong&gt; o funci&amp;oacute;n &lt;strong&gt;al que apunta la expresi&amp;oacute;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f3edc398608fb9b543cd714f6b95b268072cc297" translate="yes" xml:space="preserve">
          <source>There's no conflict within &lt;code&gt;inc_int&lt;/code&gt; because all accesses to the storage accessed through &lt;code&gt;*p&lt;/code&gt; are done with an lvalue of type &lt;code&gt;int&lt;/code&gt;, and there's no conflict in &lt;code&gt;test&lt;/code&gt; because &lt;code&gt;p&lt;/code&gt; is visibly derived from a &lt;code&gt;struct S&lt;/code&gt;, and by the next time &lt;code&gt;s&lt;/code&gt; is used, all accesses to that storage that will ever be made through &lt;code&gt;p&lt;/code&gt; will have already happened.</source>
          <target state="translated">No hay conflicto dentro de &lt;code&gt;inc_int&lt;/code&gt; porque todos los accesos al almacenamiento al que se accede a trav&amp;eacute;s de &lt;code&gt;*p&lt;/code&gt; se realizan con un valor l de tipo &lt;code&gt;int&lt;/code&gt; , y no hay conflicto en la &lt;code&gt;test&lt;/code&gt; porque &lt;code&gt;p&lt;/code&gt; se deriva visiblemente de una &lt;code&gt;struct S&lt;/code&gt; , y para la pr&amp;oacute;xima vez que se usa &lt;code&gt;s&lt;/code&gt; , todos los accesos a ese almacenamiento que se realizar&amp;aacute;n a trav&amp;eacute;s de &lt;code&gt;p&lt;/code&gt; ya habr&amp;aacute;n sucedido.</target>
        </trans-unit>
        <trans-unit id="1e47063a12afd4868e46be1f29d48214f059315d" translate="yes" xml:space="preserve">
          <source>This can be told to the compiler in two ways, by using different types to point to. i.e.:</source>
          <target state="translated">Esto se puede decir al compilador de dos maneras,usando diferentes tipos para señalar,es decir:</target>
        </trans-unit>
        <trans-unit id="6f8c42e0f055d24e57ba0b97836be0b7abeb6542" translate="yes" xml:space="preserve">
          <source>This extra code is slow and &lt;strong&gt;hurts performance&lt;/strong&gt; since it performs extra memory read / write operations which are both slower and (possibly) unnecessary.</source>
          <target state="translated">Este c&amp;oacute;digo adicional es lento y &lt;strong&gt;perjudica el rendimiento&lt;/strong&gt; ya que realiza operaciones adicionales de lectura / escritura de memoria que son m&amp;aacute;s lentas y (posiblemente) innecesarias.</target>
        </trans-unit>
        <trans-unit id="03bd20f42d11715386a09efa404ec49187a334ec" translate="yes" xml:space="preserve">
          <source>This is excerpted from my &lt;a href=&quot;https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8&quot;&gt;&quot;What is the Strict Aliasing Rule and Why do we care?&quot;&lt;/a&gt; write-up.</source>
          <target state="translated">Esto se extrae de mi &lt;a href=&quot;https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8&quot;&gt;&quot;&amp;iquest;Cu&amp;aacute;l es la regla de alias estricto y por qu&amp;eacute; nos importa?&quot;&lt;/a&gt; redacci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="23f8f6c33332ebb487428148aeaa250e333c0297" translate="yes" xml:space="preserve">
          <source>This is not valid in C++ and some consider the purpose of unions to be solely for implementing variant types and feel using unions for type punning is an abuse.</source>
          <target state="translated">Esto no es válido en C++y algunos consideran que el propósito de las uniones es únicamente para implementar los tipos variantes y sienten que usar las uniones para el castigo de tipos es un abuso.</target>
        </trans-unit>
        <trans-unit id="b5a81d05fa60ca66493d7a8dd3adf9606ece3212" translate="yes" xml:space="preserve">
          <source>This is only one potential minefield when overlaying two types onto each other. You should also learn about &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;endianness&lt;/a&gt;, &lt;a href=&quot;http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html&quot;&gt;word alignment&lt;/a&gt;, and how to deal with alignment issues through &lt;a href=&quot;http://grok2.com/structure_packing.html&quot;&gt;packing structs&lt;/a&gt; correctly.</source>
          <target state="translated">Este es solo un campo minado potencial cuando se superponen dos tipos entre s&amp;iacute;. Tambi&amp;eacute;n debe aprender sobre &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;endianness&lt;/a&gt; , &lt;a href=&quot;http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html&quot;&gt;alineaci&amp;oacute;n de palabras&lt;/a&gt; y c&amp;oacute;mo lidiar con problemas de alineaci&amp;oacute;n a trav&amp;eacute;s de &lt;a href=&quot;http://grok2.com/structure_packing.html&quot;&gt;estructuras de empaque&lt;/a&gt; correctamente.</target>
        </trans-unit>
        <trans-unit id="1206246dfe34c612a18075c8bf78ec4ea7f41bed" translate="yes" xml:space="preserve">
          <source>This is the strict aliasing rule, found in section 3.10 of the &lt;strong&gt;C++03&lt;/strong&gt; standard (other answers provide good explanation, but none provided the rule itself):</source>
          <target state="translated">Esta es la estricta regla de alias, que se encuentra en la secci&amp;oacute;n 3.10 del est&amp;aacute;ndar &lt;strong&gt;C ++ 03&lt;/strong&gt; (otras respuestas proporcionan una buena explicaci&amp;oacute;n, pero ninguna proporcion&amp;oacute; la regla en s&amp;iacute;):</target>
        </trans-unit>
        <trans-unit id="136cb4ca2af68d11d5c37a73bdbfaeaff7fafa9a" translate="yes" xml:space="preserve">
          <source>This optimization couldn't have been done before, because of the possible collision (where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; would be tripled instead of doubled).</source>
          <target state="translated">Esta optimizaci&amp;oacute;n no podr&amp;iacute;a haberse hecho antes, debido a la posible colisi&amp;oacute;n (donde &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; se triplicar&amp;iacute;an en lugar de duplicarse).</target>
        </trans-unit>
        <trans-unit id="0c6e49d370e8ee32d1f9fb66865bb3dc534b3fdf" translate="yes" xml:space="preserve">
          <source>To see why this behavior is undefined, we have to think about what the strict aliasing rule buys the compiler. Basically, with this rule, it doesn't have to think about inserting instructions to refresh the contents of &lt;code&gt;buff&lt;/code&gt; every run of the loop. Instead, when optimizing, with some annoyingly unenforced assumptions about aliasing, it can omit those instructions, load &lt;code&gt;buff[0]&lt;/code&gt; and &lt;code&gt;buff[1&lt;/code&gt;] into CPU registers once before the loop is run, and speed up the body of the loop. Before strict aliasing was introduced, the compiler had to live in a state of paranoia that the contents of &lt;code&gt;buff&lt;/code&gt; could change at anytime from anywhere by anybody. So to get an extra performance edge, and assuming most people don't type-pun pointers, the strict aliasing rule was introduced.</source>
          <target state="translated">Para ver por qu&amp;eacute; este comportamiento es indefinido, tenemos que pensar en lo que la regla de alias estricto compra al compilador. B&amp;aacute;sicamente, con esta regla, no tiene que pensar en insertar instrucciones para actualizar el contenido de &lt;code&gt;buff&lt;/code&gt; en cada ejecuci&amp;oacute;n del ciclo. En cambio, cuando se optimiza, con algunas suposiciones molestas sobre el alias, puede omitir esas instrucciones, cargar &lt;code&gt;buff[0]&lt;/code&gt; y &lt;code&gt;buff[1&lt;/code&gt; ] en los registros de la CPU una vez antes de que se ejecute el bucle y acelerar el cuerpo del bucle. Antes de que se introdujera un alias estricto, el compilador ten&amp;iacute;a que vivir en un estado de paranoia que el contenido de &lt;code&gt;buff&lt;/code&gt; pod&amp;iacute;a cambiar en cualquier momento desde cualquier lugar por cualquier persona. Entonces, para obtener una ventaja de rendimiento adicional, y suponiendo que la mayor&amp;iacute;a de las personas no escriben punteros, se introdujo la estricta regla de alias.</target>
        </trans-unit>
        <trans-unit id="2cca1ba7b02e14ee263ba59cb168d4ba464a31b0" translate="yes" xml:space="preserve">
          <source>To understand more about why we care, we will discuss issues that come up when violating strict aliasing rules, type punning since common techniques used in type punning often violate strict aliasing rules and how to type pun correctly.</source>
          <target state="translated">Para entender mejor por qué nos preocupamos,discutiremos los temas que surgen cuando se violan las estrictas reglas de alias,los juegos de palabras,ya que las técnicas comunes utilizadas en los juegos de palabras a menudo violan las estrictas reglas de alias y cómo escribir correctamente los juegos de palabras.</target>
        </trans-unit>
        <trans-unit id="e92874def1c707e293c92fd2c84a024426689bc4" translate="yes" xml:space="preserve">
          <source>Traditionally this has been accomplished by taking the address of the object, casting it to a pointer of the type we want to reinterpret it as and then accessing the value, or in other words by aliasing. For example:</source>
          <target state="translated">Tradicionalmente,esto se ha logrado tomando la dirección del objeto,lanzándolo a un puntero del tipo que queremos reinterpretar como y luego accediendo al valor,o en otras palabras,mediante el alias.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="edef09f47c7522a6bf38ab921e88dc728d2d2210" translate="yes" xml:space="preserve">
          <source>Two changes were small: &lt;em&gt;glvalue&lt;/em&gt; instead of &lt;em&gt;lvalue&lt;/em&gt;, and clarification of the aggregate/union case.</source>
          <target state="translated">Dos cambios fueron peque&amp;ntilde;os: &lt;em&gt;glvalue en&lt;/em&gt; lugar de &lt;em&gt;lvalue&lt;/em&gt; , y aclaraci&amp;oacute;n del caso agregado / uni&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0200f9824ad4e7d323fbd799151680bd20557e5c" translate="yes" xml:space="preserve">
          <source>Unfortunately with strict aliasing violations, we will often obtain the results we expect, leaving the possibility the a future version of a compiler with a new optimization will break code we thought was valid. This is undesirable and it is a worthwhile goal to understand the strict aliasing rules and how to avoid violating them.</source>
          <target state="translated">Desafortunadamente con las estrictas violaciones de alias,a menudo obtendremos los resultados que esperamos,dejando la posibilidad de que la futura versión de un compilador con una nueva optimización rompa el código que creíamos válido.Esto es indeseable y es un objetivo que vale la pena entender las estrictas reglas de aliasing y cómo evitar su violación.</target>
        </trans-unit>
        <trans-unit id="db8ca5d18a2da2723c323eb4668458564a4e8a8e" translate="yes" xml:space="preserve">
          <source>Unfortunately, the authors of the C89 wrote their rule in a way that, if read literally, would make even the following function invoke Undefined Behavior:</source>
          <target state="translated">Desafortunadamente,los autores del C89 escribieron su regla de una manera que,si se lee literalmente,haría que incluso la siguiente función invocara el Comportamiento Indefinido:</target>
        </trans-unit>
        <trans-unit id="c9eb5ca0a29983f2cff35266a2b00fda06003422" translate="yes" xml:space="preserve">
          <source>Use a union. Most compilers support this without complaining about strict aliasing. This is allowed in C99 and explicitly allowed in C11.</source>
          <target state="translated">Usa un sindicato.La mayoría de los compiladores apoyan esto sin quejarse de un estricto alias.Esto está permitido en el C99 y explícitamente en el C11.</target>
        </trans-unit>
        <trans-unit id="ffd25c02b83ef5f0f4c7c45af829e62dae0bf2c5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;restrict&lt;/code&gt; keyword. i.e.:</source>
          <target state="translated">Usando la palabra clave &lt;code&gt;restrict&lt;/code&gt; . es decir:</target>
        </trans-unit>
        <trans-unit id="798b73c4c9c14434f5fd6ba2176351fdd836980d" translate="yes" xml:space="preserve">
          <source>We don't have a lot of good tools for catching strict aliasing in C++, the tools we have will catch some cases of strict aliasing violations and some cases of misaligned loads and stores.</source>
          <target state="translated">No tenemos muchas buenas herramientas para atrapar alias estrictos en C++,las herramientas que tenemos atraparán algunos casos de violaciones de alias estrictos y algunos casos de cargas y almacenes desalineados.</target>
        </trans-unit>
        <trans-unit id="7a25725c5206d96d54103f39151066cf147a0d46" translate="yes" xml:space="preserve">
          <source>We have a &lt;em&gt;int*&lt;/em&gt; pointing to memory occupied by an &lt;em&gt;int&lt;/em&gt; and this is a valid aliasing. The optimizer must assume that assignments through &lt;strong&gt;ip&lt;/strong&gt; could update the value occupied by &lt;strong&gt;x&lt;/strong&gt;.</source>
          <target state="translated">Tenemos un &lt;em&gt;int * que&lt;/em&gt; apunta a la memoria ocupada por un &lt;em&gt;int&lt;/em&gt; y este es un alias v&amp;aacute;lido. El optimizador debe asumir que las asignaciones a trav&amp;eacute;s de &lt;strong&gt;ip&lt;/strong&gt; podr&amp;iacute;an actualizar el valor ocupado por &lt;strong&gt;x&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b4304e0250327f603bbd29b9479b911b0f3e7e12" translate="yes" xml:space="preserve">
          <source>We have gotten to this point and we may be wondering, why would we want to alias for? The answer typically is to &lt;em&gt;type pun&lt;/em&gt;, often the methods used violate strict aliasing rules.</source>
          <target state="translated">Hemos llegado a este punto y podemos preguntarnos, &amp;iquest;por qu&amp;eacute; querr&amp;iacute;amos alias? La respuesta generalmente es &lt;em&gt;escribir juegos de palabras&lt;/em&gt; , a menudo los m&amp;eacute;todos utilizados violan estrictas reglas de alias.</target>
        </trans-unit>
        <trans-unit id="486a3a882c8d445100340edd5a8f2d6177c5a9af" translate="yes" xml:space="preserve">
          <source>What are they talking about?</source>
          <target state="translated">¿De qué están hablando?</target>
        </trans-unit>
        <trans-unit id="8c58623950ce7060c946f960d5a1072d0350e835" translate="yes" xml:space="preserve">
          <source>What does the C11 standard say?</source>
          <target state="translated">¿Qué dice la norma C11?</target>
        </trans-unit>
        <trans-unit id="be95c287c482fdf98be1e57328b6181a5b151c60" translate="yes" xml:space="preserve">
          <source>What exactly does the standard say we are allowed and not allowed to do? The standard language is not straightforward, so for each item I will try to provide code examples that demonstrates the meaning.</source>
          <target state="translated">¿Qué dice exactamente la norma que se nos permite y no se nos permite hacer? El lenguaje estándar no es sencillo,por lo que para cada artículo trataré de proporcionar ejemplos de código que demuestren el significado.</target>
        </trans-unit>
        <trans-unit id="80f819d6238279d0e91326c0caabb3b332286522" translate="yes" xml:space="preserve">
          <source>What is Type Punning</source>
          <target state="translated">¿Qué es el juego de palabras?</target>
        </trans-unit>
        <trans-unit id="0484d0796de9fffe254f71284bf9ef8e03cb6100" translate="yes" xml:space="preserve">
          <source>What is strict aliasing?</source>
          <target state="translated">¿Qué es el alias estricto?</target>
        </trans-unit>
        <trans-unit id="bd5bd917a7164fc90491e58bae353151d7d6d43e" translate="yes" xml:space="preserve">
          <source>What is the strict aliasing rule</source>
          <target state="translated">¿Cuál es la estricta regla de alias</target>
        </trans-unit>
        <trans-unit id="cfad540cca405d9e6ac5dbafe09c03446c539f96" translate="yes" xml:space="preserve">
          <source>What the C++17 Draft Standard say</source>
          <target state="translated">Lo que dice el proyecto de norma C++17</target>
        </trans-unit>
        <trans-unit id="2b2f3220f114ca6e5fa9f3ff293ad00e83672d76" translate="yes" xml:space="preserve">
          <source>When asking about &lt;a href=&quot;https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into&quot;&gt;common undefined behavior in C&lt;/a&gt;, people sometimes refer to the strict aliasing rule.</source>
          <target state="translated">Al preguntar sobre &lt;a href=&quot;https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into&quot;&gt;el comportamiento indefinido com&amp;uacute;n en C&lt;/a&gt; , las personas a veces se refieren a la estricta regla de alias.</target>
        </trans-unit>
        <trans-unit id="c3986cda3c380d27ccea1e1786651cd0707eff3f" translate="yes" xml:space="preserve">
          <source>Which may not be expected but is perfectly valid since we have invoked undefined behavior. A &lt;em&gt;float&lt;/em&gt; can not validly alias an &lt;em&gt;int&lt;/em&gt; object. Therefore the optimizer can assume the &lt;em&gt;constant 1&lt;/em&gt; stored when dereferencing &lt;strong&gt;i&lt;/strong&gt; will be the return value since a store through &lt;strong&gt;f&lt;/strong&gt; could not validly affect an &lt;em&gt;int&lt;/em&gt; object. Plugging the code in Compiler Explorer shows this is exactly what is happening(&lt;a href=&quot;https://godbolt.org/g/yNV5aj&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">Lo cual puede no esperarse pero es perfectamente v&amp;aacute;lido ya que hemos invocado un comportamiento indefinido. Un &lt;em&gt;flotante&lt;/em&gt; no puede alias v&amp;aacute;lidamente un objeto &lt;em&gt;int&lt;/em&gt; . Por lo tanto, el optimizador puede asumir que la &lt;em&gt;constante 1&lt;/em&gt; almacenada al desreferenciar &lt;strong&gt;i&lt;/strong&gt; ser&amp;aacute; el valor de retorno ya que una tienda a trav&amp;eacute;s de &lt;strong&gt;f&lt;/strong&gt; no podr&amp;iacute;a afectar v&amp;aacute;lidamente un objeto &lt;em&gt;int&lt;/em&gt; . Conectar el c&amp;oacute;digo en el Explorador de compiladores muestra que esto es exactamente lo que est&amp;aacute; sucediendo ( &lt;a href=&quot;https://godbolt.org/g/yNV5aj&quot;&gt;ejemplo en vivo&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="07141bb6d0d110634a7409d34c366630d3c98a44" translate="yes" xml:space="preserve">
          <source>Worth noting &lt;em&gt;signed char&lt;/em&gt; is not included in the list above, this is a notable difference from &lt;em&gt;C&lt;/em&gt; which says &lt;em&gt;a character type&lt;/em&gt;.</source>
          <target state="translated">Vale la pena se&amp;ntilde;alar que el &lt;em&gt;car&amp;aacute;cter firmado&lt;/em&gt; no est&amp;aacute; incluido en la lista anterior, esta es una diferencia notable de &lt;em&gt;C&lt;/em&gt; que dice &lt;em&gt;un tipo de car&amp;aacute;cter&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6ec4bca0456ee32bdbabe8e73b9e3df68f5d736b" translate="yes" xml:space="preserve">
          <source>You can disable strict aliasing in your compiler (&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825&quot;&gt;f[no-]strict-aliasing&lt;/a&gt; in gcc))</source>
          <target state="translated">Puede deshabilitar el alias estricto en su compilador ( &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825&quot;&gt;f [no-] alias estricto&lt;/a&gt; en gcc))</target>
        </trans-unit>
        <trans-unit id="9a40a7037ea21cd56a31798eee7807d9c8786d82" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;char*&lt;/code&gt; for aliasing instead of your system's word. The rules allow an exception for &lt;code&gt;char*&lt;/code&gt; (including &lt;code&gt;signed char&lt;/code&gt; and &lt;code&gt;unsigned char&lt;/code&gt;). It's always assumed that &lt;code&gt;char*&lt;/code&gt; aliases other types. However this won't work the other way: there's no assumption that your struct aliases a buffer of chars.</source>
          <target state="translated">Puede usar &lt;code&gt;char*&lt;/code&gt; para crear alias en lugar de la palabra de su sistema. Las reglas permiten una excepci&amp;oacute;n para &lt;code&gt;char*&lt;/code&gt; (incluidos &lt;code&gt;signed char&lt;/code&gt; &lt;code&gt;unsigned char&lt;/code&gt; y char sin signo ). Siempre se supone que &lt;code&gt;char*&lt;/code&gt; alias otros tipos. Sin embargo, esto no funcionar&amp;aacute; de otra manera: no se supone que su estructura alias un b&amp;uacute;fer de caracteres.</target>
        </trans-unit>
        <trans-unit id="3ee51db5fb0d07b269bfed3eb63461eb650f3683" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">un tipo de &lt;code&gt;unsigned char&lt;/code&gt; &lt;code&gt;char&lt;/code&gt; o unsigned .</target>
        </trans-unit>
        <trans-unit id="597ff02af60ec975bbc5261d748ee4cf1e57a446" translate="yes" xml:space="preserve">
          <source>a character type.</source>
          <target state="translated">un tipo de personaje.</target>
        </trans-unit>
        <trans-unit id="cce769f3e61ed7c57c27b8bbabf2ecde89913120" translate="yes" xml:space="preserve">
          <source>a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">una versión con calificación cv del tipo dinámico del objeto,</target>
        </trans-unit>
        <trans-unit id="d5c0b51b12ba45e66cdb0c200363fe41dca17267" translate="yes" xml:space="preserve">
          <source>a qualified version of a type compatible with the effective type of the object,</source>
          <target state="translated">una versión calificada de un tipo compatible con el tipo efectivo del objeto,</target>
        </trans-unit>
        <trans-unit id="913991e5ddd84e880c9ee8623ae50786c0e5aa58" translate="yes" xml:space="preserve">
          <source>a qualiﬁed version of a type compatible with the effective type of
  the object,</source>
          <target state="translated">una versión qualiﬁed de un tipo compatible con el tipo efectivo del objeto,</target>
        </trans-unit>
        <trans-unit id="b75dd2203435a45255f541a92e8f52a7c687df9d" translate="yes" xml:space="preserve">
          <source>a type compatible with the effective type of the object,</source>
          <target state="translated">un tipo compatible con el tipo efectivo del objeto,</target>
        </trans-unit>
        <trans-unit id="75d68aa8a13ac3e6c2e72772064d82f9a07c3a25" translate="yes" xml:space="preserve">
          <source>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</source>
          <target state="translated">un tipo que es un tipo de clase base (posiblemente calificado como cv)del tipo dinámico del objeto,</target>
        </trans-unit>
        <trans-unit id="b65677be1e1487df5175120a02cfc67364b289cb" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a
  qualiﬁed version of the effective type of the object,</source>
          <target state="translated">un tipo que es el tipo firmado o no firmado correspondiente a una versión qualiﬁed del tipo efectivo del objeto,</target>
        </trans-unit>
        <trans-unit id="bac8eec6cb1615e6948be007906aef75526747ef" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">un tipo que es el tipo con o sin firma que corresponde a una versión cv-calificada del tipo dinámico del objeto,</target>
        </trans-unit>
        <trans-unit id="32f34f0edd59f5a473682cd472684b341a58daef" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,</source>
          <target state="translated">un tipo que es el tipo firmado o no firmado que corresponde a una versión cualificada del tipo efectivo del objeto,</target>
        </trans-unit>
        <trans-unit id="e7c8760740b87a7f9140b423e924d45e4999f46b" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to the
  effective type of the object,</source>
          <target state="translated">un tipo que es el tipo con o sin signo correspondiente al tipo efectivo del objeto,</target>
        </trans-unit>
        <trans-unit id="3fb43283d88825a91d147ec87a46390b16119ec1" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</source>
          <target state="translated">un tipo que es el tipo con o sin signo correspondiente al tipo dinámico del objeto,</target>
        </trans-unit>
        <trans-unit id="09589aee6f97ca1ced0e9615240163fa1a8aac6b" translate="yes" xml:space="preserve">
          <source>add &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">agregue &lt;code&gt;a&lt;/code&gt; a &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4989e9968b633144d1dfa1a4b1a8a78e58f871e" translate="yes" xml:space="preserve">
          <source>add &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">agregue &lt;code&gt;b&lt;/code&gt; a &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7dfe2e2b4ee47faaabfeac29663335e09827e6a" translate="yes" xml:space="preserve">
          <source>although it will not catch this additional case (&lt;a href=&quot;https://wandbox.org/permlink/dwd9jhy53AF7a2D0&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">aunque no captar&amp;aacute; este caso adicional ( &lt;a href=&quot;https://wandbox.org/permlink/dwd9jhy53AF7a2D0&quot;&gt;verlo en vivo&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="e191b7b82407cef0ada97dd29a20d0793010dffe" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned
  types among its members (including, recursively, a member of a
  subaggregate or contained union), or</source>
          <target state="translated">un tipo de agregado o unión que incluya uno de los tipos mencionados entre sus miembros (incluyendo,recursivamente,un miembro de una unión subagregada o contenida),o</target>
        </trans-unit>
        <trans-unit id="fdece15d7bccebfe8183f34b848fc0e4942877cb" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned types among its &lt;em&gt;elements or non-static data members&lt;/em&gt; (including, recursively, an &lt;em&gt;element or non-static data member&lt;/em&gt; of a subaggregate or contained union),</source>
          <target state="translated">un tipo agregado o de uni&amp;oacute;n que incluye uno de los tipos mencionados anteriormente entre sus &lt;em&gt;elementos o miembros de datos no est&amp;aacute;ticos&lt;/em&gt; (incluido, recursivamente, un &lt;em&gt;elemento o miembro&lt;/em&gt; de &lt;em&gt;datos no est&amp;aacute;tico&lt;/em&gt; de un subaggregado o uni&amp;oacute;n contenida),</target>
        </trans-unit>
        <trans-unit id="3bb5bb5a7fb40894ca32d70cc8dbec9f68ef6180" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union),</source>
          <target state="translated">un tipo de agregado o unión que incluye uno de los tipos mencionados entre sus miembros (incluyendo,recursivamente,un miembro de una unión subagregada o contenida),</target>
        </trans-unit>
        <trans-unit id="9904ae77bbd2a07d458dc75556c60522d6fed3a1" translate="yes" xml:space="preserve">
          <source>because it uses an lvalue of type &lt;code&gt;int&lt;/code&gt; to access an object of type &lt;code&gt;struct S&lt;/code&gt;, and &lt;code&gt;int&lt;/code&gt; is not among the types that may be used accessing a &lt;code&gt;struct S&lt;/code&gt;.  Because it would be absurd to treat all use of non-character-type members of structs and unions as Undefined Behavior, almost everyone recognizes that there are at least some circumstances where an lvalue of one type may be used to access an object of another type.  Unfortunately, the C Standards Committee has failed to define what those circumstances are.</source>
          <target state="translated">porque usa un valor l de tipo &lt;code&gt;int&lt;/code&gt; para acceder a un objeto de tipo &lt;code&gt;struct S&lt;/code&gt; , y &lt;code&gt;int&lt;/code&gt; no est&amp;aacute; entre los tipos que se pueden usar para acceder a una &lt;code&gt;struct S&lt;/code&gt; Debido a que ser&amp;iacute;a absurdo tratar todo uso de miembros de estructuras y uniones que no sean del tipo de caracteres como Comportamiento indefinido, casi todos reconocen que hay al menos algunas circunstancias en las que se puede usar un valor de un tipo para acceder a un objeto de otro tipo . Lamentablemente, el Comit&amp;eacute; de Normas C no ha podido definir cu&amp;aacute;les son esas circunstancias.</target>
        </trans-unit>
        <trans-unit id="13f76d1176cba1d67741f0be2b7d390647245ed8" translate="yes" xml:space="preserve">
          <source>check.c</source>
          <target state="translated">check.c</target>
        </trans-unit>
        <trans-unit id="6cc4950f9d59b228de0ffc8dfa255d0ff18a24aa" translate="yes" xml:space="preserve">
          <source>gcc using the flag &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; and &lt;strong&gt;-Wstrict-aliasing&lt;/strong&gt; can catch some cases although not without false positives/negatives. For example the following cases will generate a warning in gcc (&lt;a href=&quot;https://wandbox.org/permlink/cfckjTgwNTYHDIry&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">gcc usando la bandera &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; y &lt;strong&gt;-Wstrict-aliasing&lt;/strong&gt; puede detectar algunos casos, aunque no sin falsos positivos / negativos. Por ejemplo, los siguientes casos generar&amp;aacute;n una advertencia en gcc ( &lt;a href=&quot;https://wandbox.org/permlink/cfckjTgwNTYHDIry&quot;&gt;verlo en vivo&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="9b9539e1dab95d4762b7ca605ff3ef29baabe352" translate="yes" xml:space="preserve">
          <source>load &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from memory.</source>
          <target state="translated">cargar &lt;code&gt;b&lt;/code&gt; de la memoria.</target>
        </trans-unit>
        <trans-unit id="3c8e98bbec15998f99b160035e6e2a5a79e70264" translate="yes" xml:space="preserve">
          <source>save &lt;code&gt;a&lt;/code&gt; (from the CPU register) to the memory.</source>
          <target state="translated">guardar &lt;code&gt;a&lt;/code&gt; (desde el registro de la CPU) en la memoria.</target>
        </trans-unit>
        <trans-unit id="e9f82b272f6f1b1af58a82bfd5c8942a5383dee9" translate="yes" xml:space="preserve">
          <source>save result both to &lt;code&gt;a&lt;/code&gt; and to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">guardar el resultado tanto en a como en &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a44e1b26b12bd2a7790e5bb3e97bb71d781569c" translate="yes" xml:space="preserve">
          <source>should be required to reload the value of &lt;code&gt;x&lt;/code&gt; between the assignment and return statement so as to allow for the possibility that &lt;code&gt;p&lt;/code&gt; might point to &lt;code&gt;x&lt;/code&gt;, and the assignment to &lt;code&gt;*p&lt;/code&gt; might consequently alter the value of &lt;code&gt;x&lt;/code&gt;.  The notion that a compiler should be entitled to presume that there won't be aliasing &lt;em&gt;in situations like the above&lt;/em&gt; was non-controversial.</source>
          <target state="translated">deber&amp;iacute;a exigirse que vuelva a cargar el valor de &lt;code&gt;x&lt;/code&gt; entre la asignaci&amp;oacute;n y la declaraci&amp;oacute;n de retorno para permitir la posibilidad de que &lt;code&gt;p&lt;/code&gt; apunte a &lt;code&gt;x&lt;/code&gt; , y la asignaci&amp;oacute;n a &lt;code&gt;*p&lt;/code&gt; podr&amp;iacute;a alterar el valor de &lt;code&gt;x&lt;/code&gt; . La noci&amp;oacute;n de que un compilador deber&amp;iacute;a tener derecho a presumir que no habr&amp;aacute; alias &lt;em&gt;en situaciones como las anteriores&lt;/em&gt; no fue controvertida.</target>
        </trans-unit>
        <trans-unit id="2ae0f749e2f2eba590823df0d938d3f9e1d9f0ad" translate="yes" xml:space="preserve">
          <source>the dynamic type of the object,</source>
          <target state="translated">el tipo dinámico del objeto,</target>
        </trans-unit>
        <trans-unit id="5c8205de1a0f5881a6eef3facb06094c46436ace" translate="yes" xml:space="preserve">
          <source>tis-interpeter is able to catch all three, the following example invokes tis-kernal as tis-interpreter (output is edited for brevity):</source>
          <target state="translated">El siguiente ejemplo invoca a tis-kernal como tis-intérprete (la salida se edita por brevedad):</target>
        </trans-unit>
        <trans-unit id="790926074ddb3f88b6b51d69cef8f57d64c8ee6d" translate="yes" xml:space="preserve">
          <source>we can use &lt;strong&gt;memcpy&lt;/strong&gt;:</source>
          <target state="translated">podemos usar &lt;strong&gt;memcpy&lt;/strong&gt; :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
