<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/98650">
    <body>
      <group id="98650">
        <trans-unit id="8bc9a3751448b75c95d0c09be39874a54d59dbbc" translate="yes" xml:space="preserve">
          <source>&quot;Strict aliasing is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias each other.)&quot;</source>
          <target state="translated">&quot;厳密なエイリアスとは、C (または C++)コンパイラが仮定したもので、異なる型のオブジェクトへのポインタを参照する際に、同じメモリ位置を参照することはありません (つまり、お互いをエイリアスにすること)。</target>
        </trans-unit>
        <trans-unit id="7cf3442516aaa5d6749824461a7def10a1b8f03a" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a character type.</source>
          <target state="translated">&amp;mdash;文字タイプ。</target>
        </trans-unit>
        <trans-unit id="16d9cec79491cede88fd0ddafcbdb33b1a1dc888" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a qualified version of a type compatible with the effective type of the object,</source>
          <target state="translated">&amp;mdash;オブジェクトの有効なタイプと互換性のあるタイプの修飾バージョン、</target>
        </trans-unit>
        <trans-unit id="13d94646e2432e838a724c25f7870cb8f332c869" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,</source>
          <target state="translated">&amp;mdash;オブジェクトの有効な型の修飾バージョンに対応する署名付きまたは署名なしの型である型</target>
        </trans-unit>
        <trans-unit id="4b87e5428fe7d01a75c7838ed5347266005ed316" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to the effective type of the object,</source>
          <target state="translated">&amp;mdash;オブジェクトの有効なタイプに対応する符号付きまたは符号なしタイプのタイプ</target>
        </trans-unit>
        <trans-unit id="62996c58c76d88b909b477d85de32e4c8a0be22f" translate="yes" xml:space="preserve">
          <source>&amp;mdash; an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or</source>
          <target state="translated">&amp;mdash;メンバーの中に前述のタイプの1つを含む集約またはユニオンタイプ（再帰的に、サブアグリゲートまたは含まれるユニオンのメンバーを含む）、または</target>
        </trans-unit>
        <trans-unit id="7682f0746a360de4bef474dee1888984c6d26a7c" translate="yes" xml:space="preserve">
          <source>(11.2) &amp;mdash; a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">（11.2）&amp;mdash;オブジェクトの動的タイプのcv修飾バージョン、</target>
        </trans-unit>
        <trans-unit id="2b7ebc143440433f6bcf7a57744dbff09cce4f85" translate="yes" xml:space="preserve">
          <source>(11.3) &amp;mdash; a type similar (as defined in 7.5) to the dynamic type of the object,</source>
          <target state="translated">（11.3）&amp;mdash;オブジェクトの動的タイプに類似したタイプ（7.5で定義）</target>
        </trans-unit>
        <trans-unit id="492220375e27ebfd7903993e017101c0d85ec3e0" translate="yes" xml:space="preserve">
          <source>(11.4) &amp;mdash; a type that is the signed or unsigned type corresponding to the dynamic type of the object,</source>
          <target state="translated">（11.4）&amp;mdash;オブジェクトの動的タイプに対応する符号付きまたは符号なしタイプのタイプ</target>
        </trans-unit>
        <trans-unit id="2d718b5cc47d538f62e075e1c68512349385137b" translate="yes" xml:space="preserve">
          <source>(11.5) &amp;mdash; a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">（11.5）&amp;mdash;オブジェクトの動的タイプのcv修飾バージョンに対応する署名付きまたは署名なしのタイプであるタイプ</target>
        </trans-unit>
        <trans-unit id="9dc6ec3bc2c4acd3e7938a177187de9946d3fbac" translate="yes" xml:space="preserve">
          <source>(11.6) &amp;mdash; an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</source>
          <target state="translated">（11.6）&amp;mdash;要素または非静的データメンバー（再帰的に、サブアグリゲートまたは含まれるユニオンの要素または非静的データメンバーを含む）の中に前述のタイプの1つを含む集約またはユニオンタイプ、</target>
        </trans-unit>
        <trans-unit id="0833cab4a3d7c43325017982c60dd1a9524db49f" translate="yes" xml:space="preserve">
          <source>(11.7) &amp;mdash; a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</source>
          <target state="translated">（11.7）&amp;mdash;オブジェクトの動的な型の（おそらくcvで修飾された）基本クラス型である型</target>
        </trans-unit>
        <trans-unit id="007312b7d7fe81dfd0e93a7cbbe02ace56aa2f12" translate="yes" xml:space="preserve">
          <source>(11.8) &amp;mdash; a char, unsigned char, or std::byte type.</source>
          <target state="translated">（11.8）&amp;mdash; char、unsigned char、またはstd :: byteタイプ。</target>
        </trans-unit>
        <trans-unit id="a6ae166834f7950f65a4a0e2017c5da76406a59c" translate="yes" xml:space="preserve">
          <source>(GCC appears somewhat inconsistent in its ability to give aliasing warnings, sometimes giving us a friendly warning and sometimes not.)</source>
          <target state="translated">(GCC はエイリアシング警告を出す能力にやや一貫性がないように見え、親切な警告を出すこともあれば、そうでないこともある)。</target>
        </trans-unit>
        <trans-unit id="dbb9367a16f124a22e627722082fe38579194d80" translate="yes" xml:space="preserve">
          <source>(save from CPU register to the memory and load from the memory to the CPU register).</source>
          <target state="translated">CPUレジスタからメモリへのセーブ、メモリからCPUレジスタへのロード)。</target>
        </trans-unit>
        <trans-unit id="9cc95d274f988057b458e8bbc62596b0bfd62e5a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;This article&lt;/a&gt; should help you understand the issue in full detail.</source>
          <target state="translated">&lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;この記事&lt;/a&gt;は、問題を完全に理解するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="db4e37199ce7a26e530372127092a913fd8e827e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_punning&quot;&gt;Type punning&lt;/a&gt; via pointer casts (as opposed to using a union) is a major example of breaking strict aliasing.</source>
          <target state="translated">（ユニオンを使用するのではなく）ポインターキャストによる&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_punning&quot;&gt;型パンニング&lt;/a&gt;は、厳密なエイリアシングを解除する主な例です。</target>
        </trans-unit>
        <trans-unit id="0f648f766517c522d736c21acf06a661385f3de0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://twitter.com/shafikyaghmour/status/957702383810658304&quot;&gt;gcc/clang has an extension&lt;/a&gt; and &lt;a href=&quot;https://gcc.gnu.org/ml/gcc/2003-10/msg00184.html&quot;&gt;also&lt;/a&gt; that allows assigning &lt;em&gt;unsigned int*&lt;/em&gt; to &lt;em&gt;int*&lt;/em&gt; even though they are not compatible types.</source>
          <target state="translated">&lt;a href=&quot;https://twitter.com/shafikyaghmour/status/957702383810658304&quot;&gt;gcc / clangには拡張機能&lt;/a&gt;があり、互換性のない型であっても&lt;em&gt;unsigned int *&lt;/em&gt;を&lt;em&gt;int *に&lt;/em&gt;割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="01b0f2dd13e6673c4bc6a8d017a4466b2eae23b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;a type similar (as defined in 4.4) to the dynamic type of the object,&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;オブジェクトの動的タイプに類似したタイプ（4.4で定義）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57fbd0f13eb9b51fcea11056b2017576feba86c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Beginner beware&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;初心者は注意してください&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="196bcd48f2a7e66de892eaf11cbe2d9cab7cc750" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11&lt;/strong&gt; and &lt;strong&gt;C++14&lt;/strong&gt; wording (changes emphasized):</source>
          <target state="translated">&lt;strong&gt;C ++ 11&lt;/strong&gt;および&lt;strong&gt;C ++ 14の&lt;/strong&gt;表現（変更を強調）：</target>
        </trans-unit>
        <trans-unit id="f83c36172e98a9c03aa145ce635aa0f76fe4904e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For example&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;たとえば、&lt;/strong&gt;次のとおりです。</target>
        </trans-unit>
        <trans-unit id="decc5376f183538b5fe7739f22bb8eb4f49596b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So how do I get around this?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;どうすればこれを回避できますか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d25be7fbd9e3672275a9ff1b70188a72553da35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;save&lt;/strong&gt;&lt;code&gt;b&lt;/code&gt; and &lt;strong&gt;reload&lt;/strong&gt;&lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; を&lt;strong&gt;保存し、&lt;/strong&gt; aを&lt;strong&gt;リロード&lt;/strong&gt; &lt;code&gt;a&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="b61bc9f66e53d7bd6c6cb170cf39fc609c4079f3" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt; 73) or 88)&lt;/sup&gt; The intent of this list is to specify those circumstances in which an object may or may not be aliased.</source>
          <target state="translated">&lt;sup&gt;73）または88）&lt;/sup&gt;このリストの目的は、オブジェクトがエイリアスされる場合とされない場合がある状況を指定することです。</target>
        </trans-unit>
        <trans-unit id="e6cbeecf47c0b79acdf7d07e84cc9b5e6b8e569d" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt; The types that C 2011 6.5 7 allows an lvalue to access are:</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; C 2011 6.5 7が左辺値にアクセスを許可するタイプは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="297342af50ab471e2b4d57de560278e8dd7b88e6" translate="yes" xml:space="preserve">
          <source>A glvalue is an expression whose evaluation determines the identity of
  an object, (...snip)</source>
          <target state="translated">glvalueは、その評価がオブジェクトの同一性を決定する式です。</target>
        </trans-unit>
        <trans-unit id="8e98f088bc239e2fa9b5abf6318d366712f8212b" translate="yes" xml:space="preserve">
          <source>A typical situation you encounter strict aliasing problems is when overlaying a struct (like a device/network msg) onto a buffer of the word size of your system (like a pointer to &lt;code&gt;uint32_t&lt;/code&gt;s or &lt;code&gt;uint16_t&lt;/code&gt;s). When you overlay a struct onto such a buffer, or a buffer onto such a struct through pointer casting you can easily violate strict aliasing rules.</source>
          <target state="translated">厳密なエイリアシングの問題が発生する一般的な状況は、システムのワードサイズのバッファー（ &lt;code&gt;uint32_t&lt;/code&gt; sまたは &lt;code&gt;uint16_t&lt;/code&gt; sへのポインターなど）に構造体（デバイス/ネットワークメッセージなど）をオーバーレイする場合です。 このようなバッファーに構造体をオーバーレイするか、ポインターのキャストを介してそのような構造体にバッファーをオーバーレイすると、厳密なエイリアス規則に簡単に違反する可能性があります。</target>
        </trans-unit>
        <trans-unit id="a9dc4be413dae8efeb97923c710712f4df67ca23" translate="yes" xml:space="preserve">
          <source>According to the C89 rationale, the authors of the Standard did not want to require that compilers given code like:</source>
          <target state="translated">C89の理論的根拠によると、標準の著者は、コンパイラがコードのように与えられたコードを要求することを望んでいませんでした。</target>
        </trans-unit>
        <trans-unit id="a1e350b0f7d46240fa54c7300839cc8197daad50" translate="yes" xml:space="preserve">
          <source>After reading many of the answers, I feel the need to add something:</source>
          <target state="translated">多くの回答を読んで、何かを付け加える必要性を感じています。</target>
        </trans-unit>
        <trans-unit id="6ef0f09f189d7f527f3216249c8e7b8d66de7464" translate="yes" xml:space="preserve">
          <source>Also from &lt;a href=&quot;http://eel.is/c++draft/basic.lval#1.1&quot;&gt;the definition of glvalue&lt;/a&gt;</source>
          <target state="translated">また&lt;a href=&quot;http://eel.is/c++draft/basic.lval#1.1&quot;&gt;、glvalueの定義&lt;/a&gt;から</target>
        </trans-unit>
        <trans-unit id="4f9a518e55a06337a7d067a77249a742f4d1724e" translate="yes" xml:space="preserve">
          <source>Also the &lt;strong&gt;C&lt;/strong&gt; wording (C99; ISO/IEC 9899:1999 6.5/7; the exact same wording is used in ISO/IEC 9899:2011 &amp;sect;6.5 &amp;para;7):</source>
          <target state="translated">また、 &lt;strong&gt;Cの&lt;/strong&gt;文言（C99; ISO / IEC 9899：1999 6.5 / 7;まったく同じ文言がISO / IEC 9899：2011&amp;sect;6.5&amp;para;7でも使用されています）：</target>
        </trans-unit>
        <trans-unit id="2985fc30fb7352cc194dd6d4058223c195eec0a4" translate="yes" xml:space="preserve">
          <source>Although clang allows these flags it apparently does not actually implement the warnings.</source>
          <target state="translated">clangはこれらのフラグを許可していますが、実際には警告を実装していないようです。</target>
        </trans-unit>
        <trans-unit id="26a14dfaa9199838addf36131d31232c359747d1" translate="yes" xml:space="preserve">
          <source>An object shall have its stored value accessed only by an lvalue
  expression that has one of the following types &lt;sup&gt; 73) or 88)&lt;/sup&gt;:</source>
          <target state="translated">オブジェクトは、次のタイプ&lt;sup&gt;73）または88）のいずれか&lt;/sup&gt;を持つ左辺値式によってのみアクセスされる格納された値を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="e89f2c7845b5b0b9f99fb0df9e776bf697055362" translate="yes" xml:space="preserve">
          <source>An object shall have its stored value accessed only by an lvalue expression that has one of the following types:&lt;sup&gt;88)&lt;/sup&gt;
  &amp;mdash; a type compatible with the effective type of the object,</source>
          <target state="translated">オブジェクトは、次のタイプのいずれかを持つ左辺値式によってのみアクセスされる格納された値を持つものとします&lt;sup&gt;。88）&lt;/sup&gt; &amp;mdash;オブジェクトの有効なタイプと互換性のあるタイプ。</target>
        </trans-unit>
        <trans-unit id="8d09e17c7fa91deb529a7711698d487fd214027c" translate="yes" xml:space="preserve">
          <source>And rewrote our earlier loop to take advantage of this convenient function</source>
          <target state="translated">そして、この便利な関数を利用するために、以前のループを書き直しました。</target>
        </trans-unit>
        <trans-unit id="0f5d219e3940c12eb3895d8e75d8bb99c681600b" translate="yes" xml:space="preserve">
          <source>Another tool we have available to us is ASan which can catch misaligned loads and stores. Although these are not directly strict aliasing violations they are a common result of strict aliasing violations. For example the following cases will generate runtime errors when built with clang using &lt;strong&gt;-fsanitize=address&lt;/strong&gt;</source>
          <target state="translated">私たちが利用できるもう1つのツールは、整列されていないロードとストアをキャッチできるASanです。 これらは直接の厳密なエイリアシング違反ではありませんが、厳密なエイリアシング違反の一般的な結果です。 たとえば、次の場合、 &lt;strong&gt;-fsanitize = address&lt;/strong&gt;を使用してclangでビルドするとランタイムエラーが発生します</target>
        </trans-unit>
        <trans-unit id="c9f941d78e7fc8fb359e7fb4d08c3662e735d087" translate="yes" xml:space="preserve">
          <source>As addendum to what Doug T. already wrote, here
is a simple test case which probably triggers it with gcc :</source>
          <target state="translated">Doug T.がすでに書いていることの補足として、ここには gcc でおそらくトリガーとなる簡単なテストケースがあります。</target>
        </trans-unit>
        <trans-unit id="10728f2d66e27dcf628afc3fd6a3a60abc38f514" translate="yes" xml:space="preserve">
          <source>As we have seen earlier this is not a valid aliasing, so we are invoking undefined behavior. But traditionally compilers did not take advantage of strict aliasing rules and this type of code usually just worked, developers have unfortunately gotten used to doing things this way. A common alternate method for type punning is through unions, which is valid in C but &lt;em&gt;undefined behavior&lt;/em&gt; in C++ (&lt;a href=&quot;https://wandbox.org/permlink/oOf9bPlcWDYrYqPF&quot;&gt;see live example&lt;/a&gt;):</source>
          <target state="translated">これまで見てきたように、これは有効なエイリアスではないため、未定義の動作を呼び出しています。 しかし、伝統的にコンパイラーは厳密なエイリアシング規則を利用せず、このタイプのコードは通常は機能しましたが、開発者は残念ながらこの方法で慣れてきました。 タイプパニングの一般的な代替方法は、Cで有効であるが、C ++では&lt;em&gt;未定義の動作&lt;/em&gt;である共用体を使用する方法です（実際の&lt;a href=&quot;https://wandbox.org/permlink/oOf9bPlcWDYrYqPF&quot;&gt;例を参照&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="31703841448c40ed3e7edbb4a235ea2f940df90f" translate="yes" xml:space="preserve">
          <source>At a sufficient optimization level any decent modern compiler generates identical code to the previously mentioned &lt;strong&gt;reinterpret_cast&lt;/strong&gt; method or &lt;em&gt;union&lt;/em&gt; method for &lt;em&gt;type punning&lt;/em&gt;. Examining the generated code we see it uses just register mov (&lt;a href=&quot;https://godbolt.org/g/BfZGwX&quot;&gt;live Compiler Explorer Example&lt;/a&gt;).</source>
          <target state="translated">十分な最適化レベルでは、適切な最新のコンパイラーは、前述の&lt;strong&gt;reinterpret_cast&lt;/strong&gt;メソッドまたは&lt;em&gt;型パンニング&lt;/em&gt;用の&lt;em&gt;union&lt;/em&gt;メソッドと同じコードを生成します。 生成されたコードを調べると、レジスターmov（ &lt;a href=&quot;https://godbolt.org/g/BfZGwX&quot;&gt;ライブコンパイラエクスプローラーの例&lt;/a&gt; ）のみを使用していることがわかります。</target>
        </trans-unit>
        <trans-unit id="6b40922067f3852129b802e5ea9ad27f2b9e841c" translate="yes" xml:space="preserve">
          <source>C++20 and bit_cast</source>
          <target state="translated">C++20とbit_cast</target>
        </trans-unit>
        <trans-unit id="d0218f26139d8420689d4b0863aae73b36ebb0d3" translate="yes" xml:space="preserve">
          <source>Catching Strict Aliasing Violations</source>
          <target state="translated">厳格なエイリアス違反の摘発</target>
        </trans-unit>
        <trans-unit id="1770c1d3a13b57ff8c334a5bc651892e9928636f" translate="yes" xml:space="preserve">
          <source>Compile with &lt;code&gt;gcc -O2 -o check check.c&lt;/code&gt; .
Usually (with most gcc versions I tried) this outputs &quot;strict aliasing problem&quot;, because the compiler assumes that &quot;h&quot; cannot be the same address as &quot;k&quot; in the &quot;check&quot; function. Because of that the compiler optimizes the &lt;code&gt;if (*h == 5)&lt;/code&gt; away and always calls the printf.</source>
          <target state="translated">&lt;code&gt;gcc -O2 -o check check.c&lt;/code&gt; でコンパイルします。 通常（私が試したほとんどのgccバージョンでは）、これは「厳密なエイリアシングの問題」を出力します。これは、コンパイラが「チェック」関数で「h」を「k」と同じアドレスにすることはできないためです。 そのため、コンパイラーは &lt;code&gt;if (*h == 5)&lt;/code&gt; 最適化し、常にprintfを呼び出します。</target>
        </trans-unit>
        <trans-unit id="53c22f9842dfbbfd7ce868f16027320909192af5" translate="yes" xml:space="preserve">
          <source>Defect Report #28 states that the program invokes Undefined Behavior because the action of writing a union member of type &quot;double&quot; and reading one of type &quot;int&quot; invokes Implementation-Defined behavior.  Such reasoning is nonsensical, but forms the basis for the Effective Type rules which needlessly complicate the language while doing nothing to address the original problem.</source>
          <target state="translated">欠陥レポート#28では、&quot;double &quot;型のユニオンメンバを書き、&quot;int &quot;型のユニオンメンバを読み込む動作が実装定義動作を呼び出すため、プログラムは未定義動作を呼び出すと述べられています。このような推論は非論理的ですが、元々の問題を解決するためには何もしていないのに言語を不必要に複雑にしているEffective Type規則の基礎を形成しています。</target>
        </trans-unit>
        <trans-unit id="7470e0123159d8ce20fb052f5950c0742dcfc961" translate="yes" xml:space="preserve">
          <source>Finally there is &lt;a href=&quot;https://www.youtube.com/watch?v=vAXJeN7k32Y&quot;&gt;TySan&lt;/a&gt; which is currently in development. This sanitizer adds type checking information in a shadow memory segment and checks accesses to see if they violate aliasing rules. The tool potentially should be able to catch all aliasing violations but may have a large run-time overhead.</source>
          <target state="translated">最後に、現在開発中の&lt;a href=&quot;https://www.youtube.com/watch?v=vAXJeN7k32Y&quot;&gt;TySan&lt;/a&gt;があります。 このサニタイザは、シャドウメモリセグメントに型チェック情報を追加し、アクセスをチェックして、エイリアスルールに違反していないかどうかを確認します。 このツールは、すべてのエイリアス違反をキャッチできる可能性がありますが、実行時のオーバーヘッドが大きくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="40e31a210a1913fd0a8b28b892780996d154c70d" translate="yes" xml:space="preserve">
          <source>Footnote</source>
          <target state="translated">Footnote</target>
        </trans-unit>
        <trans-unit id="f2e444e508c3340837f99f92afb5d8d282d725cc" translate="yes" xml:space="preserve">
          <source>For C we have all the tools already covered and we also have tis-interpreter, a static analyzer that exhaustively analyzes a program for a large subset of the C language. Given a C verions of the  earlier example where using &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; misses one case (&lt;a href=&quot;https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY&quot;&gt;see it live&lt;/a&gt;)</source>
          <target state="translated">Cについては、すべてのツールがすでにカバーされており、C言語の大部分のプログラムを徹底的に分析する静的アナライザーであるtis-interpreterもあります。 -fstrict &lt;strong&gt;-aliasing&lt;/strong&gt;を使用すると1つのケースが見落とされる前の例のCバージョンが指定されているとします（ &lt;a href=&quot;https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY&quot;&gt;ライブで参照してください&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="9ead309bf16c2a5aba6251f6671c48b68c88f5ee" translate="yes" xml:space="preserve">
          <source>For those who are interested here is the x64 assembler code, produced by gcc 4.6.3, running on ubuntu 12.04.2 for x64:</source>
          <target state="translated">興味のある方のために、ここではgcc 4.6.3によって生成されたx64アセンブラのコードがあります。</target>
        </trans-unit>
        <trans-unit id="eef7c5809b1e5a8ae1c2904d803bf0988e0597e2" translate="yes" xml:space="preserve">
          <source>From the article:</source>
          <target state="translated">記事より。</target>
        </trans-unit>
        <trans-unit id="c9937d5f217a938cee9523df51e9f8f215d05426" translate="yes" xml:space="preserve">
          <source>Had Defect Report 028 said the original example invoked UB because of the overlap between the creation and use of the two pointers, that would have made things a lot more clear without having to add &quot;Effective Types&quot; or other such complexity.</source>
          <target state="translated">Defect Report 028 に、元の例が 2 つのポインタの作成と使用が重複しているために UB を呼び出したと書いてあれば、&quot;Effective Types&quot; などの複雑なものを追加しなくても、もっとはっきりしたものになったでしょう。</target>
        </trans-unit>
        <trans-unit id="cacd74e6fcf654b36a1d1e2975d8c5a7ad506007" translate="yes" xml:space="preserve">
          <source>Here, there is an aliasing conflict between &lt;code&gt;p&lt;/code&gt; and the access to &lt;code&gt;s.x&lt;/code&gt; on the marked line because at that point in execution another reference exists &lt;em&gt;that will be used to access the same storage&lt;/em&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;p&lt;/code&gt; とマークされた行の &lt;code&gt;s.x&lt;/code&gt; へのアクセスとの間にエイリアシングの競合があります。その時点で&lt;em&gt;、同じストレージへのアクセスに使用される&lt;/em&gt;別の参照が存在する&lt;em&gt;ためです&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="33dc7f4dd2ec6bc77310a0b059a423d8f65352d8" translate="yes" xml:space="preserve">
          <source>How do we Type Pun correctly?</source>
          <target state="translated">どうすれば正しいタイプパンができるのか?</target>
        </trans-unit>
        <trans-unit id="4e0983c0e8fab722fa11f33077148a6fa369c40d" translate="yes" xml:space="preserve">
          <source>If a compiler notices that two pointers point to different types (for example, an &lt;code&gt;int *&lt;/code&gt; and a &lt;code&gt;float *&lt;/code&gt;), it will assume the memory address is different and it &lt;strong&gt;will not&lt;/strong&gt; protect against memory address collisions, resulting in faster machine code.</source>
          <target state="translated">2つのポインターが異なる型（たとえば、 &lt;code&gt;int *&lt;/code&gt; と &lt;code&gt;float *&lt;/code&gt; ）を指していることにコンパイラーが気付いた場合、コンパイラーはメモリー・アドレスが異なると想定し、メモリー・アドレスの衝突から保護し&lt;strong&gt;ない&lt;/strong&gt;ため、マシン・コードが高速になります。</target>
        </trans-unit>
        <trans-unit id="e33bcaeae41be78c102c11d9ce6bff1ab9700bea" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through a &lt;em&gt;glvalue&lt;/em&gt; of other than one of the following types the behavior is undefined:</source>
          <target state="translated">プログラムが次のタイプのいずれか以外の&lt;em&gt;glvalue&lt;/em&gt;を介してオブジェクトの格納された値にアクセスしようとした場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="a1ad9d68fd05386372885ebe000df27028379d8d" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:&lt;sup&gt;63&lt;/sup&gt;
  (11.1) &amp;mdash; the dynamic type of the object,</source>
          <target state="translated">プログラムが次のタイプのいずれか以外のglvalueを介してオブジェクトの格納された値にアクセスしようとした場合の動作は未定義です。63（11.1）&amp;mdash;オブジェクトの動的タイプ、</target>
        </trans-unit>
        <trans-unit id="186894b2031b450693c2e08ce7146e1a9f218d92" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined:</source>
          <target state="translated">プログラムが、以下のいずれかの型以外の lvalue を使用してオブジェクトの保存された値にアクセスしようとすると、動作は未定義になります。</target>
        </trans-unit>
        <trans-unit id="c58ff6992c8aa3747c4710bda431e84ee2b32d03" translate="yes" xml:space="preserve">
          <source>If data in two different CPU registers will be written to the same memory space, &lt;strong&gt;we can't predict which data will &quot;survive&quot;&lt;/strong&gt; when we code in C.</source>
          <target state="translated">2つの異なるCPUレジスタのデータが同じメモリ空間に書き込まれる場合、Cでコーディングするときに&lt;strong&gt;どのデータが「存続」するかを予測できません&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a0013265978c8a291d1a659ebe89febc56bb358" translate="yes" xml:space="preserve">
          <source>If the code were changed slightly...</source>
          <target state="translated">コードが少し変わっていたら</target>
        </trans-unit>
        <trans-unit id="0b4c6074b02b2e16ccba9dd1023db8c912e4726d" translate="yes" xml:space="preserve">
          <source>In C and C++ aliasing has to do with what expression types we are allowed to access stored values through. In both C and C++ the standard specifies which expression types are allowed to alias which types. The compiler and optimizer are allowed to assume we follow the aliasing rules strictly, hence the term &lt;em&gt;strict aliasing rule&lt;/em&gt;. If we attempt to access a value using a type not allowed it is classified as &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/ub&quot;&gt;undefined behavior&lt;/a&gt;(&lt;strong&gt;UB&lt;/strong&gt;). Once we have undefined behavior all bets are off, the results of our program are no longer reliable.</source>
          <target state="translated">CおよびC ++では、エイリアシングは、格納された値へのアクセスを許可されている式のタイプに関係しています。 CとC ++の両方で、標準では、どの型にエイリアスを付けることができる式の型が指定されています。 コンパイラとオプティマイザは、エイリアシングルールに厳密に従うことを前提としています。そのため、 &lt;em&gt;厳密なエイリアシングルール&lt;/em&gt;という用語を使用します。 許可されていない型を使用して値にアクセスしようとすると、 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/ub&quot;&gt;未定義の動作&lt;/a&gt; （ &lt;strong&gt;UB&lt;/strong&gt; ）として分類されます。 未定義の動作が発生すると、すべての賭けが無効になり、プログラムの結果は信頼できなくなります。</target>
        </trans-unit>
        <trans-unit id="5c8e94cbd15bdd54a4fb204f2d1514b6f794ce32" translate="yes" xml:space="preserve">
          <source>In C++20 we may gain &lt;strong&gt;bit_cast&lt;/strong&gt; (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html&quot;&gt;implementation available in link from proposal&lt;/a&gt;) which gives a simple and safe way to type-pun as well as being usable in a constexpr context.</source>
          <target state="translated">C ++ 20では、 &lt;strong&gt;bit_cast&lt;/strong&gt; （ &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html&quot;&gt;提案からのリンクで利用可能な実装）&lt;/a&gt;を得ることができます。これにより、constexprコンテキストで使用できるだけでなく、タイプパンするシンプルで安全な方法が提供されます。</target>
        </trans-unit>
        <trans-unit id="30d64c522aac604d7e48c4556b8d77b5be2eeb6e" translate="yes" xml:space="preserve">
          <source>In assembly, where we code the loading and unloading of CPU registers manually, we will know which data remains intact. But C (thankfully) abstracts this detail away.</source>
          <target state="translated">アセンブリでは、CPUレジスタのロードとアンロードを手動でコーディングすると、どのデータがそのまま残っているかがわかります。しかし、Cは(ありがたいことに)この詳細を抽象化しています。</target>
        </trans-unit>
        <trans-unit id="1098f88dd457b5be2f2059df57bcf4338d706f24" translate="yes" xml:space="preserve">
          <source>In fact, by adding the &lt;code&gt;restrict&lt;/code&gt; keyword, the whole function could be optimized to:</source>
          <target state="translated">実際、 &lt;code&gt;restrict&lt;/code&gt; キーワードを追加すると、関数全体を次のように最適化できます。</target>
        </trans-unit>
        <trans-unit id="f5757f1784e296249565c7c4929c37f6183ec27c" translate="yes" xml:space="preserve">
          <source>In order to handle the case in which &lt;code&gt;a == b&lt;/code&gt; (both pointers point to the same memory), we need to order and test the way we load data from the memory to the CPU registers, so the code might end up like this:</source>
          <target state="translated">&lt;code&gt;a == b&lt;/code&gt; （両方のポインターが同じメモリを指す）の場合を処理するには、メモリからCPUレジスタにデータをロードする方法を順序付けてテストする必要があるため、コードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="edbd3b6b40a8cde551f4ffba070d64d6c6313a52" translate="yes" xml:space="preserve">
          <source>In the case where &lt;em&gt;To&lt;/em&gt; and &lt;em&gt;From&lt;/em&gt; types don't have the same size, it requires us to use an intermediate struct15. We will use a struct containing a &lt;strong&gt;sizeof( unsigned int )&lt;/strong&gt; character array (&lt;em&gt;assumes 4 byte unsigned int&lt;/em&gt;) to be the &lt;em&gt;From&lt;/em&gt; type and &lt;em&gt;unsigned int&lt;/em&gt; as the &lt;em&gt;To&lt;/em&gt; type.:</source>
          <target state="translated">&lt;em&gt;To&lt;/em&gt;型と&lt;em&gt;From&lt;/em&gt;型のサイズが同じでない場合は、中間のstruct15を使用する必要があります。 &lt;strong&gt;sizeof（unsigned int）&lt;/strong&gt;文字配列（ &lt;em&gt;4バイトのunsigned intを想定&lt;/em&gt; &lt;strong&gt;）&lt;/strong&gt;を含む構造体を&lt;em&gt;From&lt;/em&gt;タイプとし、 &lt;em&gt;unsigned int&lt;/em&gt;を&lt;em&gt;To&lt;/em&gt;タイプとして使用します。</target>
        </trans-unit>
        <trans-unit id="d116eeee6f567bfeb6ee6948778e1441846b7681" translate="yes" xml:space="preserve">
          <source>In the function &lt;strong&gt;foo&lt;/strong&gt; we take an &lt;em&gt;int*&lt;/em&gt; and a &lt;em&gt;float*&lt;/em&gt;, in this example we call &lt;strong&gt;foo&lt;/strong&gt; and set both parameters to point to the same memory location which in this example contains an &lt;em&gt;int&lt;/em&gt;. Note, the &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; is telling the compiler to treat the the expression as if it had the type specificed by its template parameter. In this case we are telling it to treat the expression &lt;strong&gt;&amp;amp;x&lt;/strong&gt; as if it had type &lt;em&gt;float*&lt;/em&gt;. We may naively expect the result of the second &lt;strong&gt;cout&lt;/strong&gt; to be &lt;strong&gt;0&lt;/strong&gt; but with optimization enabled using &lt;strong&gt;-O2&lt;/strong&gt; both gcc and clang produce the following result:</source>
          <target state="translated">関数&lt;strong&gt;foo&lt;/strong&gt;では、 &lt;em&gt;int *&lt;/em&gt;と&lt;em&gt;float *&lt;/em&gt;を使用します。この例では、 &lt;strong&gt;foo&lt;/strong&gt;を呼び出して、両方のパラメーターを、この例では&lt;em&gt;intを&lt;/em&gt;含む同じメモリー位置を指すように設定します。 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt;は、テンプレートパラメーターで指定された型があるかのように式を処理するようコンパイラーに指示していることに注意してください。 この場合、式&lt;strong&gt;＆x&lt;/strong&gt;を&lt;em&gt;float *&lt;/em&gt;型であるかのように扱うように指示しています。 &lt;strong&gt;単純&lt;/strong&gt;に2番目の&lt;strong&gt;coutの&lt;/strong&gt;結果が&lt;strong&gt;0&lt;/strong&gt;になると予想する場合があり&lt;strong&gt;ます&lt;/strong&gt;が、 &lt;strong&gt;-O2&lt;/strong&gt;を使用して最適化を有効にすると、gccとclangの両方が次の結果を生成します。</target>
        </trans-unit>
        <trans-unit id="d68abdd18fdbebaf82ef26f4a744ddcd23eee685" translate="yes" xml:space="preserve">
          <source>It is unfortunate that we need this intermediate type but that is the current constraint of &lt;strong&gt;bit_cast&lt;/strong&gt;.</source>
          <target state="translated">この中間型が必要なのは残念ですが、それが現在の&lt;strong&gt;bit_castの&lt;/strong&gt;制約です。</target>
        </trans-unit>
        <trans-unit id="da92ddda51dcc47ff0f56cb81c8d27a13de9b35f" translate="yes" xml:space="preserve">
          <source>Keep in mind, if you think the example is contrived, this might even happen if you're passing a buffer to another function doing the sending for you, if instead you have.</source>
          <target state="translated">もしこの例が作り話だと思うのであれば、バッファを別の関数に渡して送信している場合にもこのようなことが起こる可能性があることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="aa2a2cd3b185c908c2467f71930ddb0e035406e3" translate="yes" xml:space="preserve">
          <source>Let's look at some examples, then we can talk about exactly what the standard(s) say, examine some further examples and then see how to avoid strict aliasing and catch violations we missed. Here is an example that should not be surprising (&lt;a href=&quot;https://wandbox.org/permlink/7sCJTAyrifZ0zfFA&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">いくつかの例を見てみましょう。次に、標準の発言について正確に話し、さらにいくつかの例を検討し、厳密なエイリアシングを回避し、見逃した違反をキャッチする方法を確認します。 これは驚くべきことではない例です（ &lt;a href=&quot;https://wandbox.org/permlink/7sCJTAyrifZ0zfFA&quot;&gt;実例&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="036ae8cbf7c3814fcac323366fb44ffbfacfa142" translate="yes" xml:space="preserve">
          <source>Lets assume the following function:</source>
          <target state="translated">以下のような機能を想定してみましょう。</target>
        </trans-unit>
        <trans-unit id="6866b7efbb6193426e6184afeb038e84825105d8" translate="yes" xml:space="preserve">
          <source>Memory access can be expensive (performance wise), which is why &lt;strong&gt;data is manipulated in CPU registers&lt;/strong&gt; before being written back to the physical memory.</source>
          <target state="translated">メモリアクセスはコストがかかる（パフォーマンスに関して）場合があるため、物理メモリに書き戻す前に&lt;strong&gt;データがCPUレジスタで操作&lt;/strong&gt;されます。</target>
        </trans-unit>
        <trans-unit id="9992043f68467a20f1d79f1ccb74a9265be5e20c" translate="yes" xml:space="preserve">
          <source>Much of the problem is a result of Defect Report #028, which asked about the behavior of a program like:</source>
          <target state="translated">問題の多くは、欠陥報告書#028の結果です。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="5650248b0b69558ceb303fc582535c5dbae34409" translate="yes" xml:space="preserve">
          <source>Note the definition of indirection (&lt;a href=&quot;http://eel.is/c++draft/expr.unary.op#def:indirection&quot;&gt;* operator&lt;/a&gt;):</source>
          <target state="translated">間接指定（ &lt;a href=&quot;http://eel.is/c++draft/expr.unary.op#def:indirection&quot;&gt;*演算子&lt;/a&gt; ）の定義に注意してください。</target>
        </trans-unit>
        <trans-unit id="00e406f7a5b6352740c9e91b4d2959a865ade69d" translate="yes" xml:space="preserve">
          <source>Now, by satisfying the Strict Aliasing rule, step 3 can be avoided and the code will run significantly faster.</source>
          <target state="translated">これで、厳密なエイリアシングルールを満たすことで、ステップ3を避けることができ、コードの実行速度が大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="24f4a3365263f6701ca3e6f9cc300671fef25d11" translate="yes" xml:space="preserve">
          <source>Now, to the Rule-Book</source>
          <target state="translated">さて、ルールブックへ</target>
        </trans-unit>
        <trans-unit id="00f2110e4b85aedc83fe7286d38033b5fadad084" translate="yes" xml:space="preserve">
          <source>Preliminary examples</source>
          <target state="translated">予備的な例</target>
        </trans-unit>
        <trans-unit id="1a68967890ea62e6416814f2cd9ae705194f7f5a" translate="yes" xml:space="preserve">
          <source>Since two pointers can point to the same location in the memory, this could result in &lt;strong&gt;complex code that handles possible collisions&lt;/strong&gt;.</source>
          <target state="translated">2つのポインタがメモリ内の同じ場所を指すことができるため、これにより、 &lt;strong&gt;衝突の可能性を処理&lt;/strong&gt;する&lt;strong&gt;複雑なコードが生成される可能性があり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e831ce62bacf79dafcd6bc9e83656cfee8fb782d" translate="yes" xml:space="preserve">
          <source>So basically if you have an &lt;code&gt;int*&lt;/code&gt; pointing to some memory containing an &lt;code&gt;int&lt;/code&gt; and then you point a &lt;code&gt;float*&lt;/code&gt; to that memory and use it as a &lt;code&gt;float&lt;/code&gt; you break the rule. If your code does not respect this, then the compiler's optimizer will most likely break your code.</source>
          <target state="translated">つまり、基本的に、 &lt;code&gt;int*&lt;/code&gt; を含むメモリを指すint *があり、 &lt;code&gt;float*&lt;/code&gt; をそのメモリにポイントし、それを &lt;code&gt;float&lt;/code&gt; として使用する場合、ルールに違反します。 コードがこれを尊重しない場合、コンパイラのオプティマイザがコードを破壊する可能性が高くなります。</target>
        </trans-unit>
        <trans-unit id="e527630d421fb5eeeebbd1a1fc94426badbe336a" translate="yes" xml:space="preserve">
          <source>So in any well defined program trace, a glvalue refers to an object. &lt;strong&gt;So the so called strict aliasing rule doesn't apply, ever.&lt;/strong&gt; This may not be what the designers wanted.</source>
          <target state="translated">したがって、明確に定義されたプログラムトレースでは、glvalueはオブジェクトを参照します。 &lt;strong&gt;したがって、いわゆる厳密なエイリアシングルールは適用されません。&lt;/strong&gt; これは、設計者が望んでいたものとは異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="deed8318c0841e594ef317b02788fe411e71c755" translate="yes" xml:space="preserve">
          <source>So in this kind of setup, if I want to send a message to something I'd have to have two incompatible pointers pointing to the same chunk of memory. I might then naively code something like this (on a system with &lt;code&gt;sizeof(int) == 2&lt;/code&gt;):</source>
          <target state="translated">したがって、この種の設定では、何かにメッセージを送信したい場合、同じメモリのチャンクを指す2つの互換性のないポインタが必要になります。 それから私はこのようなものを単純にコーディングするかもしれません（ &lt;code&gt;sizeof(int) == 2&lt;/code&gt; システムで）：</target>
        </trans-unit>
        <trans-unit id="aafc604e71041d21e6cb4b116236a68fac502d6a" translate="yes" xml:space="preserve">
          <source>So the if condition is completely gone from the assembler code.</source>
          <target state="translated">そのため、アセンブラのコードからif条件が完全に消えています。</target>
        </trans-unit>
        <trans-unit id="be497017b70114a5fa54de0086695c60b70ce08f" translate="yes" xml:space="preserve">
          <source>Sometimes we want to circumvent the type system and interpret an object as a different type. This is called &lt;em&gt;type punning&lt;/em&gt;, to reinterpret a segment of memory as another type. &lt;em&gt;Type punning&lt;/em&gt; is useful for tasks that want access to the underlying representation of an object to view, transport or manipulate. Typical areas we find type punning being used are compilers, serialization, networking code, etc&amp;hellip;</source>
          <target state="translated">型システムを回避して、オブジェクトを別の型として解釈したい場合があります。 これは&lt;em&gt;タイプパニング&lt;/em&gt;と呼ばれ、メモリのセグメントを別のタイプとして再解釈します。 &lt;em&gt;型パンニング&lt;/em&gt;は、オブジェクトの基になる表現にアクセスして表示、転送、または操作する必要があるタスクに役立ちます。 タイプパニングが使用されているのがわかる典型的な領域は、コンパイラ、シリアル化、ネットワークコードなどです。</target>
        </trans-unit>
        <trans-unit id="0e41cb1a9e14feeabe231350d4a98b43b5438b1e" translate="yes" xml:space="preserve">
          <source>Step 3 is very slow because it needs to access the physical memory. However, it's required to protect against instances where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; point to the same memory address.</source>
          <target state="translated">手順3は物理メモリにアクセスする必要があるため、非常に低速です。 ただし、 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; が同じメモリアドレスを指すインスタンスから保護する必要があります。</target>
        </trans-unit>
        <trans-unit id="6950bbb2a5fc815374e2b4c9fe07f848dcde484e" translate="yes" xml:space="preserve">
          <source>Strict aliasing (which I'll describe in a bit) &lt;strong&gt;is important because&lt;/strong&gt;:</source>
          <target state="translated">厳密なエイリアス（少し説明します） &lt;strong&gt;は重要です&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b097276866172c8f0649d49560868d6d4cb3def" translate="yes" xml:space="preserve">
          <source>Strict aliasing doesn't refer only to pointers, it affects references as well, I wrote a paper about it for the boost developer wiki and it was so well received that I turned it into a page on my consulting web site.  It explains completely what it is, why it confuses people so much and what to do about it. &lt;a href=&quot;http://dbp-consulting.com/tutorials/StrictAliasing.html&quot;&gt;Strict Aliasing White Paper&lt;/a&gt;.  In particular it explains why unions are risky behavior for C++, and why using memcpy is the only fix portable across both C and C++.  Hope this is helpful.</source>
          <target state="translated">厳密なエイリアシングはポインターだけを参照するのではなく、参照にも影響します。ブースト開発者wikiについてそれについて論文を書きましたが、非常に評判が良かったので、コンサルティングWebサイトのページに変えました。 それはそれが何であるか、それが人々をそれほど混乱させる理由とそれについて何をすべきかを完全に説明しています。 &lt;a href=&quot;http://dbp-consulting.com/tutorials/StrictAliasing.html&quot;&gt;厳密なエイリアシングホワイトペーパー&lt;/a&gt; 。 特に、ユニオンがC ++にとって危険な動作である理由、およびmemcpyの使用がCとC ++の両方で移植可能な唯一の修正である理由を説明しています。 これがお役に立てば幸いです。</target>
        </trans-unit>
        <trans-unit id="ed51e87442d0b7d44562385cb2eaa5830e3da786" translate="yes" xml:space="preserve">
          <source>Strict aliasing is not allowing different pointer types to the same data.</source>
          <target state="translated">厳密なエイリアシングは、同じデータに対して異なるポインタ型を許可しません。</target>
        </trans-unit>
        <trans-unit id="08f4008712546a2f35d451915a75c5ce6707541f" translate="yes" xml:space="preserve">
          <source>Strict aliasing would allow us to prevent this by telling the compiler that these memory addresses are distinctly different (which, in this case, will allow even further optimization which can't be performed if the pointers share a memory address).</source>
          <target state="translated">厳密なエイリアシングを行うことで、これらのメモリアドレスが明確に異なることをコンパイラに伝えることでこれを防ぐことができます (この場合、ポインタがメモリアドレスを共有している場合に実行できない更なる最適化が可能になります)。</target>
        </trans-unit>
        <trans-unit id="3de059986d55a4c9204e0422ce6405ee0f2fae76" translate="yes" xml:space="preserve">
          <source>Technically in C++, the strict aliasing rule is probably never applicable.</source>
          <target state="translated">技術的には、C++では厳密なエイリアシングルールはおそらく適用されません。</target>
        </trans-unit>
        <trans-unit id="907bce6add949792da1d5d77350df907126f6c70" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;C11&lt;/strong&gt; standard says the following in section &lt;em&gt;6.5 Expressions paragraph 7&lt;/em&gt;:</source>
          <target state="translated">&lt;strong&gt;C11&lt;/strong&gt;標準では、セクション&lt;em&gt;6.5式の段落7で&lt;/em&gt;次のように述べています。</target>
        </trans-unit>
        <trans-unit id="bfd25f24e236cc975bc1fefb913df995d3049915" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Strict aliasing rule allows us to avoid redundant machine code&lt;/strong&gt; in cases in which it &lt;em&gt;should be&lt;/em&gt; safe to assume that two pointers don't point to the same memory block (see also the &lt;code&gt;restrict&lt;/code&gt; keyword).</source>
          <target state="translated">&lt;strong&gt;Strictエイリアシングルールを使用&lt;/strong&gt;すると、2つのポインターが同じメモリブロックを指していないと想定して&lt;em&gt;も&lt;/em&gt;安全である場合に、 &lt;strong&gt;マシンコードの冗長化を回避できます&lt;/strong&gt; （ &lt;code&gt;restrict&lt;/code&gt; キーワードも参照）。</target>
        </trans-unit>
        <trans-unit id="8c06897729db17629b567058f47bdaf4c4318b26" translate="yes" xml:space="preserve">
          <source>The C++17 draft standard in section &lt;em&gt;[basic.lval] paragraph 11&lt;/em&gt; says:</source>
          <target state="translated">セクション&lt;em&gt;[basic.lval]パラグラフ11&lt;/em&gt;のC ++ 17ドラフト標準は次のように述べています。</target>
        </trans-unit>
        <trans-unit id="9bc4e143126dccfdfaa1a458c40e03e32eb19eb7" translate="yes" xml:space="preserve">
          <source>The Strict aliasing states it's safe to assume that pointers to different types point to different locations in the memory.</source>
          <target state="translated">Strictエイリアシングでは、異なる型へのポインタがメモリ内の異なる場所を指していると仮定しても安全だとしています。</target>
        </trans-unit>
        <trans-unit id="7928780bf9e4496f92d12638d4fa464749948340" translate="yes" xml:space="preserve">
          <source>The best explanation I have found is by Mike Acton, &lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;Understanding Strict Aliasing&lt;/a&gt;. It's focused a little on PS3 development, but that's basically just GCC.</source>
          <target state="translated">私が見つけた最良の説明は、Mike Acton、 &lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;Understanding Strict Aliasing&lt;/a&gt;です。 PS3開発に少し焦点を当てていますが、それは基本的には単なるGCCです。</target>
        </trans-unit>
        <trans-unit id="49c47e96747dd9ea774b5bc163ec15c244b5f868" translate="yes" xml:space="preserve">
          <source>The best way to resolve the original problem would probably be to treat the
footnote about the purpose of the rule as though it were normative, and made
the rule unenforceable except in cases which actually involve conflicting accesses using aliases.  Given something like:</source>
          <target state="translated">元々の問題を解決する最善の方法は、ルールの目的に関する脚注をあたかも規範的なものであるかのように扱い、エイリアスを使って実際に相反するアクセスを伴う場合を除いて、ルールを強制力のないものにすることではないでしょうか。以下のようなことが考えられます。</target>
        </trans-unit>
        <trans-unit id="85b689b0761df13dcd7da661f9fdf03565c0a4a1" translate="yes" xml:space="preserve">
          <source>The compiler may or may not be able to or smart enough to try to inline SendMessage and it may or may not decide to load or not load buff again. If &lt;code&gt;SendMessage&lt;/code&gt; is part of another API that's compiled separately, it probably has instructions to load buff's contents. Then again, maybe you're in C++ and this is some templated header only implementation that the compiler thinks it can inline. Or maybe it's just something you wrote in your .c file for your own convenience. Anyway undefined behavior might still ensue. Even when we know some of what's happening under the hood, it's still a violation of the rule so no well defined behavior is guaranteed. So just by wrapping in a function that takes our word delimited buffer doesn't necessarily help.</source>
          <target state="translated">コンパイラーは、SendMessageをインライン化しようとすることができるか、または十分に賢い場合もそうでない場合もあり、buffを再度ロードするかしないかを決定する場合としない場合があります。 &lt;code&gt;SendMessage&lt;/code&gt; が個別にコンパイルされる別のAPIの一部である場合、buffのコンテンツをロードするための指示が含まれている可能性があります。 次に、C ++を使用している可能性があります。これは、コンパイラーがインライン化できると考える、テンプレート化されたヘッダーのみの実装です。 あるいは、自分の便宜のために.cファイルに書き込んだものかもしれません。 とにかく、未定義の動作が引き続き発生する可能性があります。 内部で何が起こっているかを知っていても、それは依然としてルール違反であるため、明確に定義された動作は保証されません。 したがって、単語区切りバッファを使用する関数をラップするだけでは、必ずしも効果はありません。</target>
        </trans-unit>
        <trans-unit id="185da178ba74f21fd6fbee6fc9a19c180251420b" translate="yes" xml:space="preserve">
          <source>The exception to the rule is a &lt;code&gt;char*&lt;/code&gt;, which is allowed to point to any type.</source>
          <target state="translated">ルールの例外は &lt;code&gt;char*&lt;/code&gt; 、これは任意のタイプを指すことができます。</target>
        </trans-unit>
        <trans-unit id="e6deb33976faa98a7a8b3f350b9d49c319c195cd" translate="yes" xml:space="preserve">
          <source>The following is an example of how to use &lt;strong&gt;bit_cast&lt;/strong&gt; to type pun a &lt;em&gt;unsigned int&lt;/em&gt; to &lt;em&gt;float&lt;/em&gt;, (&lt;a href=&quot;https://wandbox.org/permlink/i5l0g4IYuCFgLzzl&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">以下は、 &lt;strong&gt;bit_cast&lt;/strong&gt;を使用して、 &lt;em&gt;unsigned int&lt;/em&gt;を&lt;em&gt;float&lt;/em&gt;に入力する方法の例です（ &lt;a href=&quot;https://wandbox.org/permlink/i5l0g4IYuCFgLzzl&quot;&gt;実際に表示されます&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bc2fdca487b4e3f2274bf45676f76859149d4991" translate="yes" xml:space="preserve">
          <source>The last tool I will recommend is C++ specific and not strictly a tool but a coding practice, don't allow C-style casts. Both gcc and clang will produce a diagnostic for C-style casts using &lt;strong&gt;-Wold-style-cast&lt;/strong&gt;. This will force any undefined type puns to use reinterpret_cast, in general reinterpret_cast should be a flag for closer code review. It is also easier to search your code base for reinterpret_cast to perform an audit.</source>
          <target state="translated">私がお勧めする最後のツールは、C ++固有のものであり、厳密にはツールではなくコーディングの実践であり、Cスタイルのキャストを許可していません。 gccとclangはどちらも、 &lt;strong&gt;-Wold-style-cast&lt;/strong&gt;を使用してCスタイルのキャストの診断を生成します。 これにより、未定義の型パンがreinterpret_castを使用するように強制されます。一般に、reinterpret_castは、より詳細なコードレビューのためのフラグである必要があります。 また、コードベースでreinterpret_castを検索して監査を実行する方が簡単です。</target>
        </trans-unit>
        <trans-unit id="d6426a86b973a6cec74fb415633b300e0a37c506" translate="yes" xml:space="preserve">
          <source>The next example shows aliasing that leads to undefined behavior (&lt;a href=&quot;https://wandbox.org/permlink/8qA8JyJRVHtS9LPf&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">次の例は、未定義の動作につながるエイリアスを示しています（ &lt;a href=&quot;https://wandbox.org/permlink/8qA8JyJRVHtS9LPf&quot;&gt;実際の例&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="5e5d6deec660f2c03a74983d7e1f704f0a612063" translate="yes" xml:space="preserve">
          <source>The optimizer using &lt;a href=&quot;http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm&quot;&gt;Type-Based Alias Analysis (TBAA)&lt;/a&gt; assumes &lt;strong&gt;1&lt;/strong&gt; will be returned and directly moves the constant value into register &lt;strong&gt;eax&lt;/strong&gt; which carries the return value. TBAA uses the languages rules about what types are allowed to alias to optimize loads and stores. In this case TBAA knows that a &lt;em&gt;float&lt;/em&gt; can not alias and &lt;em&gt;int&lt;/em&gt; and optimizes away the load of &lt;strong&gt;i&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm&quot;&gt;Type-Based Alias Analysis（TBAA）&lt;/a&gt;を使用するオプティマイザは、 &lt;strong&gt;1&lt;/strong&gt;が返されると想定し、定数値を、戻り値を運ぶレジスタ&lt;strong&gt;eaxに&lt;/strong&gt;直接移動します。 TBAAは、ロードとストアを最適化するために、どのタイプにエイリアスを許可するかについての言語ルールを使用します。 この場合、TBAAは、 &lt;em&gt;float&lt;/em&gt;がエイリアスおよび&lt;em&gt;int&lt;/em&gt;できないことを認識し、 &lt;strong&gt;i&lt;/strong&gt;の負荷を最適化します。</target>
        </trans-unit>
        <trans-unit id="eb988ee6dabc3ef8446376c66441177c2cd532a0" translate="yes" xml:space="preserve">
          <source>The standard method for &lt;em&gt;type punning&lt;/em&gt; in both C and C++ is &lt;strong&gt;memcpy&lt;/strong&gt;. This may seem a little heavy handed but the optimizer should recognize the use of &lt;strong&gt;memcpy&lt;/strong&gt; for &lt;em&gt;type punning&lt;/em&gt; and optimize it away and generate a register to register move. For example if we know &lt;em&gt;int64_t&lt;/em&gt; is the same size as &lt;em&gt;double&lt;/em&gt;:</source>
          <target state="translated">CとC ++の両方で&lt;em&gt;型パンニングを行う&lt;/em&gt;標準的な方法は、 &lt;strong&gt;memcpy&lt;/strong&gt;です。 これはやや強引に見えるかもしれませんが、オプティマイザは&lt;em&gt;型パンニングの&lt;/em&gt;ための&lt;strong&gt;memcpy&lt;/strong&gt;の使用を認識し、それを最適化して、レジスターからレジスターへの移動を生成する必要があります。 たとえば、 &lt;em&gt;int64_t&lt;/em&gt;が&lt;em&gt;double&lt;/em&gt;と同じサイズであることがわかっている場合：</target>
        </trans-unit>
        <trans-unit id="08b2135b25032781b64ff4c52a4bdd14662d43d7" translate="yes" xml:space="preserve">
          <source>The strict aliasing rule makes this setup illegal: dereferencing a pointer that aliases an object that is not of a &lt;a href=&quot;http://en.cppreference.com/w/c/language/type&quot;&gt;compatible type&lt;/a&gt; or one of the other types allowed by C 2011 6.5 paragraph 7&lt;sup&gt;1&lt;/sup&gt; is undefined behavior. Unfortunately, you can still code this way, &lt;em&gt;maybe&lt;/em&gt; get some warnings, have it compile fine, only to have weird unexpected behavior when you run the code.</source>
          <target state="translated">厳密なエイリアシングルールはこの設定を不正にします。 &lt;a href=&quot;http://en.cppreference.com/w/c/language/type&quot;&gt;互換性のあるタイプ&lt;/a&gt;またはC 2011 6.5パラグラフ7 &lt;sup&gt;1で&lt;/sup&gt;許可されている他のタイプの1つではないオブジェクトをエイリアスするポインターの逆参照は、未定義の動作です。 残念ながら、この方法でコーディングすることはできますが、いくつかの警告が表示されたり、問題なくコンパイルされたりして、コードを実行したときに予期しない予期しない動作が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="bd0246c8dec2dd6e8cc0d773260f9ddcf056333b" translate="yes" xml:space="preserve">
          <source>The third change makes a stronger guarantee (relaxes the strong aliasing rule): The new concept of &lt;em&gt;similar types&lt;/em&gt; that are now safe to alias.</source>
          <target state="translated">3番目の変更により、より強力な保証が行われます（強力なエイリアシングルールが緩和されます）：エイリアスしても安全な、 &lt;em&gt;類似のタイプ&lt;/em&gt;の新しいコンセプト。</target>
        </trans-unit>
        <trans-unit id="428a7cf24521c1266f3851b503c14cb107e579a2" translate="yes" xml:space="preserve">
          <source>The unary * operator performs indirection: the expression to which it
  is applied shall be a pointer to an object type, or a pointer to a
  function type and &lt;strong&gt;the result is an lvalue referring to the object&lt;/strong&gt; or
  function &lt;strong&gt;to which the expression points&lt;/strong&gt;.</source>
          <target state="translated">単項*演算子は間接参照を実行します。適用される式は、オブジェクト型へのポインター、または関数型へのポインターであり&lt;strong&gt;、結果は、&lt;/strong&gt;式&lt;strong&gt;が指すオブジェクト&lt;/strong&gt;または関数&lt;strong&gt;を&lt;/strong&gt; &lt;strong&gt;参照する左辺値&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="f3edc398608fb9b543cd714f6b95b268072cc297" translate="yes" xml:space="preserve">
          <source>There's no conflict within &lt;code&gt;inc_int&lt;/code&gt; because all accesses to the storage accessed through &lt;code&gt;*p&lt;/code&gt; are done with an lvalue of type &lt;code&gt;int&lt;/code&gt;, and there's no conflict in &lt;code&gt;test&lt;/code&gt; because &lt;code&gt;p&lt;/code&gt; is visibly derived from a &lt;code&gt;struct S&lt;/code&gt;, and by the next time &lt;code&gt;s&lt;/code&gt; is used, all accesses to that storage that will ever be made through &lt;code&gt;p&lt;/code&gt; will have already happened.</source>
          <target state="translated">&lt;code&gt;*p&lt;/code&gt; を介してアクセスされるストレージへのすべてのアクセスは &lt;code&gt;int&lt;/code&gt; 型の左辺値で行われるため、 &lt;code&gt;inc_int&lt;/code&gt; 内で競合は発生しません。また、 &lt;code&gt;p&lt;/code&gt; は &lt;code&gt;struct S&lt;/code&gt; から明らかに派生し、次に &lt;code&gt;s&lt;/code&gt; が使用されるときにすべての &lt;code&gt;test&lt;/code&gt; 競合が発生しません。 &lt;code&gt;p&lt;/code&gt; を介して行われるそのストレージへのアクセスはすでに行われています。</target>
        </trans-unit>
        <trans-unit id="1e47063a12afd4868e46be1f29d48214f059315d" translate="yes" xml:space="preserve">
          <source>This can be told to the compiler in two ways, by using different types to point to. i.e.:</source>
          <target state="translated">これをコンパイラに伝えるには、異なる型を指定することで、2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="6f8c42e0f055d24e57ba0b97836be0b7abeb6542" translate="yes" xml:space="preserve">
          <source>This extra code is slow and &lt;strong&gt;hurts performance&lt;/strong&gt; since it performs extra memory read / write operations which are both slower and (possibly) unnecessary.</source>
          <target state="translated">この余分なコードは、低速で（おそらく）不要な追加のメモリ読み取り/書き込み操作を実行するため、低速で&lt;strong&gt;パフォーマンス&lt;/strong&gt;が低下します。</target>
        </trans-unit>
        <trans-unit id="03bd20f42d11715386a09efa404ec49187a334ec" translate="yes" xml:space="preserve">
          <source>This is excerpted from my &lt;a href=&quot;https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8&quot;&gt;&quot;What is the Strict Aliasing Rule and Why do we care?&quot;&lt;/a&gt; write-up.</source>
          <target state="translated">これは私の&lt;a href=&quot;https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8&quot;&gt;「厳格なエイリアシングルールとは何か、なぜ私たちは気にするのか」&lt;/a&gt;からの抜粋です。 書き上げる。</target>
        </trans-unit>
        <trans-unit id="23f8f6c33332ebb487428148aeaa250e333c0297" translate="yes" xml:space="preserve">
          <source>This is not valid in C++ and some consider the purpose of unions to be solely for implementing variant types and feel using unions for type punning is an abuse.</source>
          <target state="translated">これはC++では有効ではなく、組合の目的をバリアント型を実装するためだけにあると考えている人もいますし、組合を型罰に使うのは悪用だと感じている人もいます。</target>
        </trans-unit>
        <trans-unit id="b5a81d05fa60ca66493d7a8dd3adf9606ece3212" translate="yes" xml:space="preserve">
          <source>This is only one potential minefield when overlaying two types onto each other. You should also learn about &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;endianness&lt;/a&gt;, &lt;a href=&quot;http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html&quot;&gt;word alignment&lt;/a&gt;, and how to deal with alignment issues through &lt;a href=&quot;http://grok2.com/structure_packing.html&quot;&gt;packing structs&lt;/a&gt; correctly.</source>
          <target state="translated">これは、2つのタイプを互いに重ね合わせる場合の1つの潜在的な地雷原です。 &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;エンディアン&lt;/a&gt; 、 &lt;a href=&quot;http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html&quot;&gt;単語の整列&lt;/a&gt; 、 &lt;a href=&quot;http://grok2.com/structure_packing.html&quot;&gt;構造体を&lt;/a&gt;正しくパッキングすることで整列の問題に対処する方法についても学ぶ必要があります。</target>
        </trans-unit>
        <trans-unit id="1206246dfe34c612a18075c8bf78ec4ea7f41bed" translate="yes" xml:space="preserve">
          <source>This is the strict aliasing rule, found in section 3.10 of the &lt;strong&gt;C++03&lt;/strong&gt; standard (other answers provide good explanation, but none provided the rule itself):</source>
          <target state="translated">これは、 &lt;strong&gt;C ++ 03&lt;/strong&gt;標準のセクション3.10にある厳密なエイリアスルール&lt;strong&gt;です&lt;/strong&gt; （他の答えは良い説明を提供しますが、ルール自体は提供していません）。</target>
        </trans-unit>
        <trans-unit id="136cb4ca2af68d11d5c37a73bdbfaeaff7fafa9a" translate="yes" xml:space="preserve">
          <source>This optimization couldn't have been done before, because of the possible collision (where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; would be tripled instead of doubled).</source>
          <target state="translated">衝突の可能性があるため（ &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; が2倍ではなく3倍になる）、この最適化は以前には実行できませんでした。</target>
        </trans-unit>
        <trans-unit id="0c6e49d370e8ee32d1f9fb66865bb3dc534b3fdf" translate="yes" xml:space="preserve">
          <source>To see why this behavior is undefined, we have to think about what the strict aliasing rule buys the compiler. Basically, with this rule, it doesn't have to think about inserting instructions to refresh the contents of &lt;code&gt;buff&lt;/code&gt; every run of the loop. Instead, when optimizing, with some annoyingly unenforced assumptions about aliasing, it can omit those instructions, load &lt;code&gt;buff[0]&lt;/code&gt; and &lt;code&gt;buff[1&lt;/code&gt;] into CPU registers once before the loop is run, and speed up the body of the loop. Before strict aliasing was introduced, the compiler had to live in a state of paranoia that the contents of &lt;code&gt;buff&lt;/code&gt; could change at anytime from anywhere by anybody. So to get an extra performance edge, and assuming most people don't type-pun pointers, the strict aliasing rule was introduced.</source>
          <target state="translated">この動作が未定義である理由を確認するには、厳密なエイリアシングルールがコンパイラに何を購入するかを考える必要があります。 基本的に、このルールでは、ループの実行ごとに &lt;code&gt;buff&lt;/code&gt; の内容を更新するための命令を挿入することを考える必要はありません。 代わりに、エイリアシングに関してうっとうしく強制されていない仮定で最適化する場合、それらの命令を省略し、 &lt;code&gt;buff[0]&lt;/code&gt; と &lt;code&gt;buff[1&lt;/code&gt; ]をループが実行される前に一度CPUレジスタにロードして、ループの本体を高速化できます。 厳密なエイリアシングが導入される前は、コンパイラは、 &lt;code&gt;buff&lt;/code&gt; の内容がいつでもどこからでも誰でも変更できるという妄想状態に陥らなければなりませんでした。 そのため、パフォーマンスをさらに向上させるために、そしてほとんどの人が型抜きのポインターを使用しないと想定して、厳密なエイリアス規則が導入されました。</target>
        </trans-unit>
        <trans-unit id="2cca1ba7b02e14ee263ba59cb168d4ba464a31b0" translate="yes" xml:space="preserve">
          <source>To understand more about why we care, we will discuss issues that come up when violating strict aliasing rules, type punning since common techniques used in type punning often violate strict aliasing rules and how to type pun correctly.</source>
          <target state="translated">なぜ気にするのかをより理解するために、厳格なエイリアシングルールに違反したときに出てくる問題、タイプパニングでよく使われるテクニックが厳格なエイリアシングルールに違反することが多いのでタイプパニング、正しいタイプパニングの方法について説明します。</target>
        </trans-unit>
        <trans-unit id="e92874def1c707e293c92fd2c84a024426689bc4" translate="yes" xml:space="preserve">
          <source>Traditionally this has been accomplished by taking the address of the object, casting it to a pointer of the type we want to reinterpret it as and then accessing the value, or in other words by aliasing. For example:</source>
          <target state="translated">伝統的に、これはオブジェクトのアドレスを取り、再解釈したい型のポインタにキャストしてから値にアクセスする、つまりエイリアシングすることで達成されてきました。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="edef09f47c7522a6bf38ab921e88dc728d2d2210" translate="yes" xml:space="preserve">
          <source>Two changes were small: &lt;em&gt;glvalue&lt;/em&gt; instead of &lt;em&gt;lvalue&lt;/em&gt;, and clarification of the aggregate/union case.</source>
          <target state="translated">2つの変更点は小さかった： &lt;em&gt;lvalue&lt;/em&gt;ではなく&lt;em&gt;glvalue&lt;/em&gt;と、集約/共用体のケースの明確化。</target>
        </trans-unit>
        <trans-unit id="0200f9824ad4e7d323fbd799151680bd20557e5c" translate="yes" xml:space="preserve">
          <source>Unfortunately with strict aliasing violations, we will often obtain the results we expect, leaving the possibility the a future version of a compiler with a new optimization will break code we thought was valid. This is undesirable and it is a worthwhile goal to understand the strict aliasing rules and how to avoid violating them.</source>
          <target state="translated">不幸なことに、厳密なエイリアシングルールに違反した場合、期待した結果が得られることが多く、新しい最適化を行ったコンパイラの将来のバージョンで、有効だと思っていたコードが壊れてしまう可能性があります。これは望ましくないことであり、厳密なエイリアシングルールを理解し、違反しないようにするにはどうすればよいかを理解することは価値のある目標です。</target>
        </trans-unit>
        <trans-unit id="db8ca5d18a2da2723c323eb4668458564a4e8a8e" translate="yes" xml:space="preserve">
          <source>Unfortunately, the authors of the C89 wrote their rule in a way that, if read literally, would make even the following function invoke Undefined Behavior:</source>
          <target state="translated">残念なことに、C89の作者は、文字通りに読めば、次の関数でさえも未定義の振る舞いを呼び出すような方法でルールを書いています。</target>
        </trans-unit>
        <trans-unit id="c9eb5ca0a29983f2cff35266a2b00fda06003422" translate="yes" xml:space="preserve">
          <source>Use a union. Most compilers support this without complaining about strict aliasing. This is allowed in C99 and explicitly allowed in C11.</source>
          <target state="translated">ユニオンを使用します。ほとんどのコンパイラはこれをサポートしており、厳密なエイリアシングに不満を感じることはありません。これはC99で許可されており、C11では明示的に許可されています。</target>
        </trans-unit>
        <trans-unit id="ffd25c02b83ef5f0f4c7c45af829e62dae0bf2c5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;restrict&lt;/code&gt; keyword. i.e.:</source>
          <target state="translated">&lt;code&gt;restrict&lt;/code&gt; キーワードを使用します。 つまり：</target>
        </trans-unit>
        <trans-unit id="798b73c4c9c14434f5fd6ba2176351fdd836980d" translate="yes" xml:space="preserve">
          <source>We don't have a lot of good tools for catching strict aliasing in C++, the tools we have will catch some cases of strict aliasing violations and some cases of misaligned loads and stores.</source>
          <target state="translated">C++で厳格なエイリアシングをキャッチするための優れたツールはあまりありませんが、我々が持っているツールは厳格なエイリアシング違反やロードやストアの位置ずれをキャッチするものです。</target>
        </trans-unit>
        <trans-unit id="7a25725c5206d96d54103f39151066cf147a0d46" translate="yes" xml:space="preserve">
          <source>We have a &lt;em&gt;int*&lt;/em&gt; pointing to memory occupied by an &lt;em&gt;int&lt;/em&gt; and this is a valid aliasing. The optimizer must assume that assignments through &lt;strong&gt;ip&lt;/strong&gt; could update the value occupied by &lt;strong&gt;x&lt;/strong&gt;.</source>
          <target state="translated">&lt;em&gt;int&lt;/em&gt;が占有するメモリを指す&lt;em&gt;int *&lt;/em&gt;があり、これは有効なエイリアスです。 オプティマイザは、 &lt;strong&gt;ipによる&lt;/strong&gt;割り当てが&lt;strong&gt;x&lt;/strong&gt;が占める値を更新できると想定する必要があります。</target>
        </trans-unit>
        <trans-unit id="b4304e0250327f603bbd29b9479b911b0f3e7e12" translate="yes" xml:space="preserve">
          <source>We have gotten to this point and we may be wondering, why would we want to alias for? The answer typically is to &lt;em&gt;type pun&lt;/em&gt;, often the methods used violate strict aliasing rules.</source>
          <target state="translated">ここまで来て、疑問に思うかもしれませんが、なぜ別名を付けたいのでしょうか？ 答えは通常&lt;em&gt;pun&lt;/em&gt;を&lt;em&gt;入力することであり&lt;/em&gt; 、多くの場合、使用されるメソッドは厳密なエイリアス規則に違反します。</target>
        </trans-unit>
        <trans-unit id="486a3a882c8d445100340edd5a8f2d6177c5a9af" translate="yes" xml:space="preserve">
          <source>What are they talking about?</source>
          <target state="translated">何を言ってるんだ?</target>
        </trans-unit>
        <trans-unit id="8c58623950ce7060c946f960d5a1072d0350e835" translate="yes" xml:space="preserve">
          <source>What does the C11 standard say?</source>
          <target state="translated">C11規格は何と言っているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="be95c287c482fdf98be1e57328b6181a5b151c60" translate="yes" xml:space="preserve">
          <source>What exactly does the standard say we are allowed and not allowed to do? The standard language is not straightforward, so for each item I will try to provide code examples that demonstrates the meaning.</source>
          <target state="translated">規格では、具体的に何をしていいのか、何をしてはいけないのかと言っているのでしょうか?標準語は一筋縄ではいかないので、各項目ごとに意味を示すコード例を挙げてみます。</target>
        </trans-unit>
        <trans-unit id="80f819d6238279d0e91326c0caabb3b332286522" translate="yes" xml:space="preserve">
          <source>What is Type Punning</source>
          <target state="translated">タイプパンニングとは</target>
        </trans-unit>
        <trans-unit id="0484d0796de9fffe254f71284bf9ef8e03cb6100" translate="yes" xml:space="preserve">
          <source>What is strict aliasing?</source>
          <target state="translated">厳格なエイリアシングとは?</target>
        </trans-unit>
        <trans-unit id="bd5bd917a7164fc90491e58bae353151d7d6d43e" translate="yes" xml:space="preserve">
          <source>What is the strict aliasing rule</source>
          <target state="translated">厳密なエイリアシングルールとは</target>
        </trans-unit>
        <trans-unit id="cfad540cca405d9e6ac5dbafe09c03446c539f96" translate="yes" xml:space="preserve">
          <source>What the C++17 Draft Standard say</source>
          <target state="translated">C++17ドラフトスタンダードで言われていること</target>
        </trans-unit>
        <trans-unit id="2b2f3220f114ca6e5fa9f3ff293ad00e83672d76" translate="yes" xml:space="preserve">
          <source>When asking about &lt;a href=&quot;https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into&quot;&gt;common undefined behavior in C&lt;/a&gt;, people sometimes refer to the strict aliasing rule.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into&quot;&gt;C&lt;/a&gt;での一般的な未定義の動作について尋ねるとき、人々は厳密なエイリアシングルールを参照することがあります。</target>
        </trans-unit>
        <trans-unit id="c3986cda3c380d27ccea1e1786651cd0707eff3f" translate="yes" xml:space="preserve">
          <source>Which may not be expected but is perfectly valid since we have invoked undefined behavior. A &lt;em&gt;float&lt;/em&gt; can not validly alias an &lt;em&gt;int&lt;/em&gt; object. Therefore the optimizer can assume the &lt;em&gt;constant 1&lt;/em&gt; stored when dereferencing &lt;strong&gt;i&lt;/strong&gt; will be the return value since a store through &lt;strong&gt;f&lt;/strong&gt; could not validly affect an &lt;em&gt;int&lt;/em&gt; object. Plugging the code in Compiler Explorer shows this is exactly what is happening(&lt;a href=&quot;https://godbolt.org/g/yNV5aj&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">これは予想されないかもしれませんが、未定義の動作を呼び出したため、完全に有効です。 &lt;em&gt;float&lt;/em&gt;は&lt;em&gt;int&lt;/em&gt;オブジェクトに有効なエイリアスを設定できません。 したがって、オプティマイザは、 &lt;strong&gt;i&lt;/strong&gt;を逆参照するときに格納された&lt;em&gt;定数1を&lt;/em&gt;戻り値と見なすことができます。これは、 &lt;strong&gt;f&lt;/strong&gt;を介した格納が&lt;em&gt;int&lt;/em&gt;オブジェクトに有効に影響しなかったためです。 コンパイラエクスプローラーでコードをプラグインすると、これがまさに何が起こっているかを示しています（ &lt;a href=&quot;https://godbolt.org/g/yNV5aj&quot;&gt;実例&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="07141bb6d0d110634a7409d34c366630d3c98a44" translate="yes" xml:space="preserve">
          <source>Worth noting &lt;em&gt;signed char&lt;/em&gt; is not included in the list above, this is a notable difference from &lt;em&gt;C&lt;/em&gt; which says &lt;em&gt;a character type&lt;/em&gt;.</source>
          <target state="translated">上記のリストには、 &lt;em&gt;signed charに&lt;/em&gt;注意する価値はありません。これは&lt;em&gt;、文字タイプを表す&lt;/em&gt; &lt;em&gt;C&lt;/em&gt;との大きな違いです。</target>
        </trans-unit>
        <trans-unit id="6ec4bca0456ee32bdbabe8e73b9e3df68f5d736b" translate="yes" xml:space="preserve">
          <source>You can disable strict aliasing in your compiler (&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825&quot;&gt;f[no-]strict-aliasing&lt;/a&gt; in gcc))</source>
          <target state="translated">コンパイラで厳格なエイリアスを無効にすることができます（ &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825&quot;&gt;f [no-] strict-aliasing&lt;/a&gt; in gcc））</target>
        </trans-unit>
        <trans-unit id="9a40a7037ea21cd56a31798eee7807d9c8786d82" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;char*&lt;/code&gt; for aliasing instead of your system's word. The rules allow an exception for &lt;code&gt;char*&lt;/code&gt; (including &lt;code&gt;signed char&lt;/code&gt; and &lt;code&gt;unsigned char&lt;/code&gt;). It's always assumed that &lt;code&gt;char*&lt;/code&gt; aliases other types. However this won't work the other way: there's no assumption that your struct aliases a buffer of chars.</source>
          <target state="translated">システムの単語の代わりに &lt;code&gt;char*&lt;/code&gt; をエイリアスに使用できます。 ルールでは、 &lt;code&gt;char*&lt;/code&gt; （ &lt;code&gt;signed char&lt;/code&gt; と &lt;code&gt;unsigned char&lt;/code&gt; を含む）の例外を許可しています。 &lt;code&gt;char*&lt;/code&gt; 他の型のエイリアスになると常に想定されています。 ただし、これは他の方法では機能しません。構造体が文字のバッファをエイリアスするという仮定はありません。</target>
        </trans-unit>
        <trans-unit id="3ee51db5fb0d07b269bfed3eb63461eb650f3683" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; または &lt;code&gt;unsigned char&lt;/code&gt; 型。</target>
        </trans-unit>
        <trans-unit id="597ff02af60ec975bbc5261d748ee4cf1e57a446" translate="yes" xml:space="preserve">
          <source>a character type.</source>
          <target state="translated">文字型を指定します。</target>
        </trans-unit>
        <trans-unit id="cce769f3e61ed7c57c27b8bbabf2ecde89913120" translate="yes" xml:space="preserve">
          <source>a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">オブジェクトの動的型の cv-qualified バージョン.</target>
        </trans-unit>
        <trans-unit id="d5c0b51b12ba45e66cdb0c200363fe41dca17267" translate="yes" xml:space="preserve">
          <source>a qualified version of a type compatible with the effective type of the object,</source>
          <target state="translated">オブジェクトの有効な型と互換性のある型の修飾されたバージョン。</target>
        </trans-unit>
        <trans-unit id="913991e5ddd84e880c9ee8623ae50786c0e5aa58" translate="yes" xml:space="preserve">
          <source>a qualiﬁed version of a type compatible with the effective type of
  the object,</source>
          <target state="translated">オブジェクトの有効な型と互換性のある型の修飾されたバージョン。</target>
        </trans-unit>
        <trans-unit id="b75dd2203435a45255f541a92e8f52a7c687df9d" translate="yes" xml:space="preserve">
          <source>a type compatible with the effective type of the object,</source>
          <target state="translated">オブジェクトの有効な型と互換性のある型を指定します。</target>
        </trans-unit>
        <trans-unit id="75d68aa8a13ac3e6c2e72772064d82f9a07c3a25" translate="yes" xml:space="preserve">
          <source>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</source>
          <target state="translated">オブジェクトの動的型の(おそらく cv-qualified された)基底クラス型である型.</target>
        </trans-unit>
        <trans-unit id="b65677be1e1487df5175120a02cfc67364b289cb" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a
  qualiﬁed version of the effective type of the object,</source>
          <target state="translated">オブジェクトの有効な型の修飾されたバージョンに対応する符号付きまたは符号なしの型です。</target>
        </trans-unit>
        <trans-unit id="bac8eec6cb1615e6948be007906aef75526747ef" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">オブジェクトの動的型の cv-qualified されたバージョンに対応する符号付きまたは符号なしの型.</target>
        </trans-unit>
        <trans-unit id="32f34f0edd59f5a473682cd472684b341a58daef" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,</source>
          <target state="translated">オブジェクトの有効な型の修飾されたバージョンに対応する符号付きまたは符号なしの型です。</target>
        </trans-unit>
        <trans-unit id="e7c8760740b87a7f9140b423e924d45e4999f46b" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to the
  effective type of the object,</source>
          <target state="translated">オブジェクトの有効型に対応する符号付きまたは符号なし型である型。</target>
        </trans-unit>
        <trans-unit id="3fb43283d88825a91d147ec87a46390b16119ec1" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</source>
          <target state="translated">オブジェクトの動的型に対応する符号付きまたは符号なしの型です。</target>
        </trans-unit>
        <trans-unit id="09589aee6f97ca1ced0e9615240163fa1a8aac6b" translate="yes" xml:space="preserve">
          <source>add &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; を &lt;code&gt;b&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="a4989e9968b633144d1dfa1a4b1a8a78e58f871e" translate="yes" xml:space="preserve">
          <source>add &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; を追加 &lt;code&gt;a&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="b7dfe2e2b4ee47faaabfeac29663335e09827e6a" translate="yes" xml:space="preserve">
          <source>although it will not catch this additional case (&lt;a href=&quot;https://wandbox.org/permlink/dwd9jhy53AF7a2D0&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">この追加のケースをキャッチしません（ &lt;a href=&quot;https://wandbox.org/permlink/dwd9jhy53AF7a2D0&quot;&gt;ライブでご覧ください&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="e191b7b82407cef0ada97dd29a20d0793010dffe" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned
  types among its members (including, recursively, a member of a
  subaggregate or contained union), or</source>
          <target state="translated">メンバーの中に前述の型のいずれかを含む集約型または組合型(再帰的に、下位集約型または含まれる組合のメンバーを含む)、または</target>
        </trans-unit>
        <trans-unit id="fdece15d7bccebfe8183f34b848fc0e4942877cb" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned types among its &lt;em&gt;elements or non-static data members&lt;/em&gt; (including, recursively, an &lt;em&gt;element or non-static data member&lt;/em&gt; of a subaggregate or contained union),</source>
          <target state="translated">&lt;em&gt;要素または非静的データメンバー&lt;/em&gt; （再帰的に、サブアグリゲートまたは含まれるユニオンの&lt;em&gt;要素または非静的データメンバー&lt;/em&gt;を含む）の中に前述のタイプの1つを含む集約またはユニオンタイプ、</target>
        </trans-unit>
        <trans-unit id="3bb5bb5a7fb40894ca32d70cc8dbec9f68ef6180" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union),</source>
          <target state="translated">そのメンバの中に前述の型のいずれかを含む集約型または組合型(再帰的に、下位集約型または含まれる組合のメンバを含む)。</target>
        </trans-unit>
        <trans-unit id="9904ae77bbd2a07d458dc75556c60522d6fed3a1" translate="yes" xml:space="preserve">
          <source>because it uses an lvalue of type &lt;code&gt;int&lt;/code&gt; to access an object of type &lt;code&gt;struct S&lt;/code&gt;, and &lt;code&gt;int&lt;/code&gt; is not among the types that may be used accessing a &lt;code&gt;struct S&lt;/code&gt;.  Because it would be absurd to treat all use of non-character-type members of structs and unions as Undefined Behavior, almost everyone recognizes that there are at least some circumstances where an lvalue of one type may be used to access an object of another type.  Unfortunately, the C Standards Committee has failed to define what those circumstances are.</source>
          <target state="translated">これは、 &lt;code&gt;int&lt;/code&gt; 型の左辺値を使用して &lt;code&gt;struct S&lt;/code&gt; 型のオブジェクトにアクセスし、 &lt;code&gt;int&lt;/code&gt; は &lt;code&gt;struct S&lt;/code&gt; へのアクセスに使用できる型の中にないためです。 構造体と共用体の非文字型メンバーのすべての使用を未定義の動作として扱うのはばかげているので、ほとんどの人は、ある型の左辺値が別の型のオブジェクトにアクセスするために使用される可能性がある少なくともいくつかの状況があることを認識しています。 残念ながら、C標準委員会はそれらの状況が何であるかを定義することに失敗しました。</target>
        </trans-unit>
        <trans-unit id="13f76d1176cba1d67741f0be2b7d390647245ed8" translate="yes" xml:space="preserve">
          <source>check.c</source>
          <target state="translated">check.c</target>
        </trans-unit>
        <trans-unit id="6cc4950f9d59b228de0ffc8dfa255d0ff18a24aa" translate="yes" xml:space="preserve">
          <source>gcc using the flag &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; and &lt;strong&gt;-Wstrict-aliasing&lt;/strong&gt; can catch some cases although not without false positives/negatives. For example the following cases will generate a warning in gcc (&lt;a href=&quot;https://wandbox.org/permlink/cfckjTgwNTYHDIry&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">フラグ&lt;strong&gt;-fstrict&lt;/strong&gt; &lt;strong&gt;-aliasing&lt;/strong&gt;と&lt;strong&gt;-Wstrict-aliasing&lt;/strong&gt;を使用するgccは、 &lt;strong&gt;誤検知&lt;/strong&gt; /否定がないわけではありませんが、いくつかのケースをキャッチできます。 たとえば、次の場合はgccで警告が生成されます（ &lt;a href=&quot;https://wandbox.org/permlink/cfckjTgwNTYHDIry&quot;&gt;ライブで確認してください&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9b9539e1dab95d4762b7ca605ff3ef29baabe352" translate="yes" xml:space="preserve">
          <source>load &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from memory.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; をメモリからロードします。</target>
        </trans-unit>
        <trans-unit id="3c8e98bbec15998f99b160035e6e2a5a79e70264" translate="yes" xml:space="preserve">
          <source>save &lt;code&gt;a&lt;/code&gt; (from the CPU register) to the memory.</source>
          <target state="translated">（CPUレジスタから）をメモリに保存します。</target>
        </trans-unit>
        <trans-unit id="e9f82b272f6f1b1af58a82bfd5c8942a5383dee9" translate="yes" xml:space="preserve">
          <source>save result both to &lt;code&gt;a&lt;/code&gt; and to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">結果を &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の両方に保存します。</target>
        </trans-unit>
        <trans-unit id="0a44e1b26b12bd2a7790e5bb3e97bb71d781569c" translate="yes" xml:space="preserve">
          <source>should be required to reload the value of &lt;code&gt;x&lt;/code&gt; between the assignment and return statement so as to allow for the possibility that &lt;code&gt;p&lt;/code&gt; might point to &lt;code&gt;x&lt;/code&gt;, and the assignment to &lt;code&gt;*p&lt;/code&gt; might consequently alter the value of &lt;code&gt;x&lt;/code&gt;.  The notion that a compiler should be entitled to presume that there won't be aliasing &lt;em&gt;in situations like the above&lt;/em&gt; was non-controversial.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; が &lt;code&gt;x&lt;/code&gt; をポイントし、 &lt;code&gt;*p&lt;/code&gt; への代入が結果として &lt;code&gt;x&lt;/code&gt; の値を変更する可能性を考慮して、代入ステートメントとreturnステートメントの間で &lt;code&gt;x&lt;/code&gt; の値を再ロードする必要があります。 コンパイラーが&lt;em&gt;、上記のような状況&lt;/em&gt;ではエイリアシング&lt;em&gt;が発生し&lt;/em&gt;ないと想定する権利を与えられるべきであるという考えは、議論の余地がないものでした。</target>
        </trans-unit>
        <trans-unit id="2ae0f749e2f2eba590823df0d938d3f9e1d9f0ad" translate="yes" xml:space="preserve">
          <source>the dynamic type of the object,</source>
          <target state="translated">オブジェクトのダイナミック型を指定します。</target>
        </trans-unit>
        <trans-unit id="5c8205de1a0f5881a6eef3facb06094c46436ace" translate="yes" xml:space="preserve">
          <source>tis-interpeter is able to catch all three, the following example invokes tis-kernal as tis-interpreter (output is edited for brevity):</source>
          <target state="translated">tis-interpeterは3つすべてをキャッチできるので、以下の例ではtis-interpreterとしてtis-kernalを呼び出します(出力は簡潔にするために編集されています)。</target>
        </trans-unit>
        <trans-unit id="790926074ddb3f88b6b51d69cef8f57d64c8ee6d" translate="yes" xml:space="preserve">
          <source>we can use &lt;strong&gt;memcpy&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;memcpy&lt;/strong&gt;を使用できます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
