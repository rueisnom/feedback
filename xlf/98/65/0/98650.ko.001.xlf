<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/98650">
    <body>
      <group id="98650">
        <trans-unit id="8bc9a3751448b75c95d0c09be39874a54d59dbbc" translate="yes" xml:space="preserve">
          <source>&quot;Strict aliasing is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias each other.)&quot;</source>
          <target state="translated">&quot;엄격한 앨리어싱은 C (또는 C ++) 컴파일러에 의해 만들어진 것으로, 다른 유형의 객체에 대한 포인터를 역 참조하는 것은 결코 같은 메모리 위치를 참조하지 않을 것이라고 가정합니다.&quot;</target>
        </trans-unit>
        <trans-unit id="7cf3442516aaa5d6749824461a7def10a1b8f03a" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a character type.</source>
          <target state="translated">&amp;mdash; 문자 유형.</target>
        </trans-unit>
        <trans-unit id="16d9cec79491cede88fd0ddafcbdb33b1a1dc888" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a qualified version of a type compatible with the effective type of the object,</source>
          <target state="translated">&amp;mdash; 유효 객체 유형과 호환되는 유형의 정규화 된 버전</target>
        </trans-unit>
        <trans-unit id="13d94646e2432e838a724c25f7870cb8f332c869" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,</source>
          <target state="translated">&amp;mdash; 객체의 유효 유형의 정규화 된 버전에 해당하는 부호있는 유형 또는 부호없는 유형 인 유형</target>
        </trans-unit>
        <trans-unit id="4b87e5428fe7d01a75c7838ed5347266005ed316" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to the effective type of the object,</source>
          <target state="translated">&amp;mdash; 객체의 유효 유형에 해당하는 부호있는 유형 또는 부호없는 유형 인 유형</target>
        </trans-unit>
        <trans-unit id="62996c58c76d88b909b477d85de32e4c8a0be22f" translate="yes" xml:space="preserve">
          <source>&amp;mdash; an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or</source>
          <target state="translated">-구성원들 중에서 상기 언급 된 유형 중 하나를 포함하는 집합 또는 조합 유형 (재귀 적으로 하위 집합 또는 포함 된 연합의 구성원 포함) 또는</target>
        </trans-unit>
        <trans-unit id="7682f0746a360de4bef474dee1888984c6d26a7c" translate="yes" xml:space="preserve">
          <source>(11.2) &amp;mdash; a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">(11.2) &amp;mdash; 객체의 동적 유형의 cv-qualified 버전</target>
        </trans-unit>
        <trans-unit id="2b7ebc143440433f6bcf7a57744dbff09cce4f85" translate="yes" xml:space="preserve">
          <source>(11.3) &amp;mdash; a type similar (as defined in 7.5) to the dynamic type of the object,</source>
          <target state="translated">(11.3) &amp;mdash; 객체의 동적 유형과 유사한 유형 (7.5에 정의 된대로)</target>
        </trans-unit>
        <trans-unit id="492220375e27ebfd7903993e017101c0d85ec3e0" translate="yes" xml:space="preserve">
          <source>(11.4) &amp;mdash; a type that is the signed or unsigned type corresponding to the dynamic type of the object,</source>
          <target state="translated">(11.4) &amp;mdash; 객체의 동적 유형에 해당하는 부호있는 유형 또는 부호없는 유형</target>
        </trans-unit>
        <trans-unit id="2d718b5cc47d538f62e075e1c68512349385137b" translate="yes" xml:space="preserve">
          <source>(11.5) &amp;mdash; a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">(11.5) &amp;mdash; 객체의 동적 유형의 cv-qualified 버전에 해당하는 부호있는 또는 부호없는 유형 인 유형</target>
        </trans-unit>
        <trans-unit id="9dc6ec3bc2c4acd3e7938a177187de9946d3fbac" translate="yes" xml:space="preserve">
          <source>(11.6) &amp;mdash; an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</source>
          <target state="translated">(11.6)-요소 또는 비 정적 데이터 멤버 (재귀 적으로 하위 집합 또는 포함 된 유니온의 요소 또는 비 정적 데이터 멤버 포함) 중 위에서 언급 한 유형 중 하나를 포함하는 집계 또는 통합 유형</target>
        </trans-unit>
        <trans-unit id="0833cab4a3d7c43325017982c60dd1a9524db49f" translate="yes" xml:space="preserve">
          <source>(11.7) &amp;mdash; a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</source>
          <target state="translated">(11.7) &amp;mdash; 객체의 동적 유형에 대한 (cv cv-qualified) 기본 클래스 유형 인 유형</target>
        </trans-unit>
        <trans-unit id="007312b7d7fe81dfd0e93a7cbbe02ace56aa2f12" translate="yes" xml:space="preserve">
          <source>(11.8) &amp;mdash; a char, unsigned char, or std::byte type.</source>
          <target state="translated">(11.8) &amp;mdash; char, unsigned char 또는 std :: byte 타입.</target>
        </trans-unit>
        <trans-unit id="a6ae166834f7950f65a4a0e2017c5da76406a59c" translate="yes" xml:space="preserve">
          <source>(GCC appears somewhat inconsistent in its ability to give aliasing warnings, sometimes giving us a friendly warning and sometimes not.)</source>
          <target state="translated">(GCC는 앨리어싱 경고를 제공하는 기능이 다소 일관성이없는 것으로 보이며 때로는 친숙한 경고를 제공하지만 때로는 그렇지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="dbb9367a16f124a22e627722082fe38579194d80" translate="yes" xml:space="preserve">
          <source>(save from CPU register to the memory and load from the memory to the CPU register).</source>
          <target state="translated">(CPU 레지스터에서 메모리로 저장하고 메모리에서 CPU 레지스터로로드).</target>
        </trans-unit>
        <trans-unit id="9cc95d274f988057b458e8bbc62596b0bfd62e5a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;This article&lt;/a&gt; should help you understand the issue in full detail.</source>
          <target state="translated">&lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;이 기사&lt;/a&gt; 는 문제를 자세하게 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="db4e37199ce7a26e530372127092a913fd8e827e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_punning&quot;&gt;Type punning&lt;/a&gt; via pointer casts (as opposed to using a union) is a major example of breaking strict aliasing.</source>
          <target state="translated">포인터 캐스트 (유니온 사용과 반대)를 통한 &lt;a href=&quot;http://en.wikipedia.org/wiki/Type_punning&quot;&gt;유형 제거&lt;/a&gt; 는 엄격한 앨리어싱을 해제하는 주요 예입니다.</target>
        </trans-unit>
        <trans-unit id="0f648f766517c522d736c21acf06a661385f3de0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://twitter.com/shafikyaghmour/status/957702383810658304&quot;&gt;gcc/clang has an extension&lt;/a&gt; and &lt;a href=&quot;https://gcc.gnu.org/ml/gcc/2003-10/msg00184.html&quot;&gt;also&lt;/a&gt; that allows assigning &lt;em&gt;unsigned int*&lt;/em&gt; to &lt;em&gt;int*&lt;/em&gt; even though they are not compatible types.</source>
          <target state="translated">&lt;a href=&quot;https://twitter.com/shafikyaghmour/status/957702383810658304&quot;&gt;gcc / clang은 확장 기능을 가지고 있으며&lt;/a&gt; 호환되지 않는 타입이더라도 &lt;em&gt;unsigned int *&lt;/em&gt; 를 &lt;em&gt;int *에&lt;/em&gt; 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01b0f2dd13e6673c4bc6a8d017a4466b2eae23b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;a type similar (as defined in 4.4) to the dynamic type of the object,&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;객체의 동적 유형과 유사한 유형 (4.4에 정의 된대로)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57fbd0f13eb9b51fcea11056b2017576feba86c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Beginner beware&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;초보자 조심&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="196bcd48f2a7e66de892eaf11cbe2d9cab7cc750" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11&lt;/strong&gt; and &lt;strong&gt;C++14&lt;/strong&gt; wording (changes emphasized):</source>
          <target state="translated">&lt;strong&gt;C ++ 11&lt;/strong&gt; 및 &lt;strong&gt;C ++ 14&lt;/strong&gt; 문구 (변경 사항 강조) :</target>
        </trans-unit>
        <trans-unit id="f83c36172e98a9c03aa145ce635aa0f76fe4904e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For example&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;예를 들면&lt;/strong&gt; 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="decc5376f183538b5fe7739f22bb8eb4f49596b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So how do I get around this?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;어떻게이 문제를 해결할 수 있습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d25be7fbd9e3672275a9ff1b70188a72553da35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;save&lt;/strong&gt;&lt;code&gt;b&lt;/code&gt; and &lt;strong&gt;reload&lt;/strong&gt;&lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 를 &lt;strong&gt;저장하고&lt;/strong&gt; a 를 &lt;strong&gt;다시로드&lt;/strong&gt; &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b61bc9f66e53d7bd6c6cb170cf39fc609c4079f3" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt; 73) or 88)&lt;/sup&gt; The intent of this list is to specify those circumstances in which an object may or may not be aliased.</source>
          <target state="translated">&lt;sup&gt;73) 또는 88)&lt;/sup&gt; 이 목록의 목적은 개체의 별칭이 지정되거나 별칭이 지정되지 않을 수있는 환경을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e6cbeecf47c0b79acdf7d07e84cc9b5e6b8e569d" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt; The types that C 2011 6.5 7 allows an lvalue to access are:</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; C 2011 6.5 7에서 lvalue가 액세스 할 수있는 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="297342af50ab471e2b4d57de560278e8dd7b88e6" translate="yes" xml:space="preserve">
          <source>A glvalue is an expression whose evaluation determines the identity of
  an object, (...snip)</source>
          <target state="translated">glvalue는 평가가 객체의 정체성을 결정하는 표현식입니다 (... 조각).</target>
        </trans-unit>
        <trans-unit id="8e98f088bc239e2fa9b5abf6318d366712f8212b" translate="yes" xml:space="preserve">
          <source>A typical situation you encounter strict aliasing problems is when overlaying a struct (like a device/network msg) onto a buffer of the word size of your system (like a pointer to &lt;code&gt;uint32_t&lt;/code&gt;s or &lt;code&gt;uint16_t&lt;/code&gt;s). When you overlay a struct onto such a buffer, or a buffer onto such a struct through pointer casting you can easily violate strict aliasing rules.</source>
          <target state="translated">엄격한 앨리어싱 문제가 발생하는 일반적인 상황은 (장치 / 네트워크 메시지와 같은) 구조체를 시스템의 단어 크기의 버퍼 ( &lt;code&gt;uint32_t&lt;/code&gt; 또는 &lt;code&gt;uint16_t&lt;/code&gt; 에 대한 포인터)에 오버레이 할 때입니다. 포인터를 캐스팅하여 이러한 버퍼 또는 구조체에 버퍼를 오버레이하면 엄격한 앨리어싱 규칙을 쉽게 위반할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9dc4be413dae8efeb97923c710712f4df67ca23" translate="yes" xml:space="preserve">
          <source>According to the C89 rationale, the authors of the Standard did not want to require that compilers given code like:</source>
          <target state="translated">C89의 이론적 근거에 따르면, 표준의 저자는 컴파일러에게 다음과 같은 코드를 주도록 요구하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a1e350b0f7d46240fa54c7300839cc8197daad50" translate="yes" xml:space="preserve">
          <source>After reading many of the answers, I feel the need to add something:</source>
          <target state="translated">많은 답변을 읽은 후 무언가를 추가해야한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="6ef0f09f189d7f527f3216249c8e7b8d66de7464" translate="yes" xml:space="preserve">
          <source>Also from &lt;a href=&quot;http://eel.is/c++draft/basic.lval#1.1&quot;&gt;the definition of glvalue&lt;/a&gt;</source>
          <target state="translated">또한 &lt;a href=&quot;http://eel.is/c++draft/basic.lval#1.1&quot;&gt;glvalue의 정의에서&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f9a518e55a06337a7d067a77249a742f4d1724e" translate="yes" xml:space="preserve">
          <source>Also the &lt;strong&gt;C&lt;/strong&gt; wording (C99; ISO/IEC 9899:1999 6.5/7; the exact same wording is used in ISO/IEC 9899:2011 &amp;sect;6.5 &amp;para;7):</source>
          <target state="translated">또한 &lt;strong&gt;C&lt;/strong&gt; 문구 (C99; ISO / IEC 9899 : 1999 6.5 / 7; ISO / IEC 9899 : 2011 &amp;sect;6.5 &amp;para;7에서 똑같은 문구가 사용됨) :</target>
        </trans-unit>
        <trans-unit id="2985fc30fb7352cc194dd6d4058223c195eec0a4" translate="yes" xml:space="preserve">
          <source>Although clang allows these flags it apparently does not actually implement the warnings.</source>
          <target state="translated">clang은 이러한 플래그를 허용하지만 실제로 경고를 구현하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="26a14dfaa9199838addf36131d31232c359747d1" translate="yes" xml:space="preserve">
          <source>An object shall have its stored value accessed only by an lvalue
  expression that has one of the following types &lt;sup&gt; 73) or 88)&lt;/sup&gt;:</source>
          <target state="translated">객체는 다음 유형 &lt;sup&gt;73) 또는 88)&lt;/sup&gt; 중 하나를 갖는 lvalue 표현식에 의해서만 저장된 값에 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="e89f2c7845b5b0b9f99fb0df9e776bf697055362" translate="yes" xml:space="preserve">
          <source>An object shall have its stored value accessed only by an lvalue expression that has one of the following types:&lt;sup&gt;88)&lt;/sup&gt;
  &amp;mdash; a type compatible with the effective type of the object,</source>
          <target state="translated">객체는 다음 유형 중 하나를 갖는 lvalue 표현식으로 만 저장된 값에 액세스해야합니다. &lt;sup&gt;88)&lt;/sup&gt; &amp;mdash; 객체의 유효 유형과 호환되는 유형,</target>
        </trans-unit>
        <trans-unit id="8d09e17c7fa91deb529a7711698d487fd214027c" translate="yes" xml:space="preserve">
          <source>And rewrote our earlier loop to take advantage of this convenient function</source>
          <target state="translated">이 편리한 기능을 활용하기 위해 이전 루프를 다시 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="0f5d219e3940c12eb3895d8e75d8bb99c681600b" translate="yes" xml:space="preserve">
          <source>Another tool we have available to us is ASan which can catch misaligned loads and stores. Although these are not directly strict aliasing violations they are a common result of strict aliasing violations. For example the following cases will generate runtime errors when built with clang using &lt;strong&gt;-fsanitize=address&lt;/strong&gt;</source>
          <target state="translated">우리가 사용할 수있는 또 다른 도구는 잘못 정렬 된로드와 저장을 잡을 수있는 ASan입니다. 이는 직접적인 앨리어싱 위반이 아니지만 엄격한 앨리어싱 위반의 일반적인 결과입니다. 예를 들어 &lt;strong&gt;-fsanitize = address를&lt;/strong&gt; 사용하여 clang으로 빌드하면 다음과 같은 경우 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c9f941d78e7fc8fb359e7fb4d08c3662e735d087" translate="yes" xml:space="preserve">
          <source>As addendum to what Doug T. already wrote, here
is a simple test case which probably triggers it with gcc :</source>
          <target state="translated">Doug T.가 이미 쓴 것에 대한 부록으로서, 다음은 아마도 gcc로 트리거하는 간단한 테스트 사례입니다.</target>
        </trans-unit>
        <trans-unit id="10728f2d66e27dcf628afc3fd6a3a60abc38f514" translate="yes" xml:space="preserve">
          <source>As we have seen earlier this is not a valid aliasing, so we are invoking undefined behavior. But traditionally compilers did not take advantage of strict aliasing rules and this type of code usually just worked, developers have unfortunately gotten used to doing things this way. A common alternate method for type punning is through unions, which is valid in C but &lt;em&gt;undefined behavior&lt;/em&gt; in C++ (&lt;a href=&quot;https://wandbox.org/permlink/oOf9bPlcWDYrYqPF&quot;&gt;see live example&lt;/a&gt;):</source>
          <target state="translated">앞에서 보았 듯이 이것은 유효한 앨리어싱이 아니므로 정의되지 않은 동작을 호출합니다. 그러나 전통적으로 컴파일러는 엄격한 앨리어싱 규칙을 이용하지 않았으며 이러한 유형의 코드는 일반적으로 작동했습니다. 개발자는 불행히도 이런 식으로 일하는 데 익숙해졌습니다. 유형 정리의 일반적인 대체 방법은 공용체를 사용하는 것입니다. 공용체는 C에서는 유효하지만 C ++에서는 &lt;em&gt;정의되지 않은 동작&lt;/em&gt; 입니다 ( &lt;a href=&quot;https://wandbox.org/permlink/oOf9bPlcWDYrYqPF&quot;&gt;실례 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="31703841448c40ed3e7edbb4a235ea2f940df90f" translate="yes" xml:space="preserve">
          <source>At a sufficient optimization level any decent modern compiler generates identical code to the previously mentioned &lt;strong&gt;reinterpret_cast&lt;/strong&gt; method or &lt;em&gt;union&lt;/em&gt; method for &lt;em&gt;type punning&lt;/em&gt;. Examining the generated code we see it uses just register mov (&lt;a href=&quot;https://godbolt.org/g/BfZGwX&quot;&gt;live Compiler Explorer Example&lt;/a&gt;).</source>
          <target state="translated">충분한 최적화 수준에서 괜찮은 최신 컴파일러는 &lt;em&gt;punning 유형에&lt;/em&gt; 대해 앞에서 언급 한 &lt;strong&gt;reinterpret_cast&lt;/strong&gt; 메소드 또는 &lt;em&gt;공용체&lt;/em&gt; 메소드와 동일한 코드를 생성합니다. 생성 된 코드를 살펴보면 register mov ( &lt;a href=&quot;https://godbolt.org/g/BfZGwX&quot;&gt;live Compiler Explorer Example&lt;/a&gt; ) 만 사용한다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b40922067f3852129b802e5ea9ad27f2b9e841c" translate="yes" xml:space="preserve">
          <source>C++20 and bit_cast</source>
          <target state="translated">C ++ 20 및 bit_cast</target>
        </trans-unit>
        <trans-unit id="d0218f26139d8420689d4b0863aae73b36ebb0d3" translate="yes" xml:space="preserve">
          <source>Catching Strict Aliasing Violations</source>
          <target state="translated">엄격한 앨리어싱 위반 잡기</target>
        </trans-unit>
        <trans-unit id="1770c1d3a13b57ff8c334a5bc651892e9928636f" translate="yes" xml:space="preserve">
          <source>Compile with &lt;code&gt;gcc -O2 -o check check.c&lt;/code&gt; .
Usually (with most gcc versions I tried) this outputs &quot;strict aliasing problem&quot;, because the compiler assumes that &quot;h&quot; cannot be the same address as &quot;k&quot; in the &quot;check&quot; function. Because of that the compiler optimizes the &lt;code&gt;if (*h == 5)&lt;/code&gt; away and always calls the printf.</source>
          <target state="translated">&lt;code&gt;gcc -O2 -o check check.c&lt;/code&gt; 로 컴파일 하십시오 . 컴파일러는 &quot;h&quot;가 &quot;check&quot;함수의 &quot;k&quot;와 같은 주소 일 수 없다고 가정하기 때문에 일반적으로 (대부분의 gcc 버전에서 시도한) &quot;엄격한 앨리어싱 문제&quot;를 출력합니다. 이 때문에 컴파일러는 &lt;code&gt;if (*h == 5)&lt;/code&gt; 최적화하고 항상 printf를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="53c22f9842dfbbfd7ce868f16027320909192af5" translate="yes" xml:space="preserve">
          <source>Defect Report #28 states that the program invokes Undefined Behavior because the action of writing a union member of type &quot;double&quot; and reading one of type &quot;int&quot; invokes Implementation-Defined behavior.  Such reasoning is nonsensical, but forms the basis for the Effective Type rules which needlessly complicate the language while doing nothing to address the original problem.</source>
          <target state="translated">결함 보고서 # 28은 &quot;double&quot;유형의 공용체 멤버를 작성하고 &quot;int&quot;유형 중 하나를 읽는 조치가 구현 정의 동작을 호출하기 때문에 프로그램이 정의되지 않은 동작을 호출한다고 설명합니다. 이러한 추론은 무의미하지만, 원래 문제를 해결하기 위해 아무 것도하지 않고 언어를 불필요하게 복잡하게하는 유효 유형 규칙의 기초를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="7470e0123159d8ce20fb052f5950c0742dcfc961" translate="yes" xml:space="preserve">
          <source>Finally there is &lt;a href=&quot;https://www.youtube.com/watch?v=vAXJeN7k32Y&quot;&gt;TySan&lt;/a&gt; which is currently in development. This sanitizer adds type checking information in a shadow memory segment and checks accesses to see if they violate aliasing rules. The tool potentially should be able to catch all aliasing violations but may have a large run-time overhead.</source>
          <target state="translated">마지막으로 현재 개발중인 &lt;a href=&quot;https://www.youtube.com/watch?v=vAXJeN7k32Y&quot;&gt;TySan&lt;/a&gt; 이 있습니다. 이 소독제는 섀도 메모리 세그먼트에 유형 검사 정보를 추가하고 앨리어싱 규칙을 위반하는지 확인합니다. 이 도구는 잠재적으로 모든 앨리어싱 위반을 포착 할 수 있어야하지만 런타임 오버 헤드가 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40e31a210a1913fd0a8b28b892780996d154c70d" translate="yes" xml:space="preserve">
          <source>Footnote</source>
          <target state="translated">Footnote</target>
        </trans-unit>
        <trans-unit id="f2e444e508c3340837f99f92afb5d8d282d725cc" translate="yes" xml:space="preserve">
          <source>For C we have all the tools already covered and we also have tis-interpreter, a static analyzer that exhaustively analyzes a program for a large subset of the C language. Given a C verions of the  earlier example where using &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; misses one case (&lt;a href=&quot;https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY&quot;&gt;see it live&lt;/a&gt;)</source>
          <target state="translated">C의 경우 이미 다룬 모든 도구와 C 언어의 큰 부분 집합에 대한 프로그램을 철저히 분석하는 정적 분석기 인 tis-interpreter도 있습니다. &lt;strong&gt;-fstrict-aliasing을&lt;/strong&gt; 사용하는 경우에 한 가지 사례가 누락 된 이전 예제의 C 버전이 &lt;strong&gt;주어짐&lt;/strong&gt; ( &lt;a href=&quot;https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY&quot;&gt;실제 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="9ead309bf16c2a5aba6251f6671c48b68c88f5ee" translate="yes" xml:space="preserve">
          <source>For those who are interested here is the x64 assembler code, produced by gcc 4.6.3, running on ubuntu 12.04.2 for x64:</source>
          <target state="translated">여기에 관심있는 사람들은 x64 용 우분투 12.04.2에서 실행되는 gcc 4.6.3에 의해 생성 된 x64 어셈블러 코드입니다.</target>
        </trans-unit>
        <trans-unit id="eef7c5809b1e5a8ae1c2904d803bf0988e0597e2" translate="yes" xml:space="preserve">
          <source>From the article:</source>
          <target state="translated">기사에서 :</target>
        </trans-unit>
        <trans-unit id="c9937d5f217a938cee9523df51e9f8f215d05426" translate="yes" xml:space="preserve">
          <source>Had Defect Report 028 said the original example invoked UB because of the overlap between the creation and use of the two pointers, that would have made things a lot more clear without having to add &quot;Effective Types&quot; or other such complexity.</source>
          <target state="translated">결함 보고서 028은 원래 예제가 두 포인터의 생성과 사용 사이의 겹침으로 인해 UB를 호출했다고 말했는데, 이는 &quot;유효 유형&quot;또는 다른 복잡성을 추가하지 않고도 상황을 훨씬 더 명확하게 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="cacd74e6fcf654b36a1d1e2975d8c5a7ad506007" translate="yes" xml:space="preserve">
          <source>Here, there is an aliasing conflict between &lt;code&gt;p&lt;/code&gt; and the access to &lt;code&gt;s.x&lt;/code&gt; on the marked line because at that point in execution another reference exists &lt;em&gt;that will be used to access the same storage&lt;/em&gt;.</source>
          <target state="translated">여기에서 &lt;code&gt;p&lt;/code&gt; 와 표시된 행의 &lt;code&gt;s.x&lt;/code&gt; 에 대한 액세스간에 앨리어싱 충돌이 발생합니다. 실행 시점에 &lt;em&gt;동일한 스토리지에 액세스하는 데 사용되는&lt;/em&gt; 다른 참조가 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="33dc7f4dd2ec6bc77310a0b059a423d8f65352d8" translate="yes" xml:space="preserve">
          <source>How do we Type Pun correctly?</source>
          <target state="translated">우리는 어떻게 정확하게 Pun을 입력합니까?</target>
        </trans-unit>
        <trans-unit id="4e0983c0e8fab722fa11f33077148a6fa369c40d" translate="yes" xml:space="preserve">
          <source>If a compiler notices that two pointers point to different types (for example, an &lt;code&gt;int *&lt;/code&gt; and a &lt;code&gt;float *&lt;/code&gt;), it will assume the memory address is different and it &lt;strong&gt;will not&lt;/strong&gt; protect against memory address collisions, resulting in faster machine code.</source>
          <target state="translated">컴파일러가 두 포인터가 다른 유형 (예 : &lt;code&gt;int *&lt;/code&gt; 및 &lt;code&gt;float *&lt;/code&gt; )을 가리키는 것을 발견하면 메모리 주소가 다른 것으로 가정하고 메모리 주소 충돌로부터 보호 &lt;strong&gt;하지 않으므로&lt;/strong&gt; 기계 코드가 더 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="e33bcaeae41be78c102c11d9ce6bff1ab9700bea" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through a &lt;em&gt;glvalue&lt;/em&gt; of other than one of the following types the behavior is undefined:</source>
          <target state="translated">프로그램이 다음 유형 중 하나 이외의 &lt;em&gt;glvalue&lt;/em&gt; 를 통해 객체의 저장된 값에 액세스하려고하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1ad9d68fd05386372885ebe000df27028379d8d" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:&lt;sup&gt;63&lt;/sup&gt;
  (11.1) &amp;mdash; the dynamic type of the object,</source>
          <target state="translated">프로그램이 다음 유형 중 하나 이외의 glvalue를 통해 객체의 저장된 값에 액세스하려고하면 동작이 정의되지 않습니다. &lt;sup&gt;63&lt;/sup&gt; (11.1) &amp;mdash; 객체의 동적 유형,</target>
        </trans-unit>
        <trans-unit id="186894b2031b450693c2e08ce7146e1a9f218d92" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined:</source>
          <target state="translated">프로그램이 다음 유형 중 하나 이외의 lvalue를 통해 오브젝트의 저장된 값에 액세스하려고하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c58ff6992c8aa3747c4710bda431e84ee2b32d03" translate="yes" xml:space="preserve">
          <source>If data in two different CPU registers will be written to the same memory space, &lt;strong&gt;we can't predict which data will &quot;survive&quot;&lt;/strong&gt; when we code in C.</source>
          <target state="translated">서로 다른 두 CPU 레지스터의 데이터가 동일한 메모리 공간에 기록되면 C로 코딩 할 때 &lt;strong&gt;어떤 데이터가 &quot;생존&quot;하는지 예측할 수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7a0013265978c8a291d1a659ebe89febc56bb358" translate="yes" xml:space="preserve">
          <source>If the code were changed slightly...</source>
          <target state="translated">코드가 약간 변경된 경우 ...</target>
        </trans-unit>
        <trans-unit id="0b4c6074b02b2e16ccba9dd1023db8c912e4726d" translate="yes" xml:space="preserve">
          <source>In C and C++ aliasing has to do with what expression types we are allowed to access stored values through. In both C and C++ the standard specifies which expression types are allowed to alias which types. The compiler and optimizer are allowed to assume we follow the aliasing rules strictly, hence the term &lt;em&gt;strict aliasing rule&lt;/em&gt;. If we attempt to access a value using a type not allowed it is classified as &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/ub&quot;&gt;undefined behavior&lt;/a&gt;(&lt;strong&gt;UB&lt;/strong&gt;). Once we have undefined behavior all bets are off, the results of our program are no longer reliable.</source>
          <target state="translated">C 및 C ++에서 앨리어싱은 저장된 값에 액세스 할 수있는 표현식 유형과 관련이 있습니다. C 및 C ++에서 표준은 어떤 표현식 유형이 어떤 유형의 별명을 지정할 수 있는지 지정합니다. 컴파일러와 옵티마이 저는 앨리어싱 규칙을 엄격하게 따른다고 가정 할 수 있으므로 &lt;em&gt;엄격한 앨리어싱 규칙&lt;/em&gt; 이라는 용어가 사용됩니다. 허용되지 않는 유형을 사용하여 값에 액세스하려고하면 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/ub&quot;&gt;정의되지 않은 동작&lt;/a&gt; ( &lt;strong&gt;UB&lt;/strong&gt; )으로 분류됩니다. 우리가 정의되지 않은 행동을 취하면 모든 베팅이 해제되고, 프로그램 결과는 더 이상 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5c8e94cbd15bdd54a4fb204f2d1514b6f794ce32" translate="yes" xml:space="preserve">
          <source>In C++20 we may gain &lt;strong&gt;bit_cast&lt;/strong&gt; (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html&quot;&gt;implementation available in link from proposal&lt;/a&gt;) which gives a simple and safe way to type-pun as well as being usable in a constexpr context.</source>
          <target state="translated">C ++ 20에서는 &lt;strong&gt;bit_cast&lt;/strong&gt; ( &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html&quot;&gt;proposal에서 링크로 사용 가능한 구현&lt;/a&gt; )를 얻을 수 있으며 이는 constpunr 컨텍스트에서 사용할 수있을뿐만 아니라 type-pun하는 간단하고 안전한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="30d64c522aac604d7e48c4556b8d77b5be2eeb6e" translate="yes" xml:space="preserve">
          <source>In assembly, where we code the loading and unloading of CPU registers manually, we will know which data remains intact. But C (thankfully) abstracts this detail away.</source>
          <target state="translated">CPU 레지스터의로드 및 언로드를 수동으로 코딩하는 어셈블리에서는 어떤 데이터가 손상되지 않았는지 알 수 있습니다. 그러나 C는 (고맙게도)이 세부 사항을 추상화합니다.</target>
        </trans-unit>
        <trans-unit id="1098f88dd457b5be2f2059df57bcf4338d706f24" translate="yes" xml:space="preserve">
          <source>In fact, by adding the &lt;code&gt;restrict&lt;/code&gt; keyword, the whole function could be optimized to:</source>
          <target state="translated">실제로 &lt;code&gt;restrict&lt;/code&gt; 키워드를 추가하면 전체 기능을 다음과 같이 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5757f1784e296249565c7c4929c37f6183ec27c" translate="yes" xml:space="preserve">
          <source>In order to handle the case in which &lt;code&gt;a == b&lt;/code&gt; (both pointers point to the same memory), we need to order and test the way we load data from the memory to the CPU registers, so the code might end up like this:</source>
          <target state="translated">&lt;code&gt;a == b&lt;/code&gt; (포인터 모두 동일한 메모리를 가리키는)의 경우를 처리하려면 메모리에서 CPU 레지스터로 데이터를로드하는 방식을 주문하고 테스트해야하므로 코드는 다음과 같이 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edbd3b6b40a8cde551f4ffba070d64d6c6313a52" translate="yes" xml:space="preserve">
          <source>In the case where &lt;em&gt;To&lt;/em&gt; and &lt;em&gt;From&lt;/em&gt; types don't have the same size, it requires us to use an intermediate struct15. We will use a struct containing a &lt;strong&gt;sizeof( unsigned int )&lt;/strong&gt; character array (&lt;em&gt;assumes 4 byte unsigned int&lt;/em&gt;) to be the &lt;em&gt;From&lt;/em&gt; type and &lt;em&gt;unsigned int&lt;/em&gt; as the &lt;em&gt;To&lt;/em&gt; type.:</source>
          <target state="translated">&lt;em&gt;To&lt;/em&gt; 와 &lt;em&gt;From&lt;/em&gt; 타입이 같은 크기가 아닌 경우 중간 구조체를 사용해야합니다 15. &lt;strong&gt;sizeof (unsigned int)&lt;/strong&gt; 문자형 배열 ( &lt;em&gt;4 바이트 unsigned int 가정&lt;/em&gt; &lt;strong&gt;)을&lt;/strong&gt; 포함하는 구조체를 &lt;em&gt;From&lt;/em&gt; 유형으로, &lt;em&gt;unsigned int&lt;/em&gt; 를 &lt;em&gt;To&lt;/em&gt; 유형으로 사용합니다. :</target>
        </trans-unit>
        <trans-unit id="d116eeee6f567bfeb6ee6948778e1441846b7681" translate="yes" xml:space="preserve">
          <source>In the function &lt;strong&gt;foo&lt;/strong&gt; we take an &lt;em&gt;int*&lt;/em&gt; and a &lt;em&gt;float*&lt;/em&gt;, in this example we call &lt;strong&gt;foo&lt;/strong&gt; and set both parameters to point to the same memory location which in this example contains an &lt;em&gt;int&lt;/em&gt;. Note, the &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; is telling the compiler to treat the the expression as if it had the type specificed by its template parameter. In this case we are telling it to treat the expression &lt;strong&gt;&amp;amp;x&lt;/strong&gt; as if it had type &lt;em&gt;float*&lt;/em&gt;. We may naively expect the result of the second &lt;strong&gt;cout&lt;/strong&gt; to be &lt;strong&gt;0&lt;/strong&gt; but with optimization enabled using &lt;strong&gt;-O2&lt;/strong&gt; both gcc and clang produce the following result:</source>
          <target state="translated">&lt;strong&gt;foo&lt;/strong&gt; 함수에서 우리는 &lt;em&gt;int *&lt;/em&gt; 와 &lt;em&gt;float *를&lt;/em&gt; 취합니다.이 예제에서 우리는 &lt;strong&gt;foo&lt;/strong&gt; 를 호출하고이 예제에서 &lt;em&gt;int&lt;/em&gt; 를 포함하는 동일한 메모리 위치를 가리 키도록 두 매개 변수를 설정합니다. &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; 는 컴파일러에게 표현식을 템플릿 매개 변수로 지정된 유형을 가진 것처럼 취급하도록 지시합니다. 이 경우 표현식 &lt;strong&gt;&amp;amp; x&lt;/strong&gt; 가 &lt;em&gt;float *&lt;/em&gt; 유형 인 것처럼 취급하도록 지시합니다. 우리는 순진하게 두 번째 &lt;strong&gt;cout&lt;/strong&gt; 의 결과가 &lt;strong&gt;0 일&lt;/strong&gt; 것으로 예상 할 수 있지만 gcc와 clang 모두 &lt;strong&gt;-O2를&lt;/strong&gt; 사용하여 최적화를 활성화하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d68abdd18fdbebaf82ef26f4a744ddcd23eee685" translate="yes" xml:space="preserve">
          <source>It is unfortunate that we need this intermediate type but that is the current constraint of &lt;strong&gt;bit_cast&lt;/strong&gt;.</source>
          <target state="translated">불행히도이 중간 유형이 필요하지만 이것이 &lt;strong&gt;bit_cast&lt;/strong&gt; 의 현재 제약 조건입니다.</target>
        </trans-unit>
        <trans-unit id="da92ddda51dcc47ff0f56cb81c8d27a13de9b35f" translate="yes" xml:space="preserve">
          <source>Keep in mind, if you think the example is contrived, this might even happen if you're passing a buffer to another function doing the sending for you, if instead you have.</source>
          <target state="translated">예제가 고안되었다고 생각하면 버퍼를 다른 함수에 전달하여 대신 보내는 기능을 수행하는 경우에도 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa2a2cd3b185c908c2467f71930ddb0e035406e3" translate="yes" xml:space="preserve">
          <source>Let's look at some examples, then we can talk about exactly what the standard(s) say, examine some further examples and then see how to avoid strict aliasing and catch violations we missed. Here is an example that should not be surprising (&lt;a href=&quot;https://wandbox.org/permlink/7sCJTAyrifZ0zfFA&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">몇 가지 예를 살펴보면 표준이 말하는 내용에 대해 자세히 이야기하고 몇 가지 추가 예를 살펴본 다음 엄격한 앨리어싱을 피하고 우리가 놓친 위반을 포착하는 방법을 볼 수 있습니다. 다음은 놀랍지 않은 예제입니다 ( &lt;a href=&quot;https://wandbox.org/permlink/7sCJTAyrifZ0zfFA&quot;&gt;live example&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="036ae8cbf7c3814fcac323366fb44ffbfacfa142" translate="yes" xml:space="preserve">
          <source>Lets assume the following function:</source>
          <target state="translated">다음과 같은 기능을 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="6866b7efbb6193426e6184afeb038e84825105d8" translate="yes" xml:space="preserve">
          <source>Memory access can be expensive (performance wise), which is why &lt;strong&gt;data is manipulated in CPU registers&lt;/strong&gt; before being written back to the physical memory.</source>
          <target state="translated">메모리 액세스는 비용이 많이 들고 (성능면에서) 물리적 메모리에 다시 쓰기 전에 &lt;strong&gt;CPU 레지스터에서 데이터가 조작되는&lt;/strong&gt; 이유입니다.</target>
        </trans-unit>
        <trans-unit id="9992043f68467a20f1d79f1ccb74a9265be5e20c" translate="yes" xml:space="preserve">
          <source>Much of the problem is a result of Defect Report #028, which asked about the behavior of a program like:</source>
          <target state="translated">대부분의 문제는 결함 보고서 # 028의 결과이며 다음과 같은 프로그램의 동작에 대해 묻습니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="5650248b0b69558ceb303fc582535c5dbae34409" translate="yes" xml:space="preserve">
          <source>Note the definition of indirection (&lt;a href=&quot;http://eel.is/c++draft/expr.unary.op#def:indirection&quot;&gt;* operator&lt;/a&gt;):</source>
          <target state="translated">간접 정의 ( &lt;a href=&quot;http://eel.is/c++draft/expr.unary.op#def:indirection&quot;&gt;* operator&lt;/a&gt; )의 정의에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="00e406f7a5b6352740c9e91b4d2959a865ade69d" translate="yes" xml:space="preserve">
          <source>Now, by satisfying the Strict Aliasing rule, step 3 can be avoided and the code will run significantly faster.</source>
          <target state="translated">이제 엄격한 앨리어싱 규칙을 충족함으로써 3 단계를 피할 수 있으며 코드가 훨씬 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="24f4a3365263f6701ca3e6f9cc300671fef25d11" translate="yes" xml:space="preserve">
          <source>Now, to the Rule-Book</source>
          <target state="translated">이제 룰북으로</target>
        </trans-unit>
        <trans-unit id="00f2110e4b85aedc83fe7286d38033b5fadad084" translate="yes" xml:space="preserve">
          <source>Preliminary examples</source>
          <target state="translated">예비 예</target>
        </trans-unit>
        <trans-unit id="1a68967890ea62e6416814f2cd9ae705194f7f5a" translate="yes" xml:space="preserve">
          <source>Since two pointers can point to the same location in the memory, this could result in &lt;strong&gt;complex code that handles possible collisions&lt;/strong&gt;.</source>
          <target state="translated">두 포인터가 메모리에서 동일한 위치를 가리킬 수 있기 때문에 &lt;strong&gt;가능한 충돌을 처리하는 복잡한 코드&lt;/strong&gt; 가 생길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e831ce62bacf79dafcd6bc9e83656cfee8fb782d" translate="yes" xml:space="preserve">
          <source>So basically if you have an &lt;code&gt;int*&lt;/code&gt; pointing to some memory containing an &lt;code&gt;int&lt;/code&gt; and then you point a &lt;code&gt;float*&lt;/code&gt; to that memory and use it as a &lt;code&gt;float&lt;/code&gt; you break the rule. If your code does not respect this, then the compiler's optimizer will most likely break your code.</source>
          <target state="translated">따라서 기본적으로 &lt;code&gt;int*&lt;/code&gt; 가 int를 포함하는 일부 메모리를 가리키는 경우 &lt;code&gt;float*&lt;/code&gt; 를 해당 메모리를 가리키고 float로 사용하면 규칙을 위반합니다. 코드가 이것을 존중하지 않으면 컴파일러의 최적화 프로그램이 코드를 손상시킬 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="e527630d421fb5eeeebbd1a1fc94426badbe336a" translate="yes" xml:space="preserve">
          <source>So in any well defined program trace, a glvalue refers to an object. &lt;strong&gt;So the so called strict aliasing rule doesn't apply, ever.&lt;/strong&gt; This may not be what the designers wanted.</source>
          <target state="translated">따라서 잘 정의 된 프로그램 추적에서 glvalue는 객체를 나타냅니다. &lt;strong&gt;따라서 소위 엄격한 앨리어싱 규칙은 적용되지 않습니다.&lt;/strong&gt; 디자이너가 원하는 것이 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="deed8318c0841e594ef317b02788fe411e71c755" translate="yes" xml:space="preserve">
          <source>So in this kind of setup, if I want to send a message to something I'd have to have two incompatible pointers pointing to the same chunk of memory. I might then naively code something like this (on a system with &lt;code&gt;sizeof(int) == 2&lt;/code&gt;):</source>
          <target state="translated">따라서 이런 종류의 설정에서 메시지를 보내려면 동일한 메모리 청크를 가리키는 두 개의 호환되지 않는 포인터가 있어야합니다. 그런 다음 다음과 같이 순진하게 코딩 할 수 있습니다 ( &lt;code&gt;sizeof(int) == 2&lt;/code&gt; 시스템에서).</target>
        </trans-unit>
        <trans-unit id="aafc604e71041d21e6cb4b116236a68fac502d6a" translate="yes" xml:space="preserve">
          <source>So the if condition is completely gone from the assembler code.</source>
          <target state="translated">따라서 if 조건은 어셈블러 코드에서 완전히 사라졌습니다.</target>
        </trans-unit>
        <trans-unit id="be497017b70114a5fa54de0086695c60b70ce08f" translate="yes" xml:space="preserve">
          <source>Sometimes we want to circumvent the type system and interpret an object as a different type. This is called &lt;em&gt;type punning&lt;/em&gt;, to reinterpret a segment of memory as another type. &lt;em&gt;Type punning&lt;/em&gt; is useful for tasks that want access to the underlying representation of an object to view, transport or manipulate. Typical areas we find type punning being used are compilers, serialization, networking code, etc&amp;hellip;</source>
          <target state="translated">때때로 우리는 타입 시스템을 우회하고 객체를 다른 타입으로 해석하려고합니다. 이것을 메모리 세그먼트를 다른 유형으로 재 해석하기 위해 &lt;em&gt;유형 punning&lt;/em&gt; 이라고합니다. &lt;em&gt;유형 제거&lt;/em&gt; 는 객체의 기본 표현에 액세스하여 보거나 전송하거나 조작하려는 작업에 유용합니다. 우리가 사용하는 타입 제거 (punning)는 컴파일러, 직렬화, 네트워킹 코드 등입니다.</target>
        </trans-unit>
        <trans-unit id="0e41cb1a9e14feeabe231350d4a98b43b5438b1e" translate="yes" xml:space="preserve">
          <source>Step 3 is very slow because it needs to access the physical memory. However, it's required to protect against instances where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; point to the same memory address.</source>
          <target state="translated">3 단계는 실제 메모리에 액세스해야하므로 매우 느립니다. 그러나 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 동일한 메모리 주소를 가리키는 인스턴스로부터 보호해야합니다.</target>
        </trans-unit>
        <trans-unit id="6950bbb2a5fc815374e2b4c9fe07f848dcde484e" translate="yes" xml:space="preserve">
          <source>Strict aliasing (which I'll describe in a bit) &lt;strong&gt;is important because&lt;/strong&gt;:</source>
          <target state="translated">다음과 같은 &lt;strong&gt;이유로&lt;/strong&gt; 엄격한 앨리어싱 (나중에 설명하겠습니다) &lt;strong&gt;이 중요합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7b097276866172c8f0649d49560868d6d4cb3def" translate="yes" xml:space="preserve">
          <source>Strict aliasing doesn't refer only to pointers, it affects references as well, I wrote a paper about it for the boost developer wiki and it was so well received that I turned it into a page on my consulting web site.  It explains completely what it is, why it confuses people so much and what to do about it. &lt;a href=&quot;http://dbp-consulting.com/tutorials/StrictAliasing.html&quot;&gt;Strict Aliasing White Paper&lt;/a&gt;.  In particular it explains why unions are risky behavior for C++, and why using memcpy is the only fix portable across both C and C++.  Hope this is helpful.</source>
          <target state="translated">엄격한 앨리어싱은 포인터만을 가리키는 것이 아니며 참조에도 영향을 미칩니다. 부스트 개발자 위키에 대한 논문을 작성했으며 컨설팅 웹 사이트의 페이지로 전환하기에 너무 많이 받았습니다. 그것은 그것이 무엇인지, 사람들을 왜 그렇게 혼란스럽게하는지, 그것에 대해 무엇을 해야하는지 완전히 설명합니다. &lt;a href=&quot;http://dbp-consulting.com/tutorials/StrictAliasing.html&quot;&gt;엄격한 앨리어싱 백서&lt;/a&gt; . 특히 C ++에서 유니온이 위험한 행동 인 이유와 memcpy를 사용하는 것이 C와 C ++ 모두에서 유일한 이식 가능한 이유를 설명합니다. 이것이 도움이 되길 바랍니다.</target>
        </trans-unit>
        <trans-unit id="ed51e87442d0b7d44562385cb2eaa5830e3da786" translate="yes" xml:space="preserve">
          <source>Strict aliasing is not allowing different pointer types to the same data.</source>
          <target state="translated">엄격한 앨리어싱은 동일한 데이터에 다른 포인터 유형을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08f4008712546a2f35d451915a75c5ce6707541f" translate="yes" xml:space="preserve">
          <source>Strict aliasing would allow us to prevent this by telling the compiler that these memory addresses are distinctly different (which, in this case, will allow even further optimization which can't be performed if the pointers share a memory address).</source>
          <target state="translated">엄격한 앨리어싱을 사용하면 컴파일러에 이러한 메모리 주소가 명확하게 다르다는 사실을 알 수 있습니다 (이 경우 포인터가 메모리 주소를 공유하는 경우 수행 할 수없는 추가 최적화가 가능함).</target>
        </trans-unit>
        <trans-unit id="3de059986d55a4c9204e0422ce6405ee0f2fae76" translate="yes" xml:space="preserve">
          <source>Technically in C++, the strict aliasing rule is probably never applicable.</source>
          <target state="translated">기술적으로 C ++에서 엄격한 앨리어싱 규칙은 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="907bce6add949792da1d5d77350df907126f6c70" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;C11&lt;/strong&gt; standard says the following in section &lt;em&gt;6.5 Expressions paragraph 7&lt;/em&gt;:</source>
          <target state="translated">&lt;strong&gt;C11&lt;/strong&gt; 표준은 &lt;em&gt;6.5 절 7&lt;/em&gt; 절에서 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="bfd25f24e236cc975bc1fefb913df995d3049915" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Strict aliasing rule allows us to avoid redundant machine code&lt;/strong&gt; in cases in which it &lt;em&gt;should be&lt;/em&gt; safe to assume that two pointers don't point to the same memory block (see also the &lt;code&gt;restrict&lt;/code&gt; keyword).</source>
          <target state="translated">&lt;strong&gt;엄격한 별칭 지정 규칙을 사용하면&lt;/strong&gt; 두 개의 포인터가 동일한 메모리 블록을 가리 키지 않는다고 가정하는 &lt;em&gt;것이&lt;/em&gt; 안전 &lt;em&gt;해야하는&lt;/em&gt; 경우 &lt;strong&gt;중복 기계 코드를 피할&lt;/strong&gt; &lt;em&gt;수&lt;/em&gt; 있습니다 ( &lt;code&gt;restrict&lt;/code&gt; 키워드도 참조).</target>
        </trans-unit>
        <trans-unit id="8c06897729db17629b567058f47bdaf4c4318b26" translate="yes" xml:space="preserve">
          <source>The C++17 draft standard in section &lt;em&gt;[basic.lval] paragraph 11&lt;/em&gt; says:</source>
          <target state="translated">&lt;em&gt;[basic.lval] 단락 11&lt;/em&gt; 의 C ++ 17 초안 표준은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9bc4e143126dccfdfaa1a458c40e03e32eb19eb7" translate="yes" xml:space="preserve">
          <source>The Strict aliasing states it's safe to assume that pointers to different types point to different locations in the memory.</source>
          <target state="translated">엄격한 앨리어싱은 다른 유형에 대한 포인터가 메모리의 다른 위치를 가리키는 것으로 가정하는 것이 안전하다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="7928780bf9e4496f92d12638d4fa464749948340" translate="yes" xml:space="preserve">
          <source>The best explanation I have found is by Mike Acton, &lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;Understanding Strict Aliasing&lt;/a&gt;. It's focused a little on PS3 development, but that's basically just GCC.</source>
          <target state="translated">내가 찾은 가장 좋은 설명은 Mike Acton의 &lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;엄격한 앨리어싱 이해&lt;/a&gt; 입니다. PS3 개발에 중점을 두었지만 기본적으로 GCC입니다.</target>
        </trans-unit>
        <trans-unit id="49c47e96747dd9ea774b5bc163ec15c244b5f868" translate="yes" xml:space="preserve">
          <source>The best way to resolve the original problem would probably be to treat the
footnote about the purpose of the rule as though it were normative, and made
the rule unenforceable except in cases which actually involve conflicting accesses using aliases.  Given something like:</source>
          <target state="translated">원래 문제를 해결하는 가장 좋은 방법은 규칙의 목적에 대한 각주를 규범적인 것처럼 취급하고 실제로 별칭을 사용하여 액세스가 충돌하는 경우를 제외하고 규칙을 시행 할 수 없게 만드는 것입니다. 다음과 같은 것이 주어진다 :</target>
        </trans-unit>
        <trans-unit id="85b689b0761df13dcd7da661f9fdf03565c0a4a1" translate="yes" xml:space="preserve">
          <source>The compiler may or may not be able to or smart enough to try to inline SendMessage and it may or may not decide to load or not load buff again. If &lt;code&gt;SendMessage&lt;/code&gt; is part of another API that's compiled separately, it probably has instructions to load buff's contents. Then again, maybe you're in C++ and this is some templated header only implementation that the compiler thinks it can inline. Or maybe it's just something you wrote in your .c file for your own convenience. Anyway undefined behavior might still ensue. Even when we know some of what's happening under the hood, it's still a violation of the rule so no well defined behavior is guaranteed. So just by wrapping in a function that takes our word delimited buffer doesn't necessarily help.</source>
          <target state="translated">컴파일러는 SendMessage를 인라인하려고 시도하기에 충분하거나 현명하지 않을 수 있으며 다시 버프를로드하거나로드하지 않기로 결정할 수도 있습니다. &lt;code&gt;SendMessage&lt;/code&gt; 가 별도로 컴파일 된 다른 API의 일부인 경우에는 버프 내용을로드하라는 지시 사항이있을 수 있습니다. 그런 다음 C ++에있을 수 있으며 컴파일러가 인라인 할 수 있다고 생각하는 템플릿 화 된 헤더 전용 구현입니다. 또는 자신의 편의를 위해 .c 파일에 작성한 것일 수도 있습니다. 어쨌든 정의되지 않은 동작이 계속 발생할 수 있습니다. 우리가 어떤 일이 벌어지고 있는지 아는 경우에도 여전히 규칙을 위반하므로 잘 정의 된 동작이 보장되지 않습니다. 따라서 단어 구분 버퍼를 취하는 함수를 래핑한다고해서 반드시 도움이되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="185da178ba74f21fd6fbee6fc9a19c180251420b" translate="yes" xml:space="preserve">
          <source>The exception to the rule is a &lt;code&gt;char*&lt;/code&gt;, which is allowed to point to any type.</source>
          <target state="translated">규칙의 예외는 &lt;code&gt;char*&lt;/code&gt; 이며 모든 유형을 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6deb33976faa98a7a8b3f350b9d49c319c195cd" translate="yes" xml:space="preserve">
          <source>The following is an example of how to use &lt;strong&gt;bit_cast&lt;/strong&gt; to type pun a &lt;em&gt;unsigned int&lt;/em&gt; to &lt;em&gt;float&lt;/em&gt;, (&lt;a href=&quot;https://wandbox.org/permlink/i5l0g4IYuCFgLzzl&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">다음은 &lt;strong&gt;bit_cast&lt;/strong&gt; 를 사용하여 &lt;em&gt;unsigned int&lt;/em&gt; 를 pun으로 입력하는 방법의 예입니다 ( &lt;a href=&quot;https://wandbox.org/permlink/i5l0g4IYuCFgLzzl&quot;&gt;실제 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bc2fdca487b4e3f2274bf45676f76859149d4991" translate="yes" xml:space="preserve">
          <source>The last tool I will recommend is C++ specific and not strictly a tool but a coding practice, don't allow C-style casts. Both gcc and clang will produce a diagnostic for C-style casts using &lt;strong&gt;-Wold-style-cast&lt;/strong&gt;. This will force any undefined type puns to use reinterpret_cast, in general reinterpret_cast should be a flag for closer code review. It is also easier to search your code base for reinterpret_cast to perform an audit.</source>
          <target state="translated">내가 추천 할 마지막 도구는 C ++ 전용이며 엄격하게 도구는 아니지만 코딩 방식이므로 C 스타일 캐스트를 허용하지 않습니다. gcc와 clang은 모두 &lt;strong&gt;-Wold-style-&lt;/strong&gt; cast를 사용하여 C 스타일 캐스트에 대한 진단을 생성합니다. 이렇게하면 정의되지 않은 유형의 펑이 reinterpret_cast를 사용하게되며, 일반적으로 reinterpret_cast는 면밀한 코드 검토를위한 플래그 여야합니다. 감사를 수행하기 위해 reinterpret_cast에 대한 코드베이스를 검색하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="d6426a86b973a6cec74fb415633b300e0a37c506" translate="yes" xml:space="preserve">
          <source>The next example shows aliasing that leads to undefined behavior (&lt;a href=&quot;https://wandbox.org/permlink/8qA8JyJRVHtS9LPf&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">다음 예제는 정의되지 않은 동작으로 이어지는 앨리어싱을 보여줍니다 ( &lt;a href=&quot;https://wandbox.org/permlink/8qA8JyJRVHtS9LPf&quot;&gt;live example&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5e5d6deec660f2c03a74983d7e1f704f0a612063" translate="yes" xml:space="preserve">
          <source>The optimizer using &lt;a href=&quot;http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm&quot;&gt;Type-Based Alias Analysis (TBAA)&lt;/a&gt; assumes &lt;strong&gt;1&lt;/strong&gt; will be returned and directly moves the constant value into register &lt;strong&gt;eax&lt;/strong&gt; which carries the return value. TBAA uses the languages rules about what types are allowed to alias to optimize loads and stores. In this case TBAA knows that a &lt;em&gt;float&lt;/em&gt; can not alias and &lt;em&gt;int&lt;/em&gt; and optimizes away the load of &lt;strong&gt;i&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm&quot;&gt;TBAA (Type-Based Alias ​​Analysis)를&lt;/a&gt; 사용하는 옵티마이 저는 &lt;strong&gt;1&lt;/strong&gt; 이 리턴되고 상수 값을 리턴 값을 전달하는 레지스터 &lt;strong&gt;eax&lt;/strong&gt; 로 직접 이동한다고 가정합니다. TBAA는로드 및 저장을 최적화하기 위해 별명을 지정할 수있는 유형에 대한 언어 규칙을 사용합니다. 이 경우 TBAA는 &lt;em&gt;float&lt;/em&gt; 가 별칭과 &lt;em&gt;int를&lt;/em&gt; 별칭으로 지정할 수 없다는 것을 알고 &lt;strong&gt;i&lt;/strong&gt; 의로드를 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="eb988ee6dabc3ef8446376c66441177c2cd532a0" translate="yes" xml:space="preserve">
          <source>The standard method for &lt;em&gt;type punning&lt;/em&gt; in both C and C++ is &lt;strong&gt;memcpy&lt;/strong&gt;. This may seem a little heavy handed but the optimizer should recognize the use of &lt;strong&gt;memcpy&lt;/strong&gt; for &lt;em&gt;type punning&lt;/em&gt; and optimize it away and generate a register to register move. For example if we know &lt;em&gt;int64_t&lt;/em&gt; is the same size as &lt;em&gt;double&lt;/em&gt;:</source>
          <target state="translated">C 및 C ++에서 &lt;em&gt;유형 punning&lt;/em&gt; 의 표준 방법은 &lt;strong&gt;memcpy&lt;/strong&gt; 입니다. 이것은 약간 무거운 것으로 보일지 모르지만 옵티마이 저는 &lt;em&gt;유형 punning&lt;/em&gt; 에 &lt;strong&gt;memcpy&lt;/strong&gt; 의 사용을 인식하고 최적화하여 레지스터 이동을 등록하는 레지스터를 생성해야합니다. 예를 들어 &lt;em&gt;int64_t&lt;/em&gt; 의 크기가 &lt;em&gt;double&lt;/em&gt; 과 같다는 것을 알고 있다면 :</target>
        </trans-unit>
        <trans-unit id="08b2135b25032781b64ff4c52a4bdd14662d43d7" translate="yes" xml:space="preserve">
          <source>The strict aliasing rule makes this setup illegal: dereferencing a pointer that aliases an object that is not of a &lt;a href=&quot;http://en.cppreference.com/w/c/language/type&quot;&gt;compatible type&lt;/a&gt; or one of the other types allowed by C 2011 6.5 paragraph 7&lt;sup&gt;1&lt;/sup&gt; is undefined behavior. Unfortunately, you can still code this way, &lt;em&gt;maybe&lt;/em&gt; get some warnings, have it compile fine, only to have weird unexpected behavior when you run the code.</source>
          <target state="translated">엄격한 앨리어싱 규칙은이 설정을 불법으로 만듭니다. &lt;a href=&quot;http://en.cppreference.com/w/c/language/type&quot;&gt;호환 가능한 유형&lt;/a&gt; 이 아니거나 C 2011 6.5 단락 7 &lt;sup&gt;1에서&lt;/sup&gt; 허용하는 다른 유형 중 하나가 아닌 개체의 별칭을 지정하는 포인터는 정의되지 않은 동작입니다. 불행히도, 당신은 여전히 ​​이런 식으로 코딩 할 수 있습니다. &lt;em&gt;어쩌면&lt;/em&gt; 경고를 받고, 잘 컴파일되도록하고, 코드를 실행할 때 이상한 예기치 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bd0246c8dec2dd6e8cc0d773260f9ddcf056333b" translate="yes" xml:space="preserve">
          <source>The third change makes a stronger guarantee (relaxes the strong aliasing rule): The new concept of &lt;em&gt;similar types&lt;/em&gt; that are now safe to alias.</source>
          <target state="translated">세 번째 변경은 더 강력한 보증을 제공합니다 (강한 앨리어싱 규칙을 완화 함). 이제 별칭에 안전한 &lt;em&gt;유사한 유형&lt;/em&gt; 의 새로운 개념.</target>
        </trans-unit>
        <trans-unit id="428a7cf24521c1266f3851b503c14cb107e579a2" translate="yes" xml:space="preserve">
          <source>The unary * operator performs indirection: the expression to which it
  is applied shall be a pointer to an object type, or a pointer to a
  function type and &lt;strong&gt;the result is an lvalue referring to the object&lt;/strong&gt; or
  function &lt;strong&gt;to which the expression points&lt;/strong&gt;.</source>
          <target state="translated">단항 * 연산자는 간접을 수행합니다. 적용되는 표현식은 객체 유형에 대한 포인터 또는 함수 유형에 대한 포인터 여야하며 &lt;strong&gt;결과는&lt;/strong&gt; &lt;strong&gt;표현식이 가리키는&lt;/strong&gt; &lt;strong&gt;객체&lt;/strong&gt; 또는 함수 &lt;strong&gt;를&lt;/strong&gt; &lt;strong&gt;참조하는 lvalue&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f3edc398608fb9b543cd714f6b95b268072cc297" translate="yes" xml:space="preserve">
          <source>There's no conflict within &lt;code&gt;inc_int&lt;/code&gt; because all accesses to the storage accessed through &lt;code&gt;*p&lt;/code&gt; are done with an lvalue of type &lt;code&gt;int&lt;/code&gt;, and there's no conflict in &lt;code&gt;test&lt;/code&gt; because &lt;code&gt;p&lt;/code&gt; is visibly derived from a &lt;code&gt;struct S&lt;/code&gt;, and by the next time &lt;code&gt;s&lt;/code&gt; is used, all accesses to that storage that will ever be made through &lt;code&gt;p&lt;/code&gt; will have already happened.</source>
          <target state="translated">&lt;code&gt;*p&lt;/code&gt; 를 통해 액세스 된 스토리지에 대한 모든 액세스는 &lt;code&gt;int&lt;/code&gt; 유형의 lvalue로 수행되므로 &lt;code&gt;inc_int&lt;/code&gt; 내에서 충돌이 없으며 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;struct S&lt;/code&gt; 에서 눈에 띄게 파생되고 다음 번에는 &lt;code&gt;s&lt;/code&gt; 가 사용될 때 &lt;code&gt;test&lt;/code&gt; 에서 충돌이 없습니다. &lt;code&gt;p&lt;/code&gt; 를 통해 수행 될 스토리지에 대한 액세스는 이미 발생했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="1e47063a12afd4868e46be1f29d48214f059315d" translate="yes" xml:space="preserve">
          <source>This can be told to the compiler in two ways, by using different types to point to. i.e.:</source>
          <target state="translated">서로 다른 유형을 사용하여 두 가지 방법으로 컴파일러에 알릴 수 있습니다. 즉 :</target>
        </trans-unit>
        <trans-unit id="6f8c42e0f055d24e57ba0b97836be0b7abeb6542" translate="yes" xml:space="preserve">
          <source>This extra code is slow and &lt;strong&gt;hurts performance&lt;/strong&gt; since it performs extra memory read / write operations which are both slower and (possibly) unnecessary.</source>
          <target state="translated">이 추가 코드는 느리고 필요하지 않은 추가 메모리 읽기 / 쓰기 작업을 수행하므로 &lt;strong&gt;성능&lt;/strong&gt; 이 저하되고 &lt;strong&gt;성능&lt;/strong&gt; 이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="03bd20f42d11715386a09efa404ec49187a334ec" translate="yes" xml:space="preserve">
          <source>This is excerpted from my &lt;a href=&quot;https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8&quot;&gt;&quot;What is the Strict Aliasing Rule and Why do we care?&quot;&lt;/a&gt; write-up.</source>
          <target state="translated">이것은 &lt;a href=&quot;https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8&quot;&gt;&quot;엄격한 앨리어싱 규칙은 무엇이며 왜 우리는 신경 쓰는가?&quot;&lt;/a&gt; 에서 발췌 한 것 입니다. 쓰기.</target>
        </trans-unit>
        <trans-unit id="23f8f6c33332ebb487428148aeaa250e333c0297" translate="yes" xml:space="preserve">
          <source>This is not valid in C++ and some consider the purpose of unions to be solely for implementing variant types and feel using unions for type punning is an abuse.</source>
          <target state="translated">이것은 C ++에서는 유효하지 않으며 일부는 노조의 목적이 변형 유형을 구현하기위한 것만 고려하고 유형 punning에 노조를 사용하는 것이 남용이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="b5a81d05fa60ca66493d7a8dd3adf9606ece3212" translate="yes" xml:space="preserve">
          <source>This is only one potential minefield when overlaying two types onto each other. You should also learn about &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;endianness&lt;/a&gt;, &lt;a href=&quot;http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html&quot;&gt;word alignment&lt;/a&gt;, and how to deal with alignment issues through &lt;a href=&quot;http://grok2.com/structure_packing.html&quot;&gt;packing structs&lt;/a&gt; correctly.</source>
          <target state="translated">두 유형을 서로 오버레이 할 때 이것은 하나의 잠재적 지뢰밭입니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;엔디안&lt;/a&gt; , &lt;a href=&quot;http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html&quot;&gt;단어 정렬&lt;/a&gt; 및 &lt;a href=&quot;http://grok2.com/structure_packing.html&quot;&gt;구조체를&lt;/a&gt; 올바르게 패킹 하여 정렬 문제를 처리하는 방법에 대해서도 배워야합니다.</target>
        </trans-unit>
        <trans-unit id="1206246dfe34c612a18075c8bf78ec4ea7f41bed" translate="yes" xml:space="preserve">
          <source>This is the strict aliasing rule, found in section 3.10 of the &lt;strong&gt;C++03&lt;/strong&gt; standard (other answers provide good explanation, but none provided the rule itself):</source>
          <target state="translated">이것은 &lt;strong&gt;C ++ 03&lt;/strong&gt; 표준의 3.10 섹션에있는 엄격한 앨리어싱 규칙입니다 (다른 답변은 좋은 설명을 제공하지만 규칙 자체는 제공하지 않았습니다).</target>
        </trans-unit>
        <trans-unit id="136cb4ca2af68d11d5c37a73bdbfaeaff7fafa9a" translate="yes" xml:space="preserve">
          <source>This optimization couldn't have been done before, because of the possible collision (where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; would be tripled instead of doubled).</source>
          <target state="translated">충돌 가능성으로 인해이 최적화를 수행 할 수 없었습니다 ( &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 두 배가 아니라 세 배가 됨).</target>
        </trans-unit>
        <trans-unit id="0c6e49d370e8ee32d1f9fb66865bb3dc534b3fdf" translate="yes" xml:space="preserve">
          <source>To see why this behavior is undefined, we have to think about what the strict aliasing rule buys the compiler. Basically, with this rule, it doesn't have to think about inserting instructions to refresh the contents of &lt;code&gt;buff&lt;/code&gt; every run of the loop. Instead, when optimizing, with some annoyingly unenforced assumptions about aliasing, it can omit those instructions, load &lt;code&gt;buff[0]&lt;/code&gt; and &lt;code&gt;buff[1&lt;/code&gt;] into CPU registers once before the loop is run, and speed up the body of the loop. Before strict aliasing was introduced, the compiler had to live in a state of paranoia that the contents of &lt;code&gt;buff&lt;/code&gt; could change at anytime from anywhere by anybody. So to get an extra performance edge, and assuming most people don't type-pun pointers, the strict aliasing rule was introduced.</source>
          <target state="translated">이 동작이 정의되지 않은 이유를 보려면 엄격한 앨리어싱 규칙이 컴파일러를 구입하는 것에 대해 생각해야합니다. 기본적으로이 규칙을 사용하면 루프를 실행할 때마다 &lt;code&gt;buff&lt;/code&gt; 의 내용을 새로 고치기위한 명령어 삽입에 대해 생각할 필요가 없습니다. 대신, 앨리어싱에 대해 성가 시게 강요되지 않는 가정을 사용하여 최적화 할 때 루프가 실행되기 전에 해당 명령어를 생략하고 &lt;code&gt;buff[0]&lt;/code&gt; 및 &lt;code&gt;buff[1&lt;/code&gt; ]을 CPU 레지스터에 한 번로드하고 루프의 본문 속도를 높일 수 있습니다. 엄격한 앨리어싱 (aliasing)이 도입되기 전에, 컴파일러는 &lt;code&gt;buff&lt;/code&gt; 의 내용이 언제 어디서나 언제 라도 변경 될 수 있다는 편집증 상태에 있어야했습니다. 따라서 성능을 높이고 대부분의 사람들이 포인터를 입력하지 않는다고 가정하면 엄격한 앨리어싱 규칙이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="2cca1ba7b02e14ee263ba59cb168d4ba464a31b0" translate="yes" xml:space="preserve">
          <source>To understand more about why we care, we will discuss issues that come up when violating strict aliasing rules, type punning since common techniques used in type punning often violate strict aliasing rules and how to type pun correctly.</source>
          <target state="translated">우리가 왜 관심을 갖는지에 대해 더 이해하기 위해, 엄격한 별칭 지정 규칙을 위반할 때 발생하는 문제, 유형 정리에 사용되는 일반적인 기술이 종종 엄격한 별칭 지정 규칙을 위반하기 때문에 펀칭 유형을 올바르게 입력하는 방법에 대해 논의합니다.</target>
        </trans-unit>
        <trans-unit id="e92874def1c707e293c92fd2c84a024426689bc4" translate="yes" xml:space="preserve">
          <source>Traditionally this has been accomplished by taking the address of the object, casting it to a pointer of the type we want to reinterpret it as and then accessing the value, or in other words by aliasing. For example:</source>
          <target state="translated">전통적으로 이것은 객체의 주소를 가져 와서 재 해석하려는 유형의 포인터로 캐스팅 한 다음 값에 액세스하거나 다른 말로 별칭을 지정하여 수행되었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="edef09f47c7522a6bf38ab921e88dc728d2d2210" translate="yes" xml:space="preserve">
          <source>Two changes were small: &lt;em&gt;glvalue&lt;/em&gt; instead of &lt;em&gt;lvalue&lt;/em&gt;, and clarification of the aggregate/union case.</source>
          <target state="translated">&lt;em&gt;lvalue&lt;/em&gt; 대신 &lt;em&gt;glvalue&lt;/em&gt; 와 집계 / 연합 사례의 명확화 &lt;em&gt;라는&lt;/em&gt; 두 가지 변화가 작았습니다.</target>
        </trans-unit>
        <trans-unit id="0200f9824ad4e7d323fbd799151680bd20557e5c" translate="yes" xml:space="preserve">
          <source>Unfortunately with strict aliasing violations, we will often obtain the results we expect, leaving the possibility the a future version of a compiler with a new optimization will break code we thought was valid. This is undesirable and it is a worthwhile goal to understand the strict aliasing rules and how to avoid violating them.</source>
          <target state="translated">불행히도 엄격한 앨리어싱 위반으로 인해, 우리는 종종 우리가 기대하는 결과를 얻습니다. 새로운 최적화 기능을 갖춘 컴파일러의 향후 버전은 우리가 유효하다고 생각한 코드를 깨뜨릴 수 있습니다. 이는 바람직하지 않으며 엄격한 앨리어싱 규칙과이를 위반하지 않는 방법을 이해하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="db8ca5d18a2da2723c323eb4668458564a4e8a8e" translate="yes" xml:space="preserve">
          <source>Unfortunately, the authors of the C89 wrote their rule in a way that, if read literally, would make even the following function invoke Undefined Behavior:</source>
          <target state="translated">불행히도, C89의 저자는 문자 그대로 읽을 경우 다음 함수조차도 Undefined Behavior를 호출하도록하는 방식으로 규칙을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="c9eb5ca0a29983f2cff35266a2b00fda06003422" translate="yes" xml:space="preserve">
          <source>Use a union. Most compilers support this without complaining about strict aliasing. This is allowed in C99 and explicitly allowed in C11.</source>
          <target state="translated">노조를 사용하십시오. 대부분의 컴파일러는 엄격한 앨리어싱에 대해 불평하지 않고이를 지원합니다. 이것은 C99에서 허용되고 C11에서 명시 적으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ffd25c02b83ef5f0f4c7c45af829e62dae0bf2c5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;restrict&lt;/code&gt; keyword. i.e.:</source>
          <target state="translated">&lt;code&gt;restrict&lt;/code&gt; 키워드를 사용합니다. 즉 :</target>
        </trans-unit>
        <trans-unit id="798b73c4c9c14434f5fd6ba2176351fdd836980d" translate="yes" xml:space="preserve">
          <source>We don't have a lot of good tools for catching strict aliasing in C++, the tools we have will catch some cases of strict aliasing violations and some cases of misaligned loads and stores.</source>
          <target state="translated">우리는 C ++에서 엄격한 앨리어싱을 잡기위한 좋은 도구가 많지 않습니다. 우리가 가지고있는 툴은 엄격한 앨리어싱 위반의 경우와 잘못 정렬 된로드 및 저장의 경우를 잡을 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a25725c5206d96d54103f39151066cf147a0d46" translate="yes" xml:space="preserve">
          <source>We have a &lt;em&gt;int*&lt;/em&gt; pointing to memory occupied by an &lt;em&gt;int&lt;/em&gt; and this is a valid aliasing. The optimizer must assume that assignments through &lt;strong&gt;ip&lt;/strong&gt; could update the value occupied by &lt;strong&gt;x&lt;/strong&gt;.</source>
          <target state="translated">우리는 &lt;em&gt;int가&lt;/em&gt; 차지하는 메모리를 가리키는 &lt;em&gt;int *를&lt;/em&gt; 가지고 있으며 이것은 유효한 앨리어싱입니다. 옵티마이 저는 &lt;strong&gt;ip를&lt;/strong&gt; 통한 할당이 &lt;strong&gt;x가&lt;/strong&gt; 차지하는 값을 업데이트 할 수 있다고 가정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4304e0250327f603bbd29b9479b911b0f3e7e12" translate="yes" xml:space="preserve">
          <source>We have gotten to this point and we may be wondering, why would we want to alias for? The answer typically is to &lt;em&gt;type pun&lt;/em&gt;, often the methods used violate strict aliasing rules.</source>
          <target state="translated">우리는이 시점에 도달했고 왜 우리가 별명을 밝히고 싶어하는지 궁금 할 것입니다. 대답은 일반적으로 &lt;em&gt;pun&lt;/em&gt; 을 &lt;em&gt;입력&lt;/em&gt; 하는 것이며, 종종 사용되는 방법은 엄격한 앨리어싱 규칙을 위반합니다.</target>
        </trans-unit>
        <trans-unit id="486a3a882c8d445100340edd5a8f2d6177c5a9af" translate="yes" xml:space="preserve">
          <source>What are they talking about?</source>
          <target state="translated">그들은 무엇에 대한 이야기?</target>
        </trans-unit>
        <trans-unit id="8c58623950ce7060c946f960d5a1072d0350e835" translate="yes" xml:space="preserve">
          <source>What does the C11 standard say?</source>
          <target state="translated">C11 표준은 무엇을 말합니까?</target>
        </trans-unit>
        <trans-unit id="be95c287c482fdf98be1e57328b6181a5b151c60" translate="yes" xml:space="preserve">
          <source>What exactly does the standard say we are allowed and not allowed to do? The standard language is not straightforward, so for each item I will try to provide code examples that demonstrates the meaning.</source>
          <target state="translated">이 표준은 정확히 우리가 허용되고 허용되지 않는다고 무엇을 말합니까? 표준 언어는 간단하지 않으므로 각 항목에 대해 의미를 보여주는 코드 예제를 제공하려고합니다.</target>
        </trans-unit>
        <trans-unit id="80f819d6238279d0e91326c0caabb3b332286522" translate="yes" xml:space="preserve">
          <source>What is Type Punning</source>
          <target state="translated">타입 펀칭이란?</target>
        </trans-unit>
        <trans-unit id="0484d0796de9fffe254f71284bf9ef8e03cb6100" translate="yes" xml:space="preserve">
          <source>What is strict aliasing?</source>
          <target state="translated">엄격한 앨리어싱이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bd5bd917a7164fc90491e58bae353151d7d6d43e" translate="yes" xml:space="preserve">
          <source>What is the strict aliasing rule</source>
          <target state="translated">엄격한 앨리어싱 규칙은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="cfad540cca405d9e6ac5dbafe09c03446c539f96" translate="yes" xml:space="preserve">
          <source>What the C++17 Draft Standard say</source>
          <target state="translated">C ++ 17 초안 표준의 내용</target>
        </trans-unit>
        <trans-unit id="2b2f3220f114ca6e5fa9f3ff293ad00e83672d76" translate="yes" xml:space="preserve">
          <source>When asking about &lt;a href=&quot;https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into&quot;&gt;common undefined behavior in C&lt;/a&gt;, people sometimes refer to the strict aliasing rule.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into&quot;&gt;C에서 정의되지 않은 일반적인 동작에&lt;/a&gt; 대해 질문 할 때 때때로 엄격한 앨리어싱 규칙을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="c3986cda3c380d27ccea1e1786651cd0707eff3f" translate="yes" xml:space="preserve">
          <source>Which may not be expected but is perfectly valid since we have invoked undefined behavior. A &lt;em&gt;float&lt;/em&gt; can not validly alias an &lt;em&gt;int&lt;/em&gt; object. Therefore the optimizer can assume the &lt;em&gt;constant 1&lt;/em&gt; stored when dereferencing &lt;strong&gt;i&lt;/strong&gt; will be the return value since a store through &lt;strong&gt;f&lt;/strong&gt; could not validly affect an &lt;em&gt;int&lt;/em&gt; object. Plugging the code in Compiler Explorer shows this is exactly what is happening(&lt;a href=&quot;https://godbolt.org/g/yNV5aj&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">정의되지 않은 동작을 호출했기 때문에 예상되지 않았지만 완벽하게 유효한 것입니다. &lt;em&gt;float&lt;/em&gt; 는 &lt;em&gt;int&lt;/em&gt; 객체의 별칭을 유효하게 지정할 수 없습니다. 따라서 &lt;strong&gt;f를&lt;/strong&gt; 통한 저장이 &lt;em&gt;int&lt;/em&gt; 오브젝트에 유효하게 영향을 줄 수 없으므로 &lt;strong&gt;i&lt;/strong&gt; 는 역 참조 할 때 &lt;strong&gt;i&lt;/strong&gt; 가 리턴 값이된다고 가정합니다. 컴파일러 탐색기에서 코드를 연결하면 이것이 정확히 무슨 일인지 보여줍니다 ( &lt;a href=&quot;https://godbolt.org/g/yNV5aj&quot;&gt;live example&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="07141bb6d0d110634a7409d34c366630d3c98a44" translate="yes" xml:space="preserve">
          <source>Worth noting &lt;em&gt;signed char&lt;/em&gt; is not included in the list above, this is a notable difference from &lt;em&gt;C&lt;/em&gt; which says &lt;em&gt;a character type&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;부호있는 char에&lt;/em&gt; 주목할 가치가있는 것은 위의 목록에 포함되어 있지 않습니다. &lt;em&gt;이것은 문자 유형&lt;/em&gt; 이라고 &lt;em&gt;하는&lt;/em&gt; &lt;em&gt;C&lt;/em&gt; 와의 현저한 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="6ec4bca0456ee32bdbabe8e73b9e3df68f5d736b" translate="yes" xml:space="preserve">
          <source>You can disable strict aliasing in your compiler (&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825&quot;&gt;f[no-]strict-aliasing&lt;/a&gt; in gcc))</source>
          <target state="translated">컴파일러에서 엄격한 앨리어싱을 비활성화 할 수 있습니다 (gcc에서 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825&quot;&gt;f [no-] strict-aliasing&lt;/a&gt; ))</target>
        </trans-unit>
        <trans-unit id="9a40a7037ea21cd56a31798eee7807d9c8786d82" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;char*&lt;/code&gt; for aliasing instead of your system's word. The rules allow an exception for &lt;code&gt;char*&lt;/code&gt; (including &lt;code&gt;signed char&lt;/code&gt; and &lt;code&gt;unsigned char&lt;/code&gt;). It's always assumed that &lt;code&gt;char*&lt;/code&gt; aliases other types. However this won't work the other way: there's no assumption that your struct aliases a buffer of chars.</source>
          <target state="translated">시스템 단어 대신 별칭을 위해 &lt;code&gt;char*&lt;/code&gt; 를 사용할 수 있습니다. 이 규칙은 &lt;code&gt;char*&lt;/code&gt; ( &lt;code&gt;signed char&lt;/code&gt; 및 &lt;code&gt;unsigned char&lt;/code&gt; 포함)에 대한 예외를 허용합니다. &lt;code&gt;char*&lt;/code&gt; 다른 유형의 별칭이라고 항상 가정합니다. 그러나 이것은 다른 방식으로는 작동하지 않습니다. 구조체 별칭에 문자 버퍼가 있다고 가정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ee51db5fb0d07b269bfed3eb63461eb650f3683" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 또는 &lt;code&gt;unsigned char&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="597ff02af60ec975bbc5261d748ee4cf1e57a446" translate="yes" xml:space="preserve">
          <source>a character type.</source>
          <target state="translated">문자 유형</target>
        </trans-unit>
        <trans-unit id="cce769f3e61ed7c57c27b8bbabf2ecde89913120" translate="yes" xml:space="preserve">
          <source>a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">객체의 동적 유형의 cv-qualified 버전</target>
        </trans-unit>
        <trans-unit id="d5c0b51b12ba45e66cdb0c200363fe41dca17267" translate="yes" xml:space="preserve">
          <source>a qualified version of a type compatible with the effective type of the object,</source>
          <target state="translated">객체의 유효 유형과 호환되는 유형의 정규화 된 버전</target>
        </trans-unit>
        <trans-unit id="913991e5ddd84e880c9ee8623ae50786c0e5aa58" translate="yes" xml:space="preserve">
          <source>a qualiﬁed version of a type compatible with the effective type of
  the object,</source>
          <target state="translated">객체의 유효 유형과 호환되는 유형의 정규화 된 버전</target>
        </trans-unit>
        <trans-unit id="b75dd2203435a45255f541a92e8f52a7c687df9d" translate="yes" xml:space="preserve">
          <source>a type compatible with the effective type of the object,</source>
          <target state="translated">객체의 유효 유형과 호환되는 유형</target>
        </trans-unit>
        <trans-unit id="75d68aa8a13ac3e6c2e72772064d82f9a07c3a25" translate="yes" xml:space="preserve">
          <source>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</source>
          <target state="translated">객체의 다이나믹 타입의 (아마도 cv-qualified) 기본 클래스 타입 인 타입</target>
        </trans-unit>
        <trans-unit id="b65677be1e1487df5175120a02cfc67364b289cb" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a
  qualiﬁed version of the effective type of the object,</source>
          <target state="translated">객체의 유효 유형의 정규화 된 버전에 해당하는 부호있는 유형 또는 부호없는 유형 인 유형</target>
        </trans-unit>
        <trans-unit id="bac8eec6cb1615e6948be007906aef75526747ef" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">cv-qualified 버전의 객체 동적 유형에 해당하는 부호있는 또는 부호없는 유형 인 유형</target>
        </trans-unit>
        <trans-unit id="32f34f0edd59f5a473682cd472684b341a58daef" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,</source>
          <target state="translated">오브젝트의 유효 유형의 규정 된 버전에 해당하는 부호있는 유형 또는 부호없는 유형 인 유형</target>
        </trans-unit>
        <trans-unit id="e7c8760740b87a7f9140b423e924d45e4999f46b" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to the
  effective type of the object,</source>
          <target state="translated">객체의 유효 유형에 해당하는 부호있는 유형 또는 부호없는 유형 인 유형</target>
        </trans-unit>
        <trans-unit id="3fb43283d88825a91d147ec87a46390b16119ec1" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</source>
          <target state="translated">객체의 동적 유형에 해당하는 부호있는 유형 또는 부호없는 유형 인 유형</target>
        </trans-unit>
        <trans-unit id="09589aee6f97ca1ced0e9615240163fa1a8aac6b" translate="yes" xml:space="preserve">
          <source>add &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 를 &lt;code&gt;b&lt;/code&gt; 에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a4989e9968b633144d1dfa1a4b1a8a78e58f871e" translate="yes" xml:space="preserve">
          <source>add &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">에 &lt;code&gt;b&lt;/code&gt; 를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b7dfe2e2b4ee47faaabfeac29663335e09827e6a" translate="yes" xml:space="preserve">
          <source>although it will not catch this additional case (&lt;a href=&quot;https://wandbox.org/permlink/dwd9jhy53AF7a2D0&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">이 추가 사례를 포착하지는 않지만 ( &lt;a href=&quot;https://wandbox.org/permlink/dwd9jhy53AF7a2D0&quot;&gt;실시간 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e191b7b82407cef0ada97dd29a20d0793010dffe" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned
  types among its members (including, recursively, a member of a
  subaggregate or contained union), or</source>
          <target state="translated">상기 구성원들 중 상기 유형들 중 하나를 포함하는 집합체 또는 노동 조합 유형 (재귀 적으로 하위 집합체 또는 포함 된 연합체를 포함)</target>
        </trans-unit>
        <trans-unit id="fdece15d7bccebfe8183f34b848fc0e4942877cb" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned types among its &lt;em&gt;elements or non-static data members&lt;/em&gt; (including, recursively, an &lt;em&gt;element or non-static data member&lt;/em&gt; of a subaggregate or contained union),</source>
          <target state="translated">상기 &lt;em&gt;요소들 또는 비 정적 데이터 멤버들&lt;/em&gt; (소 집합 또는 포함 된 유니언의 &lt;em&gt;요소 또는 비 정적 데이터 멤버를&lt;/em&gt; 포함하여) 중에서 상기 언급 된 유형들 중 하나를 포함하는 집합 또는 통합 유형;</target>
        </trans-unit>
        <trans-unit id="3bb5bb5a7fb40894ca32d70cc8dbec9f68ef6180" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union),</source>
          <target state="translated">전술 한 유형 중 하나를 포함하는 집합체 또는 결합체 유형 (재귀 적으로 하위 집합체 또는 포함 된 결합체를 포함)</target>
        </trans-unit>
        <trans-unit id="9904ae77bbd2a07d458dc75556c60522d6fed3a1" translate="yes" xml:space="preserve">
          <source>because it uses an lvalue of type &lt;code&gt;int&lt;/code&gt; to access an object of type &lt;code&gt;struct S&lt;/code&gt;, and &lt;code&gt;int&lt;/code&gt; is not among the types that may be used accessing a &lt;code&gt;struct S&lt;/code&gt;.  Because it would be absurd to treat all use of non-character-type members of structs and unions as Undefined Behavior, almost everyone recognizes that there are at least some circumstances where an lvalue of one type may be used to access an object of another type.  Unfortunately, the C Standards Committee has failed to define what those circumstances are.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 유형의 lvalue를 사용하여 &lt;code&gt;struct S&lt;/code&gt; 유형의 오브젝트에 액세스하고 &lt;code&gt;int&lt;/code&gt; 는 &lt;code&gt;struct S&lt;/code&gt; 에 액세스하는 데 사용할 수있는 유형에 속하지 않기 때문입니다. 문자가 아닌 유형의 구조체 및 공용체 멤버의 모든 사용을 정의되지 않은 동작으로 취급하는 것은 터무니없는 일이기 때문에, 거의 모든 사람들은 한 유형의 lvalue가 다른 유형의 객체에 액세스하는 데 사용될 수있는 상황이 적어도 있음을 인식합니다. . 불행히도 C 표준위원회는 그러한 상황을 정의하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="13f76d1176cba1d67741f0be2b7d390647245ed8" translate="yes" xml:space="preserve">
          <source>check.c</source>
          <target state="translated">check.c</target>
        </trans-unit>
        <trans-unit id="6cc4950f9d59b228de0ffc8dfa255d0ff18a24aa" translate="yes" xml:space="preserve">
          <source>gcc using the flag &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; and &lt;strong&gt;-Wstrict-aliasing&lt;/strong&gt; can catch some cases although not without false positives/negatives. For example the following cases will generate a warning in gcc (&lt;a href=&quot;https://wandbox.org/permlink/cfckjTgwNTYHDIry&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">플래그 &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; 및 &lt;strong&gt;-Wstrict-aliasing을&lt;/strong&gt; 사용하는 gcc는 오 탐지 / 음수가 아닌 경우도있을 수 있습니다. 예를 들어 다음과 같은 경우 gcc에서 경고가 생성됩니다 ( &lt;a href=&quot;https://wandbox.org/permlink/cfckjTgwNTYHDIry&quot;&gt;실제 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9b9539e1dab95d4762b7ca605ff3ef29baabe352" translate="yes" xml:space="preserve">
          <source>load &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from memory.</source>
          <target state="translated">메모리에서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 를로드 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c8e98bbec15998f99b160035e6e2a5a79e70264" translate="yes" xml:space="preserve">
          <source>save &lt;code&gt;a&lt;/code&gt; (from the CPU register) to the memory.</source>
          <target state="translated">(CPU 레지스터에서) 메모리에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="e9f82b272f6f1b1af58a82bfd5c8942a5383dee9" translate="yes" xml:space="preserve">
          <source>save result both to &lt;code&gt;a&lt;/code&gt; and to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">결과를 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 모두에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="0a44e1b26b12bd2a7790e5bb3e97bb71d781569c" translate="yes" xml:space="preserve">
          <source>should be required to reload the value of &lt;code&gt;x&lt;/code&gt; between the assignment and return statement so as to allow for the possibility that &lt;code&gt;p&lt;/code&gt; might point to &lt;code&gt;x&lt;/code&gt;, and the assignment to &lt;code&gt;*p&lt;/code&gt; might consequently alter the value of &lt;code&gt;x&lt;/code&gt;.  The notion that a compiler should be entitled to presume that there won't be aliasing &lt;em&gt;in situations like the above&lt;/em&gt; was non-controversial.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;x&lt;/code&gt; 를 가리킬 가능성을 허용하고 &lt;code&gt;*p&lt;/code&gt; 에 대한 지정이 &lt;code&gt;x&lt;/code&gt; 값을 변경할 수 있도록 대입 문과 return 문 사이에 &lt;code&gt;x&lt;/code&gt; 값을 다시로드해야합니다. 컴파일러가 &lt;em&gt;위와 같은 상황에서&lt;/em&gt; 앨리어싱이 없을 것이라고 가정 할 수 있다는 개념은 논란의 여지가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ae0f749e2f2eba590823df0d938d3f9e1d9f0ad" translate="yes" xml:space="preserve">
          <source>the dynamic type of the object,</source>
          <target state="translated">객체의 동적 유형</target>
        </trans-unit>
        <trans-unit id="5c8205de1a0f5881a6eef3facb06094c46436ace" translate="yes" xml:space="preserve">
          <source>tis-interpeter is able to catch all three, the following example invokes tis-kernal as tis-interpreter (output is edited for brevity):</source>
          <target state="translated">tis-interpeter는 세 가지를 모두 포착 할 수 있으며 다음 예제에서는 tis-kernal을 tis-interpreter로 호출합니다 (출력은 간결하게 편집 됨).</target>
        </trans-unit>
        <trans-unit id="790926074ddb3f88b6b51d69cef8f57d64c8ee6d" translate="yes" xml:space="preserve">
          <source>we can use &lt;strong&gt;memcpy&lt;/strong&gt;:</source>
          <target state="translated">우리는 &lt;strong&gt;memcpy&lt;/strong&gt; 를 사용할 수 있습니다 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
