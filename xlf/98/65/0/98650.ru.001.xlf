<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/98650">
    <body>
      <group id="98650">
        <trans-unit id="8bc9a3751448b75c95d0c09be39874a54d59dbbc" translate="yes" xml:space="preserve">
          <source>&quot;Strict aliasing is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias each other.)&quot;</source>
          <target state="translated">&quot;Строгое наложение псевдонима-это допущение,сделанное компилятором C (или C++),что разыменование указателей на объекты разных типов никогда не будет ссылаться на одну и ту же область памяти (т.е.псевдонимы друг друга)&quot;.</target>
        </trans-unit>
        <trans-unit id="7cf3442516aaa5d6749824461a7def10a1b8f03a" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a character type.</source>
          <target state="translated">- тип персонажа.</target>
        </trans-unit>
        <trans-unit id="16d9cec79491cede88fd0ddafcbdb33b1a1dc888" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a qualified version of a type compatible with the effective type of the object,</source>
          <target state="translated">- квалифицированная версия типа, совместимого с эффективным типом объекта,</target>
        </trans-unit>
        <trans-unit id="13d94646e2432e838a724c25f7870cb8f332c869" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,</source>
          <target state="translated">- тип, который является типом со знаком или без знака, соответствующим квалифицированной версии действующего типа объекта,</target>
        </trans-unit>
        <trans-unit id="4b87e5428fe7d01a75c7838ed5347266005ed316" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to the effective type of the object,</source>
          <target state="translated">- тип, который является типом со знаком или без знака, соответствующим действующему типу объекта,</target>
        </trans-unit>
        <trans-unit id="62996c58c76d88b909b477d85de32e4c8a0be22f" translate="yes" xml:space="preserve">
          <source>&amp;mdash; an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or</source>
          <target state="translated">- агрегатный или объединенный тип, который включает в себя один из вышеупомянутых типов среди своих членов (включая, рекурсивно, член субагрегированного или автономного объединения), или</target>
        </trans-unit>
        <trans-unit id="7682f0746a360de4bef474dee1888984c6d26a7c" translate="yes" xml:space="preserve">
          <source>(11.2) &amp;mdash; a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">(11.2) - cv-квалифицированная версия динамического типа объекта,</target>
        </trans-unit>
        <trans-unit id="2b7ebc143440433f6bcf7a57744dbff09cce4f85" translate="yes" xml:space="preserve">
          <source>(11.3) &amp;mdash; a type similar (as defined in 7.5) to the dynamic type of the object,</source>
          <target state="translated">(11.3) - тип, подобный (как определено в 7.5) динамическому типу объекта,</target>
        </trans-unit>
        <trans-unit id="492220375e27ebfd7903993e017101c0d85ec3e0" translate="yes" xml:space="preserve">
          <source>(11.4) &amp;mdash; a type that is the signed or unsigned type corresponding to the dynamic type of the object,</source>
          <target state="translated">(11.4) - тип, который является типом со знаком или без знака, соответствующим динамическому типу объекта,</target>
        </trans-unit>
        <trans-unit id="2d718b5cc47d538f62e075e1c68512349385137b" translate="yes" xml:space="preserve">
          <source>(11.5) &amp;mdash; a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">(11.5) - тип, который является типом со знаком или без знака, соответствующим cv-квалифицированной версии динамического типа объекта,</target>
        </trans-unit>
        <trans-unit id="9dc6ec3bc2c4acd3e7938a177187de9946d3fbac" translate="yes" xml:space="preserve">
          <source>(11.6) &amp;mdash; an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</source>
          <target state="translated">(11.6) - агрегатный тип или тип объединения, который включает в себя один из вышеупомянутых типов среди своих элементов или нестатических элементов данных (включая рекурсивно элемент или элемент нестатических данных субагрегата или автономного объединения),</target>
        </trans-unit>
        <trans-unit id="0833cab4a3d7c43325017982c60dd1a9524db49f" translate="yes" xml:space="preserve">
          <source>(11.7) &amp;mdash; a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</source>
          <target state="translated">(11.7) - тип, который является (возможно, квалифицированным по cv) типом базового класса динамического типа объекта,</target>
        </trans-unit>
        <trans-unit id="007312b7d7fe81dfd0e93a7cbbe02ace56aa2f12" translate="yes" xml:space="preserve">
          <source>(11.8) &amp;mdash; a char, unsigned char, or std::byte type.</source>
          <target state="translated">(11.8) - тип char, unsigned char или std :: byte.</target>
        </trans-unit>
        <trans-unit id="a6ae166834f7950f65a4a0e2017c5da76406a59c" translate="yes" xml:space="preserve">
          <source>(GCC appears somewhat inconsistent in its ability to give aliasing warnings, sometimes giving us a friendly warning and sometimes not.)</source>
          <target state="translated">(GCC представляется несколько противоречивым в своей способности давать предупреждения с использованием псевдонимов,иногда давая нам дружеское предупреждение,а иногда нет).</target>
        </trans-unit>
        <trans-unit id="dbb9367a16f124a22e627722082fe38579194d80" translate="yes" xml:space="preserve">
          <source>(save from CPU register to the memory and load from the memory to the CPU register).</source>
          <target state="translated">(сохранить из регистра CPU в память и загрузить из памяти в регистр CPU).</target>
        </trans-unit>
        <trans-unit id="9cc95d274f988057b458e8bbc62596b0bfd62e5a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;This article&lt;/a&gt; should help you understand the issue in full detail.</source>
          <target state="translated">&lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;Эта статья&lt;/a&gt; должна помочь вам понять проблему в деталях.</target>
        </trans-unit>
        <trans-unit id="db4e37199ce7a26e530372127092a913fd8e827e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_punning&quot;&gt;Type punning&lt;/a&gt; via pointer casts (as opposed to using a union) is a major example of breaking strict aliasing.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_punning&quot;&gt;Пуннинг типов с&lt;/a&gt; помощью приведения указателей (в отличие от использования объединения) является основным примером нарушения строгого алиасинга.</target>
        </trans-unit>
        <trans-unit id="0f648f766517c522d736c21acf06a661385f3de0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://twitter.com/shafikyaghmour/status/957702383810658304&quot;&gt;gcc/clang has an extension&lt;/a&gt; and &lt;a href=&quot;https://gcc.gnu.org/ml/gcc/2003-10/msg00184.html&quot;&gt;also&lt;/a&gt; that allows assigning &lt;em&gt;unsigned int*&lt;/em&gt; to &lt;em&gt;int*&lt;/em&gt; even though they are not compatible types.</source>
          <target state="translated">&lt;a href=&quot;https://twitter.com/shafikyaghmour/status/957702383810658304&quot;&gt;gcc / clang имеет расширение,&lt;/a&gt; а &lt;a href=&quot;https://gcc.gnu.org/ml/gcc/2003-10/msg00184.html&quot;&gt;также&lt;/a&gt; позволяет присваивать &lt;em&gt;int без знака int *&lt;/em&gt; значение &lt;em&gt;int *,&lt;/em&gt; даже если они несовместимы.</target>
        </trans-unit>
        <trans-unit id="01b0f2dd13e6673c4bc6a8d017a4466b2eae23b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;a type similar (as defined in 4.4) to the dynamic type of the object,&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;тип, подобный (как определено в 4.4) динамическому типу объекта,&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57fbd0f13eb9b51fcea11056b2017576feba86c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Beginner beware&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Начинающий остерегаться&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="196bcd48f2a7e66de892eaf11cbe2d9cab7cc750" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11&lt;/strong&gt; and &lt;strong&gt;C++14&lt;/strong&gt; wording (changes emphasized):</source>
          <target state="translated">Формулировки &lt;strong&gt;C ++ 11&lt;/strong&gt; и &lt;strong&gt;C ++ 14&lt;/strong&gt; (изменения подчеркнуты):</target>
        </trans-unit>
        <trans-unit id="f83c36172e98a9c03aa145ce635aa0f76fe4904e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For example&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Например&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="decc5376f183538b5fe7739f22bb8eb4f49596b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So how do I get around this?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Так как мне обойти это?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d25be7fbd9e3672275a9ff1b70188a72553da35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;save&lt;/strong&gt;&lt;code&gt;b&lt;/code&gt; and &lt;strong&gt;reload&lt;/strong&gt;&lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;сохранить&lt;/strong&gt; &lt;code&gt;b&lt;/code&gt; и &lt;strong&gt;перезагрузить&lt;/strong&gt; &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b61bc9f66e53d7bd6c6cb170cf39fc609c4079f3" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt; 73) or 88)&lt;/sup&gt; The intent of this list is to specify those circumstances in which an object may or may not be aliased.</source>
          <target state="translated">&lt;sup&gt;73) или 88)&lt;/sup&gt; Целью этого списка является определение тех обстоятельств, при которых объект может или не может быть псевдонимом.</target>
        </trans-unit>
        <trans-unit id="e6cbeecf47c0b79acdf7d07e84cc9b5e6b8e569d" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt; The types that C 2011 6.5 7 allows an lvalue to access are:</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; Типы, которые C 2011 6.5 7 разрешает доступ к lvalue:</target>
        </trans-unit>
        <trans-unit id="297342af50ab471e2b4d57de560278e8dd7b88e6" translate="yes" xml:space="preserve">
          <source>A glvalue is an expression whose evaluation determines the identity of
  an object, (...snip)</source>
          <target state="translated">Значение клея-это выражение,оценка которого определяет идентичность предмета (...обрезок).</target>
        </trans-unit>
        <trans-unit id="8e98f088bc239e2fa9b5abf6318d366712f8212b" translate="yes" xml:space="preserve">
          <source>A typical situation you encounter strict aliasing problems is when overlaying a struct (like a device/network msg) onto a buffer of the word size of your system (like a pointer to &lt;code&gt;uint32_t&lt;/code&gt;s or &lt;code&gt;uint16_t&lt;/code&gt;s). When you overlay a struct onto such a buffer, or a buffer onto such a struct through pointer casting you can easily violate strict aliasing rules.</source>
          <target state="translated">Типичная ситуация, с которой вы сталкиваетесь со строгими проблемами псевдонимов, - это наложение структуры (например, сообщения устройства / сети) на буфер размера слова вашей системы (например, указатель на &lt;code&gt;uint32_t&lt;/code&gt; s или &lt;code&gt;uint16_t&lt;/code&gt; s). Когда вы накладываете структуру на такой буфер или буфер на такую ​​структуру с помощью приведения указателя, вы можете легко нарушить строгие правила наложения имен.</target>
        </trans-unit>
        <trans-unit id="a9dc4be413dae8efeb97923c710712f4df67ca23" translate="yes" xml:space="preserve">
          <source>According to the C89 rationale, the authors of the Standard did not want to require that compilers given code like:</source>
          <target state="translated">Согласно обоснованию C89,авторы Стандарта не хотели требовать,чтобы компиляторы выдавали такой код:</target>
        </trans-unit>
        <trans-unit id="a1e350b0f7d46240fa54c7300839cc8197daad50" translate="yes" xml:space="preserve">
          <source>After reading many of the answers, I feel the need to add something:</source>
          <target state="translated">После прочтения многих ответов,я чувствую необходимость что-то добавить:</target>
        </trans-unit>
        <trans-unit id="6ef0f09f189d7f527f3216249c8e7b8d66de7464" translate="yes" xml:space="preserve">
          <source>Also from &lt;a href=&quot;http://eel.is/c++draft/basic.lval#1.1&quot;&gt;the definition of glvalue&lt;/a&gt;</source>
          <target state="translated">Также из &lt;a href=&quot;http://eel.is/c++draft/basic.lval#1.1&quot;&gt;определения glvalue&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f9a518e55a06337a7d067a77249a742f4d1724e" translate="yes" xml:space="preserve">
          <source>Also the &lt;strong&gt;C&lt;/strong&gt; wording (C99; ISO/IEC 9899:1999 6.5/7; the exact same wording is used in ISO/IEC 9899:2011 &amp;sect;6.5 &amp;para;7):</source>
          <target state="translated">Также формулировка &lt;strong&gt;C&lt;/strong&gt; (C99; ISO / IEC 9899: 1999 6.5 / 7; точно такая же формулировка используется в ISO / IEC 9899: 2011 &amp;sect;6.5 &amp;para;7):</target>
        </trans-unit>
        <trans-unit id="2985fc30fb7352cc194dd6d4058223c195eec0a4" translate="yes" xml:space="preserve">
          <source>Although clang allows these flags it apparently does not actually implement the warnings.</source>
          <target state="translated">Несмотря на то,что clang позволяет использовать эти флаги,он,очевидно,на самом деле не реализует предупреждения.</target>
        </trans-unit>
        <trans-unit id="26a14dfaa9199838addf36131d31232c359747d1" translate="yes" xml:space="preserve">
          <source>An object shall have its stored value accessed only by an lvalue
  expression that has one of the following types &lt;sup&gt; 73) or 88)&lt;/sup&gt;:</source>
          <target state="translated">Объект должен иметь свое сохраненное значение, доступное только через выражение lvalue, которое имеет один из следующих типов &lt;sup&gt;73) или 88)&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="e89f2c7845b5b0b9f99fb0df9e776bf697055362" translate="yes" xml:space="preserve">
          <source>An object shall have its stored value accessed only by an lvalue expression that has one of the following types:&lt;sup&gt;88)&lt;/sup&gt;
  &amp;mdash; a type compatible with the effective type of the object,</source>
          <target state="translated">Объект должен иметь свое сохраненное значение, доступное только через выражение lvalue, которое имеет один из следующих типов: &lt;sup&gt;88)&lt;/sup&gt; - тип, совместимый с действующим типом объекта,</target>
        </trans-unit>
        <trans-unit id="8d09e17c7fa91deb529a7711698d487fd214027c" translate="yes" xml:space="preserve">
          <source>And rewrote our earlier loop to take advantage of this convenient function</source>
          <target state="translated">И переписали наш предыдущий цикл,чтобы воспользоваться этой удобной функцией.</target>
        </trans-unit>
        <trans-unit id="0f5d219e3940c12eb3895d8e75d8bb99c681600b" translate="yes" xml:space="preserve">
          <source>Another tool we have available to us is ASan which can catch misaligned loads and stores. Although these are not directly strict aliasing violations they are a common result of strict aliasing violations. For example the following cases will generate runtime errors when built with clang using &lt;strong&gt;-fsanitize=address&lt;/strong&gt;</source>
          <target state="translated">Еще одним инструментом, который у нас есть, является ASan, который может отследить смещенные грузы и запасы. Хотя это не является прямым строгим нарушением псевдонимов, это общий результат строгих нарушений псевдонимов. Например, следующие случаи будут генерировать ошибки времени выполнения при &lt;strong&gt;сборке&lt;/strong&gt; с помощью clang с использованием &lt;strong&gt;-fsanitize = address&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c9f941d78e7fc8fb359e7fb4d08c3662e735d087" translate="yes" xml:space="preserve">
          <source>As addendum to what Doug T. already wrote, here
is a simple test case which probably triggers it with gcc :</source>
          <target state="translated">Как дополнение к тому,что уже писал Дуг Т.,вот простой тестовый случай,который,вероятно,запускает его с помощью gcc :</target>
        </trans-unit>
        <trans-unit id="10728f2d66e27dcf628afc3fd6a3a60abc38f514" translate="yes" xml:space="preserve">
          <source>As we have seen earlier this is not a valid aliasing, so we are invoking undefined behavior. But traditionally compilers did not take advantage of strict aliasing rules and this type of code usually just worked, developers have unfortunately gotten used to doing things this way. A common alternate method for type punning is through unions, which is valid in C but &lt;em&gt;undefined behavior&lt;/em&gt; in C++ (&lt;a href=&quot;https://wandbox.org/permlink/oOf9bPlcWDYrYqPF&quot;&gt;see live example&lt;/a&gt;):</source>
          <target state="translated">Как мы видели ранее, это неверный псевдоним, поэтому мы вызываем неопределенное поведение. Но традиционно компиляторы не пользовались преимуществами строгих правил псевдонимов, и этот тип кода обычно просто работал, разработчики, к сожалению, привыкли делать такие вещи. Распространенный альтернативный метод для обозначения типов - через объединения, что допустимо в C, но &lt;em&gt;неопределенное поведение&lt;/em&gt; в C ++ ( &lt;a href=&quot;https://wandbox.org/permlink/oOf9bPlcWDYrYqPF&quot;&gt;см. Живой пример&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="31703841448c40ed3e7edbb4a235ea2f940df90f" translate="yes" xml:space="preserve">
          <source>At a sufficient optimization level any decent modern compiler generates identical code to the previously mentioned &lt;strong&gt;reinterpret_cast&lt;/strong&gt; method or &lt;em&gt;union&lt;/em&gt; method for &lt;em&gt;type punning&lt;/em&gt;. Examining the generated code we see it uses just register mov (&lt;a href=&quot;https://godbolt.org/g/BfZGwX&quot;&gt;live Compiler Explorer Example&lt;/a&gt;).</source>
          <target state="translated">При достаточном уровне оптимизации любой приличный современный компилятор генерирует код, идентичный ранее упомянутому методу &lt;strong&gt;reinterpret_cast&lt;/strong&gt; или методу &lt;em&gt;объединения&lt;/em&gt; для определения &lt;em&gt;типов&lt;/em&gt; . Изучая сгенерированный код, мы видим, что он использует только регистр mov ( &lt;a href=&quot;https://godbolt.org/g/BfZGwX&quot;&gt;живой пример Compiler Explorer&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6b40922067f3852129b802e5ea9ad27f2b9e841c" translate="yes" xml:space="preserve">
          <source>C++20 and bit_cast</source>
          <target state="translated">C++20 и bit_cast</target>
        </trans-unit>
        <trans-unit id="d0218f26139d8420689d4b0863aae73b36ebb0d3" translate="yes" xml:space="preserve">
          <source>Catching Strict Aliasing Violations</source>
          <target state="translated">Поймать строгие нарушения Aliasing</target>
        </trans-unit>
        <trans-unit id="1770c1d3a13b57ff8c334a5bc651892e9928636f" translate="yes" xml:space="preserve">
          <source>Compile with &lt;code&gt;gcc -O2 -o check check.c&lt;/code&gt; .
Usually (with most gcc versions I tried) this outputs &quot;strict aliasing problem&quot;, because the compiler assumes that &quot;h&quot; cannot be the same address as &quot;k&quot; in the &quot;check&quot; function. Because of that the compiler optimizes the &lt;code&gt;if (*h == 5)&lt;/code&gt; away and always calls the printf.</source>
          <target state="translated">Скомпилируйте с &lt;code&gt;gcc -O2 -o check check.c&lt;/code&gt; . Обычно (с большинством версий gcc, которые я пробовал) это выдает &amp;laquo;проблему строгого алиасинга&amp;raquo;, потому что компилятор предполагает, что &amp;laquo;h&amp;raquo; не может быть тем же адресом, что и &amp;laquo;k&amp;raquo; в функции &amp;laquo;check&amp;raquo;. Из-за этого компилятор оптимизирует &lt;code&gt;if (*h == 5)&lt;/code&gt; и всегда вызывает printf.</target>
        </trans-unit>
        <trans-unit id="53c22f9842dfbbfd7ce868f16027320909192af5" translate="yes" xml:space="preserve">
          <source>Defect Report #28 states that the program invokes Undefined Behavior because the action of writing a union member of type &quot;double&quot; and reading one of type &quot;int&quot; invokes Implementation-Defined behavior.  Such reasoning is nonsensical, but forms the basis for the Effective Type rules which needlessly complicate the language while doing nothing to address the original problem.</source>
          <target state="translated">Отчет о дефектах №28 утверждает,что программа вызывает Undefined Behavior,потому что действие записи члена профсоюза типа &quot;double&quot; и чтения одного из типов типа &quot;int&quot; вызывает Implementation-Defined behavior (Реализация-определенное поведение).Подобные рассуждения бессмысленны,но составляют основу правил Effective Type,которые излишне усложняют язык,ничего не делая для решения исходной проблемы.</target>
        </trans-unit>
        <trans-unit id="7470e0123159d8ce20fb052f5950c0742dcfc961" translate="yes" xml:space="preserve">
          <source>Finally there is &lt;a href=&quot;https://www.youtube.com/watch?v=vAXJeN7k32Y&quot;&gt;TySan&lt;/a&gt; which is currently in development. This sanitizer adds type checking information in a shadow memory segment and checks accesses to see if they violate aliasing rules. The tool potentially should be able to catch all aliasing violations but may have a large run-time overhead.</source>
          <target state="translated">Наконец, &lt;a href=&quot;https://www.youtube.com/watch?v=vAXJeN7k32Y&quot;&gt;TySan,&lt;/a&gt; который в настоящее время находится в разработке. Это дезинфицирующее средство добавляет информацию проверки типов в сегмент теневой памяти и проверяет доступы, чтобы определить, не нарушают ли они правила псевдонимов. Инструмент потенциально должен быть в состоянии отследить все нарушения псевдонимов, но может иметь большие накладные расходы во время выполнения.</target>
        </trans-unit>
        <trans-unit id="40e31a210a1913fd0a8b28b892780996d154c70d" translate="yes" xml:space="preserve">
          <source>Footnote</source>
          <target state="translated">Footnote</target>
        </trans-unit>
        <trans-unit id="f2e444e508c3340837f99f92afb5d8d282d725cc" translate="yes" xml:space="preserve">
          <source>For C we have all the tools already covered and we also have tis-interpreter, a static analyzer that exhaustively analyzes a program for a large subset of the C language. Given a C verions of the  earlier example where using &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; misses one case (&lt;a href=&quot;https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY&quot;&gt;see it live&lt;/a&gt;)</source>
          <target state="translated">Для C у нас есть все инструменты, которые уже описаны, и у нас также есть tis-интерпретатор, статический анализатор, который исчерпывающе анализирует программу для большого подмножества языка C. Учитывая C-версии более раннего примера, где использование &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; пропускает один случай ( &lt;a href=&quot;https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY&quot;&gt;смотрите его вживую&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="9ead309bf16c2a5aba6251f6671c48b68c88f5ee" translate="yes" xml:space="preserve">
          <source>For those who are interested here is the x64 assembler code, produced by gcc 4.6.3, running on ubuntu 12.04.2 for x64:</source>
          <target state="translated">Для тех,кто интересуется здесь x64 ассемблерным кодом,произведенным gcc 4.6.3,запущенным на ubuntu 12.04.2 для x64:</target>
        </trans-unit>
        <trans-unit id="eef7c5809b1e5a8ae1c2904d803bf0988e0597e2" translate="yes" xml:space="preserve">
          <source>From the article:</source>
          <target state="translated">Из статьи:</target>
        </trans-unit>
        <trans-unit id="c9937d5f217a938cee9523df51e9f8f215d05426" translate="yes" xml:space="preserve">
          <source>Had Defect Report 028 said the original example invoked UB because of the overlap between the creation and use of the two pointers, that would have made things a lot more clear without having to add &quot;Effective Types&quot; or other such complexity.</source>
          <target state="translated">Если бы в отчете Defect Report 028 было сказано,что исходный пример вызвал UB из-за перекрытия между созданием и использованием двух указателей,это сделало бы вещи намного более понятными без необходимости добавлять &quot;Типы эффективности&quot; или другой подобной сложности.</target>
        </trans-unit>
        <trans-unit id="cacd74e6fcf654b36a1d1e2975d8c5a7ad506007" translate="yes" xml:space="preserve">
          <source>Here, there is an aliasing conflict between &lt;code&gt;p&lt;/code&gt; and the access to &lt;code&gt;s.x&lt;/code&gt; on the marked line because at that point in execution another reference exists &lt;em&gt;that will be used to access the same storage&lt;/em&gt;.</source>
          <target state="translated">Здесь существует конфликт псевдонимов между &lt;code&gt;p&lt;/code&gt; и доступом к &lt;code&gt;s.x&lt;/code&gt; в отмеченной строке, потому что в этот момент выполнения существует другая ссылка, &lt;em&gt;которая будет использоваться для доступа к тому же хранилищу&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="33dc7f4dd2ec6bc77310a0b059a423d8f65352d8" translate="yes" xml:space="preserve">
          <source>How do we Type Pun correctly?</source>
          <target state="translated">Как правильно набирать каламбур?</target>
        </trans-unit>
        <trans-unit id="4e0983c0e8fab722fa11f33077148a6fa369c40d" translate="yes" xml:space="preserve">
          <source>If a compiler notices that two pointers point to different types (for example, an &lt;code&gt;int *&lt;/code&gt; and a &lt;code&gt;float *&lt;/code&gt;), it will assume the memory address is different and it &lt;strong&gt;will not&lt;/strong&gt; protect against memory address collisions, resulting in faster machine code.</source>
          <target state="translated">Если компилятор заметит, что два указателя указывают на разные типы (например, &lt;code&gt;int *&lt;/code&gt; и &lt;code&gt;float *&lt;/code&gt; ), он предположит, что адрес памяти отличается, и он &lt;strong&gt;не&lt;/strong&gt; защитит от конфликтов адресов памяти, что приведет к более быстрому машинному коду.</target>
        </trans-unit>
        <trans-unit id="e33bcaeae41be78c102c11d9ce6bff1ab9700bea" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through a &lt;em&gt;glvalue&lt;/em&gt; of other than one of the following types the behavior is undefined:</source>
          <target state="translated">Если программа пытается получить доступ к сохраненному значению объекта через &lt;em&gt;glvalue,&lt;/em&gt; отличный от одного из следующих типов, поведение не определено:</target>
        </trans-unit>
        <trans-unit id="a1ad9d68fd05386372885ebe000df27028379d8d" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:&lt;sup&gt;63&lt;/sup&gt;
  (11.1) &amp;mdash; the dynamic type of the object,</source>
          <target state="translated">Если программа пытается получить доступ к сохраненному значению объекта через glvalue другого, чем один из следующих типов, поведение не определено: &lt;sup&gt;63&lt;/sup&gt; (11.1) - динамический тип объекта,</target>
        </trans-unit>
        <trans-unit id="186894b2031b450693c2e08ce7146e1a9f218d92" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined:</source>
          <target state="translated">Если программа пытается получить доступ к сохраненному значению объекта через значение l,отличное от одного из следующих типов,поведение не определено:</target>
        </trans-unit>
        <trans-unit id="c58ff6992c8aa3747c4710bda431e84ee2b32d03" translate="yes" xml:space="preserve">
          <source>If data in two different CPU registers will be written to the same memory space, &lt;strong&gt;we can't predict which data will &quot;survive&quot;&lt;/strong&gt; when we code in C.</source>
          <target state="translated">Если данные в двух разных регистрах ЦП будут записаны в одно и то же пространство памяти, &lt;strong&gt;мы не можем предсказать, какие данные &amp;laquo;выживут&amp;raquo;,&lt;/strong&gt; когда мы кодируем в C.</target>
        </trans-unit>
        <trans-unit id="7a0013265978c8a291d1a659ebe89febc56bb358" translate="yes" xml:space="preserve">
          <source>If the code were changed slightly...</source>
          <target state="translated">Если бы код был слегка изменен...</target>
        </trans-unit>
        <trans-unit id="0b4c6074b02b2e16ccba9dd1023db8c912e4726d" translate="yes" xml:space="preserve">
          <source>In C and C++ aliasing has to do with what expression types we are allowed to access stored values through. In both C and C++ the standard specifies which expression types are allowed to alias which types. The compiler and optimizer are allowed to assume we follow the aliasing rules strictly, hence the term &lt;em&gt;strict aliasing rule&lt;/em&gt;. If we attempt to access a value using a type not allowed it is classified as &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/ub&quot;&gt;undefined behavior&lt;/a&gt;(&lt;strong&gt;UB&lt;/strong&gt;). Once we have undefined behavior all bets are off, the results of our program are no longer reliable.</source>
          <target state="translated">В C и C ++ псевдонимы связаны с тем, через какие типы выражений нам разрешен доступ к хранимым значениям. Как в C, так и в C ++ стандарт определяет, какие типы выражений допускаются для псевдонимов и каких типов. Компилятору и оптимизатору разрешается предполагать, что мы строго следуем правилам алиасинга, отсюда и термин &lt;em&gt;строгое правило алиасинга&lt;/em&gt; . Если мы пытаемся получить доступ к значению с использованием недопустимого типа, оно классифицируется как &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/ub&quot;&gt;неопределенное поведение&lt;/a&gt; ( &lt;strong&gt;UB&lt;/strong&gt; ). Когда у нас неопределенное поведение, все ставки отменены, результаты нашей программы перестают быть достоверными.</target>
        </trans-unit>
        <trans-unit id="5c8e94cbd15bdd54a4fb204f2d1514b6f794ce32" translate="yes" xml:space="preserve">
          <source>In C++20 we may gain &lt;strong&gt;bit_cast&lt;/strong&gt; (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html&quot;&gt;implementation available in link from proposal&lt;/a&gt;) which gives a simple and safe way to type-pun as well as being usable in a constexpr context.</source>
          <target state="translated">В C ++ 20 мы можем получить &lt;strong&gt;bit_cast&lt;/strong&gt; ( &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html&quot;&gt;реализация доступна по ссылке в предложении&lt;/a&gt; ), который дает простой и безопасный способ ввода слов, а также может использоваться в контексте constexpr.</target>
        </trans-unit>
        <trans-unit id="30d64c522aac604d7e48c4556b8d77b5be2eeb6e" translate="yes" xml:space="preserve">
          <source>In assembly, where we code the loading and unloading of CPU registers manually, we will know which data remains intact. But C (thankfully) abstracts this detail away.</source>
          <target state="translated">В сборке,где мы кодируем загрузку и выгрузку регистров CPU вручную,мы будем знать,какие данные останутся нетронутыми.Но C (к счастью)отбросит эту деталь в сторону.</target>
        </trans-unit>
        <trans-unit id="1098f88dd457b5be2f2059df57bcf4338d706f24" translate="yes" xml:space="preserve">
          <source>In fact, by adding the &lt;code&gt;restrict&lt;/code&gt; keyword, the whole function could be optimized to:</source>
          <target state="translated">Фактически, добавив ключевое слово &lt;code&gt;restrict&lt;/code&gt; , можно оптимизировать всю функцию:</target>
        </trans-unit>
        <trans-unit id="f5757f1784e296249565c7c4929c37f6183ec27c" translate="yes" xml:space="preserve">
          <source>In order to handle the case in which &lt;code&gt;a == b&lt;/code&gt; (both pointers point to the same memory), we need to order and test the way we load data from the memory to the CPU registers, so the code might end up like this:</source>
          <target state="translated">Чтобы обработать случай, когда &lt;code&gt;a == b&lt;/code&gt; (оба указателя указывают на одну и ту же память), нам нужно упорядочить и протестировать способ загрузки данных из памяти в регистры ЦП, чтобы код мог выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="edbd3b6b40a8cde551f4ffba070d64d6c6313a52" translate="yes" xml:space="preserve">
          <source>In the case where &lt;em&gt;To&lt;/em&gt; and &lt;em&gt;From&lt;/em&gt; types don't have the same size, it requires us to use an intermediate struct15. We will use a struct containing a &lt;strong&gt;sizeof( unsigned int )&lt;/strong&gt; character array (&lt;em&gt;assumes 4 byte unsigned int&lt;/em&gt;) to be the &lt;em&gt;From&lt;/em&gt; type and &lt;em&gt;unsigned int&lt;/em&gt; as the &lt;em&gt;To&lt;/em&gt; type.:</source>
          <target state="translated">В случае, когда типы &lt;em&gt;To&lt;/em&gt; и &lt;em&gt;From&lt;/em&gt; не имеют одинаковый размер, это требует от нас использования промежуточной структуры15. Мы будем использовать структуру, содержащую символьный массив &lt;strong&gt;sizeof (unsigned int)&lt;/strong&gt; ( &lt;em&gt;предполагается, что 4-байтовое unsigned int&lt;/em&gt; ) будет типом &lt;em&gt;From,&lt;/em&gt; а &lt;em&gt;unsigned int&lt;/em&gt; - типом &lt;em&gt;To .&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="d116eeee6f567bfeb6ee6948778e1441846b7681" translate="yes" xml:space="preserve">
          <source>In the function &lt;strong&gt;foo&lt;/strong&gt; we take an &lt;em&gt;int*&lt;/em&gt; and a &lt;em&gt;float*&lt;/em&gt;, in this example we call &lt;strong&gt;foo&lt;/strong&gt; and set both parameters to point to the same memory location which in this example contains an &lt;em&gt;int&lt;/em&gt;. Note, the &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; is telling the compiler to treat the the expression as if it had the type specificed by its template parameter. In this case we are telling it to treat the expression &lt;strong&gt;&amp;amp;x&lt;/strong&gt; as if it had type &lt;em&gt;float*&lt;/em&gt;. We may naively expect the result of the second &lt;strong&gt;cout&lt;/strong&gt; to be &lt;strong&gt;0&lt;/strong&gt; but with optimization enabled using &lt;strong&gt;-O2&lt;/strong&gt; both gcc and clang produce the following result:</source>
          <target state="translated">В функции &lt;strong&gt;foo&lt;/strong&gt; мы берем &lt;em&gt;int *&lt;/em&gt; и &lt;em&gt;float *&lt;/em&gt; , в этом примере мы вызываем &lt;strong&gt;foo&lt;/strong&gt; и устанавливаем оба параметра, чтобы они указывали на одну и ту же ячейку памяти, которая в этом примере содержит &lt;em&gt;int&lt;/em&gt; . Обратите внимание, что &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; говорит компилятору обрабатывать выражение так, как если бы оно имело тип, определенный его параметром шаблона. В этом случае мы говорим ему обрабатывать выражение &lt;strong&gt;&amp;amp; x,&lt;/strong&gt; как если бы оно имело тип &lt;em&gt;float *&lt;/em&gt; . Мы можем наивно ожидать, что результат второй &lt;strong&gt;cout&lt;/strong&gt; будет равен &lt;strong&gt;0,&lt;/strong&gt; но при включенной оптимизации с использованием &lt;strong&gt;-O2&lt;/strong&gt; и gcc, и clang дают следующий результат:</target>
        </trans-unit>
        <trans-unit id="d68abdd18fdbebaf82ef26f4a744ddcd23eee685" translate="yes" xml:space="preserve">
          <source>It is unfortunate that we need this intermediate type but that is the current constraint of &lt;strong&gt;bit_cast&lt;/strong&gt;.</source>
          <target state="translated">К сожалению, нам нужен этот промежуточный тип, но это текущее ограничение &lt;strong&gt;bit_cast&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="da92ddda51dcc47ff0f56cb81c8d27a13de9b35f" translate="yes" xml:space="preserve">
          <source>Keep in mind, if you think the example is contrived, this might even happen if you're passing a buffer to another function doing the sending for you, if instead you have.</source>
          <target state="translated">Имейте в виду,если вы думаете,что пример надуман,это может даже произойти,если вы передаете буфер в другую функцию,выполняющую отправку за вас,если вместо этого вы это сделали.</target>
        </trans-unit>
        <trans-unit id="aa2a2cd3b185c908c2467f71930ddb0e035406e3" translate="yes" xml:space="preserve">
          <source>Let's look at some examples, then we can talk about exactly what the standard(s) say, examine some further examples and then see how to avoid strict aliasing and catch violations we missed. Here is an example that should not be surprising (&lt;a href=&quot;https://wandbox.org/permlink/7sCJTAyrifZ0zfFA&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">Давайте посмотрим на некоторые примеры, затем мы сможем поговорить о том, что конкретно говорится в стандарте (ах), рассмотрим некоторые дополнительные примеры, а затем посмотрим, как избежать строгого псевдонима и отследить нарушения, которые мы пропустили. Вот пример, который не должен удивлять ( &lt;a href=&quot;https://wandbox.org/permlink/7sCJTAyrifZ0zfFA&quot;&gt;живой пример&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="036ae8cbf7c3814fcac323366fb44ffbfacfa142" translate="yes" xml:space="preserve">
          <source>Lets assume the following function:</source>
          <target state="translated">Возьмем на себя следующую функцию:</target>
        </trans-unit>
        <trans-unit id="6866b7efbb6193426e6184afeb038e84825105d8" translate="yes" xml:space="preserve">
          <source>Memory access can be expensive (performance wise), which is why &lt;strong&gt;data is manipulated in CPU registers&lt;/strong&gt; before being written back to the physical memory.</source>
          <target state="translated">Доступ к памяти может быть дорогим (с точки зрения производительности), поэтому &lt;strong&gt;данные обрабатываются в регистрах ЦП,&lt;/strong&gt; прежде чем они записываются обратно в физическую память.</target>
        </trans-unit>
        <trans-unit id="9992043f68467a20f1d79f1ccb74a9265be5e20c" translate="yes" xml:space="preserve">
          <source>Much of the problem is a result of Defect Report #028, which asked about the behavior of a program like:</source>
          <target state="translated">Большая часть проблемы является результатом Defect Report #028,в котором задавался вопрос о поведении такой программы:</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="5650248b0b69558ceb303fc582535c5dbae34409" translate="yes" xml:space="preserve">
          <source>Note the definition of indirection (&lt;a href=&quot;http://eel.is/c++draft/expr.unary.op#def:indirection&quot;&gt;* operator&lt;/a&gt;):</source>
          <target state="translated">Обратите внимание на определение косвенности ( &lt;a href=&quot;http://eel.is/c++draft/expr.unary.op#def:indirection&quot;&gt;оператор *&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="00e406f7a5b6352740c9e91b4d2959a865ade69d" translate="yes" xml:space="preserve">
          <source>Now, by satisfying the Strict Aliasing rule, step 3 can be avoided and the code will run significantly faster.</source>
          <target state="translated">Теперь,удовлетворяя правилу Strict Aliasing,можно избежать шага 3 и код будет работать значительно быстрее.</target>
        </trans-unit>
        <trans-unit id="24f4a3365263f6701ca3e6f9cc300671fef25d11" translate="yes" xml:space="preserve">
          <source>Now, to the Rule-Book</source>
          <target state="translated">А теперь,к книге правил</target>
        </trans-unit>
        <trans-unit id="00f2110e4b85aedc83fe7286d38033b5fadad084" translate="yes" xml:space="preserve">
          <source>Preliminary examples</source>
          <target state="translated">Предварительные примеры</target>
        </trans-unit>
        <trans-unit id="1a68967890ea62e6416814f2cd9ae705194f7f5a" translate="yes" xml:space="preserve">
          <source>Since two pointers can point to the same location in the memory, this could result in &lt;strong&gt;complex code that handles possible collisions&lt;/strong&gt;.</source>
          <target state="translated">Поскольку два указателя могут указывать на одно и то же место в памяти, это может привести к &lt;strong&gt;сложному коду, который обрабатывает возможные коллизии&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e831ce62bacf79dafcd6bc9e83656cfee8fb782d" translate="yes" xml:space="preserve">
          <source>So basically if you have an &lt;code&gt;int*&lt;/code&gt; pointing to some memory containing an &lt;code&gt;int&lt;/code&gt; and then you point a &lt;code&gt;float*&lt;/code&gt; to that memory and use it as a &lt;code&gt;float&lt;/code&gt; you break the rule. If your code does not respect this, then the compiler's optimizer will most likely break your code.</source>
          <target state="translated">Таким образом, если у вас есть &lt;code&gt;int*&lt;/code&gt; указывающий на некоторую память, содержащую &lt;code&gt;int&lt;/code&gt; , а затем вы указываете &lt;code&gt;float*&lt;/code&gt; на эту память и используете его как &lt;code&gt;float&lt;/code&gt; , вы нарушаете правило. Если ваш код не соблюдает это, оптимизатор компилятора, скорее всего, сломает ваш код.</target>
        </trans-unit>
        <trans-unit id="e527630d421fb5eeeebbd1a1fc94426badbe336a" translate="yes" xml:space="preserve">
          <source>So in any well defined program trace, a glvalue refers to an object. &lt;strong&gt;So the so called strict aliasing rule doesn't apply, ever.&lt;/strong&gt; This may not be what the designers wanted.</source>
          <target state="translated">Таким образом, в любой четко определенной программной трассировке glvalue ссылается на объект. &lt;strong&gt;Так что так называемое правило строгого наложения не применяется никогда.&lt;/strong&gt; Возможно, это не то, что хотели дизайнеры.</target>
        </trans-unit>
        <trans-unit id="deed8318c0841e594ef317b02788fe411e71c755" translate="yes" xml:space="preserve">
          <source>So in this kind of setup, if I want to send a message to something I'd have to have two incompatible pointers pointing to the same chunk of memory. I might then naively code something like this (on a system with &lt;code&gt;sizeof(int) == 2&lt;/code&gt;):</source>
          <target state="translated">Таким образом, при такой настройке, если я хочу отправить сообщение чему-либо, мне нужно иметь два несовместимых указателя, указывающих на один и тот же кусок памяти. Затем я мог бы наивно кодировать что-то вроде этого (в системе с &lt;code&gt;sizeof(int) == 2&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="aafc604e71041d21e6cb4b116236a68fac502d6a" translate="yes" xml:space="preserve">
          <source>So the if condition is completely gone from the assembler code.</source>
          <target state="translated">Так что если условие полностью исчезло из ассемблерного кода.</target>
        </trans-unit>
        <trans-unit id="be497017b70114a5fa54de0086695c60b70ce08f" translate="yes" xml:space="preserve">
          <source>Sometimes we want to circumvent the type system and interpret an object as a different type. This is called &lt;em&gt;type punning&lt;/em&gt;, to reinterpret a segment of memory as another type. &lt;em&gt;Type punning&lt;/em&gt; is useful for tasks that want access to the underlying representation of an object to view, transport or manipulate. Typical areas we find type punning being used are compilers, serialization, networking code, etc&amp;hellip;</source>
          <target state="translated">Иногда мы хотим обойти систему типов и интерпретировать объект как другой тип. Это называется &lt;em&gt;типом паннинга&lt;/em&gt; , чтобы переосмыслить сегмент памяти как другой тип. &lt;em&gt;Тип punning&lt;/em&gt; полезен для задач, которые хотят получить доступ к базовому представлению объекта для просмотра, транспортировки или манипулирования. Типичные области, в которых мы находим использование типов ввода: компиляторы, сериализация, сетевой код и т. Д.</target>
        </trans-unit>
        <trans-unit id="0e41cb1a9e14feeabe231350d4a98b43b5438b1e" translate="yes" xml:space="preserve">
          <source>Step 3 is very slow because it needs to access the physical memory. However, it's required to protect against instances where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; point to the same memory address.</source>
          <target state="translated">Шаг 3 очень медленный, потому что ему нужен доступ к физической памяти. Однако требуется защита от случаев, когда &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; указывают на один и тот же адрес памяти.</target>
        </trans-unit>
        <trans-unit id="6950bbb2a5fc815374e2b4c9fe07f848dcde484e" translate="yes" xml:space="preserve">
          <source>Strict aliasing (which I'll describe in a bit) &lt;strong&gt;is important because&lt;/strong&gt;:</source>
          <target state="translated">Строгий псевдоним (который я опишу чуть позже) &lt;strong&gt;важен, потому что&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="7b097276866172c8f0649d49560868d6d4cb3def" translate="yes" xml:space="preserve">
          <source>Strict aliasing doesn't refer only to pointers, it affects references as well, I wrote a paper about it for the boost developer wiki and it was so well received that I turned it into a page on my consulting web site.  It explains completely what it is, why it confuses people so much and what to do about it. &lt;a href=&quot;http://dbp-consulting.com/tutorials/StrictAliasing.html&quot;&gt;Strict Aliasing White Paper&lt;/a&gt;.  In particular it explains why unions are risky behavior for C++, and why using memcpy is the only fix portable across both C and C++.  Hope this is helpful.</source>
          <target state="translated">Строгое псевдонимы относятся не только к указателям, но и к ссылкам. Я написал статью об этом для вики-сайта Boost для разработчиков, и он был настолько хорошо принят, что я превратил его в страницу на своем консультационном веб-сайте. Это полностью объясняет, что это такое, почему это так сильно смущает людей и что с этим делать. &lt;a href=&quot;http://dbp-consulting.com/tutorials/StrictAliasing.html&quot;&gt;Строгий Aliasing White Paper&lt;/a&gt; . В частности, это объясняет, почему объединения являются рискованным поведением для C ++, и почему использование memcpy является единственным переносимым исправлением как для C, так и для C ++. Надеюсь, это полезно.</target>
        </trans-unit>
        <trans-unit id="ed51e87442d0b7d44562385cb2eaa5830e3da786" translate="yes" xml:space="preserve">
          <source>Strict aliasing is not allowing different pointer types to the same data.</source>
          <target state="translated">Строгое наложение псевдонимов не позволяет использовать разные типы указателей для одних и тех же данных.</target>
        </trans-unit>
        <trans-unit id="08f4008712546a2f35d451915a75c5ce6707541f" translate="yes" xml:space="preserve">
          <source>Strict aliasing would allow us to prevent this by telling the compiler that these memory addresses are distinctly different (which, in this case, will allow even further optimization which can't be performed if the pointers share a memory address).</source>
          <target state="translated">Строгое наложение псевдонимов позволит предотвратить это,сообщив компилятору,что эти адреса памяти явно отличаются (что в данном случае позволит провести еще большую оптимизацию,которую нельзя будет провести,если указатели будут иметь общий адрес памяти).</target>
        </trans-unit>
        <trans-unit id="3de059986d55a4c9204e0422ce6405ee0f2fae76" translate="yes" xml:space="preserve">
          <source>Technically in C++, the strict aliasing rule is probably never applicable.</source>
          <target state="translated">Технически,в С++,правило строгого псевдонизирования,вероятно,никогда не применяется.</target>
        </trans-unit>
        <trans-unit id="907bce6add949792da1d5d77350df907126f6c70" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;C11&lt;/strong&gt; standard says the following in section &lt;em&gt;6.5 Expressions paragraph 7&lt;/em&gt;:</source>
          <target state="translated">Стандарт &lt;strong&gt;C11&lt;/strong&gt; говорит следующее в разделе &lt;em&gt;6.5 Выражения параграфа 7&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="bfd25f24e236cc975bc1fefb913df995d3049915" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Strict aliasing rule allows us to avoid redundant machine code&lt;/strong&gt; in cases in which it &lt;em&gt;should be&lt;/em&gt; safe to assume that two pointers don't point to the same memory block (see also the &lt;code&gt;restrict&lt;/code&gt; keyword).</source>
          <target state="translated">&lt;strong&gt;Правило строгого псевдонима позволяет нам избегать избыточного машинного кода&lt;/strong&gt; в тех случаях, когда &lt;em&gt;можно с&lt;/em&gt; уверенностью предположить, что два указателя не указывают на один и тот же блок памяти (см. Также ключевое слово &lt;code&gt;restrict&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8c06897729db17629b567058f47bdaf4c4318b26" translate="yes" xml:space="preserve">
          <source>The C++17 draft standard in section &lt;em&gt;[basic.lval] paragraph 11&lt;/em&gt; says:</source>
          <target state="translated">Проект стандарта C ++ 17 в разделе 11 &lt;em&gt;[basic.lval]&lt;/em&gt; гласит:</target>
        </trans-unit>
        <trans-unit id="9bc4e143126dccfdfaa1a458c40e03e32eb19eb7" translate="yes" xml:space="preserve">
          <source>The Strict aliasing states it's safe to assume that pointers to different types point to different locations in the memory.</source>
          <target state="translated">Строгое наложение знаков позволяет предположить,что указатели на разные типы указывают на разные места в памяти.</target>
        </trans-unit>
        <trans-unit id="7928780bf9e4496f92d12638d4fa464749948340" translate="yes" xml:space="preserve">
          <source>The best explanation I have found is by Mike Acton, &lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;Understanding Strict Aliasing&lt;/a&gt;. It's focused a little on PS3 development, but that's basically just GCC.</source>
          <target state="translated">Лучшее объяснение, которое я нашел, - Майк Актон, &amp;laquo; &lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;Понимание строгого алиасинга&amp;raquo;&lt;/a&gt; . Он немного сфокусирован на разработке PS3, но в основном это только GCC.</target>
        </trans-unit>
        <trans-unit id="49c47e96747dd9ea774b5bc163ec15c244b5f868" translate="yes" xml:space="preserve">
          <source>The best way to resolve the original problem would probably be to treat the
footnote about the purpose of the rule as though it were normative, and made
the rule unenforceable except in cases which actually involve conflicting accesses using aliases.  Given something like:</source>
          <target state="translated">Лучшим способом решения исходной проблемы,вероятно,было бы обращение к сноске о цели правила,как к нормативному,и сделать правило невыполнимым,за исключением случаев,которые на самом деле связаны с конфликтующим доступом с использованием псевдонимов.Учитывая нечто подобное:</target>
        </trans-unit>
        <trans-unit id="85b689b0761df13dcd7da661f9fdf03565c0a4a1" translate="yes" xml:space="preserve">
          <source>The compiler may or may not be able to or smart enough to try to inline SendMessage and it may or may not decide to load or not load buff again. If &lt;code&gt;SendMessage&lt;/code&gt; is part of another API that's compiled separately, it probably has instructions to load buff's contents. Then again, maybe you're in C++ and this is some templated header only implementation that the compiler thinks it can inline. Or maybe it's just something you wrote in your .c file for your own convenience. Anyway undefined behavior might still ensue. Even when we know some of what's happening under the hood, it's still a violation of the rule so no well defined behavior is guaranteed. So just by wrapping in a function that takes our word delimited buffer doesn't necessarily help.</source>
          <target state="translated">Компилятор может или не может быть достаточно умным, чтобы попытаться встроить SendMessage, и он может или не может решить загружать или не загружать бафф снова. Если &lt;code&gt;SendMessage&lt;/code&gt; является частью другого API, который компилируется отдельно, он, вероятно, содержит инструкции для загрузки содержимого баффа. С другой стороны, может быть, вы находитесь в C ++, и это некая шаблонная реализация только для заголовков, которую компилятор считает встроенной. Или, может быть, это просто то, что вы написали в своем .c файле для вашего удобства. В любом случае неопределенное поведение все еще может возникнуть. Даже когда мы узнаем кое-что о том, что происходит под капотом, это все равно является нарушением правила, поэтому четко определенное поведение не гарантируется. Так что простое включение в функцию, которая принимает наш буфер с разделителями слов, не обязательно поможет.</target>
        </trans-unit>
        <trans-unit id="185da178ba74f21fd6fbee6fc9a19c180251420b" translate="yes" xml:space="preserve">
          <source>The exception to the rule is a &lt;code&gt;char*&lt;/code&gt;, which is allowed to point to any type.</source>
          <target state="translated">Исключением из правила является &lt;code&gt;char*&lt;/code&gt; , который может указывать на любой тип.</target>
        </trans-unit>
        <trans-unit id="e6deb33976faa98a7a8b3f350b9d49c319c195cd" translate="yes" xml:space="preserve">
          <source>The following is an example of how to use &lt;strong&gt;bit_cast&lt;/strong&gt; to type pun a &lt;em&gt;unsigned int&lt;/em&gt; to &lt;em&gt;float&lt;/em&gt;, (&lt;a href=&quot;https://wandbox.org/permlink/i5l0g4IYuCFgLzzl&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">Ниже приведен пример того, как использовать &lt;strong&gt;bit_cast&lt;/strong&gt; для ввода pun &lt;em&gt;беззнакового&lt;/em&gt; &lt;strong&gt;целого&lt;/strong&gt; типа с &lt;em&gt;плавающей точкой&lt;/em&gt; ( &lt;a href=&quot;https://wandbox.org/permlink/i5l0g4IYuCFgLzzl&quot;&gt;смотрите в реальном времени&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="bc2fdca487b4e3f2274bf45676f76859149d4991" translate="yes" xml:space="preserve">
          <source>The last tool I will recommend is C++ specific and not strictly a tool but a coding practice, don't allow C-style casts. Both gcc and clang will produce a diagnostic for C-style casts using &lt;strong&gt;-Wold-style-cast&lt;/strong&gt;. This will force any undefined type puns to use reinterpret_cast, in general reinterpret_cast should be a flag for closer code review. It is also easier to search your code base for reinterpret_cast to perform an audit.</source>
          <target state="translated">Последний инструмент, который я порекомендую, специфичен для C ++ и не только инструмент, но и практика кодирования, не допускающая приведение в стиле C. И gcc, и clang будут производить диагностику для приведения в стиле C с использованием &lt;strong&gt;-Wold-style-cast&lt;/strong&gt; . Это заставит любые неопределенные каламбуры типа использовать reinterpret_cast, в общем случае reinterpret_cast должен быть флагом для более тщательного анализа кода. Также проще выполнить поиск в базе кода для reinterpret_cast, чтобы выполнить аудит.</target>
        </trans-unit>
        <trans-unit id="d6426a86b973a6cec74fb415633b300e0a37c506" translate="yes" xml:space="preserve">
          <source>The next example shows aliasing that leads to undefined behavior (&lt;a href=&quot;https://wandbox.org/permlink/8qA8JyJRVHtS9LPf&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">В следующем примере показан псевдоним, который приводит к неопределенному поведению ( &lt;a href=&quot;https://wandbox.org/permlink/8qA8JyJRVHtS9LPf&quot;&gt;пример в реальном времени&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="5e5d6deec660f2c03a74983d7e1f704f0a612063" translate="yes" xml:space="preserve">
          <source>The optimizer using &lt;a href=&quot;http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm&quot;&gt;Type-Based Alias Analysis (TBAA)&lt;/a&gt; assumes &lt;strong&gt;1&lt;/strong&gt; will be returned and directly moves the constant value into register &lt;strong&gt;eax&lt;/strong&gt; which carries the return value. TBAA uses the languages rules about what types are allowed to alias to optimize loads and stores. In this case TBAA knows that a &lt;em&gt;float&lt;/em&gt; can not alias and &lt;em&gt;int&lt;/em&gt; and optimizes away the load of &lt;strong&gt;i&lt;/strong&gt;.</source>
          <target state="translated">Оптимизатор, использующий &lt;a href=&quot;http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm&quot;&gt;анализ псевдонимов на основе типов (TBAA),&lt;/a&gt; предполагает, что &lt;strong&gt;1&lt;/strong&gt; будет возвращен, и непосредственно перемещает постоянное значение в регистр &lt;strong&gt;eax,&lt;/strong&gt; который несет возвращаемое значение. TBAA использует правила языков о том, какие типы разрешены для псевдонимов для оптимизации загрузки и хранения. В этом случае TBAA знает, что &lt;em&gt;float&lt;/em&gt; не может использовать псевдонимы и &lt;em&gt;int,&lt;/em&gt; и оптимизирует загрузку &lt;strong&gt;i&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="eb988ee6dabc3ef8446376c66441177c2cd532a0" translate="yes" xml:space="preserve">
          <source>The standard method for &lt;em&gt;type punning&lt;/em&gt; in both C and C++ is &lt;strong&gt;memcpy&lt;/strong&gt;. This may seem a little heavy handed but the optimizer should recognize the use of &lt;strong&gt;memcpy&lt;/strong&gt; for &lt;em&gt;type punning&lt;/em&gt; and optimize it away and generate a register to register move. For example if we know &lt;em&gt;int64_t&lt;/em&gt; is the same size as &lt;em&gt;double&lt;/em&gt;:</source>
          <target state="translated">Стандартный метод для определения &lt;em&gt;типов&lt;/em&gt; в C и C ++ - это &lt;strong&gt;memcpy&lt;/strong&gt; . Это может показаться немного сложным, но оптимизатор должен распознавать использование &lt;strong&gt;memcpy&lt;/strong&gt; для обозначения &lt;em&gt;типа,&lt;/em&gt; оптимизировать его и генерировать регистр для регистрации перемещения. Например, если мы знаем, что &lt;em&gt;int64_t&lt;/em&gt; имеет тот же размер, что и &lt;em&gt;double&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="08b2135b25032781b64ff4c52a4bdd14662d43d7" translate="yes" xml:space="preserve">
          <source>The strict aliasing rule makes this setup illegal: dereferencing a pointer that aliases an object that is not of a &lt;a href=&quot;http://en.cppreference.com/w/c/language/type&quot;&gt;compatible type&lt;/a&gt; or one of the other types allowed by C 2011 6.5 paragraph 7&lt;sup&gt;1&lt;/sup&gt; is undefined behavior. Unfortunately, you can still code this way, &lt;em&gt;maybe&lt;/em&gt; get some warnings, have it compile fine, only to have weird unexpected behavior when you run the code.</source>
          <target state="translated">Строгое правило псевдонимов делает эту настройку недопустимой: разыменование указателя на псевдоним объекта, который не является &lt;a href=&quot;http://en.cppreference.com/w/c/language/type&quot;&gt;совместимым типом&lt;/a&gt; или одним из других типов, разрешенных C 2011 6.5, пункт 7 &lt;sup&gt;1,&lt;/sup&gt; является неопределенным поведением. К сожалению, вы все еще можете кодировать таким образом, &lt;em&gt;возможно,&lt;/em&gt; получить несколько предупреждений, сделать так, чтобы он нормально компилировался, только для того, чтобы иметь странное неожиданное поведение при запуске кода.</target>
        </trans-unit>
        <trans-unit id="bd0246c8dec2dd6e8cc0d773260f9ddcf056333b" translate="yes" xml:space="preserve">
          <source>The third change makes a stronger guarantee (relaxes the strong aliasing rule): The new concept of &lt;em&gt;similar types&lt;/em&gt; that are now safe to alias.</source>
          <target state="translated">Третье изменение дает более сильную гарантию (ослабляет строгое правило псевдонимов): новая концепция &lt;em&gt;похожих типов&lt;/em&gt; , которые теперь безопасны для псевдонимов.</target>
        </trans-unit>
        <trans-unit id="428a7cf24521c1266f3851b503c14cb107e579a2" translate="yes" xml:space="preserve">
          <source>The unary * operator performs indirection: the expression to which it
  is applied shall be a pointer to an object type, or a pointer to a
  function type and &lt;strong&gt;the result is an lvalue referring to the object&lt;/strong&gt; or
  function &lt;strong&gt;to which the expression points&lt;/strong&gt;.</source>
          <target state="translated">Унарный оператор * выполняет косвенное обращение: выражение, к которому он применяется, должно быть указателем на тип объекта или указателем на тип функции, а &lt;strong&gt;результатом является lvalue, указывающее на объект&lt;/strong&gt; или функцию, &lt;strong&gt;на которые указывает выражение&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f3edc398608fb9b543cd714f6b95b268072cc297" translate="yes" xml:space="preserve">
          <source>There's no conflict within &lt;code&gt;inc_int&lt;/code&gt; because all accesses to the storage accessed through &lt;code&gt;*p&lt;/code&gt; are done with an lvalue of type &lt;code&gt;int&lt;/code&gt;, and there's no conflict in &lt;code&gt;test&lt;/code&gt; because &lt;code&gt;p&lt;/code&gt; is visibly derived from a &lt;code&gt;struct S&lt;/code&gt;, and by the next time &lt;code&gt;s&lt;/code&gt; is used, all accesses to that storage that will ever be made through &lt;code&gt;p&lt;/code&gt; will have already happened.</source>
          <target state="translated">Внутри &lt;code&gt;inc_int&lt;/code&gt; нет конфликта, потому что все обращения к хранилищу, доступ к которому осуществляется через &lt;code&gt;*p&lt;/code&gt; , осуществляются с l-значением типа &lt;code&gt;int&lt;/code&gt; , и в &lt;code&gt;test&lt;/code&gt; нет конфликта, потому что &lt;code&gt;p&lt;/code&gt; явно выводится из &lt;code&gt;struct S&lt;/code&gt; , и к следующему использованию &lt;code&gt;s&lt;/code&gt; все доступ к тому хранилищу, которое когда-либо будет сделано через &lt;code&gt;p&lt;/code&gt; , уже произошел.</target>
        </trans-unit>
        <trans-unit id="1e47063a12afd4868e46be1f29d48214f059315d" translate="yes" xml:space="preserve">
          <source>This can be told to the compiler in two ways, by using different types to point to. i.e.:</source>
          <target state="translated">Это можно сказать компилятору двумя способами,используя различные типы,на которые следует указывать,т.е:</target>
        </trans-unit>
        <trans-unit id="6f8c42e0f055d24e57ba0b97836be0b7abeb6542" translate="yes" xml:space="preserve">
          <source>This extra code is slow and &lt;strong&gt;hurts performance&lt;/strong&gt; since it performs extra memory read / write operations which are both slower and (possibly) unnecessary.</source>
          <target state="translated">Этот дополнительный код является медленным и &lt;strong&gt;снижает производительность,&lt;/strong&gt; поскольку он выполняет операции чтения / записи дополнительной памяти, которые являются одновременно более медленными и (возможно) ненужными.</target>
        </trans-unit>
        <trans-unit id="03bd20f42d11715386a09efa404ec49187a334ec" translate="yes" xml:space="preserve">
          <source>This is excerpted from my &lt;a href=&quot;https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8&quot;&gt;&quot;What is the Strict Aliasing Rule and Why do we care?&quot;&lt;/a&gt; write-up.</source>
          <target state="translated">Это выдержка из моего &lt;a href=&quot;https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8&quot;&gt;&amp;laquo;Что такое строгое правило алиасинга и почему нас это волнует?&amp;raquo;&lt;/a&gt; записать.</target>
        </trans-unit>
        <trans-unit id="23f8f6c33332ebb487428148aeaa250e333c0297" translate="yes" xml:space="preserve">
          <source>This is not valid in C++ and some consider the purpose of unions to be solely for implementing variant types and feel using unions for type punning is an abuse.</source>
          <target state="translated">Это не относится к С++,и некоторые считают,что целью союзов является исключительно реализация вариантов,и считают,что использование союзов для типового наказания является злоупотреблением.</target>
        </trans-unit>
        <trans-unit id="b5a81d05fa60ca66493d7a8dd3adf9606ece3212" translate="yes" xml:space="preserve">
          <source>This is only one potential minefield when overlaying two types onto each other. You should also learn about &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;endianness&lt;/a&gt;, &lt;a href=&quot;http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html&quot;&gt;word alignment&lt;/a&gt;, and how to deal with alignment issues through &lt;a href=&quot;http://grok2.com/structure_packing.html&quot;&gt;packing structs&lt;/a&gt; correctly.</source>
          <target state="translated">Это только одно потенциальное минное поле при наложении двух типов друг на друга. Вы также должны узнать о порядке &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;байтов&lt;/a&gt; , &lt;a href=&quot;http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html&quot;&gt;выравнивании слов&lt;/a&gt; и о том, как правильно решать проблемы выравнивания с помощью &lt;a href=&quot;http://grok2.com/structure_packing.html&quot;&gt;структур упаковки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1206246dfe34c612a18075c8bf78ec4ea7f41bed" translate="yes" xml:space="preserve">
          <source>This is the strict aliasing rule, found in section 3.10 of the &lt;strong&gt;C++03&lt;/strong&gt; standard (other answers provide good explanation, but none provided the rule itself):</source>
          <target state="translated">Это строгое правило псевдонимов, которое можно найти в разделе 3.10 стандарта &lt;strong&gt;C ++ 03&lt;/strong&gt; (другие ответы дают хорошее объяснение, но ни один из них не содержит самого правила):</target>
        </trans-unit>
        <trans-unit id="136cb4ca2af68d11d5c37a73bdbfaeaff7fafa9a" translate="yes" xml:space="preserve">
          <source>This optimization couldn't have been done before, because of the possible collision (where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; would be tripled instead of doubled).</source>
          <target state="translated">Эта оптимизация не могла быть сделана раньше из-за возможного столкновения (где &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; были бы утроены, а не удвоены).</target>
        </trans-unit>
        <trans-unit id="0c6e49d370e8ee32d1f9fb66865bb3dc534b3fdf" translate="yes" xml:space="preserve">
          <source>To see why this behavior is undefined, we have to think about what the strict aliasing rule buys the compiler. Basically, with this rule, it doesn't have to think about inserting instructions to refresh the contents of &lt;code&gt;buff&lt;/code&gt; every run of the loop. Instead, when optimizing, with some annoyingly unenforced assumptions about aliasing, it can omit those instructions, load &lt;code&gt;buff[0]&lt;/code&gt; and &lt;code&gt;buff[1&lt;/code&gt;] into CPU registers once before the loop is run, and speed up the body of the loop. Before strict aliasing was introduced, the compiler had to live in a state of paranoia that the contents of &lt;code&gt;buff&lt;/code&gt; could change at anytime from anywhere by anybody. So to get an extra performance edge, and assuming most people don't type-pun pointers, the strict aliasing rule was introduced.</source>
          <target state="translated">Чтобы понять, почему это поведение не определено, нам нужно подумать о том, какое правило строгого алиасинга покупает компилятор. По сути, с этим правилом не нужно думать о вставке инструкций для обновления содержимого &lt;code&gt;buff&lt;/code&gt; каждом запуске цикла. Вместо этого, при оптимизации с некоторыми досадными необоснованными предположениями о псевдонимах, он может опустить эти инструкции, загрузить &lt;code&gt;buff[0]&lt;/code&gt; и &lt;code&gt;buff[1&lt;/code&gt; ] в регистры ЦП один раз перед запуском цикла и ускорить тело цикла. До введения строгого псевдонима компилятор должен был жить в состоянии паранойи, когда содержимое &lt;code&gt;buff&lt;/code&gt; может измениться в любое время и в любом месте кем-либо. Таким образом, чтобы получить дополнительное преимущество в производительности, и при условии, что большинство людей не вводят указатели с каламбура, было введено строгое правило псевдонимов.</target>
        </trans-unit>
        <trans-unit id="2cca1ba7b02e14ee263ba59cb168d4ba464a31b0" translate="yes" xml:space="preserve">
          <source>To understand more about why we care, we will discuss issues that come up when violating strict aliasing rules, type punning since common techniques used in type punning often violate strict aliasing rules and how to type pun correctly.</source>
          <target state="translated">Чтобы понять,почему нас это волнует,мы обсудим вопросы,которые возникают при нарушении строгих правил наложения псевдонима,наложения псевдонима,так как обычные методы,используемые при наложении псевдонима,часто нарушают строгие правила наложения псевдонима,и как наложить псевдоним правильно.</target>
        </trans-unit>
        <trans-unit id="e92874def1c707e293c92fd2c84a024426689bc4" translate="yes" xml:space="preserve">
          <source>Traditionally this has been accomplished by taking the address of the object, casting it to a pointer of the type we want to reinterpret it as and then accessing the value, or in other words by aliasing. For example:</source>
          <target state="translated">Традиционно это достигалось путем взятия адреса объекта,приведения его к указателю того типа,которым мы хотим его переинтерпретировать,а затем доступа к значению,или,другими словами,с помощью псевдонима.Например:</target>
        </trans-unit>
        <trans-unit id="edef09f47c7522a6bf38ab921e88dc728d2d2210" translate="yes" xml:space="preserve">
          <source>Two changes were small: &lt;em&gt;glvalue&lt;/em&gt; instead of &lt;em&gt;lvalue&lt;/em&gt;, and clarification of the aggregate/union case.</source>
          <target state="translated">Два изменения были небольшими: &lt;em&gt;glvalue&lt;/em&gt; вместо &lt;em&gt;lvalue&lt;/em&gt; и прояснение случая совокупности / объединения.</target>
        </trans-unit>
        <trans-unit id="0200f9824ad4e7d323fbd799151680bd20557e5c" translate="yes" xml:space="preserve">
          <source>Unfortunately with strict aliasing violations, we will often obtain the results we expect, leaving the possibility the a future version of a compiler with a new optimization will break code we thought was valid. This is undesirable and it is a worthwhile goal to understand the strict aliasing rules and how to avoid violating them.</source>
          <target state="translated">К сожалению,со строгими нарушениями алиасинга мы часто получаем ожидаемые результаты,оставляя возможность того,что будущая версия компилятора с новой оптимизацией сломает код,который мы считали правильным.Это нежелательно и стоит понять строгие правила наложения псевдонимов и как избежать их нарушения.</target>
        </trans-unit>
        <trans-unit id="db8ca5d18a2da2723c323eb4668458564a4e8a8e" translate="yes" xml:space="preserve">
          <source>Unfortunately, the authors of the C89 wrote their rule in a way that, if read literally, would make even the following function invoke Undefined Behavior:</source>
          <target state="translated">К сожалению,авторы C89 написали свое правило таким образом,что при буквальном прочтении даже следующая функция будет вызывать Неопределенное поведение:</target>
        </trans-unit>
        <trans-unit id="c9eb5ca0a29983f2cff35266a2b00fda06003422" translate="yes" xml:space="preserve">
          <source>Use a union. Most compilers support this without complaining about strict aliasing. This is allowed in C99 and explicitly allowed in C11.</source>
          <target state="translated">Использовать профсоюз.Большинство компиляторов поддерживают это,не жалуясь на строгий псевдоним.Это разрешено в C99 и явно разрешено в C11.</target>
        </trans-unit>
        <trans-unit id="ffd25c02b83ef5f0f4c7c45af829e62dae0bf2c5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;restrict&lt;/code&gt; keyword. i.e.:</source>
          <target state="translated">Используя ключевое слово &lt;code&gt;restrict&lt;/code&gt; . то есть:</target>
        </trans-unit>
        <trans-unit id="798b73c4c9c14434f5fd6ba2176351fdd836980d" translate="yes" xml:space="preserve">
          <source>We don't have a lot of good tools for catching strict aliasing in C++, the tools we have will catch some cases of strict aliasing violations and some cases of misaligned loads and stores.</source>
          <target state="translated">У нас не так много хороших инструментов для перехвата строгого псевдонима на C++,инструменты,которые у нас есть,перехватят некоторые случаи нарушения строгого псевдонима,а также некоторые случаи неправильно выровненных загрузок и магазинов.</target>
        </trans-unit>
        <trans-unit id="7a25725c5206d96d54103f39151066cf147a0d46" translate="yes" xml:space="preserve">
          <source>We have a &lt;em&gt;int*&lt;/em&gt; pointing to memory occupied by an &lt;em&gt;int&lt;/em&gt; and this is a valid aliasing. The optimizer must assume that assignments through &lt;strong&gt;ip&lt;/strong&gt; could update the value occupied by &lt;strong&gt;x&lt;/strong&gt;.</source>
          <target state="translated">У нас есть &lt;em&gt;int *,&lt;/em&gt; указывающий на память, занятую &lt;em&gt;int,&lt;/em&gt; и это допустимый псевдоним. Оптимизатор должен предполагать, что назначения через &lt;strong&gt;ip&lt;/strong&gt; могут обновить значение, занимаемое &lt;strong&gt;x&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b4304e0250327f603bbd29b9479b911b0f3e7e12" translate="yes" xml:space="preserve">
          <source>We have gotten to this point and we may be wondering, why would we want to alias for? The answer typically is to &lt;em&gt;type pun&lt;/em&gt;, often the methods used violate strict aliasing rules.</source>
          <target state="translated">Мы дошли до этой точки, и нам может быть интересно, зачем нам нужен псевдоним? Ответ обычно заключается в &lt;em&gt;вводе слов&lt;/em&gt; , часто используемые методы нарушают строгие правила наложения имен.</target>
        </trans-unit>
        <trans-unit id="486a3a882c8d445100340edd5a8f2d6177c5a9af" translate="yes" xml:space="preserve">
          <source>What are they talking about?</source>
          <target state="translated">О чем они говорят?</target>
        </trans-unit>
        <trans-unit id="8c58623950ce7060c946f960d5a1072d0350e835" translate="yes" xml:space="preserve">
          <source>What does the C11 standard say?</source>
          <target state="translated">Что говорит стандарт C11?</target>
        </trans-unit>
        <trans-unit id="be95c287c482fdf98be1e57328b6181a5b151c60" translate="yes" xml:space="preserve">
          <source>What exactly does the standard say we are allowed and not allowed to do? The standard language is not straightforward, so for each item I will try to provide code examples that demonstrates the meaning.</source>
          <target state="translated">Что именно говорится в стандарте,что нам позволено и не позволено делать? Стандартный язык не является простым,поэтому для каждого пункта я постараюсь привести примеры кода,демонстрирующие значение.</target>
        </trans-unit>
        <trans-unit id="80f819d6238279d0e91326c0caabb3b332286522" translate="yes" xml:space="preserve">
          <source>What is Type Punning</source>
          <target state="translated">Что такое наказание по типу</target>
        </trans-unit>
        <trans-unit id="0484d0796de9fffe254f71284bf9ef8e03cb6100" translate="yes" xml:space="preserve">
          <source>What is strict aliasing?</source>
          <target state="translated">Что такое строгое наложение псевдонимов?</target>
        </trans-unit>
        <trans-unit id="bd5bd917a7164fc90491e58bae353151d7d6d43e" translate="yes" xml:space="preserve">
          <source>What is the strict aliasing rule</source>
          <target state="translated">Какое строгое правило наложения псевдонимов</target>
        </trans-unit>
        <trans-unit id="cfad540cca405d9e6ac5dbafe09c03446c539f96" translate="yes" xml:space="preserve">
          <source>What the C++17 Draft Standard say</source>
          <target state="translated">То,что говорится в проекте стандарта С++17</target>
        </trans-unit>
        <trans-unit id="2b2f3220f114ca6e5fa9f3ff293ad00e83672d76" translate="yes" xml:space="preserve">
          <source>When asking about &lt;a href=&quot;https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into&quot;&gt;common undefined behavior in C&lt;/a&gt;, people sometimes refer to the strict aliasing rule.</source>
          <target state="translated">Отвечая на вопрос о &lt;a href=&quot;https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into&quot;&gt;распространенном неопределенном поведении в C&lt;/a&gt; , люди иногда ссылаются на строгое правило псевдонимов.</target>
        </trans-unit>
        <trans-unit id="c3986cda3c380d27ccea1e1786651cd0707eff3f" translate="yes" xml:space="preserve">
          <source>Which may not be expected but is perfectly valid since we have invoked undefined behavior. A &lt;em&gt;float&lt;/em&gt; can not validly alias an &lt;em&gt;int&lt;/em&gt; object. Therefore the optimizer can assume the &lt;em&gt;constant 1&lt;/em&gt; stored when dereferencing &lt;strong&gt;i&lt;/strong&gt; will be the return value since a store through &lt;strong&gt;f&lt;/strong&gt; could not validly affect an &lt;em&gt;int&lt;/em&gt; object. Plugging the code in Compiler Explorer shows this is exactly what is happening(&lt;a href=&quot;https://godbolt.org/g/yNV5aj&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">Что может и не ожидаться, но совершенно правильно, так как мы вызвали неопределенное поведение. Число с &lt;em&gt;плавающей запятой&lt;/em&gt; не может правильно называть объект &lt;em&gt;int&lt;/em&gt; . Следовательно, оптимизатор может предположить, что &lt;em&gt;константа 1,&lt;/em&gt; сохраненная при разыменовании &lt;strong&gt;i,&lt;/strong&gt; будет возвращаемым значением, поскольку сохранение через &lt;strong&gt;f&lt;/strong&gt; не может корректно влиять на объект &lt;em&gt;int&lt;/em&gt; . Подсоединение кода в Compiler Explorer показывает, что это именно то, что происходит ( &lt;a href=&quot;https://godbolt.org/g/yNV5aj&quot;&gt;живой пример&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="07141bb6d0d110634a7409d34c366630d3c98a44" translate="yes" xml:space="preserve">
          <source>Worth noting &lt;em&gt;signed char&lt;/em&gt; is not included in the list above, this is a notable difference from &lt;em&gt;C&lt;/em&gt; which says &lt;em&gt;a character type&lt;/em&gt;.</source>
          <target state="translated">Стоит отметить, что &lt;em&gt;подписанный символ&lt;/em&gt; не включен в приведенный выше список, это заметное отличие от &lt;em&gt;C,&lt;/em&gt; который говорит &lt;em&gt;о типе символа&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6ec4bca0456ee32bdbabe8e73b9e3df68f5d736b" translate="yes" xml:space="preserve">
          <source>You can disable strict aliasing in your compiler (&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825&quot;&gt;f[no-]strict-aliasing&lt;/a&gt; in gcc))</source>
          <target state="translated">Вы можете отключить строгое псевдонимы в вашем компиляторе ( &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825&quot;&gt;f [no-] strict-aliasing&lt;/a&gt; в gcc))</target>
        </trans-unit>
        <trans-unit id="9a40a7037ea21cd56a31798eee7807d9c8786d82" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;char*&lt;/code&gt; for aliasing instead of your system's word. The rules allow an exception for &lt;code&gt;char*&lt;/code&gt; (including &lt;code&gt;signed char&lt;/code&gt; and &lt;code&gt;unsigned char&lt;/code&gt;). It's always assumed that &lt;code&gt;char*&lt;/code&gt; aliases other types. However this won't work the other way: there's no assumption that your struct aliases a buffer of chars.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;char*&lt;/code&gt; для псевдонимов вместо слова вашей системы. Правила допускают исключение для &lt;code&gt;char*&lt;/code&gt; (включая &lt;code&gt;signed char&lt;/code&gt; и &lt;code&gt;unsigned char&lt;/code&gt; ). Всегда предполагается, что &lt;code&gt;char*&lt;/code&gt; псевдонимы других типов. Однако это не сработает иначе: нет предположения, что ваша структура псевдонимом является буфер символов.</target>
        </trans-unit>
        <trans-unit id="3ee51db5fb0d07b269bfed3eb63461eb650f3683" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">тип &lt;code&gt;char&lt;/code&gt; или &lt;code&gt;unsigned char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="597ff02af60ec975bbc5261d748ee4cf1e57a446" translate="yes" xml:space="preserve">
          <source>a character type.</source>
          <target state="translated">тип символов.</target>
        </trans-unit>
        <trans-unit id="cce769f3e61ed7c57c27b8bbabf2ecde89913120" translate="yes" xml:space="preserve">
          <source>a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">cv-квалифицированная версия динамического типа объекта,</target>
        </trans-unit>
        <trans-unit id="d5c0b51b12ba45e66cdb0c200363fe41dca17267" translate="yes" xml:space="preserve">
          <source>a qualified version of a type compatible with the effective type of the object,</source>
          <target state="translated">квалифицированную версию типа,совместимого с действующим типом объекта,</target>
        </trans-unit>
        <trans-unit id="913991e5ddd84e880c9ee8623ae50786c0e5aa58" translate="yes" xml:space="preserve">
          <source>a qualiﬁed version of a type compatible with the effective type of
  the object,</source>
          <target state="translated">квалифицированную версию типа,совместимого с действующим типом объекта,</target>
        </trans-unit>
        <trans-unit id="b75dd2203435a45255f541a92e8f52a7c687df9d" translate="yes" xml:space="preserve">
          <source>a type compatible with the effective type of the object,</source>
          <target state="translated">тип,совместимый с действующим типом объекта,</target>
        </trans-unit>
        <trans-unit id="75d68aa8a13ac3e6c2e72772064d82f9a07c3a25" translate="yes" xml:space="preserve">
          <source>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</source>
          <target state="translated">тип,который является (возможно,cv-квалифицированным)базовым типом динамического типа объекта,</target>
        </trans-unit>
        <trans-unit id="b65677be1e1487df5175120a02cfc67364b289cb" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a
  qualiﬁed version of the effective type of the object,</source>
          <target state="translated">тип,который является подписанным или неподписанным типом,соответствующим квалифицированному варианту действующего типа объекта,</target>
        </trans-unit>
        <trans-unit id="bac8eec6cb1615e6948be007906aef75526747ef" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">тип,который является знаковым или беззнаковым,соответствующим cv-квалифицированной версии динамического типа объекта,</target>
        </trans-unit>
        <trans-unit id="32f34f0edd59f5a473682cd472684b341a58daef" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,</source>
          <target state="translated">тип,который является знаковым или неподписанным типом,соответствующим квалифицированной версии действующего типа объекта,</target>
        </trans-unit>
        <trans-unit id="e7c8760740b87a7f9140b423e924d45e4999f46b" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to the
  effective type of the object,</source>
          <target state="translated">тип,который является знаковым или беззнаковым,соответствующим действующему типу объекта,</target>
        </trans-unit>
        <trans-unit id="3fb43283d88825a91d147ec87a46390b16119ec1" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</source>
          <target state="translated">тип,который является знаковым или беззнаковым,соответствующим динамическому типу объекта,</target>
        </trans-unit>
        <trans-unit id="09589aee6f97ca1ced0e9615240163fa1a8aac6b" translate="yes" xml:space="preserve">
          <source>add &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">добавить к &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4989e9968b633144d1dfa1a4b1a8a78e58f871e" translate="yes" xml:space="preserve">
          <source>add &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">добавить &lt;code&gt;b&lt;/code&gt; к &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7dfe2e2b4ee47faaabfeac29663335e09827e6a" translate="yes" xml:space="preserve">
          <source>although it will not catch this additional case (&lt;a href=&quot;https://wandbox.org/permlink/dwd9jhy53AF7a2D0&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">хотя он не поймает этот дополнительный случай ( &lt;a href=&quot;https://wandbox.org/permlink/dwd9jhy53AF7a2D0&quot;&gt;посмотри вживую&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="e191b7b82407cef0ada97dd29a20d0793010dffe" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned
  types among its members (including, recursively, a member of a
  subaggregate or contained union), or</source>
          <target state="translated">совокупный или профсоюзный тип,который включает один из вышеупомянутых типов среди своих членов (включая,рекурсивно,члена подгруппы или содержащегося профсоюза),либо</target>
        </trans-unit>
        <trans-unit id="fdece15d7bccebfe8183f34b848fc0e4942877cb" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned types among its &lt;em&gt;elements or non-static data members&lt;/em&gt; (including, recursively, an &lt;em&gt;element or non-static data member&lt;/em&gt; of a subaggregate or contained union),</source>
          <target state="translated">агрегатный или объединенный тип, который включает в себя один из вышеупомянутых типов среди своих &lt;em&gt;элементов или нестатических элементов данных&lt;/em&gt; (включая, рекурсивно, &lt;em&gt;элемент или нестатический элемент&lt;/em&gt; данных субагрегата или содержащего объединения),</target>
        </trans-unit>
        <trans-unit id="3bb5bb5a7fb40894ca32d70cc8dbec9f68ef6180" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union),</source>
          <target state="translated">совокупный или профсоюзный тип,который включает один из вышеупомянутых типов среди своих членов (включая,рекурсивно,члена подгруппы или содержащегося профсоюза),</target>
        </trans-unit>
        <trans-unit id="9904ae77bbd2a07d458dc75556c60522d6fed3a1" translate="yes" xml:space="preserve">
          <source>because it uses an lvalue of type &lt;code&gt;int&lt;/code&gt; to access an object of type &lt;code&gt;struct S&lt;/code&gt;, and &lt;code&gt;int&lt;/code&gt; is not among the types that may be used accessing a &lt;code&gt;struct S&lt;/code&gt;.  Because it would be absurd to treat all use of non-character-type members of structs and unions as Undefined Behavior, almost everyone recognizes that there are at least some circumstances where an lvalue of one type may be used to access an object of another type.  Unfortunately, the C Standards Committee has failed to define what those circumstances are.</source>
          <target state="translated">потому что он использует lvalue типа &lt;code&gt;int&lt;/code&gt; для доступа к объекту типа &lt;code&gt;struct S&lt;/code&gt; , а &lt;code&gt;int&lt;/code&gt; не входит в число типов, которые могут использоваться для доступа к &lt;code&gt;struct S&lt;/code&gt; . Поскольку было бы абсурдно рассматривать любое использование элементов структур и объединений, не относящихся к символьному типу, как неопределенное поведение, почти каждый признает, что существуют, по крайней мере, некоторые обстоятельства, когда lvalue одного типа может использоваться для доступа к объекту другого типа. , К сожалению, Комитет по стандартам C не смог определить, каковы эти обстоятельства.</target>
        </trans-unit>
        <trans-unit id="13f76d1176cba1d67741f0be2b7d390647245ed8" translate="yes" xml:space="preserve">
          <source>check.c</source>
          <target state="translated">check.c</target>
        </trans-unit>
        <trans-unit id="6cc4950f9d59b228de0ffc8dfa255d0ff18a24aa" translate="yes" xml:space="preserve">
          <source>gcc using the flag &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; and &lt;strong&gt;-Wstrict-aliasing&lt;/strong&gt; can catch some cases although not without false positives/negatives. For example the following cases will generate a warning in gcc (&lt;a href=&quot;https://wandbox.org/permlink/cfckjTgwNTYHDIry&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">gcc с использованием флагов &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; и &lt;strong&gt;-Wstrict-aliasing&lt;/strong&gt; может отлавливать некоторые случаи, хотя и без ложных срабатываний / отрицаний. Например, в следующих случаях в gcc будет сгенерировано предупреждение ( &lt;a href=&quot;https://wandbox.org/permlink/cfckjTgwNTYHDIry&quot;&gt;смотрите его вживую&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="9b9539e1dab95d4762b7ca605ff3ef29baabe352" translate="yes" xml:space="preserve">
          <source>load &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from memory.</source>
          <target state="translated">загрузить А и В из памяти.</target>
        </trans-unit>
        <trans-unit id="3c8e98bbec15998f99b160035e6e2a5a79e70264" translate="yes" xml:space="preserve">
          <source>save &lt;code&gt;a&lt;/code&gt; (from the CPU register) to the memory.</source>
          <target state="translated">сохранить (из регистра ЦП) в памяти.</target>
        </trans-unit>
        <trans-unit id="e9f82b272f6f1b1af58a82bfd5c8942a5383dee9" translate="yes" xml:space="preserve">
          <source>save result both to &lt;code&gt;a&lt;/code&gt; and to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">сохранить результат как в &lt;code&gt;a&lt;/code&gt; ,так и в &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a44e1b26b12bd2a7790e5bb3e97bb71d781569c" translate="yes" xml:space="preserve">
          <source>should be required to reload the value of &lt;code&gt;x&lt;/code&gt; between the assignment and return statement so as to allow for the possibility that &lt;code&gt;p&lt;/code&gt; might point to &lt;code&gt;x&lt;/code&gt;, and the assignment to &lt;code&gt;*p&lt;/code&gt; might consequently alter the value of &lt;code&gt;x&lt;/code&gt;.  The notion that a compiler should be entitled to presume that there won't be aliasing &lt;em&gt;in situations like the above&lt;/em&gt; was non-controversial.</source>
          <target state="translated">должно потребоваться перезагрузить значение &lt;code&gt;x&lt;/code&gt; между оператором присваивания и возврата, чтобы учесть вероятность того, что &lt;code&gt;p&lt;/code&gt; может указывать на &lt;code&gt;x&lt;/code&gt; , а назначение &lt;code&gt;*p&lt;/code&gt; может, следовательно, изменить значение &lt;code&gt;x&lt;/code&gt; . Идея о том, что компилятор должен иметь право предполагать, что &lt;em&gt;в ситуациях, подобных описанным выше,&lt;/em&gt; не будет псевдонимов, не вызывала сомнений.</target>
        </trans-unit>
        <trans-unit id="2ae0f749e2f2eba590823df0d938d3f9e1d9f0ad" translate="yes" xml:space="preserve">
          <source>the dynamic type of the object,</source>
          <target state="translated">динамический тип объекта,</target>
        </trans-unit>
        <trans-unit id="5c8205de1a0f5881a6eef3facb06094c46436ace" translate="yes" xml:space="preserve">
          <source>tis-interpeter is able to catch all three, the following example invokes tis-kernal as tis-interpreter (output is edited for brevity):</source>
          <target state="translated">tis-интерпретатор способен поймать все три,следующий пример вызывает tis-kernal как tis-интерпретатор (вывод редактируется для краткости):</target>
        </trans-unit>
        <trans-unit id="790926074ddb3f88b6b51d69cef8f57d64c8ee6d" translate="yes" xml:space="preserve">
          <source>we can use &lt;strong&gt;memcpy&lt;/strong&gt;:</source>
          <target state="translated">мы можем использовать &lt;strong&gt;memcpy&lt;/strong&gt; :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
