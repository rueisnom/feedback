<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/98650">
    <body>
      <group id="98650">
        <trans-unit id="8bc9a3751448b75c95d0c09be39874a54d59dbbc" translate="yes" xml:space="preserve">
          <source>&quot;Strict aliasing is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias each other.)&quot;</source>
          <target state="translated">&quot;严格的别名是C(或C++)编译器所做的一个假设,即对不同类型的对象的引申指针永远不会引用到相同的内存位置(即相互别名)。&quot;</target>
        </trans-unit>
        <trans-unit id="7cf3442516aaa5d6749824461a7def10a1b8f03a" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a character type.</source>
          <target state="translated">&amp;mdash;字符类型。</target>
        </trans-unit>
        <trans-unit id="16d9cec79491cede88fd0ddafcbdb33b1a1dc888" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a qualified version of a type compatible with the effective type of the object,</source>
          <target state="translated">&amp;mdash;与对象的有效类型兼容的类型的限定版本，</target>
        </trans-unit>
        <trans-unit id="13d94646e2432e838a724c25f7870cb8f332c869" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,</source>
          <target state="translated">&amp;mdash;一种类型，是与对象的有效类型的限定版本相对应的有符号或无符号类型，</target>
        </trans-unit>
        <trans-unit id="4b87e5428fe7d01a75c7838ed5347266005ed316" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to the effective type of the object,</source>
          <target state="translated">&amp;mdash;一个类型，它是与对象的有效类型相对应的有符号或无符号类型，</target>
        </trans-unit>
        <trans-unit id="62996c58c76d88b909b477d85de32e4c8a0be22f" translate="yes" xml:space="preserve">
          <source>&amp;mdash; an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or</source>
          <target state="translated">&amp;mdash;集合或联合类型，其成员中包括上述类型之一（递归地包括子集合或包含的联合的成员），或</target>
        </trans-unit>
        <trans-unit id="7682f0746a360de4bef474dee1888984c6d26a7c" translate="yes" xml:space="preserve">
          <source>(11.2) &amp;mdash; a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">（11.2）&amp;mdash;对象的动态类型的cv限定版本，</target>
        </trans-unit>
        <trans-unit id="2b7ebc143440433f6bcf7a57744dbff09cce4f85" translate="yes" xml:space="preserve">
          <source>(11.3) &amp;mdash; a type similar (as defined in 7.5) to the dynamic type of the object,</source>
          <target state="translated">（11.3）&amp;mdash;与对象的动态类型类似的类型（定义见7.5），</target>
        </trans-unit>
        <trans-unit id="492220375e27ebfd7903993e017101c0d85ec3e0" translate="yes" xml:space="preserve">
          <source>(11.4) &amp;mdash; a type that is the signed or unsigned type corresponding to the dynamic type of the object,</source>
          <target state="translated">（11.4）&amp;mdash;一种类型，是与对象的动态类型相对应的有符号或无符号类型，</target>
        </trans-unit>
        <trans-unit id="2d718b5cc47d538f62e075e1c68512349385137b" translate="yes" xml:space="preserve">
          <source>(11.5) &amp;mdash; a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">（11.5）&amp;mdash;一种类型，是与对象的动态类型的CV限定版本相对应的有符号或无符号类型，</target>
        </trans-unit>
        <trans-unit id="9dc6ec3bc2c4acd3e7938a177187de9946d3fbac" translate="yes" xml:space="preserve">
          <source>(11.6) &amp;mdash; an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</source>
          <target state="translated">（11.6）&amp;mdash;集合或联合类型，在其元素或非静态数据成员（包括递归地包括子集合或包含的联合的元素或非静态数据成员）中包括上述类型之一，</target>
        </trans-unit>
        <trans-unit id="0833cab4a3d7c43325017982c60dd1a9524db49f" translate="yes" xml:space="preserve">
          <source>(11.7) &amp;mdash; a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</source>
          <target state="translated">（11.7）&amp;mdash;一种类型，它是对象的动态类型的（可能是经过cv限定的）基类类型，</target>
        </trans-unit>
        <trans-unit id="007312b7d7fe81dfd0e93a7cbbe02ace56aa2f12" translate="yes" xml:space="preserve">
          <source>(11.8) &amp;mdash; a char, unsigned char, or std::byte type.</source>
          <target state="translated">（11.8）&amp;mdash; char，unsigned char或std :: byte类型。</target>
        </trans-unit>
        <trans-unit id="a6ae166834f7950f65a4a0e2017c5da76406a59c" translate="yes" xml:space="preserve">
          <source>(GCC appears somewhat inconsistent in its ability to give aliasing warnings, sometimes giving us a friendly warning and sometimes not.)</source>
          <target state="translated">(GCC似乎有些不一致,有时给我们一个友好的警告,有时不给我们一个友好的警告)。</target>
        </trans-unit>
        <trans-unit id="dbb9367a16f124a22e627722082fe38579194d80" translate="yes" xml:space="preserve">
          <source>(save from CPU register to the memory and load from the memory to the CPU register).</source>
          <target state="translated">从CPU寄存器保存到存储器,从存储器加载到CPU寄存器)。</target>
        </trans-unit>
        <trans-unit id="9cc95d274f988057b458e8bbc62596b0bfd62e5a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;This article&lt;/a&gt; should help you understand the issue in full detail.</source>
          <target state="translated">&lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;本文&lt;/a&gt;应帮助您详细了解此问题。</target>
        </trans-unit>
        <trans-unit id="db4e37199ce7a26e530372127092a913fd8e827e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_punning&quot;&gt;Type punning&lt;/a&gt; via pointer casts (as opposed to using a union) is a major example of breaking strict aliasing.</source>
          <target state="translated">通过指针强制&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_punning&quot;&gt;类型&lt;/a&gt;转换（与使用联合相对）是打破严格别名的主要示例。</target>
        </trans-unit>
        <trans-unit id="0f648f766517c522d736c21acf06a661385f3de0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://twitter.com/shafikyaghmour/status/957702383810658304&quot;&gt;gcc/clang has an extension&lt;/a&gt; and &lt;a href=&quot;https://gcc.gnu.org/ml/gcc/2003-10/msg00184.html&quot;&gt;also&lt;/a&gt; that allows assigning &lt;em&gt;unsigned int*&lt;/em&gt; to &lt;em&gt;int*&lt;/em&gt; even though they are not compatible types.</source>
          <target state="translated">&lt;a href=&quot;https://twitter.com/shafikyaghmour/status/957702383810658304&quot;&gt;gcc / clang有一个扩展，&lt;/a&gt;并且即使它们不是兼容类型， &lt;a href=&quot;https://gcc.gnu.org/ml/gcc/2003-10/msg00184.html&quot;&gt;也&lt;/a&gt;允许将&lt;em&gt;unsigned int *&lt;/em&gt;分配给&lt;em&gt;int *&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="01b0f2dd13e6673c4bc6a8d017a4466b2eae23b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;a type similar (as defined in 4.4) to the dynamic type of the object,&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;与对象的动态类型类似的类型（定义见4.4），&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57fbd0f13eb9b51fcea11056b2017576feba86c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Beginner beware&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;初学者当心&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="196bcd48f2a7e66de892eaf11cbe2d9cab7cc750" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11&lt;/strong&gt; and &lt;strong&gt;C++14&lt;/strong&gt; wording (changes emphasized):</source>
          <target state="translated">&lt;strong&gt;C ++ 11&lt;/strong&gt;和&lt;strong&gt;C ++ 14&lt;/strong&gt;措辞（强调更改）：</target>
        </trans-unit>
        <trans-unit id="f83c36172e98a9c03aa145ce635aa0f76fe4904e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For example&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;例如&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="decc5376f183538b5fe7739f22bb8eb4f49596b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So how do I get around this?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;那么我该如何解决呢？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d25be7fbd9e3672275a9ff1b70188a72553da35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;save&lt;/strong&gt;&lt;code&gt;b&lt;/code&gt; and &lt;strong&gt;reload&lt;/strong&gt;&lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;保存&lt;/strong&gt; &lt;code&gt;b&lt;/code&gt; 并&lt;strong&gt;重新加载&lt;/strong&gt; &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b61bc9f66e53d7bd6c6cb170cf39fc609c4079f3" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt; 73) or 88)&lt;/sup&gt; The intent of this list is to specify those circumstances in which an object may or may not be aliased.</source>
          <target state="translated">&lt;sup&gt;73）或88）&lt;/sup&gt;该列表的目的是指定对象可能会别名也可能不会别名的那些情况。</target>
        </trans-unit>
        <trans-unit id="e6cbeecf47c0b79acdf7d07e84cc9b5e6b8e569d" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt; The types that C 2011 6.5 7 allows an lvalue to access are:</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; C 2011 6.5 7允许左值访问的类型为：</target>
        </trans-unit>
        <trans-unit id="297342af50ab471e2b4d57de560278e8dd7b88e6" translate="yes" xml:space="preserve">
          <source>A glvalue is an expression whose evaluation determines the identity of
  an object, (...snip)</source>
          <target state="translated">glvalue是一个表达式,其评价决定了对象的身份,(...snip)</target>
        </trans-unit>
        <trans-unit id="8e98f088bc239e2fa9b5abf6318d366712f8212b" translate="yes" xml:space="preserve">
          <source>A typical situation you encounter strict aliasing problems is when overlaying a struct (like a device/network msg) onto a buffer of the word size of your system (like a pointer to &lt;code&gt;uint32_t&lt;/code&gt;s or &lt;code&gt;uint16_t&lt;/code&gt;s). When you overlay a struct onto such a buffer, or a buffer onto such a struct through pointer casting you can easily violate strict aliasing rules.</source>
          <target state="translated">遇到严格的别名问题的典型情况是，将结构（如设备/网络消息）覆盖在系统字长的缓冲区（如指向 &lt;code&gt;uint32_t&lt;/code&gt; 或 &lt;code&gt;uint16_t&lt;/code&gt; 的指针）上时。 当您将结构叠加到这样的缓冲区上，或者通过指针强制转换将缓冲区叠加到这样的结构上时，您很容易违反严格的别名规则。</target>
        </trans-unit>
        <trans-unit id="a9dc4be413dae8efeb97923c710712f4df67ca23" translate="yes" xml:space="preserve">
          <source>According to the C89 rationale, the authors of the Standard did not want to require that compilers given code like:</source>
          <target state="translated">根据C89的原理,标准的作者不想要求编译器给定的代码像C89这样的代码。</target>
        </trans-unit>
        <trans-unit id="a1e350b0f7d46240fa54c7300839cc8197daad50" translate="yes" xml:space="preserve">
          <source>After reading many of the answers, I feel the need to add something:</source>
          <target state="translated">看了很多答案后,我觉得有必要补充一下。</target>
        </trans-unit>
        <trans-unit id="6ef0f09f189d7f527f3216249c8e7b8d66de7464" translate="yes" xml:space="preserve">
          <source>Also from &lt;a href=&quot;http://eel.is/c++draft/basic.lval#1.1&quot;&gt;the definition of glvalue&lt;/a&gt;</source>
          <target state="translated">同样从&lt;a href=&quot;http://eel.is/c++draft/basic.lval#1.1&quot;&gt;glvalue的定义&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f9a518e55a06337a7d067a77249a742f4d1724e" translate="yes" xml:space="preserve">
          <source>Also the &lt;strong&gt;C&lt;/strong&gt; wording (C99; ISO/IEC 9899:1999 6.5/7; the exact same wording is used in ISO/IEC 9899:2011 &amp;sect;6.5 &amp;para;7):</source>
          <target state="translated">还有&lt;strong&gt;C&lt;/strong&gt;措辞（C99; ISO / IEC 9899：1999 6.5 / 7; ISO / IEC 9899：2011&amp;sect;6.5&amp;para;7使用完全相同的措辞）：</target>
        </trans-unit>
        <trans-unit id="2985fc30fb7352cc194dd6d4058223c195eec0a4" translate="yes" xml:space="preserve">
          <source>Although clang allows these flags it apparently does not actually implement the warnings.</source>
          <target state="translated">虽然Clang允许这些标志,但它显然没有实际执行警告。</target>
        </trans-unit>
        <trans-unit id="26a14dfaa9199838addf36131d31232c359747d1" translate="yes" xml:space="preserve">
          <source>An object shall have its stored value accessed only by an lvalue
  expression that has one of the following types &lt;sup&gt; 73) or 88)&lt;/sup&gt;:</source>
          <target state="translated">对象的存储值只能由具有以下类型&lt;sup&gt;73）或88）&lt;/sup&gt;之一的左值表达式访问：</target>
        </trans-unit>
        <trans-unit id="e89f2c7845b5b0b9f99fb0df9e776bf697055362" translate="yes" xml:space="preserve">
          <source>An object shall have its stored value accessed only by an lvalue expression that has one of the following types:&lt;sup&gt;88)&lt;/sup&gt;
  &amp;mdash; a type compatible with the effective type of the object,</source>
          <target state="translated">一个对象只能通过具有以下类型之一的左值表达式访问其存储值： &lt;sup&gt;88）&lt;/sup&gt; &amp;mdash;与该对象的有效类型兼容的类型，</target>
        </trans-unit>
        <trans-unit id="8d09e17c7fa91deb529a7711698d487fd214027c" translate="yes" xml:space="preserve">
          <source>And rewrote our earlier loop to take advantage of this convenient function</source>
          <target state="translated">并重写了我们之前的循环,以利用这个方便的功能。</target>
        </trans-unit>
        <trans-unit id="0f5d219e3940c12eb3895d8e75d8bb99c681600b" translate="yes" xml:space="preserve">
          <source>Another tool we have available to us is ASan which can catch misaligned loads and stores. Although these are not directly strict aliasing violations they are a common result of strict aliasing violations. For example the following cases will generate runtime errors when built with clang using &lt;strong&gt;-fsanitize=address&lt;/strong&gt;</source>
          <target state="translated">我们提供给我们的另一个工具是ASan，它可以捕获未对齐的负载和存储。 尽管这些不是直接的严格混叠违例，但它们是严格混叠违例的常见结果。 例如，以下情况在使用&lt;strong&gt;-fsanitize = address&lt;/strong&gt;与clang &lt;strong&gt;一起&lt;/strong&gt;构建时会产生运行时错误</target>
        </trans-unit>
        <trans-unit id="c9f941d78e7fc8fb359e7fb4d08c3662e735d087" translate="yes" xml:space="preserve">
          <source>As addendum to what Doug T. already wrote, here
is a simple test case which probably triggers it with gcc :</source>
          <target state="translated">作为对Doug T.已经写过的内容的补充,这里有一个简单的测试案例,可能是用gcc :</target>
        </trans-unit>
        <trans-unit id="10728f2d66e27dcf628afc3fd6a3a60abc38f514" translate="yes" xml:space="preserve">
          <source>As we have seen earlier this is not a valid aliasing, so we are invoking undefined behavior. But traditionally compilers did not take advantage of strict aliasing rules and this type of code usually just worked, developers have unfortunately gotten used to doing things this way. A common alternate method for type punning is through unions, which is valid in C but &lt;em&gt;undefined behavior&lt;/em&gt; in C++ (&lt;a href=&quot;https://wandbox.org/permlink/oOf9bPlcWDYrYqPF&quot;&gt;see live example&lt;/a&gt;):</source>
          <target state="translated">如前所述，这不是有效的别名，因此我们正在调用未定义的行为。 但是传统上，编译器没有利用严格的别名规则，这种类型的代码通常只能工作，不幸的是，开发人员已经习惯了这种方式。 一种类型为punning的常见替代方法是通过联合，该联合在C中有效，但在C ++中为&lt;em&gt;未定义行为&lt;/em&gt; （ &lt;a href=&quot;https://wandbox.org/permlink/oOf9bPlcWDYrYqPF&quot;&gt;请参见实时示例&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="31703841448c40ed3e7edbb4a235ea2f940df90f" translate="yes" xml:space="preserve">
          <source>At a sufficient optimization level any decent modern compiler generates identical code to the previously mentioned &lt;strong&gt;reinterpret_cast&lt;/strong&gt; method or &lt;em&gt;union&lt;/em&gt; method for &lt;em&gt;type punning&lt;/em&gt;. Examining the generated code we see it uses just register mov (&lt;a href=&quot;https://godbolt.org/g/BfZGwX&quot;&gt;live Compiler Explorer Example&lt;/a&gt;).</source>
          <target state="translated">在足够的优化级别上，任何体面的现代编译器都会生成与前面提到的用于&lt;em&gt;punning类型的&lt;/em&gt; &lt;strong&gt;reinterpret_cast&lt;/strong&gt;方法或&lt;em&gt;union&lt;/em&gt;方法相同的代码。 检查生成的代码，我们看到它仅使用了mov（ &lt;a href=&quot;https://godbolt.org/g/BfZGwX&quot;&gt;实时Compiler Explorer示例&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6b40922067f3852129b802e5ea9ad27f2b9e841c" translate="yes" xml:space="preserve">
          <source>C++20 and bit_cast</source>
          <target state="translated">C++20和bit_cast</target>
        </trans-unit>
        <trans-unit id="d0218f26139d8420689d4b0863aae73b36ebb0d3" translate="yes" xml:space="preserve">
          <source>Catching Strict Aliasing Violations</source>
          <target state="translated">捉住严格的别名违规行为</target>
        </trans-unit>
        <trans-unit id="1770c1d3a13b57ff8c334a5bc651892e9928636f" translate="yes" xml:space="preserve">
          <source>Compile with &lt;code&gt;gcc -O2 -o check check.c&lt;/code&gt; .
Usually (with most gcc versions I tried) this outputs &quot;strict aliasing problem&quot;, because the compiler assumes that &quot;h&quot; cannot be the same address as &quot;k&quot; in the &quot;check&quot; function. Because of that the compiler optimizes the &lt;code&gt;if (*h == 5)&lt;/code&gt; away and always calls the printf.</source>
          <target state="translated">用 &lt;code&gt;gcc -O2 -o check check.c&lt;/code&gt; 编译。 通常（我尝试过的大多数gcc版本）都会输出&amp;ldquo;严格的别名问题&amp;rdquo;，因为编译器认为&amp;ldquo; h&amp;rdquo;不能与&amp;ldquo; check&amp;rdquo;函数中的&amp;ldquo; k&amp;rdquo;相同。 因此，编译器优化了 &lt;code&gt;if (*h == 5)&lt;/code&gt; 并始终调用printf。</target>
        </trans-unit>
        <trans-unit id="53c22f9842dfbbfd7ce868f16027320909192af5" translate="yes" xml:space="preserve">
          <source>Defect Report #28 states that the program invokes Undefined Behavior because the action of writing a union member of type &quot;double&quot; and reading one of type &quot;int&quot; invokes Implementation-Defined behavior.  Such reasoning is nonsensical, but forms the basis for the Effective Type rules which needlessly complicate the language while doing nothing to address the original problem.</source>
          <target state="translated">缺陷报告#28指出,程序会调用Undefined Behavior,因为写一个类型为 &quot;double &quot;的联合成员和读一个类型为 &quot;int &quot;的联合成员的动作会调用Implementation-Defined行为。这样的推理是毫无意义的,但却构成了有效类型规则的基础,它不必要地使语言复杂化,而对解决原始问题毫无作用。</target>
        </trans-unit>
        <trans-unit id="7470e0123159d8ce20fb052f5950c0742dcfc961" translate="yes" xml:space="preserve">
          <source>Finally there is &lt;a href=&quot;https://www.youtube.com/watch?v=vAXJeN7k32Y&quot;&gt;TySan&lt;/a&gt; which is currently in development. This sanitizer adds type checking information in a shadow memory segment and checks accesses to see if they violate aliasing rules. The tool potentially should be able to catch all aliasing violations but may have a large run-time overhead.</source>
          <target state="translated">最后是目前正在开发中的&lt;a href=&quot;https://www.youtube.com/watch?v=vAXJeN7k32Y&quot;&gt;TySan&lt;/a&gt; 。 该清理程序在影子内存段中添加类型检查信息，并检查访问是否违反别名规则。 该工具可能应该能够捕获所有混叠违规行为，但可能会有较大的运行时开销。</target>
        </trans-unit>
        <trans-unit id="40e31a210a1913fd0a8b28b892780996d154c70d" translate="yes" xml:space="preserve">
          <source>Footnote</source>
          <target state="translated">Footnote</target>
        </trans-unit>
        <trans-unit id="f2e444e508c3340837f99f92afb5d8d282d725cc" translate="yes" xml:space="preserve">
          <source>For C we have all the tools already covered and we also have tis-interpreter, a static analyzer that exhaustively analyzes a program for a large subset of the C language. Given a C verions of the  earlier example where using &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; misses one case (&lt;a href=&quot;https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY&quot;&gt;see it live&lt;/a&gt;)</source>
          <target state="translated">对于C，我们已经涵盖了所有工具，并且我们还拥有tis解释器，这是一个静态分析器，可以对程序的大部分C语言进行详尽的分析。 给定较早示例的C版本，其中使用&lt;strong&gt;-fstrict-aliasing会遗漏&lt;/strong&gt;一种情况（ &lt;a href=&quot;https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY&quot;&gt;现场直播&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="9ead309bf16c2a5aba6251f6671c48b68c88f5ee" translate="yes" xml:space="preserve">
          <source>For those who are interested here is the x64 assembler code, produced by gcc 4.6.3, running on ubuntu 12.04.2 for x64:</source>
          <target state="translated">对于那些有兴趣的人来说,这里是x64汇编器代码,由gcc 4.6.3生成,运行在ubuntu 12.04.2 for x64上。</target>
        </trans-unit>
        <trans-unit id="eef7c5809b1e5a8ae1c2904d803bf0988e0597e2" translate="yes" xml:space="preserve">
          <source>From the article:</source>
          <target state="translated">从文章中可以看出:</target>
        </trans-unit>
        <trans-unit id="c9937d5f217a938cee9523df51e9f8f215d05426" translate="yes" xml:space="preserve">
          <source>Had Defect Report 028 said the original example invoked UB because of the overlap between the creation and use of the two pointers, that would have made things a lot more clear without having to add &quot;Effective Types&quot; or other such complexity.</source>
          <target state="translated">如果缺陷报告028说原来的例子因为创建和使用这两个指针的重叠而调用了UB,那就会让事情变得更加清晰,而不需要再加上 &quot;有效类型 &quot;或其他这样的复杂内容。</target>
        </trans-unit>
        <trans-unit id="cacd74e6fcf654b36a1d1e2975d8c5a7ad506007" translate="yes" xml:space="preserve">
          <source>Here, there is an aliasing conflict between &lt;code&gt;p&lt;/code&gt; and the access to &lt;code&gt;s.x&lt;/code&gt; on the marked line because at that point in execution another reference exists &lt;em&gt;that will be used to access the same storage&lt;/em&gt;.</source>
          <target state="translated">此处，在 &lt;code&gt;p&lt;/code&gt; 和标记行上对 &lt;code&gt;s.x&lt;/code&gt; 的访问之间存在别名冲突，因为在执行该点时，存在另一个引用， &lt;em&gt;该&lt;/em&gt;引用&lt;em&gt;将用于访问同一存储&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="33dc7f4dd2ec6bc77310a0b059a423d8f65352d8" translate="yes" xml:space="preserve">
          <source>How do we Type Pun correctly?</source>
          <target state="translated">我们如何正确地打出Pun字?</target>
        </trans-unit>
        <trans-unit id="4e0983c0e8fab722fa11f33077148a6fa369c40d" translate="yes" xml:space="preserve">
          <source>If a compiler notices that two pointers point to different types (for example, an &lt;code&gt;int *&lt;/code&gt; and a &lt;code&gt;float *&lt;/code&gt;), it will assume the memory address is different and it &lt;strong&gt;will not&lt;/strong&gt; protect against memory address collisions, resulting in faster machine code.</source>
          <target state="translated">如果编译器注意到两个指针指向不同的类型（例如， &lt;code&gt;int *&lt;/code&gt; 和 &lt;code&gt;float *&lt;/code&gt; ），则它将假定内存地址不同，并且&lt;strong&gt;无法&lt;/strong&gt;防止内存地址冲突，从而导致更快的机器代码。</target>
        </trans-unit>
        <trans-unit id="e33bcaeae41be78c102c11d9ce6bff1ab9700bea" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through a &lt;em&gt;glvalue&lt;/em&gt; of other than one of the following types the behavior is undefined:</source>
          <target state="translated">如果程序尝试通过以下类型之一以外的&lt;em&gt;glvalue&lt;/em&gt;访问对象的存储值，则行为未定义：</target>
        </trans-unit>
        <trans-unit id="a1ad9d68fd05386372885ebe000df27028379d8d" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:&lt;sup&gt;63&lt;/sup&gt;
  (11.1) &amp;mdash; the dynamic type of the object,</source>
          <target state="translated">如果程序尝试通过除以下类型之一之外的glvalue来访问对象的存储值，则行为未定义： &lt;sup&gt;63&lt;/sup&gt; （11.1）-对象的动态类型，</target>
        </trans-unit>
        <trans-unit id="186894b2031b450693c2e08ce7146e1a9f218d92" translate="yes" xml:space="preserve">
          <source>If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined:</source>
          <target state="translated">如果程序试图通过以下类型以外的l值访问对象的存储值,则该行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="c58ff6992c8aa3747c4710bda431e84ee2b32d03" translate="yes" xml:space="preserve">
          <source>If data in two different CPU registers will be written to the same memory space, &lt;strong&gt;we can't predict which data will &quot;survive&quot;&lt;/strong&gt; when we code in C.</source>
          <target state="translated">如果将两个不同的CPU寄存器中的数据写入相同的内存空间， &lt;strong&gt;那么&lt;/strong&gt;当我们用C编写代码时， &lt;strong&gt;我们无法预测哪些数据将&amp;ldquo;存活&amp;rdquo;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a0013265978c8a291d1a659ebe89febc56bb358" translate="yes" xml:space="preserve">
          <source>If the code were changed slightly...</source>
          <target state="translated">如果代码稍作改动.....</target>
        </trans-unit>
        <trans-unit id="0b4c6074b02b2e16ccba9dd1023db8c912e4726d" translate="yes" xml:space="preserve">
          <source>In C and C++ aliasing has to do with what expression types we are allowed to access stored values through. In both C and C++ the standard specifies which expression types are allowed to alias which types. The compiler and optimizer are allowed to assume we follow the aliasing rules strictly, hence the term &lt;em&gt;strict aliasing rule&lt;/em&gt;. If we attempt to access a value using a type not allowed it is classified as &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/ub&quot;&gt;undefined behavior&lt;/a&gt;(&lt;strong&gt;UB&lt;/strong&gt;). Once we have undefined behavior all bets are off, the results of our program are no longer reliable.</source>
          <target state="translated">在C和C ++中，别名与允许我们通过哪些表达式类型访问存储的值有关。 在C和C ++中，标准均指定允许使用哪种表达式类型作为别名的别名。 允许编译器和优化器假定我们严格遵循别名规则，因此，术语&amp;ldquo; &lt;em&gt;严格别名规则&amp;rdquo;&lt;/em&gt; 。 如果我们尝试使用不允许的类型访问值，则将其分类为&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/ub&quot;&gt;未定义行为&lt;/a&gt; （ &lt;strong&gt;UB&lt;/strong&gt; ）。 一旦我们具有不确定的行为，所有的赌注都将关闭，我们的程序结果将不再可靠。</target>
        </trans-unit>
        <trans-unit id="5c8e94cbd15bdd54a4fb204f2d1514b6f794ce32" translate="yes" xml:space="preserve">
          <source>In C++20 we may gain &lt;strong&gt;bit_cast&lt;/strong&gt; (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html&quot;&gt;implementation available in link from proposal&lt;/a&gt;) which gives a simple and safe way to type-pun as well as being usable in a constexpr context.</source>
          <target state="translated">在C ++ 20中，我们可能会获得&lt;strong&gt;bit_cast&lt;/strong&gt; （ &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html&quot;&gt;在proposal的链接中可用的实现&lt;/a&gt; ），该类型提供了一种简单且安全的方法来进行pun-pun操作，并可以在constexpr上下文中使用。</target>
        </trans-unit>
        <trans-unit id="30d64c522aac604d7e48c4556b8d77b5be2eeb6e" translate="yes" xml:space="preserve">
          <source>In assembly, where we code the loading and unloading of CPU registers manually, we will know which data remains intact. But C (thankfully) abstracts this detail away.</source>
          <target state="translated">在汇编中,当我们手动编码加载和卸载CPU寄存器的时候,我们就会知道哪些数据是完整的。但是C语言(幸好)把这个细节抽象出来了。</target>
        </trans-unit>
        <trans-unit id="1098f88dd457b5be2f2059df57bcf4338d706f24" translate="yes" xml:space="preserve">
          <source>In fact, by adding the &lt;code&gt;restrict&lt;/code&gt; keyword, the whole function could be optimized to:</source>
          <target state="translated">实际上，通过添加 &lt;code&gt;restrict&lt;/code&gt; 关键字，可以将整个功能优化为：</target>
        </trans-unit>
        <trans-unit id="f5757f1784e296249565c7c4929c37f6183ec27c" translate="yes" xml:space="preserve">
          <source>In order to handle the case in which &lt;code&gt;a == b&lt;/code&gt; (both pointers point to the same memory), we need to order and test the way we load data from the memory to the CPU registers, so the code might end up like this:</source>
          <target state="translated">为了处理 &lt;code&gt;a == b&lt;/code&gt; （两个指针都指向同一个内存）的情况，我们需要排序并测试将数据从内存加载到CPU寄存器的方式，因此代码可能会像这样结束：</target>
        </trans-unit>
        <trans-unit id="edbd3b6b40a8cde551f4ffba070d64d6c6313a52" translate="yes" xml:space="preserve">
          <source>In the case where &lt;em&gt;To&lt;/em&gt; and &lt;em&gt;From&lt;/em&gt; types don't have the same size, it requires us to use an intermediate struct15. We will use a struct containing a &lt;strong&gt;sizeof( unsigned int )&lt;/strong&gt; character array (&lt;em&gt;assumes 4 byte unsigned int&lt;/em&gt;) to be the &lt;em&gt;From&lt;/em&gt; type and &lt;em&gt;unsigned int&lt;/em&gt; as the &lt;em&gt;To&lt;/em&gt; type.:</source>
          <target state="translated">如果&lt;em&gt;To&lt;/em&gt;和&lt;em&gt;From&lt;/em&gt;类型的大小不同，则需要我们使用中间struct15。 我们将使用一个包含&lt;strong&gt;sizeof（unsigned int）&lt;/strong&gt;字符数组的结构（ &lt;em&gt;假定4字节unsigned int&lt;/em&gt; ）作为&lt;em&gt;From&lt;/em&gt;类型，而&lt;em&gt;unsigned int&lt;/em&gt;作为&lt;em&gt;To&lt;/em&gt;类型。</target>
        </trans-unit>
        <trans-unit id="d116eeee6f567bfeb6ee6948778e1441846b7681" translate="yes" xml:space="preserve">
          <source>In the function &lt;strong&gt;foo&lt;/strong&gt; we take an &lt;em&gt;int*&lt;/em&gt; and a &lt;em&gt;float*&lt;/em&gt;, in this example we call &lt;strong&gt;foo&lt;/strong&gt; and set both parameters to point to the same memory location which in this example contains an &lt;em&gt;int&lt;/em&gt;. Note, the &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; is telling the compiler to treat the the expression as if it had the type specificed by its template parameter. In this case we are telling it to treat the expression &lt;strong&gt;&amp;amp;x&lt;/strong&gt; as if it had type &lt;em&gt;float*&lt;/em&gt;. We may naively expect the result of the second &lt;strong&gt;cout&lt;/strong&gt; to be &lt;strong&gt;0&lt;/strong&gt; but with optimization enabled using &lt;strong&gt;-O2&lt;/strong&gt; both gcc and clang produce the following result:</source>
          <target state="translated">在函数&lt;strong&gt;foo中，&lt;/strong&gt;我们使用&lt;em&gt;int *&lt;/em&gt;和&lt;em&gt;float *&lt;/em&gt; ，在此示例中，我们调用&lt;strong&gt;foo&lt;/strong&gt;并将两个参数设置为指向相同的内存位置，该内存位置在此示例中包含&lt;em&gt;int&lt;/em&gt; 。 注意， &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt;告诉编译器将表达式视为具有其模板参数指定的类型。 在这种情况下，我们告诉它将表达式&lt;strong&gt;＆x&lt;/strong&gt;视为具有&lt;em&gt;float *&lt;/em&gt;类型。 我们可能天真地希望第二个&lt;strong&gt;cout&lt;/strong&gt;的结果为&lt;strong&gt;0，&lt;/strong&gt;但使用&lt;strong&gt;-O2&lt;/strong&gt;启用优化后，gcc和clang都会产生以下结果：</target>
        </trans-unit>
        <trans-unit id="d68abdd18fdbebaf82ef26f4a744ddcd23eee685" translate="yes" xml:space="preserve">
          <source>It is unfortunate that we need this intermediate type but that is the current constraint of &lt;strong&gt;bit_cast&lt;/strong&gt;.</source>
          <target state="translated">不幸的是，我们需要这种中间类型，但这是&lt;strong&gt;bit_cast&lt;/strong&gt;的当前约束。</target>
        </trans-unit>
        <trans-unit id="da92ddda51dcc47ff0f56cb81c8d27a13de9b35f" translate="yes" xml:space="preserve">
          <source>Keep in mind, if you think the example is contrived, this might even happen if you're passing a buffer to another function doing the sending for you, if instead you have.</source>
          <target state="translated">请记住,如果你认为这个例子是虚构的,如果你把一个缓冲区传递给另一个为你做发送工作的函数,甚至可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="aa2a2cd3b185c908c2467f71930ddb0e035406e3" translate="yes" xml:space="preserve">
          <source>Let's look at some examples, then we can talk about exactly what the standard(s) say, examine some further examples and then see how to avoid strict aliasing and catch violations we missed. Here is an example that should not be surprising (&lt;a href=&quot;https://wandbox.org/permlink/7sCJTAyrifZ0zfFA&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">让我们看一些示例，然后我们可以确切讨论标准所说的内容，研究其他示例，然后看看如何避免严格的混叠并捕获我们错过的违规行为。 这是一个不足为奇的&lt;a href=&quot;https://wandbox.org/permlink/7sCJTAyrifZ0zfFA&quot;&gt;示例&lt;/a&gt; （ 实时示例 ）：</target>
        </trans-unit>
        <trans-unit id="036ae8cbf7c3814fcac323366fb44ffbfacfa142" translate="yes" xml:space="preserve">
          <source>Lets assume the following function:</source>
          <target state="translated">让我们假设以下功能:</target>
        </trans-unit>
        <trans-unit id="6866b7efbb6193426e6184afeb038e84825105d8" translate="yes" xml:space="preserve">
          <source>Memory access can be expensive (performance wise), which is why &lt;strong&gt;data is manipulated in CPU registers&lt;/strong&gt; before being written back to the physical memory.</source>
          <target state="translated">内存访问可能很昂贵（从性能角度而言），这就是为什么在将&lt;strong&gt;数据&lt;/strong&gt;写回物理内存之前先&lt;strong&gt;在CPU寄存器中对其&lt;/strong&gt;进行&lt;strong&gt;操作&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="9992043f68467a20f1d79f1ccb74a9265be5e20c" translate="yes" xml:space="preserve">
          <source>Much of the problem is a result of Defect Report #028, which asked about the behavior of a program like:</source>
          <target state="translated">问题的很大一部分是缺陷报告#028的结果,问的是像程序的行为。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="5650248b0b69558ceb303fc582535c5dbae34409" translate="yes" xml:space="preserve">
          <source>Note the definition of indirection (&lt;a href=&quot;http://eel.is/c++draft/expr.unary.op#def:indirection&quot;&gt;* operator&lt;/a&gt;):</source>
          <target state="translated">请注意间接定义（ &lt;a href=&quot;http://eel.is/c++draft/expr.unary.op#def:indirection&quot;&gt;*运算符&lt;/a&gt; ）的定义：</target>
        </trans-unit>
        <trans-unit id="00e406f7a5b6352740c9e91b4d2959a865ade69d" translate="yes" xml:space="preserve">
          <source>Now, by satisfying the Strict Aliasing rule, step 3 can be avoided and the code will run significantly faster.</source>
          <target state="translated">现在,通过满足严格的别名规则,可以避免步骤3,代码的运行速度会明显加快。</target>
        </trans-unit>
        <trans-unit id="24f4a3365263f6701ca3e6f9cc300671fef25d11" translate="yes" xml:space="preserve">
          <source>Now, to the Rule-Book</source>
          <target state="translated">现在说到规则书</target>
        </trans-unit>
        <trans-unit id="00f2110e4b85aedc83fe7286d38033b5fadad084" translate="yes" xml:space="preserve">
          <source>Preliminary examples</source>
          <target state="translated">初步的例子</target>
        </trans-unit>
        <trans-unit id="1a68967890ea62e6416814f2cd9ae705194f7f5a" translate="yes" xml:space="preserve">
          <source>Since two pointers can point to the same location in the memory, this could result in &lt;strong&gt;complex code that handles possible collisions&lt;/strong&gt;.</source>
          <target state="translated">由于两个指针可以指向内存中的同一位置，因此这可能导致&lt;strong&gt;处理可能的冲突的复杂代码&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e831ce62bacf79dafcd6bc9e83656cfee8fb782d" translate="yes" xml:space="preserve">
          <source>So basically if you have an &lt;code&gt;int*&lt;/code&gt; pointing to some memory containing an &lt;code&gt;int&lt;/code&gt; and then you point a &lt;code&gt;float*&lt;/code&gt; to that memory and use it as a &lt;code&gt;float&lt;/code&gt; you break the rule. If your code does not respect this, then the compiler's optimizer will most likely break your code.</source>
          <target state="translated">因此，基本上，如果您有一个 &lt;code&gt;int*&lt;/code&gt; 指向某个包含 &lt;code&gt;int&lt;/code&gt; 的内存，然后将 &lt;code&gt;float*&lt;/code&gt; 指向该内存并将其用作 &lt;code&gt;float&lt;/code&gt; 则会违反规则。 如果您的代码不遵守此规定，则编译器的优化器很可能会破坏您的代码。</target>
        </trans-unit>
        <trans-unit id="e527630d421fb5eeeebbd1a1fc94426badbe336a" translate="yes" xml:space="preserve">
          <source>So in any well defined program trace, a glvalue refers to an object. &lt;strong&gt;So the so called strict aliasing rule doesn't apply, ever.&lt;/strong&gt; This may not be what the designers wanted.</source>
          <target state="translated">因此，在任何定义良好的程序跟踪中，glvalue均指向对象。 &lt;strong&gt;因此，所谓的严格别名规则永远不会适用。&lt;/strong&gt; 这可能不是设计师想要的。</target>
        </trans-unit>
        <trans-unit id="deed8318c0841e594ef317b02788fe411e71c755" translate="yes" xml:space="preserve">
          <source>So in this kind of setup, if I want to send a message to something I'd have to have two incompatible pointers pointing to the same chunk of memory. I might then naively code something like this (on a system with &lt;code&gt;sizeof(int) == 2&lt;/code&gt;):</source>
          <target state="translated">因此，在这种设置中，如果要向某条消息发送消息，则必须有两个不兼容的指针指向同一块内存。 然后，我可能会天真地编写如下代码（在具有 &lt;code&gt;sizeof(int) == 2&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="aafc604e71041d21e6cb4b116236a68fac502d6a" translate="yes" xml:space="preserve">
          <source>So the if condition is completely gone from the assembler code.</source>
          <target state="translated">所以if条件从汇编器代码中完全消失了。</target>
        </trans-unit>
        <trans-unit id="be497017b70114a5fa54de0086695c60b70ce08f" translate="yes" xml:space="preserve">
          <source>Sometimes we want to circumvent the type system and interpret an object as a different type. This is called &lt;em&gt;type punning&lt;/em&gt;, to reinterpret a segment of memory as another type. &lt;em&gt;Type punning&lt;/em&gt; is useful for tasks that want access to the underlying representation of an object to view, transport or manipulate. Typical areas we find type punning being used are compilers, serialization, networking code, etc&amp;hellip;</source>
          <target state="translated">有时我们想绕过类型系统，并将对象解释为其他类型。 这称为&lt;em&gt;type punning&lt;/em&gt; ，用于将内存段重新解释为另一种类型。 对于需要访问对象的基础表示形式以进行查看，运输或操作的任务， &lt;em&gt;类型修剪&lt;/em&gt;非常有用。 我们发现使用的类型修剪的典型领域是编译器，序列化，网络代码等。</target>
        </trans-unit>
        <trans-unit id="0e41cb1a9e14feeabe231350d4a98b43b5438b1e" translate="yes" xml:space="preserve">
          <source>Step 3 is very slow because it needs to access the physical memory. However, it's required to protect against instances where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; point to the same memory address.</source>
          <target state="translated">步骤3非常慢，因为它需要访问物理内存。 但是，需要防止 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 指向相同内存地址的实例。</target>
        </trans-unit>
        <trans-unit id="6950bbb2a5fc815374e2b4c9fe07f848dcde484e" translate="yes" xml:space="preserve">
          <source>Strict aliasing (which I'll describe in a bit) &lt;strong&gt;is important because&lt;/strong&gt;:</source>
          <target state="translated">严格的别名（稍后将描述） &lt;strong&gt;很重要，因为&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="7b097276866172c8f0649d49560868d6d4cb3def" translate="yes" xml:space="preserve">
          <source>Strict aliasing doesn't refer only to pointers, it affects references as well, I wrote a paper about it for the boost developer wiki and it was so well received that I turned it into a page on my consulting web site.  It explains completely what it is, why it confuses people so much and what to do about it. &lt;a href=&quot;http://dbp-consulting.com/tutorials/StrictAliasing.html&quot;&gt;Strict Aliasing White Paper&lt;/a&gt;.  In particular it explains why unions are risky behavior for C++, and why using memcpy is the only fix portable across both C and C++.  Hope this is helpful.</source>
          <target state="translated">严格的别名不仅指指针，还影响引用，我为boost开发人员Wiki撰写了一篇有关它的论文，并且受到广泛好评，以至于我将其变成了我的咨询网站上的一个页面。 它完全解释了它是什么，为什么使人们如此困惑以及如何处理。 &lt;a href=&quot;http://dbp-consulting.com/tutorials/StrictAliasing.html&quot;&gt;严格的别名白皮书&lt;/a&gt; 。 特别是，它解释了为什么工会是C ++的危险行为，以及为什么使用memcpy是跨C和C ++的唯一可移植修订。 希望这会有所帮助。</target>
        </trans-unit>
        <trans-unit id="ed51e87442d0b7d44562385cb2eaa5830e3da786" translate="yes" xml:space="preserve">
          <source>Strict aliasing is not allowing different pointer types to the same data.</source>
          <target state="translated">严格的别名是不允许对同一数据有不同的指针类型。</target>
        </trans-unit>
        <trans-unit id="08f4008712546a2f35d451915a75c5ce6707541f" translate="yes" xml:space="preserve">
          <source>Strict aliasing would allow us to prevent this by telling the compiler that these memory addresses are distinctly different (which, in this case, will allow even further optimization which can't be performed if the pointers share a memory address).</source>
          <target state="translated">严格的别名将允许我们通过告诉编译器这些内存地址是明显不同的(在这种情况下,如果指针共享一个内存地址,将允许进一步的优化,而如果指针共享一个内存地址,则无法进行进一步的优化)来防止这种情况的发生。</target>
        </trans-unit>
        <trans-unit id="3de059986d55a4c9204e0422ce6405ee0f2fae76" translate="yes" xml:space="preserve">
          <source>Technically in C++, the strict aliasing rule is probably never applicable.</source>
          <target state="translated">技术上,在C++中,严格的别名规则可能永远不适用。</target>
        </trans-unit>
        <trans-unit id="907bce6add949792da1d5d77350df907126f6c70" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;C11&lt;/strong&gt; standard says the following in section &lt;em&gt;6.5 Expressions paragraph 7&lt;/em&gt;:</source>
          <target state="translated">&lt;strong&gt;C11&lt;/strong&gt;标准在&lt;em&gt;6.5表达式第7&lt;/em&gt;段中指出以下内容：</target>
        </trans-unit>
        <trans-unit id="bfd25f24e236cc975bc1fefb913df995d3049915" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Strict aliasing rule allows us to avoid redundant machine code&lt;/strong&gt; in cases in which it &lt;em&gt;should be&lt;/em&gt; safe to assume that two pointers don't point to the same memory block (see also the &lt;code&gt;restrict&lt;/code&gt; keyword).</source>
          <target state="translated">&lt;strong&gt;严格的别名规则使我们可以避免冗余的机器代码&lt;/strong&gt; ，在这种情况下， &lt;em&gt;可以&lt;/em&gt;安全地假设两个指针没有指向同一个内存块（另请参见&lt;strong&gt;strict&lt;/strong&gt;关键字）。</target>
        </trans-unit>
        <trans-unit id="8c06897729db17629b567058f47bdaf4c4318b26" translate="yes" xml:space="preserve">
          <source>The C++17 draft standard in section &lt;em&gt;[basic.lval] paragraph 11&lt;/em&gt; says:</source>
          <target state="translated">&lt;em&gt;[basic.lval]第11段中&lt;/em&gt;的C ++ 17标准草案说：</target>
        </trans-unit>
        <trans-unit id="9bc4e143126dccfdfaa1a458c40e03e32eb19eb7" translate="yes" xml:space="preserve">
          <source>The Strict aliasing states it's safe to assume that pointers to different types point to different locations in the memory.</source>
          <target state="translated">严格的别名规定,可以安全地认为不同类型的指针指向内存中的不同位置。</target>
        </trans-unit>
        <trans-unit id="7928780bf9e4496f92d12638d4fa464749948340" translate="yes" xml:space="preserve">
          <source>The best explanation I have found is by Mike Acton, &lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;Understanding Strict Aliasing&lt;/a&gt;. It's focused a little on PS3 development, but that's basically just GCC.</source>
          <target state="translated">我发现的最好的解释是Mike Acton的《 &lt;a href=&quot;http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html&quot;&gt;理解严格的别名》&lt;/a&gt; 。 它只专注于PS3开发，但这基本上只是GCC。</target>
        </trans-unit>
        <trans-unit id="49c47e96747dd9ea774b5bc163ec15c244b5f868" translate="yes" xml:space="preserve">
          <source>The best way to resolve the original problem would probably be to treat the
footnote about the purpose of the rule as though it were normative, and made
the rule unenforceable except in cases which actually involve conflicting accesses using aliases.  Given something like:</source>
          <target state="translated">解决原始问题的最好办法可能是把关于该规则目的的脚注当作规范性的,并使该规则无法执行,除非在实际使用别名的访问发生冲突的情况下,否则该规则无法执行。鉴于这样的情况:</target>
        </trans-unit>
        <trans-unit id="85b689b0761df13dcd7da661f9fdf03565c0a4a1" translate="yes" xml:space="preserve">
          <source>The compiler may or may not be able to or smart enough to try to inline SendMessage and it may or may not decide to load or not load buff again. If &lt;code&gt;SendMessage&lt;/code&gt; is part of another API that's compiled separately, it probably has instructions to load buff's contents. Then again, maybe you're in C++ and this is some templated header only implementation that the compiler thinks it can inline. Or maybe it's just something you wrote in your .c file for your own convenience. Anyway undefined behavior might still ensue. Even when we know some of what's happening under the hood, it's still a violation of the rule so no well defined behavior is guaranteed. So just by wrapping in a function that takes our word delimited buffer doesn't necessarily help.</source>
          <target state="translated">编译器可能会或可能不会或足够聪明以尝试内联SendMessage，并且它可能会或可能不会决定再次加载或不加载buff。 如果 &lt;code&gt;SendMessage&lt;/code&gt; 是另一个单独编译的API的一部分，则它可能具有加载buff内容的说明。 再说一遍，也许您使用的是C ++，这是编译器认为可以内联的仅模板头实现。 也许这只是您为了自己的方便而在.c文件中编写的内容。 无论如何，仍可能会发生未定义的行为。 即使我们知道幕后发生的事情，也仍然违反规则，因此无法保证定义明确的行为。 因此，仅通过包装一个使用我们的单词分隔缓冲区的函数并不一定会有所帮助。</target>
        </trans-unit>
        <trans-unit id="185da178ba74f21fd6fbee6fc9a19c180251420b" translate="yes" xml:space="preserve">
          <source>The exception to the rule is a &lt;code&gt;char*&lt;/code&gt;, which is allowed to point to any type.</source>
          <target state="translated">该规则的例外是 &lt;code&gt;char*&lt;/code&gt; ，它可以指向任何类型。</target>
        </trans-unit>
        <trans-unit id="e6deb33976faa98a7a8b3f350b9d49c319c195cd" translate="yes" xml:space="preserve">
          <source>The following is an example of how to use &lt;strong&gt;bit_cast&lt;/strong&gt; to type pun a &lt;em&gt;unsigned int&lt;/em&gt; to &lt;em&gt;float&lt;/em&gt;, (&lt;a href=&quot;https://wandbox.org/permlink/i5l0g4IYuCFgLzzl&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">以下是如何使用&lt;strong&gt;bit_cast&lt;/strong&gt;将pun &lt;em&gt;无符号int&lt;/em&gt;类型为pun进行&lt;em&gt;浮动&lt;/em&gt;的示例（ &lt;a href=&quot;https://wandbox.org/permlink/i5l0g4IYuCFgLzzl&quot;&gt;请现场观看&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="bc2fdca487b4e3f2274bf45676f76859149d4991" translate="yes" xml:space="preserve">
          <source>The last tool I will recommend is C++ specific and not strictly a tool but a coding practice, don't allow C-style casts. Both gcc and clang will produce a diagnostic for C-style casts using &lt;strong&gt;-Wold-style-cast&lt;/strong&gt;. This will force any undefined type puns to use reinterpret_cast, in general reinterpret_cast should be a flag for closer code review. It is also easier to search your code base for reinterpret_cast to perform an audit.</source>
          <target state="translated">我将推荐的最后一个工具是C ++特定的，而不是严格的工具，而是编码实践，不允许C样式转换。 gcc和clang都将使用&lt;strong&gt;-Wold-style-cast&lt;/strong&gt;为C样式转换生成诊断。 这将强制所有未定义类型的双关语使用reinterpret_cast，通常rerefly_cast应该是进行更仔细代码审查的标志。 在代码库中搜索reinterpret_cast来执行审核也更加容易。</target>
        </trans-unit>
        <trans-unit id="d6426a86b973a6cec74fb415633b300e0a37c506" translate="yes" xml:space="preserve">
          <source>The next example shows aliasing that leads to undefined behavior (&lt;a href=&quot;https://wandbox.org/permlink/8qA8JyJRVHtS9LPf&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">下一个示例显示了导致未定义行为的别名（ &lt;a href=&quot;https://wandbox.org/permlink/8qA8JyJRVHtS9LPf&quot;&gt;实时示例&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="5e5d6deec660f2c03a74983d7e1f704f0a612063" translate="yes" xml:space="preserve">
          <source>The optimizer using &lt;a href=&quot;http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm&quot;&gt;Type-Based Alias Analysis (TBAA)&lt;/a&gt; assumes &lt;strong&gt;1&lt;/strong&gt; will be returned and directly moves the constant value into register &lt;strong&gt;eax&lt;/strong&gt; which carries the return value. TBAA uses the languages rules about what types are allowed to alias to optimize loads and stores. In this case TBAA knows that a &lt;em&gt;float&lt;/em&gt; can not alias and &lt;em&gt;int&lt;/em&gt; and optimizes away the load of &lt;strong&gt;i&lt;/strong&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm&quot;&gt;基于类型的别名分析（TBAA）&lt;/a&gt;的优化器假定将返回&lt;strong&gt;1，&lt;/strong&gt;并将常数直接移到带有返回值的寄存器&lt;strong&gt;eax&lt;/strong&gt;中。 TBAA使用关于允许使用哪种类型的别名的语言规则来优化负载和存储。 在这种情况下，TBAA知道&lt;em&gt;float&lt;/em&gt;不能别名和&lt;em&gt;int&lt;/em&gt;并优化了&lt;strong&gt;i&lt;/strong&gt;的负载。</target>
        </trans-unit>
        <trans-unit id="eb988ee6dabc3ef8446376c66441177c2cd532a0" translate="yes" xml:space="preserve">
          <source>The standard method for &lt;em&gt;type punning&lt;/em&gt; in both C and C++ is &lt;strong&gt;memcpy&lt;/strong&gt;. This may seem a little heavy handed but the optimizer should recognize the use of &lt;strong&gt;memcpy&lt;/strong&gt; for &lt;em&gt;type punning&lt;/em&gt; and optimize it away and generate a register to register move. For example if we know &lt;em&gt;int64_t&lt;/em&gt; is the same size as &lt;em&gt;double&lt;/em&gt;:</source>
          <target state="translated">在C和C ++中进行&lt;em&gt;类型修剪&lt;/em&gt;的标准方法是&lt;strong&gt;memcpy&lt;/strong&gt; 。 这看起来似乎有点费劲，但是优化器应该认识到使用&lt;strong&gt;memcpy&lt;/strong&gt;进行&lt;em&gt;类型修剪&lt;/em&gt;并对其进行优化，并生成一个寄存器来记录移动。 例如，如果我们知道&lt;em&gt;int64_t&lt;/em&gt;与&lt;em&gt;double&lt;/em&gt;大小相同：</target>
        </trans-unit>
        <trans-unit id="08b2135b25032781b64ff4c52a4bdd14662d43d7" translate="yes" xml:space="preserve">
          <source>The strict aliasing rule makes this setup illegal: dereferencing a pointer that aliases an object that is not of a &lt;a href=&quot;http://en.cppreference.com/w/c/language/type&quot;&gt;compatible type&lt;/a&gt; or one of the other types allowed by C 2011 6.5 paragraph 7&lt;sup&gt;1&lt;/sup&gt; is undefined behavior. Unfortunately, you can still code this way, &lt;em&gt;maybe&lt;/em&gt; get some warnings, have it compile fine, only to have weird unexpected behavior when you run the code.</source>
          <target state="translated">严格的别名规则使该设置非法：取消引用对不具有&lt;a href=&quot;http://en.cppreference.com/w/c/language/type&quot;&gt;兼容类型&lt;/a&gt;或C 2011 6.5第7 &lt;sup&gt;1&lt;/sup&gt;段所允许的其他类型之一的对象进行别名的指针是未定义的行为。 不幸的是，您仍然可以通过这种方式进行编码， &lt;em&gt;也许&lt;/em&gt;会得到一些警告，可以很好地进行编译，但是在运行代码时却只有怪异的意外行为。</target>
        </trans-unit>
        <trans-unit id="bd0246c8dec2dd6e8cc0d773260f9ddcf056333b" translate="yes" xml:space="preserve">
          <source>The third change makes a stronger guarantee (relaxes the strong aliasing rule): The new concept of &lt;em&gt;similar types&lt;/em&gt; that are now safe to alias.</source>
          <target state="translated">第三个更改提供了更强的保证（放松了强大的别名规则）：现在可以安全别名的&lt;em&gt;类似类型&lt;/em&gt;的新概念。</target>
        </trans-unit>
        <trans-unit id="428a7cf24521c1266f3851b503c14cb107e579a2" translate="yes" xml:space="preserve">
          <source>The unary * operator performs indirection: the expression to which it
  is applied shall be a pointer to an object type, or a pointer to a
  function type and &lt;strong&gt;the result is an lvalue referring to the object&lt;/strong&gt; or
  function &lt;strong&gt;to which the expression points&lt;/strong&gt;.</source>
          <target state="translated">一元*运算符执行间接操作：应用该表达式的表达式应该是指向对象类型的指针，或者是指向函数类型的指针，并且&lt;strong&gt;结果是指向&lt;/strong&gt; &lt;strong&gt;表达式所指向&lt;/strong&gt; &lt;strong&gt;的对象&lt;/strong&gt;或函数&lt;strong&gt;的左值&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3edc398608fb9b543cd714f6b95b268072cc297" translate="yes" xml:space="preserve">
          <source>There's no conflict within &lt;code&gt;inc_int&lt;/code&gt; because all accesses to the storage accessed through &lt;code&gt;*p&lt;/code&gt; are done with an lvalue of type &lt;code&gt;int&lt;/code&gt;, and there's no conflict in &lt;code&gt;test&lt;/code&gt; because &lt;code&gt;p&lt;/code&gt; is visibly derived from a &lt;code&gt;struct S&lt;/code&gt;, and by the next time &lt;code&gt;s&lt;/code&gt; is used, all accesses to that storage that will ever be made through &lt;code&gt;p&lt;/code&gt; will have already happened.</source>
          <target state="translated">在 &lt;code&gt;inc_int&lt;/code&gt; 中没有冲突，因为对所有通过 &lt;code&gt;*p&lt;/code&gt; 访问的存储的访问都是使用 &lt;code&gt;int&lt;/code&gt; 类型的lvalue完成的，并且在 &lt;code&gt;test&lt;/code&gt; 也没有冲突，因为 &lt;code&gt;p&lt;/code&gt; 显然是从 &lt;code&gt;struct S&lt;/code&gt; 派生的，并且在下次使用 &lt;code&gt;s&lt;/code&gt; 时 ，所有通过 &lt;code&gt;p&lt;/code&gt; 进行对该存储的访问已经发生。</target>
        </trans-unit>
        <trans-unit id="1e47063a12afd4868e46be1f29d48214f059315d" translate="yes" xml:space="preserve">
          <source>This can be told to the compiler in two ways, by using different types to point to. i.e.:</source>
          <target state="translated">这可以通过两种方式告诉编译器,用不同的类型来指向,即。</target>
        </trans-unit>
        <trans-unit id="6f8c42e0f055d24e57ba0b97836be0b7abeb6542" translate="yes" xml:space="preserve">
          <source>This extra code is slow and &lt;strong&gt;hurts performance&lt;/strong&gt; since it performs extra memory read / write operations which are both slower and (possibly) unnecessary.</source>
          <target state="translated">这种额外的代码很慢，并且&lt;strong&gt;会降低性能，&lt;/strong&gt;因为它会执行额外的内存读/写操作，这既慢又（可能）不必要。</target>
        </trans-unit>
        <trans-unit id="03bd20f42d11715386a09efa404ec49187a334ec" translate="yes" xml:space="preserve">
          <source>This is excerpted from my &lt;a href=&quot;https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8&quot;&gt;&quot;What is the Strict Aliasing Rule and Why do we care?&quot;&lt;/a&gt; write-up.</source>
          <target state="translated">这摘自我的&lt;a href=&quot;https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8&quot;&gt;&amp;ldquo;严格的混叠规则是什么，我们为什么要关心？&amp;rdquo;&lt;/a&gt; 写上去。</target>
        </trans-unit>
        <trans-unit id="23f8f6c33332ebb487428148aeaa250e333c0297" translate="yes" xml:space="preserve">
          <source>This is not valid in C++ and some consider the purpose of unions to be solely for implementing variant types and feel using unions for type punning is an abuse.</source>
          <target state="translated">这在C++中是不成立的,有些人认为unions的目的仅仅是为了实现变异类型,觉得用unions来进行类型惩罚是一种滥用。</target>
        </trans-unit>
        <trans-unit id="b5a81d05fa60ca66493d7a8dd3adf9606ece3212" translate="yes" xml:space="preserve">
          <source>This is only one potential minefield when overlaying two types onto each other. You should also learn about &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;endianness&lt;/a&gt;, &lt;a href=&quot;http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html&quot;&gt;word alignment&lt;/a&gt;, and how to deal with alignment issues through &lt;a href=&quot;http://grok2.com/structure_packing.html&quot;&gt;packing structs&lt;/a&gt; correctly.</source>
          <target state="translated">当两种类型彼此叠加时，这只是一个潜在的雷区。 您还应该了解&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;字节序&lt;/a&gt; ， &lt;a href=&quot;http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html&quot;&gt;单词对齐&lt;/a&gt;以及如何通过正确&lt;a href=&quot;http://grok2.com/structure_packing.html&quot;&gt;打包结构&lt;/a&gt;来处理对齐问题。</target>
        </trans-unit>
        <trans-unit id="1206246dfe34c612a18075c8bf78ec4ea7f41bed" translate="yes" xml:space="preserve">
          <source>This is the strict aliasing rule, found in section 3.10 of the &lt;strong&gt;C++03&lt;/strong&gt; standard (other answers provide good explanation, but none provided the rule itself):</source>
          <target state="translated">这是严格的别名规则，可在&lt;strong&gt;C ++ 03&lt;/strong&gt;标准的3.10节中找到（其他答案提供了很好的解释，但没有一个提供规则本身）：</target>
        </trans-unit>
        <trans-unit id="136cb4ca2af68d11d5c37a73bdbfaeaff7fafa9a" translate="yes" xml:space="preserve">
          <source>This optimization couldn't have been done before, because of the possible collision (where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; would be tripled instead of doubled).</source>
          <target state="translated">由于可能会发生冲突（其中 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 将变为三倍而不是两倍），因此之前无法完成此优化。</target>
        </trans-unit>
        <trans-unit id="0c6e49d370e8ee32d1f9fb66865bb3dc534b3fdf" translate="yes" xml:space="preserve">
          <source>To see why this behavior is undefined, we have to think about what the strict aliasing rule buys the compiler. Basically, with this rule, it doesn't have to think about inserting instructions to refresh the contents of &lt;code&gt;buff&lt;/code&gt; every run of the loop. Instead, when optimizing, with some annoyingly unenforced assumptions about aliasing, it can omit those instructions, load &lt;code&gt;buff[0]&lt;/code&gt; and &lt;code&gt;buff[1&lt;/code&gt;] into CPU registers once before the loop is run, and speed up the body of the loop. Before strict aliasing was introduced, the compiler had to live in a state of paranoia that the contents of &lt;code&gt;buff&lt;/code&gt; could change at anytime from anywhere by anybody. So to get an extra performance edge, and assuming most people don't type-pun pointers, the strict aliasing rule was introduced.</source>
          <target state="translated">要了解为什么未定义此行为，我们必须考虑严格的别名规则会给编译器带来什么。 基本上，使用此规则，不必考虑在每次循环运行时插入指令来刷新 &lt;code&gt;buff&lt;/code&gt; 的内容。 取而代之的是，在进行优化时，可以使用一些令人讨厌的关于别名的非强制性假设，它可以忽略这些指令，在循环运行之前将 &lt;code&gt;buff[0]&lt;/code&gt; 和 &lt;code&gt;buff[1&lt;/code&gt; ]加载到CPU寄存器中一次，并加快循环的执行速度。 在引入严格的别名之前，编译器必须处于偏执状态， &lt;code&gt;buff&lt;/code&gt; 的内容可能随时随地由任何人更改。 因此，为了获得额外的性能优势，并假设大多数人不键入双关型指针，便引入了严格的别名规则。</target>
        </trans-unit>
        <trans-unit id="2cca1ba7b02e14ee263ba59cb168d4ba464a31b0" translate="yes" xml:space="preserve">
          <source>To understand more about why we care, we will discuss issues that come up when violating strict aliasing rules, type punning since common techniques used in type punning often violate strict aliasing rules and how to type pun correctly.</source>
          <target state="translated">为了进一步了解我们为什么要关心这个问题,我们将讨论违反严格的别名规则的时候会出现的问题,字体打点,因为在字体打点中常用的技巧经常会违反严格的别名规则,以及如何正确地打点字体。</target>
        </trans-unit>
        <trans-unit id="e92874def1c707e293c92fd2c84a024426689bc4" translate="yes" xml:space="preserve">
          <source>Traditionally this has been accomplished by taking the address of the object, casting it to a pointer of the type we want to reinterpret it as and then accessing the value, or in other words by aliasing. For example:</source>
          <target state="translated">传统上是通过获取对象的地址,将其铸造为我们想要重新解释的类型的指针,然后访问该值,或者换句话说,通过别名来实现。比如说</target>
        </trans-unit>
        <trans-unit id="edef09f47c7522a6bf38ab921e88dc728d2d2210" translate="yes" xml:space="preserve">
          <source>Two changes were small: &lt;em&gt;glvalue&lt;/em&gt; instead of &lt;em&gt;lvalue&lt;/em&gt;, and clarification of the aggregate/union case.</source>
          <target state="translated">有两个很小的变化： &lt;em&gt;glvalue&lt;/em&gt;代替了&lt;em&gt;lvalue&lt;/em&gt; ，并且澄清了聚集/联合的情况。</target>
        </trans-unit>
        <trans-unit id="0200f9824ad4e7d323fbd799151680bd20557e5c" translate="yes" xml:space="preserve">
          <source>Unfortunately with strict aliasing violations, we will often obtain the results we expect, leaving the possibility the a future version of a compiler with a new optimization will break code we thought was valid. This is undesirable and it is a worthwhile goal to understand the strict aliasing rules and how to avoid violating them.</source>
          <target state="translated">不幸的是,在违反严格别名规则的情况下,我们往往会得到我们期望的结果,这就给未来版本的编译器留下了一个新的优化的可能性,即破坏了我们认为有效的代码。这种情况是不可取的,了解严格的别名规则以及如何避免违反这些规则,是一个值得我们去了解的目标。</target>
        </trans-unit>
        <trans-unit id="db8ca5d18a2da2723c323eb4668458564a4e8a8e" translate="yes" xml:space="preserve">
          <source>Unfortunately, the authors of the C89 wrote their rule in a way that, if read literally, would make even the following function invoke Undefined Behavior:</source>
          <target state="translated">不幸的是,C89的作者在写他们的规则时,如果从字面意义上看,即使是下面的函数,也会调用Undefined Behavior。</target>
        </trans-unit>
        <trans-unit id="c9eb5ca0a29983f2cff35266a2b00fda06003422" translate="yes" xml:space="preserve">
          <source>Use a union. Most compilers support this without complaining about strict aliasing. This is allowed in C99 and explicitly allowed in C11.</source>
          <target state="translated">使用联盟。大多数编译器都支持这样做,不会抱怨严格的别名。这在C99中是允许的,在C11中也明确允许。</target>
        </trans-unit>
        <trans-unit id="ffd25c02b83ef5f0f4c7c45af829e62dae0bf2c5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;restrict&lt;/code&gt; keyword. i.e.:</source>
          <target state="translated">使用 &lt;code&gt;restrict&lt;/code&gt; 关键字。 即：</target>
        </trans-unit>
        <trans-unit id="798b73c4c9c14434f5fd6ba2176351fdd836980d" translate="yes" xml:space="preserve">
          <source>We don't have a lot of good tools for catching strict aliasing in C++, the tools we have will catch some cases of strict aliasing violations and some cases of misaligned loads and stores.</source>
          <target state="translated">我们没有很多好的工具来抓取C++中的严格别名,我们现有的工具会抓取一些违反严格别名的情况,以及一些错位的加载和存储的情况。</target>
        </trans-unit>
        <trans-unit id="7a25725c5206d96d54103f39151066cf147a0d46" translate="yes" xml:space="preserve">
          <source>We have a &lt;em&gt;int*&lt;/em&gt; pointing to memory occupied by an &lt;em&gt;int&lt;/em&gt; and this is a valid aliasing. The optimizer must assume that assignments through &lt;strong&gt;ip&lt;/strong&gt; could update the value occupied by &lt;strong&gt;x&lt;/strong&gt;.</source>
          <target state="translated">我们有一个&lt;em&gt;int *&lt;/em&gt;指向一个&lt;em&gt;int&lt;/em&gt;占用的内存，这是有效的别名。 优化器必须假设通过&lt;strong&gt;ip&lt;/strong&gt;进行分配可以更新&lt;strong&gt;x&lt;/strong&gt;占用的值。</target>
        </trans-unit>
        <trans-unit id="b4304e0250327f603bbd29b9479b911b0f3e7e12" translate="yes" xml:space="preserve">
          <source>We have gotten to this point and we may be wondering, why would we want to alias for? The answer typically is to &lt;em&gt;type pun&lt;/em&gt;, often the methods used violate strict aliasing rules.</source>
          <target state="translated">我们到了这一点，我们可能想知道，为什么要别名呢？ 答案通常是&lt;em&gt;键入pun&lt;/em&gt; ，通常所使用的方法违反严格的别名规则。</target>
        </trans-unit>
        <trans-unit id="486a3a882c8d445100340edd5a8f2d6177c5a9af" translate="yes" xml:space="preserve">
          <source>What are they talking about?</source>
          <target state="translated">他们在说什么呢?</target>
        </trans-unit>
        <trans-unit id="8c58623950ce7060c946f960d5a1072d0350e835" translate="yes" xml:space="preserve">
          <source>What does the C11 standard say?</source>
          <target state="translated">C11标准是怎么说的?</target>
        </trans-unit>
        <trans-unit id="be95c287c482fdf98be1e57328b6181a5b151c60" translate="yes" xml:space="preserve">
          <source>What exactly does the standard say we are allowed and not allowed to do? The standard language is not straightforward, so for each item I will try to provide code examples that demonstrates the meaning.</source>
          <target state="translated">标准中到底说了什么是允许做和不允许做的?标准的语言并不直截了当,所以对于每一个项目,我都会尽量提供一些代码的例子来证明其含义。</target>
        </trans-unit>
        <trans-unit id="80f819d6238279d0e91326c0caabb3b332286522" translate="yes" xml:space="preserve">
          <source>What is Type Punning</source>
          <target state="translated">什么是 &quot;类型化惩罚&quot;?</target>
        </trans-unit>
        <trans-unit id="0484d0796de9fffe254f71284bf9ef8e03cb6100" translate="yes" xml:space="preserve">
          <source>What is strict aliasing?</source>
          <target state="translated">什么是严格的别名?</target>
        </trans-unit>
        <trans-unit id="bd5bd917a7164fc90491e58bae353151d7d6d43e" translate="yes" xml:space="preserve">
          <source>What is the strict aliasing rule</source>
          <target state="translated">什么是严格的别名规则</target>
        </trans-unit>
        <trans-unit id="cfad540cca405d9e6ac5dbafe09c03446c539f96" translate="yes" xml:space="preserve">
          <source>What the C++17 Draft Standard say</source>
          <target state="translated">C++17标准草案是怎么说的</target>
        </trans-unit>
        <trans-unit id="2b2f3220f114ca6e5fa9f3ff293ad00e83672d76" translate="yes" xml:space="preserve">
          <source>When asking about &lt;a href=&quot;https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into&quot;&gt;common undefined behavior in C&lt;/a&gt;, people sometimes refer to the strict aliasing rule.</source>
          <target state="translated">当询问&lt;a href=&quot;https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into&quot;&gt;C中常见的未定义行为时&lt;/a&gt; ，人们有时会参考严格的别名规则。</target>
        </trans-unit>
        <trans-unit id="c3986cda3c380d27ccea1e1786651cd0707eff3f" translate="yes" xml:space="preserve">
          <source>Which may not be expected but is perfectly valid since we have invoked undefined behavior. A &lt;em&gt;float&lt;/em&gt; can not validly alias an &lt;em&gt;int&lt;/em&gt; object. Therefore the optimizer can assume the &lt;em&gt;constant 1&lt;/em&gt; stored when dereferencing &lt;strong&gt;i&lt;/strong&gt; will be the return value since a store through &lt;strong&gt;f&lt;/strong&gt; could not validly affect an &lt;em&gt;int&lt;/em&gt; object. Plugging the code in Compiler Explorer shows this is exactly what is happening(&lt;a href=&quot;https://godbolt.org/g/yNV5aj&quot;&gt;live example&lt;/a&gt;):</source>
          <target state="translated">因为我们已经调用了未定义的行为，所以这可能不是预期的，但是完全有效。 &lt;em&gt;浮点数&lt;/em&gt;不能有效地别名为&lt;em&gt;int&lt;/em&gt;对象。 因此，优化器可以假定在解引用&lt;strong&gt;i&lt;/strong&gt;时存储的&lt;em&gt;常数1&lt;/em&gt;将是返回值，因为通过&lt;strong&gt;f&lt;/strong&gt;进行的存储无法有效影响&lt;em&gt;int&lt;/em&gt;对象。 将代码插入Compiler Explorer可以显示这正是正在发生的情况（ &lt;a href=&quot;https://godbolt.org/g/yNV5aj&quot;&gt;实时示例&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="07141bb6d0d110634a7409d34c366630d3c98a44" translate="yes" xml:space="preserve">
          <source>Worth noting &lt;em&gt;signed char&lt;/em&gt; is not included in the list above, this is a notable difference from &lt;em&gt;C&lt;/em&gt; which says &lt;em&gt;a character type&lt;/em&gt;.</source>
          <target state="translated">值得一提的是，上面的列表中未包括带&lt;em&gt;符号的char&lt;/em&gt; ，这与&lt;em&gt;C&lt;/em&gt;表示&lt;em&gt;字符类型&lt;/em&gt;的显着区别。</target>
        </trans-unit>
        <trans-unit id="6ec4bca0456ee32bdbabe8e73b9e3df68f5d736b" translate="yes" xml:space="preserve">
          <source>You can disable strict aliasing in your compiler (&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825&quot;&gt;f[no-]strict-aliasing&lt;/a&gt; in gcc))</source>
          <target state="translated">您可以在编译器中禁用严格别名（gcc中的&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825&quot;&gt;f [no-] strict-aliasing&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="9a40a7037ea21cd56a31798eee7807d9c8786d82" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;char*&lt;/code&gt; for aliasing instead of your system's word. The rules allow an exception for &lt;code&gt;char*&lt;/code&gt; (including &lt;code&gt;signed char&lt;/code&gt; and &lt;code&gt;unsigned char&lt;/code&gt;). It's always assumed that &lt;code&gt;char*&lt;/code&gt; aliases other types. However this won't work the other way: there's no assumption that your struct aliases a buffer of chars.</source>
          <target state="translated">您可以将 &lt;code&gt;char*&lt;/code&gt; 用作别名而不是系统的单词。 规则允许 &lt;code&gt;char*&lt;/code&gt; （包括 &lt;code&gt;signed char&lt;/code&gt; 和 &lt;code&gt;unsigned char&lt;/code&gt; ）例外。 始终假定 &lt;code&gt;char*&lt;/code&gt; 其他类型的别名。 但是，这不会以其他方式起作用：没有假设您的结构别名为chars缓冲区。</target>
        </trans-unit>
        <trans-unit id="3ee51db5fb0d07b269bfed3eb63461eb650f3683" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 或 &lt;code&gt;unsigned char&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="597ff02af60ec975bbc5261d748ee4cf1e57a446" translate="yes" xml:space="preserve">
          <source>a character type.</source>
          <target state="translated">一个字符类型。</target>
        </trans-unit>
        <trans-unit id="cce769f3e61ed7c57c27b8bbabf2ecde89913120" translate="yes" xml:space="preserve">
          <source>a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">对象的动态类型的CV-qualified版本。</target>
        </trans-unit>
        <trans-unit id="d5c0b51b12ba45e66cdb0c200363fe41dca17267" translate="yes" xml:space="preserve">
          <source>a qualified version of a type compatible with the effective type of the object,</source>
          <target state="translated">与对象的有效类型相符的类型的合格版本;</target>
        </trans-unit>
        <trans-unit id="913991e5ddd84e880c9ee8623ae50786c0e5aa58" translate="yes" xml:space="preserve">
          <source>a qualiﬁed version of a type compatible with the effective type of
  the object,</source>
          <target state="translated">一个与对象的有效类型兼容的类型的限定版本。</target>
        </trans-unit>
        <trans-unit id="b75dd2203435a45255f541a92e8f52a7c687df9d" translate="yes" xml:space="preserve">
          <source>a type compatible with the effective type of the object,</source>
          <target state="translated">与对象的有效类型相符的类型;</target>
        </trans-unit>
        <trans-unit id="75d68aa8a13ac3e6c2e72772064d82f9a07c3a25" translate="yes" xml:space="preserve">
          <source>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</source>
          <target state="translated">对象的动态类型的基类类型(可能是cv-qualified)。</target>
        </trans-unit>
        <trans-unit id="b65677be1e1487df5175120a02cfc67364b289cb" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a
  qualiﬁed version of the effective type of the object,</source>
          <target state="translated">一种类型,是与对象的有效类型的限定版本对应的有符号或无符号类型。</target>
        </trans-unit>
        <trans-unit id="bac8eec6cb1615e6948be007906aef75526747ef" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</source>
          <target state="translated">类型,是与对象的动态类型的cv-qualified版本对应的有符号或无符号类型。</target>
        </trans-unit>
        <trans-unit id="32f34f0edd59f5a473682cd472684b341a58daef" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object,</source>
          <target state="translated">类型,是与对象的有效类型的限定版本对应的有符号或无符号类型;</target>
        </trans-unit>
        <trans-unit id="e7c8760740b87a7f9140b423e924d45e4999f46b" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to the
  effective type of the object,</source>
          <target state="translated">类型,是与对象的有效类型对应的有符号或无符号类型。</target>
        </trans-unit>
        <trans-unit id="3fb43283d88825a91d147ec87a46390b16119ec1" translate="yes" xml:space="preserve">
          <source>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</source>
          <target state="translated">类型,是与对象的动态类型对应的有符号或无符号类型。</target>
        </trans-unit>
        <trans-unit id="09589aee6f97ca1ced0e9615240163fa1a8aac6b" translate="yes" xml:space="preserve">
          <source>add &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;a&lt;/code&gt; 添加到 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4989e9968b633144d1dfa1a4b1a8a78e58f871e" translate="yes" xml:space="preserve">
          <source>add &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;b&lt;/code&gt; 加到 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7dfe2e2b4ee47faaabfeac29663335e09827e6a" translate="yes" xml:space="preserve">
          <source>although it will not catch this additional case (&lt;a href=&quot;https://wandbox.org/permlink/dwd9jhy53AF7a2D0&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">尽管它不会捕获这种额外的情况（ &lt;a href=&quot;https://wandbox.org/permlink/dwd9jhy53AF7a2D0&quot;&gt;请现场观看&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="e191b7b82407cef0ada97dd29a20d0793010dffe" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned
  types among its members (including, recursively, a member of a
  subaggregate or contained union), or</source>
          <target state="translated">在其成员中包含上述类型之一的集合或联合类型(包括递归的子集合或包含的联合成员),或</target>
        </trans-unit>
        <trans-unit id="fdece15d7bccebfe8183f34b848fc0e4942877cb" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned types among its &lt;em&gt;elements or non-static data members&lt;/em&gt; (including, recursively, an &lt;em&gt;element or non-static data member&lt;/em&gt; of a subaggregate or contained union),</source>
          <target state="translated">聚合或联合类型，在其&lt;em&gt;元素或非静态数据成员&lt;/em&gt; （递归包括子聚合或包含的联合的&lt;em&gt;元素或非静态数据成员）中&lt;/em&gt;包括上述类型之一，</target>
        </trans-unit>
        <trans-unit id="3bb5bb5a7fb40894ca32d70cc8dbec9f68ef6180" translate="yes" xml:space="preserve">
          <source>an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union),</source>
          <target state="translated">在其成员中包含上述类型之一的集合或联合类型(包括递归的子集合或包含的联合成员);</target>
        </trans-unit>
        <trans-unit id="9904ae77bbd2a07d458dc75556c60522d6fed3a1" translate="yes" xml:space="preserve">
          <source>because it uses an lvalue of type &lt;code&gt;int&lt;/code&gt; to access an object of type &lt;code&gt;struct S&lt;/code&gt;, and &lt;code&gt;int&lt;/code&gt; is not among the types that may be used accessing a &lt;code&gt;struct S&lt;/code&gt;.  Because it would be absurd to treat all use of non-character-type members of structs and unions as Undefined Behavior, almost everyone recognizes that there are at least some circumstances where an lvalue of one type may be used to access an object of another type.  Unfortunately, the C Standards Committee has failed to define what those circumstances are.</source>
          <target state="translated">因为它使用 &lt;code&gt;int&lt;/code&gt; 类型的左值访问 &lt;code&gt;struct S&lt;/code&gt; 类型的对象，并且 &lt;code&gt;int&lt;/code&gt; 不在可用于访问 &lt;code&gt;struct S&lt;/code&gt; 的类型之中。 因为将所有对结构和联合的非字符类型成员的使用都视为未定义行为是荒谬的，所以几乎每个人都认识到至少在某些情况下，一种类型的左值可用于访问另一种类型的对象。 不幸的是，C标准委员会未能定义这些情况。</target>
        </trans-unit>
        <trans-unit id="13f76d1176cba1d67741f0be2b7d390647245ed8" translate="yes" xml:space="preserve">
          <source>check.c</source>
          <target state="translated">check.c</target>
        </trans-unit>
        <trans-unit id="6cc4950f9d59b228de0ffc8dfa255d0ff18a24aa" translate="yes" xml:space="preserve">
          <source>gcc using the flag &lt;strong&gt;-fstrict-aliasing&lt;/strong&gt; and &lt;strong&gt;-Wstrict-aliasing&lt;/strong&gt; can catch some cases although not without false positives/negatives. For example the following cases will generate a warning in gcc (&lt;a href=&quot;https://wandbox.org/permlink/cfckjTgwNTYHDIry&quot;&gt;see it live&lt;/a&gt;):</source>
          <target state="translated">使用标志&lt;strong&gt;-fstrict-aliasing&lt;/strong&gt;和&lt;strong&gt;-Wstrict-aliasing的&lt;/strong&gt; gcc可以捕获某些情况，尽管并非没有假阳性/阴性。 例如，以下情况将在gcc中生成警告（ &lt;a href=&quot;https://wandbox.org/permlink/cfckjTgwNTYHDIry&quot;&gt;实时查看&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="9b9539e1dab95d4762b7ca605ff3ef29baabe352" translate="yes" xml:space="preserve">
          <source>load &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from memory.</source>
          <target state="translated">从内存中加载 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c8e98bbec15998f99b160035e6e2a5a79e70264" translate="yes" xml:space="preserve">
          <source>save &lt;code&gt;a&lt;/code&gt; (from the CPU register) to the memory.</source>
          <target state="translated">将 &lt;code&gt;a&lt;/code&gt; （来自CPU寄存器）保存到内存中。</target>
        </trans-unit>
        <trans-unit id="e9f82b272f6f1b1af58a82bfd5c8942a5383dee9" translate="yes" xml:space="preserve">
          <source>save result both to &lt;code&gt;a&lt;/code&gt; and to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">将结果保存到 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a44e1b26b12bd2a7790e5bb3e97bb71d781569c" translate="yes" xml:space="preserve">
          <source>should be required to reload the value of &lt;code&gt;x&lt;/code&gt; between the assignment and return statement so as to allow for the possibility that &lt;code&gt;p&lt;/code&gt; might point to &lt;code&gt;x&lt;/code&gt;, and the assignment to &lt;code&gt;*p&lt;/code&gt; might consequently alter the value of &lt;code&gt;x&lt;/code&gt;.  The notion that a compiler should be entitled to presume that there won't be aliasing &lt;em&gt;in situations like the above&lt;/em&gt; was non-controversial.</source>
          <target state="translated">应该要求在赋值和return语句之间重新加载 &lt;code&gt;x&lt;/code&gt; 的值，以允许 &lt;code&gt;p&lt;/code&gt; 可能指向 &lt;code&gt;x&lt;/code&gt; 的可能性，并且 &lt;code&gt;*p&lt;/code&gt; 的赋值可能因此改变 &lt;code&gt;x&lt;/code&gt; 的值。 编译器应有权假定&lt;em&gt;在上述情况下&lt;/em&gt;不会出现别名的观点是无争议的。</target>
        </trans-unit>
        <trans-unit id="2ae0f749e2f2eba590823df0d938d3f9e1d9f0ad" translate="yes" xml:space="preserve">
          <source>the dynamic type of the object,</source>
          <target state="translated">对象的动态类型。</target>
        </trans-unit>
        <trans-unit id="5c8205de1a0f5881a6eef3facb06094c46436ace" translate="yes" xml:space="preserve">
          <source>tis-interpeter is able to catch all three, the following example invokes tis-kernal as tis-interpreter (output is edited for brevity):</source>
          <target state="translated">tis-interpeter能够捕捉到这三者,下面的例子调用tis-kernal作为tis-inpreter(为了简洁起见,输出被编辑了)。</target>
        </trans-unit>
        <trans-unit id="790926074ddb3f88b6b51d69cef8f57d64c8ee6d" translate="yes" xml:space="preserve">
          <source>we can use &lt;strong&gt;memcpy&lt;/strong&gt;:</source>
          <target state="translated">我们可以使用&lt;strong&gt;memcpy&lt;/strong&gt; ：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
