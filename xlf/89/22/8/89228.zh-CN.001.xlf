<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/89228">
    <body>
      <group id="89228">
        <trans-unit id="2fa022bd967a52296e65e0e93e4983b8a1355086" translate="yes" xml:space="preserve">
          <source>(I find it interesting and slightly counterintuitive that the version info gets put to stderr instead of stdout.)</source>
          <target state="translated">(我发现版本信息会被放到 stderr 而不是 stdout,这很有趣,也有点反直觉。)</target>
        </trans-unit>
        <trans-unit id="d73ee7e04c378d99b234285f778f66d6d33d3f5e" translate="yes" xml:space="preserve">
          <source>...or for a very simple command:</source>
          <target state="translated">...或者是一个非常简单的命令。</target>
        </trans-unit>
        <trans-unit id="03e119785353bdbc85f2148afb573722fd371740" translate="yes" xml:space="preserve">
          <source>/* &lt;em&gt;UPD 2015.10.27&lt;/em&gt; @eryksun in a comment below notes, that the semantically correct flag is CREATE_NEW_CONSOLE (0x00000010) */</source>
          <target state="translated">/ * &lt;em&gt;UPD 2015.10.27&lt;/em&gt; @eryksun在下面的注释中指出，语义正确的标志是CREATE_NEW_CONSOLE（0x00000010）* /</target>
        </trans-unit>
        <trans-unit id="a13e78e8e9e3bfa32930177509f879f3e0e23897" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;commands&lt;/code&gt; contains wrapper functions for &lt;code&gt;os.popen&lt;/code&gt;, but it has been removed from Python 3 since &lt;code&gt;subprocess&lt;/code&gt; is a better alternative.</source>
          <target state="translated">&lt;code&gt;commands&lt;/code&gt; 包含 &lt;code&gt;os.popen&lt;/code&gt; 的包装函数，但由于 &lt;code&gt;subprocess&lt;/code&gt; 是更好的选择，因此已从Python 3中删除了该函数。</target>
        </trans-unit>
        <trans-unit id="4c8bf122b90b453d9cf47e82094c872bf30dbac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.system(&quot;some_command with args&quot;)&lt;/code&gt; passes the command and arguments to your system's shell.  This is nice because you can actually run multiple commands at once in this manner and set up pipes and input/output redirection.  For example:</source>
          <target state="translated">&lt;code&gt;os.system(&quot;some_command with args&quot;)&lt;/code&gt; 将命令和参数传递给系统的外壳程序。 很好，因为您实际上可以以这种方式一次运行多个命令，并设置管道和输入/输出重定向。 例如：</target>
        </trans-unit>
        <trans-unit id="f933a6d1f532e7034395c9645f4d7b96a2af4e03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.system&lt;/code&gt; does not allow you to store results, so if you want to store results in some list or something, a &lt;code&gt;subprocess.call&lt;/code&gt; works.</source>
          <target state="translated">&lt;code&gt;os.system&lt;/code&gt; 不允许您存储结果，因此，如果要将结果存储在某个列表或某些内容中，则可以使用 &lt;code&gt;subprocess.call&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0a4cc68bc86b75a6e42b06c428e42fa3f4d7cd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.system&lt;/code&gt; is OK, but kind of dated.  It's also not very secure.  Instead, try &lt;code&gt;subprocess&lt;/code&gt;.  &lt;code&gt;subprocess&lt;/code&gt; does not call sh directly and is therefore more secure than &lt;code&gt;os.system&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os.system&lt;/code&gt; 可以，但是有点陈旧。 这也不是很安全。 相反，请尝试 &lt;code&gt;subprocess&lt;/code&gt; 。 &lt;code&gt;subprocess&lt;/code&gt; &lt;code&gt;os.system&lt;/code&gt; 不会直接调用sh，因此比os.system更安全。</target>
        </trans-unit>
        <trans-unit id="1be8c4f39fb826c1206cfeb8a2a8525188e3ba01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run&lt;/code&gt; waits for the command to successfully finish, then returns a &lt;code&gt;CompletedProcess&lt;/code&gt; object. It may instead raise &lt;code&gt;TimeoutExpired&lt;/code&gt; (if you give it a &lt;code&gt;timeout=&lt;/code&gt; argument) or &lt;code&gt;CalledProcessError&lt;/code&gt; (if it fails and you pass &lt;code&gt;check=True&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 等待命令成功完成，然后返回 &lt;code&gt;CompletedProcess&lt;/code&gt; 对象。 它可能改为引发 &lt;code&gt;TimeoutExpired&lt;/code&gt; （如果给它提供 &lt;code&gt;timeout=&lt;/code&gt; 参数）或 &lt;code&gt;CalledProcessError&lt;/code&gt; （如果失败，并通过 &lt;code&gt;check=True&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="37700740d479dac1f23a3d7e42187418def430b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stream = os.popen(&quot;some_command with args&quot;)&lt;/code&gt; will do the same thing as &lt;code&gt;os.system&lt;/code&gt; except that it gives you a file-like object that you can use to access standard input/output for that process.  There are 3 other variants of popen that all handle the i/o slightly differently.  If you pass everything as a string, then your command is passed to the shell; if you pass them as a list then you don't need to worry about escaping anything.  See &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.popen&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;stream = os.popen(&quot;some_command with args&quot;)&lt;/code&gt; 与 &lt;code&gt;os.system&lt;/code&gt; 的作用相同，只是它为您提供了一个类似于文件的对象，您可以使用该对象访问该进程的标准输入/输出。 Popen还有其他3种变体，它们对I / O的处理略有不同。 如果您将所有内容都作为字符串传递，那么您的命令将传递到外壳程序； 如果将它们作为列表传递，则无需担心转义任何内容。 请参阅&lt;a href=&quot;https://docs.python.org/2/library/os.html#os.popen&quot;&gt;文档&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="4416f3a6f2bce6eeb7854601cba76dadb8bf5bd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subprocess.Popen&lt;/code&gt; executes the &amp;lt;command&amp;gt; as a subprocess. In my case, I need to execute file &amp;lt;a&amp;gt; which needs to communicate with another program, &amp;lt;b&amp;gt;.</source>
          <target state="translated">&lt;code&gt;subprocess.Popen&lt;/code&gt; 将&amp;lt;command&amp;gt;作为子进程执行。 就我而言，我需要执行文件&amp;lt;a&amp;gt;，该文件需要与另一个程序&amp;lt;b&amp;gt;通信。</target>
        </trans-unit>
        <trans-unit id="33e4bd1cac6b8c03f49979ab4855183ec2d516b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subprocess.check_call&lt;/code&gt; is convenient if you don't want to test return values. It throws an exception on any error.</source>
          <target state="translated">如果您不想测试返回值， &lt;code&gt;subprocess.check_call&lt;/code&gt; 很方便。 任何错误都会引发异常。</target>
        </trans-unit>
        <trans-unit id="ff4a1b97ccf371c558c702bd25078a23e3ea92ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subprocess.run&lt;/code&gt; is the recommended approach &lt;a href=&quot;https://docs.python.org/3.6/whatsnew/3.5.html#whatsnew-subprocess&quot;&gt;as of Python 3.5&lt;/a&gt; if your code does not need to maintain compatibility with earlier Python versions. It's more consistent and offers similar ease-of-use as Envoy. (Piping isn't as straightforward though. See &lt;a href=&quot;https://stackoverflow.com/questions/7389662/link-several-popen-commands-with-pipes&quot;&gt;this question for how&lt;/a&gt;.)</source>
          <target state="translated">如果您的代码不需要保持与早期Python版本的兼容性，则从Python &lt;a href=&quot;https://docs.python.org/3.6/whatsnew/3.5.html#whatsnew-subprocess&quot;&gt;3.5开始&lt;/a&gt; ，建议使用subprocess.run。 它更加一致，并且提供与Envoy类似的易用性。 （虽然管道并不是那么简单。有关&lt;a href=&quot;https://stackoverflow.com/questions/7389662/link-several-popen-commands-with-pipes&quot;&gt;如何操作，&lt;/a&gt;请参见此问题 。）</target>
        </trans-unit>
        <trans-unit id="6c10957c993d4d3137d83cbbd9734cf58bddc749" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note on Python version: If you are still using Python 2, &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#subprocess.call&quot;&gt;subprocess.call&lt;/a&gt; works in a similar way.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;关于Python版本的注意事项：如果您仍在使用Python 2， &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#subprocess.call&quot;&gt;subprocess.call的&lt;/a&gt;工作方式与此类似。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="abdf1ab661fc1bb5d31823425f22c54b0fe0a4c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ProTip: &lt;a href=&quot;https://docs.python.org/2/library/shlex.html#shlex.split&quot;&gt;shlex.split&lt;/a&gt; can help you to parse the command for &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and other &lt;code&gt;subprocess&lt;/code&gt; functions in case you don't want (or you can't!) provide them in form of lists:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ProTip： &lt;a href=&quot;https://docs.python.org/2/library/shlex.html#shlex.split&quot;&gt;shlex.split&lt;/a&gt;可以帮助您解析 &lt;code&gt;run&lt;/code&gt; ， &lt;code&gt;call&lt;/code&gt; 和其他 &lt;code&gt;subprocess&lt;/code&gt; 函数的命令，以防您不想（或您不能！）以列表形式提供它们：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2beb69e6e367fef69658c1d696a2a07e072fa71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sources:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Sources:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fae92702cc843aed7b6f7742cd5bf98fb81d5390" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;These are all the libraries:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这些都是库：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="122b554b12ec9d4243a60880464396676946c117" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;commands&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;commands&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="295a7b21b6132cb7af6f19ee9b55d3e68dccd713" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;envoy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;envoy&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0f149e4b6717c8ff1d7cb99cddbe344ab27b8f06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fabric&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;fabric&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57b5d2dd621b183cb3e77e4464994db536fc8f8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;os - This module provides a portable way of using operating system-dependent functionality.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;os-此模块提供了使用依赖于操作系统的功能的便携式方法。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce67685e9d0f0271929077ff3385b7f97cb94aa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;os&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;os&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e109416858f9fd7878d662f569388a7e5ac5120e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;pexpect&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;pexpect&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8ee21152a9f689364ff72189ea954186f6d2bea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;plumbum&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;plumbum&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fe04888499cbb6a1a7308e216ab1b1883dd3550a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;sh&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;sh&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a295458c00f4d8f888b9bb2e34b5e88b7961da8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;subprocess&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;subprocess&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f4b0ef6809aac2c4cea3880f034fe3f8c0e1165" translate="yes" xml:space="preserve">
          <source>Also note the &lt;a href=&quot;https://docs.python.org/3.6/library/subprocess.html#frequently-used-arguments&quot;&gt;shell&lt;/a&gt; parameter.</source>
          <target state="translated">还要注意&lt;a href=&quot;https://docs.python.org/3.6/library/subprocess.html#frequently-used-arguments&quot;&gt;shell&lt;/a&gt;参数。</target>
        </trans-unit>
        <trans-unit id="12fa2ebb13aa4c6f3737660d048e954b248d81c2" translate="yes" xml:space="preserve">
          <source>An example with task spooler:</source>
          <target state="translated">一个有任务控制器的例子。</target>
        </trans-unit>
        <trans-unit id="783369e650b595352e4b203badb3f8950cfa6399" translate="yes" xml:space="preserve">
          <source>Another popular library is &lt;a href=&quot;https://pypi.python.org/pypi/sh&quot;&gt;sh&lt;/a&gt;:</source>
          <target state="translated">另一个受欢迎的图书馆是&lt;a href=&quot;https://pypi.python.org/pypi/sh&quot;&gt;sh&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="d7810dfe6b8148f0e818246c5528184e5ee081bc" translate="yes" xml:space="preserve">
          <source>Anyone runs the kwrite not being a subprocess (i.e. in the system monitor it must appear at the leftmost edge of the tree).</source>
          <target state="translated">任何人运行的kwrite不是子进程(即在系统监视器中,它必须出现在树的最左边的边缘)。</target>
        </trans-unit>
        <trans-unit id="cb2a196ab266c2677a36a1ff39e9a77602d3e268" translate="yes" xml:space="preserve">
          <source>As of Python 3.5, the documentation recommends &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt;subprocess.run&lt;/a&gt;:</source>
          <target state="translated">从Python 3.5开始，文档建议使用&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt;subprocess.run&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="e0a5626c26468b935b29b7609635694dc9b379ed" translate="yes" xml:space="preserve">
          <source>As you might infer from the above example, stdout and stderr both get piped to your own stdout and stderr by default.</source>
          <target state="translated">从上面的例子中可以推断出,stdout和stderr默认都会被传送到你自己的stdout和stderr。</target>
        </trans-unit>
        <trans-unit id="71e8fb399394db284421a62daa01522b012fe135" translate="yes" xml:space="preserve">
          <source>But more informative is &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#popen-constructor&quot;&gt;the &lt;code&gt;Popen&lt;/code&gt; documentation&lt;/a&gt;:</source>
          <target state="translated">但更多有用的是&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#popen-constructor&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; 文档&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="42c3d980ac63ed21471d91749f0230e954125b26" translate="yes" xml:space="preserve">
          <source>But this seem to be a good tool: &lt;a href=&quot;https://github.com/amoffat/sh&quot;&gt;&lt;code&gt;sh&lt;/code&gt; (Python subprocess interface)&lt;/a&gt;.</source>
          <target state="translated">但这似乎是一个很好的工具： &lt;a href=&quot;https://github.com/amoffat/sh&quot;&gt; &lt;code&gt;sh&lt;/code&gt; （Python子进程接口）&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="040353c1be3fc4d64bd7a04883d5de25a9889047" translate="yes" xml:space="preserve">
          <source>Calling an external command from Python</source>
          <target state="translated">调用Python的外部命令</target>
        </trans-unit>
        <trans-unit id="73d24b095f38cb410b90189e614453dd440a6a13" translate="yes" xml:space="preserve">
          <source>Calling an external command in Python</source>
          <target state="translated">在Python中调用外部命令</target>
        </trans-unit>
        <trans-unit id="73c1ff3b1f2c79f4fb4b9eeeb7f9489bc652b2ed" translate="yes" xml:space="preserve">
          <source>Capture output:</source>
          <target state="translated">捕获输出。</target>
        </trans-unit>
        <trans-unit id="821248556b70b1a5b77fcba34211dde7762c0d29" translate="yes" xml:space="preserve">
          <source>Capturing output</source>
          <target state="translated">捕获输出</target>
        </trans-unit>
        <trans-unit id="7b6e4384f3588ea08309a1d68b2c594a5a6ef91d" translate="yes" xml:space="preserve">
          <source>Check the &quot;pexpect&quot; Python library, too.</source>
          <target state="translated">检查 &quot;pexpect &quot;Python库,也是如此。</target>
        </trans-unit>
        <trans-unit id="04c1ab878cc2981820a3c703c587e0b1e6d43b31" translate="yes" xml:space="preserve">
          <source>Example usage from &lt;a href=&quot;https://github.com/kennethreitz/envoy#readme&quot;&gt;the README&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/kennethreitz/envoy#readme&quot;&gt;自述文件中的&lt;/a&gt;示例用法：</target>
        </trans-unit>
        <trans-unit id="85d1e51f42bcdee83f1807c85ad03b44972f7625" translate="yes" xml:space="preserve">
          <source>Execute a child program in a new process. On POSIX, the class uses
  os.execvp()-like behavior to execute the child program. On Windows,
  the class uses the Windows CreateProcess() function. The arguments to
  Popen are as follows.</source>
          <target state="translated">在一个新进程中执行子程序。在POSIX上,该类使用类似os.execvp()的行为来执行子程序。在Windows上,该类使用Windows CreateProcess()函数。对Popen的参数如下。</target>
        </trans-unit>
        <trans-unit id="8a714c705dea02d0d422508d397211ab5d0c556f" translate="yes" xml:space="preserve">
          <source>Expanded Signature</source>
          <target state="translated">扩展签名</target>
        </trans-unit>
        <trans-unit id="4793ba5a9403e9efafa59c26d506241288256613" translate="yes" xml:space="preserve">
          <source>Finally please be aware that for all methods where you pass the final command to be executed by the shell as a string and you are responsible for escaping it. &lt;strong&gt;There are serious security implications&lt;/strong&gt; if any part of the string that you pass can not be fully trusted. For example, if a user is entering some/any part of the string. If you are unsure, only use these methods with constants. To give you a hint of the implications consider this code:</source>
          <target state="translated">最后，请注意，对于所有方法，在这些方法中，您将要由外壳执行的最终命令作为字符串传递给您，并且您有责任对其进行转义。 如果您传递的字符串的任何部分不能被完全信任，则将&lt;strong&gt;带来严重的安全隐患&lt;/strong&gt; 。 例如，如果用户正在输入字符串的某些/任何部分。 如果不确定，请仅将这些方法与常量一起使用。 为了给您暗示的含义，请考虑以下代码：</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="fd628ede4dea14449c2bd6ce7ddc3a17d4be5bc0" translate="yes" xml:space="preserve">
          <source>For the more &lt;code&gt;os&lt;/code&gt; functions, &lt;a href=&quot;https://docs.python.org/2/library/os.html&quot;&gt;here&lt;/a&gt; is the documentation.</source>
          <target state="translated">有关更多 &lt;code&gt;os&lt;/code&gt; 功能，请参见文档。</target>
        </trans-unit>
        <trans-unit id="9c4ae2ec46821c328b164a9bd8097808acc3eb0e" translate="yes" xml:space="preserve">
          <source>For versions of Python before 3.5, use &lt;code&gt;call&lt;/code&gt;:</source>
          <target state="translated">对于3.5之前的Python版本，请使用 &lt;code&gt;call&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="048b33f3180e834803e6dc87333de2eb9542760b" translate="yes" xml:space="preserve">
          <source>Full Signature</source>
          <target state="translated">完整的签名</target>
        </trans-unit>
        <trans-unit id="6d74b3bf384964ae40c82bc487f9ebeeff7b54bd" translate="yes" xml:space="preserve">
          <source>Get more information &lt;a href=&quot;https://docs.python.org/library/subprocess.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/library/subprocess.html&quot;&gt;在这里&lt;/a&gt;获取更多信息。</target>
        </trans-unit>
        <trans-unit id="a1ddee242c3c47b20fdebe1a8e42128b53fe1db7" translate="yes" xml:space="preserve">
          <source>Here's a summary of the ways to call external programs and the advantages and disadvantages of each:</source>
          <target state="translated">下面就给大家总结一下外部程序的调用方式以及各自的优缺点。</target>
        </trans-unit>
        <trans-unit id="69638c61ab5a206a75c4a4d3c5fd0660eeea0a49" translate="yes" xml:space="preserve">
          <source>Here's an example from the documentation:</source>
          <target state="translated">下面是文档中的一个例子。</target>
        </trans-unit>
        <trans-unit id="89e73100a297543bdc607a0b518448335c8e3a66" translate="yes" xml:space="preserve">
          <source>Here's an example of the simplest possible usage - and it does exactly as asked:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a57c3b7a9b591fcf528aa657d826d36e28aadd44" translate="yes" xml:space="preserve">
          <source>Here's an expanded signature, as given in the documentation:</source>
          <target state="translated">下面是文件中给出的扩展签名。</target>
        </trans-unit>
        <trans-unit id="8f8248ec43960110eab95fc9c88ecc8149428271" translate="yes" xml:space="preserve">
          <source>Here's some examples from &lt;a href=&quot;https://docs.python.org/3.6/library/subprocess.html#subprocess.run&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">以下是&lt;a href=&quot;https://docs.python.org/3.6/library/subprocess.html#subprocess.run&quot;&gt;文档中&lt;/a&gt;的一些示例。</target>
        </trans-unit>
        <trans-unit id="7df370006ffdbaaae32d6957ed8cd623e4cabd51" translate="yes" xml:space="preserve">
          <source>Here's the &lt;code&gt;Popen&lt;/code&gt; signature as given in &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/subprocess.py#L587&quot;&gt;the source&lt;/a&gt;. I think this is the most precise encapsulation of the information (as opposed to &lt;code&gt;help(Popen)&lt;/code&gt;):</source>
          <target state="translated">这是&lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/subprocess.py#L587&quot;&gt;源代码中&lt;/a&gt;给出的 &lt;code&gt;Popen&lt;/code&gt; 签名。 我认为这是信息的最精确封装（与 &lt;code&gt;help(Popen)&lt;/code&gt; 相对）：</target>
        </trans-unit>
        <trans-unit id="df51a7d6022c342aad00d00ab7ef7e5c14f28726" translate="yes" xml:space="preserve">
          <source>Here's the actual signature in the source and as shown by &lt;code&gt;help(run)&lt;/code&gt;:</source>
          <target state="translated">这是源代码中的实际签名，如 &lt;code&gt;help(run)&lt;/code&gt; 所示 ：</target>
        </trans-unit>
        <trans-unit id="2908129e81281b22c758cbb06b4955a1e130bec2" translate="yes" xml:space="preserve">
          <source>Hopefully this will help you make a decision on which library to use :)</source>
          <target state="translated">希望这能帮助你决定使用哪个图书馆 :)</target>
        </trans-unit>
        <trans-unit id="d51db9b97fe38ab99295964d3561093d6d5384a2" translate="yes" xml:space="preserve">
          <source>How do you call an external command (as if I'd typed it at the Unix shell or Windows command prompt) from within a Python script?</source>
          <target state="translated">如何在Python脚本中调用一个外部命令 (就像我在Unix shell或Windows命令提示符中键入一样)?</target>
        </trans-unit>
        <trans-unit id="36fa38bf21838dc62f7e8cb9fd98dc8c0092ddac" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;sh&lt;/code&gt; dropped Windows support, so it's not as awesome as it used to be. Install by &lt;code&gt;pip install sh&lt;/code&gt;.</source>
          <target state="translated">但是，不再提供Windows支持，因此它不再像以前那样出色。 通过 &lt;code&gt;pip install sh&lt;/code&gt; 安装 。</target>
        </trans-unit>
        <trans-unit id="f015f510394548ba21928d02139f329649001561" translate="yes" xml:space="preserve">
          <source>However, while this is convenient, you have to manually handle the escaping of shell characters such as spaces, etc.  On the other hand, this also lets you run commands which are simply shell commands and not actually external programs.  See &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.system&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">但是，尽管这很方便，但是您必须手动处理外壳字符（例如空格等）的转义。另一方面，这也使您可以运行只是外壳命令而非实际上是外部程序的命令。 请参阅&lt;a href=&quot;https://docs.python.org/2/library/os.html#os.system&quot;&gt;文档&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8ff91da18889bd85a334ef54dcb4f539b84312b" translate="yes" xml:space="preserve">
          <source>I always use &lt;code&gt;fabric&lt;/code&gt; for this things like:</source>
          <target state="translated">我总是用 &lt;code&gt;fabric&lt;/code&gt; 这样的事情：</target>
        </trans-unit>
        <trans-unit id="a34e56daccbd52ec707831ca674c7a9f92aa8b9c" translate="yes" xml:space="preserve">
          <source>I have not checked the code on other platforms and do not know the reasons of the behaviour on FreeBSD. If anyone knows, please share your ideas. Googling on starting background processes in Python does not shed any light yet.</source>
          <target state="translated">我没有检查过其他平台上的代码,也不知道FreeBSD上出现这种行为的原因。如果有人知道,请分享一下你的想法。Googling关于Python中启动后台进程的问题还没有找到答案。</target>
        </trans-unit>
        <trans-unit id="89a3de001ed039e3c675db0ed8e17c1de62d6bb7" translate="yes" xml:space="preserve">
          <source>I quite like &lt;a href=&quot;http://shell-command.readthedocs.org/en/latest/index.html&quot;&gt;shell_command&lt;/a&gt; for its simplicity.  It's built on top of the subprocess module.</source>
          <target state="translated">我非常喜欢&lt;a href=&quot;http://shell-command.readthedocs.org/en/latest/index.html&quot;&gt;shell_command&lt;/a&gt;的简单性。 它建立在子流程模块的顶部。</target>
        </trans-unit>
        <trans-unit id="bc6c376176890b6c7f696d60143eb6f24c04e18b" translate="yes" xml:space="preserve">
          <source>I recommend trying &lt;a href=&quot;https://github.com/kennethreitz/envoy&quot;&gt;Envoy&lt;/a&gt;. It's a wrapper for subprocess, which in turn &lt;a href=&quot;http://docs.python.org/2/library/subprocess.html&quot;&gt;aims to replace&lt;/a&gt; the older modules and functions. Envoy is subprocess for humans.</source>
          <target state="translated">我建议尝试&lt;a href=&quot;https://github.com/kennethreitz/envoy&quot;&gt;Envoy&lt;/a&gt; 。 它是子流程的包装，后者&lt;a href=&quot;http://docs.python.org/2/library/subprocess.html&quot;&gt;旨在替换&lt;/a&gt;较旧的模块和功能。 特使是人类的子过程。</target>
        </trans-unit>
        <trans-unit id="6f120f3c03a438bb08852a052c9519c10e97399d" translate="yes" xml:space="preserve">
          <source>I tend to use &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html&quot;&gt;subprocess&lt;/a&gt; together with &lt;a href=&quot;https://docs.python.org/2/library/shlex.html&quot;&gt;shlex&lt;/a&gt; (to handle escaping of quoted strings):</source>
          <target state="translated">我倾向于将&lt;a href=&quot;https://docs.python.org/2/library/subprocess.html&quot;&gt;子&lt;/a&gt; &lt;a href=&quot;https://docs.python.org/2/library/shlex.html&quot;&gt;进程&lt;/a&gt;与shlex一起使用（以处理带引号的字符串的转义）：</target>
        </trans-unit>
        <trans-unit id="a1fb0cafb2ff5f705a7913c2243d7361a24e9395" translate="yes" xml:space="preserve">
          <source>I tried subprocess, and execution was successful. However &amp;lt;b&amp;gt; could not communicate with &amp;lt;a&amp;gt;.
Everything is normal when I run both from the terminal.</source>
          <target state="translated">我尝试了子流程，执行成功。 但是&amp;lt;b&amp;gt;无法与&amp;lt;a&amp;gt;通信。 当我从终端运行时，一切都正常。</target>
        </trans-unit>
        <trans-unit id="20d0bdd77f0317c3ad96c6df5b327ec89ea4e117" translate="yes" xml:space="preserve">
          <source>I'd recommend using the &lt;a href=&quot;http://docs.python.org/library/subprocess.html&quot;&gt;subprocess&lt;/a&gt; module instead of os.system because it does shell escaping for you and is therefore much safer.</source>
          <target state="translated">我建议使用subprocess模块​​而不是os.system，因为它确实为您进行外壳转义，因此更加安全。</target>
        </trans-unit>
        <trans-unit id="3306f6b4f57a8e60469dc14d026d29435c7937c1" translate="yes" xml:space="preserve">
          <source>If check is true, and the process exits with a non-zero exit code, a
  CalledProcessError exception will be raised. Attributes of that
  exception hold the arguments, the exit code, and stdout and stderr if
  they were captured.</source>
          <target state="translated">如果check为true,并且进程以非零的退出代码退出,则会产生一个CalledProcessError异常。该异常的属性包含参数、退出代码,以及stdout和stderr(如果它们被捕获)。</target>
        </trans-unit>
        <trans-unit id="7513b2e3638518f8194dc11be855a41d965d8024" translate="yes" xml:space="preserve">
          <source>If shell is &lt;code&gt;True&lt;/code&gt;, the specified command will be executed through the shell. This can be useful if you are using Python primarily for the enhanced control flow it offers over most system shells and still want convenient access to other shell features such as shell pipes, filename wildcards, environment variable expansion, and expansion of ~ to a user&amp;rsquo;s home directory. However, note that Python itself offers implementations of many shell-like features (in particular, &lt;code&gt;glob&lt;/code&gt;, &lt;code&gt;fnmatch&lt;/code&gt;, &lt;code&gt;os.walk()&lt;/code&gt;, &lt;code&gt;os.path.expandvars()&lt;/code&gt;, &lt;code&gt;os.path.expanduser()&lt;/code&gt;, and &lt;code&gt;shutil&lt;/code&gt;).</source>
          <target state="translated">如果shell为 &lt;code&gt;True&lt;/code&gt; ，则将通过shell执行指定的命令。 如果您主要将Python用于大多数系统外壳程序提供的增强控制流，并且仍然希望方便地访问其他外壳程序功能（例如外壳程序管道，文件名通配符，环境变量扩展以及〜扩展到用户的家），则这可能很有用。目录。 但是，请注意，Python本身提供了许多类似于shell的功能（特别是 &lt;code&gt;glob&lt;/code&gt; ， &lt;code&gt;fnmatch&lt;/code&gt; ， &lt;code&gt;os.walk()&lt;/code&gt; ， &lt;code&gt;os.path.expandvars()&lt;/code&gt; ， &lt;code&gt;os.path.expanduser()&lt;/code&gt; 和 &lt;code&gt;shutil&lt;/code&gt; ）的实现。</target>
        </trans-unit>
        <trans-unit id="c64a88fb4da9b7b730048f1a8dd5918c6a117af0" translate="yes" xml:space="preserve">
          <source>If you do not mind external dependencies, use &lt;a href=&quot;https://pypi.python.org/pypi/plumbum&quot;&gt;plumbum&lt;/a&gt;:</source>
          <target state="translated">如果您不介意外部依赖性，请使用&lt;a href=&quot;https://pypi.python.org/pypi/plumbum&quot;&gt;plumbum&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="7363228fcdaba9c20bf56aae3fc8e7f106d140e2" translate="yes" xml:space="preserve">
          <source>If you need the output from the command you are calling,
then you can use &lt;a href=&quot;https://docs.python.org/3.6/library/subprocess.html#subprocess.check_output&quot;&gt;subprocess.check_output&lt;/a&gt; (Python 2.7+).</source>
          <target state="translated">如果需要调用命令的输出，则可以使用subprocess.check_output（Python 2.7+）。</target>
        </trans-unit>
        <trans-unit id="8f4e9f7315aeec38a6e52736117eab1064d48ef4" translate="yes" xml:space="preserve">
          <source>If you try &lt;code&gt;os.system(&quot;kwrite&quot;)&lt;/code&gt;, program flow freezes until the user closes kwrite. To overcome that I tried instead &lt;code&gt;os.system(konsole -e kwrite)&lt;/code&gt;. This time program continued to flow, but kwrite became the subprocess of the console.</source>
          <target state="translated">如果您尝试 &lt;code&gt;os.system(&quot;kwrite&quot;)&lt;/code&gt; ，程序流将冻结，直到用户关闭kwrite。 为了克服这个问题，我尝试改用 &lt;code&gt;os.system(konsole -e kwrite)&lt;/code&gt; 。 这个时间程序继续进行，但是kwrite成为了控制台的子进程。</target>
        </trans-unit>
        <trans-unit id="e7dd6dd4afa9c4d20e2b859c4c05c2f008a37f97" translate="yes" xml:space="preserve">
          <source>If you want to capture the output, you can pass &lt;code&gt;subprocess.PIPE&lt;/code&gt; to the appropriate &lt;code&gt;stderr&lt;/code&gt; or &lt;code&gt;stdout&lt;/code&gt;:</source>
          <target state="translated">如果要捕获输出，可以将 &lt;code&gt;subprocess.PIPE&lt;/code&gt; 传递给适当的 &lt;code&gt;stderr&lt;/code&gt; 或 &lt;code&gt;stdout&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="92362498e29cfb081397f0c34ab9249f9720243e" translate="yes" xml:space="preserve">
          <source>If you want to return the results of the command, you can use &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.popen&quot;&gt;&lt;code&gt;os.popen&lt;/code&gt;&lt;/a&gt;. However, this is deprecated since version 2.6 in favor of the &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#module-subprocess&quot;&gt;subprocess module&lt;/a&gt;, which other answers have covered well.</source>
          <target state="translated">如果要返回命令的结果，可以使用&lt;a href=&quot;https://docs.python.org/2/library/os.html#os.popen&quot;&gt; &lt;code&gt;os.popen&lt;/code&gt; &lt;/a&gt; 。 但是，自2.6版以来，不推荐使用此方法，而推荐使用&lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#module-subprocess&quot;&gt;subprocess模块&lt;/a&gt; ，其他答案也对此进行了很好的介绍。</target>
        </trans-unit>
        <trans-unit id="af2adabd4a25ba82a40a7045bc7d52e5e486b80a" translate="yes" xml:space="preserve">
          <source>If you're on Python 3.5 or later, you can use the new &lt;a href=&quot;https://docs.python.org/3.5/library/subprocess.html#subprocess.run&quot;&gt;&lt;code&gt;subprocess.run&lt;/code&gt;&lt;/a&gt; function, which is a lot like the above but even more flexible and returns a &lt;a href=&quot;https://docs.python.org/3.5/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;CompletedProcess&lt;/code&gt;&lt;/a&gt; object when the command finishes executing.</source>
          <target state="translated">如果您使用的是Python 3.5或更高版本，则可以使用新的&lt;a href=&quot;https://docs.python.org/3.5/library/subprocess.html#subprocess.run&quot;&gt; &lt;code&gt;subprocess.run&lt;/code&gt; &lt;/a&gt;函数，该函数与上面的代码非常相似，但是更加灵活，并在命令完成执行后返回&lt;a href=&quot;https://docs.python.org/3.5/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;CompletedProcess&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="a8c86e3653f19cdf348b2172a4bbdb83232ae1aa" translate="yes" xml:space="preserve">
          <source>In Windows you can just import the &lt;code&gt;subprocess&lt;/code&gt; module and run external commands by calling &lt;code&gt;subprocess.Popen()&lt;/code&gt;, &lt;code&gt;subprocess.Popen().communicate()&lt;/code&gt; and &lt;code&gt;subprocess.Popen().wait()&lt;/code&gt; as below:</source>
          <target state="translated">在Windows中，您可以导入 &lt;code&gt;subprocess&lt;/code&gt; 模块并通过调用 &lt;code&gt;subprocess.Popen()&lt;/code&gt; ， &lt;code&gt;subprocess.Popen().communicate()&lt;/code&gt; 和 &lt;code&gt;subprocess.Popen().wait()&lt;/code&gt; 来运行外部命令，如下所示：</target>
        </trans-unit>
        <trans-unit id="6098bdcea6354241592eea73912efde1afabb629" translate="yes" xml:space="preserve">
          <source>Installing &lt;code&gt;ts&lt;/code&gt; doesn't requires admin privileges. You can download and compile it from source with a simple &lt;code&gt;make&lt;/code&gt;, add it to your path and you're done.</source>
          <target state="translated">安装 &lt;code&gt;ts&lt;/code&gt; 不需要管理员权限。 您可以使用简单的 &lt;code&gt;make&lt;/code&gt; 从源代码下载并编译它，将其添加到路径中，就可以完成。</target>
        </trans-unit>
        <trans-unit id="e98b09203f0328a90cfc78f75d841debdd5b9276" translate="yes" xml:space="preserve">
          <source>It allows for interactive controlling of external programs/commands, even ssh, ftp, telnet, etc. You can just type something like:</source>
          <target state="translated">它允许交互式控制外部程序命令,甚至是ssh、ftp、telnet等。你只需键入类似这样的语句就可以了。</target>
        </trans-unit>
        <trans-unit id="2b17b931e5cc7a41baf907fc20f514914e06f75b" translate="yes" xml:space="preserve">
          <source>It can be this simple:</source>
          <target state="translated">可以这么简单。</target>
        </trans-unit>
        <trans-unit id="1876f45c1a10b475e3da4f444793d729e158467c" translate="yes" xml:space="preserve">
          <source>It is the best &lt;code&gt;subprocess&lt;/code&gt; wrapper. It's cross-platform, i.e. it works on both Windows and Unix-like systems. Install by &lt;code&gt;pip install plumbum&lt;/code&gt;.</source>
          <target state="translated">这是最好的 &lt;code&gt;subprocess&lt;/code&gt; 包装器。 它是跨平台的，即可以在Windows和类似Unix的系统上运行。 通过 &lt;code&gt;pip install plumbum&lt;/code&gt; 安装 。</target>
        </trans-unit>
        <trans-unit id="aaa07cbf594cc966ace34cd19c136a6ec2b63b2b" translate="yes" xml:space="preserve">
          <source>It is the recommended standard way. However, more complicated tasks (pipes, output, input, etc.) can be tedious to construct and write.</source>
          <target state="translated">这是推荐的标准方式。但是,比较复杂的任务(管道、输出、输入等)的构造和编写会比较繁琐。</target>
        </trans-unit>
        <trans-unit id="0950087da2cd9f6a22ccabfcf26acb05ebf55d6c" translate="yes" xml:space="preserve">
          <source>It's basically a wrapper for popen and shlex for now. It also supports piping commands so you can chain commands easier in Python. So you can do things like:</source>
          <target state="translated">它现在基本上是popen和shlex的一个包装器。它还支持piping命令,所以你可以在Python中更容易地串联命令。所以你可以做一些事情,比如</target>
        </trans-unit>
        <trans-unit id="684e4264c8db3e123a99d38088e818bc7f171eb5" translate="yes" xml:space="preserve">
          <source>Look at an example:</source>
          <target state="translated">看一个例子。</target>
        </trans-unit>
        <trans-unit id="1204c37bac4cb816da4fb8a8d0bc2c80ab7bd8aa" translate="yes" xml:space="preserve">
          <source>Look at the &lt;a href=&quot;https://docs.python.org/library/subprocess.html&quot;&gt;subprocess&lt;/a&gt; module in the standard library:</source>
          <target state="translated">查看标准库中的&lt;a href=&quot;https://docs.python.org/library/subprocess.html&quot;&gt;子流程&lt;/a&gt;模块：</target>
        </trans-unit>
        <trans-unit id="9233d608f7c0dc4bbdf19142923c6ea55bddb4ae" translate="yes" xml:space="preserve">
          <source>My target platform was FreeBSD, but the development was on Windows, so I faced the problem on Windows first.</source>
          <target state="translated">我的目标平台是FreeBSD,但开发是在Windows上,所以我首先面对的是Windows上的问题。</target>
        </trans-unit>
        <trans-unit id="3e19a10fe630c4891bdeeed97635e547e260c810" translate="yes" xml:space="preserve">
          <source>Note that this indicates that only the args list should be passed positionally. So pass the remaining arguments as keyword arguments.</source>
          <target state="translated">注意,这表明只需要将args列表作为位置传递。所以把剩下的参数作为关键字参数传递给对方。</target>
        </trans-unit>
        <trans-unit id="a24dc5dfdb8a300a722b06eb63d191c14fe3e25a" translate="yes" xml:space="preserve">
          <source>Note that this is dangerous, since the command isn't cleaned. I leave it up to you to google for the relevant documentation on the 'os' and 'sys' modules. There are a bunch of functions (exec* and spawn*) that will do similar things.</source>
          <target state="translated">注意,这很危险,因为这个命令没有被清理。我让你自己去谷歌上找'os'和'sys'模块的相关文档。有一堆函数(exec*和 spawn*)会做类似的事情。</target>
        </trans-unit>
        <trans-unit id="6d935935cd721060cd471db94f9ef7b7e4d625f4" translate="yes" xml:space="preserve">
          <source>Note, only &lt;code&gt;args&lt;/code&gt; should be passed positionally.</source>
          <target state="translated">注意，仅应在位置传递 &lt;code&gt;args&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13e1383053d018a118f339a408b60348fa0c10df" translate="yes" xml:space="preserve">
          <source>Notes about task spooler (&lt;code&gt;ts&lt;/code&gt;):</source>
          <target state="translated">有关任务后台处理程序（ &lt;code&gt;ts&lt;/code&gt; ）的注意事项：</target>
        </trans-unit>
        <trans-unit id="17f85f0219883423eaae3030acbe2e8068839e11" translate="yes" xml:space="preserve">
          <source>On FreeBSD we have another problem: when the parent process is finished, it finishes the child processes as well. And that is not what you want in a CGI script either. Some experiments showed that the problem seemed to be in sharing sys.stdout. And the working solution was the following:</source>
          <target state="translated">在 FreeBSD 上,我们还有一个问题:当父进程完成后,它也会完成子进程。而这也不是你在 CGI 脚本中想要的。一些实验表明,问题似乎出在共享 sys.stdout 上。而工作的解决方案如下。</target>
        </trans-unit>
        <trans-unit id="d77fda016063bfb5e284fb2828725f67f1e0abcd" translate="yes" xml:space="preserve">
          <source>On Windows (Windows&amp;nbsp;XP), the parent process will not finish until the longtask.py has finished its work. It is not what you want in a CGI script. The problem is not specific to Python; in the PHP community the problems are the same.</source>
          <target state="translated">在Windows（Windows XP）上，直到longtask.py完成工作后，父进程才会完成。 这不是CGI脚本中想要的。 这个问题不是特定于Python的。 在PHP社区中，问题是相同的。</target>
        </trans-unit>
        <trans-unit id="73cc2ccf316b575a875f3123af48e3e1bc8b7676" translate="yes" xml:space="preserve">
          <source>One might easily move from manually providing a command string (like the question suggests) to providing a string built programmatically. &lt;strong&gt;Don't build strings programmatically.&lt;/strong&gt; This is a potential security issue. It's better to assume you don't trust the input.</source>
          <target state="translated">可以很容易地从手动提供命令字符串（如问题所提示的）转变为以编程方式构建的字符串。 &lt;strong&gt;不要以编程方式构建字符串。&lt;/strong&gt; 这是一个潜在的安全问题。 最好假设您不信任输入。</target>
        </trans-unit>
        <trans-unit id="41a57f8f481028cebaba1e0f5469024183974d84" translate="yes" xml:space="preserve">
          <source>One more: 
(NOTE: kwrite behaves different from other applications. If you try the below with Firefox, the results will not be the same.)</source>
          <target state="translated">还有一个:(注意:kwrite的行为与其他应用程序不同。如果你在Firefox中尝试下面的方法,结果会不一样。)</target>
        </trans-unit>
        <trans-unit id="e25727ac8c89aabb607297c433808248a7a0e1e1" translate="yes" xml:space="preserve">
          <source>Original answer:</source>
          <target state="translated">原始答案:</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="9eb209cce757a602d7f2f0ca560ec376bddc2235" translate="yes" xml:space="preserve">
          <source>Pass a command list</source>
          <target state="translated">传递一个命令列表</target>
        </trans-unit>
        <trans-unit id="8cab791770584f20f8736085e6f06ba110e4d582" translate="yes" xml:space="preserve">
          <source>Pipe stuff around too:</source>
          <target state="translated">管子的东西也在附近。</target>
        </trans-unit>
        <trans-unit id="ebb071acd0b348557933898f1183ca1a9ebf2a6b" translate="yes" xml:space="preserve">
          <source>Popen</source>
          <target state="translated">Popen</target>
        </trans-unit>
        <trans-unit id="2bbaa21688c027b406e5f4b12b6e7be1b87ff580" translate="yes" xml:space="preserve">
          <source>Raise on failed run:</source>
          <target state="translated">跑步失败就加薪。</target>
        </trans-unit>
        <trans-unit id="bf8cfc7ba5a5f5bee4c9521c60f879e6686ff1dc" translate="yes" xml:space="preserve">
          <source>Run a process:</source>
          <target state="translated">运行一个过程。</target>
        </trans-unit>
        <trans-unit id="770bbd7c071f378133b5752a9ea61c937cf5ce7e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#subprocess.call&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#subprocess.call&quot;&gt;文档&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f169459d9aa145196151308de045b7515b46ab1" translate="yes" xml:space="preserve">
          <source>Shameless plug, I wrote a library for this :P
&lt;a href=&quot;https://github.com/houqp/shell.py&quot;&gt;https://github.com/houqp/shell.py&lt;/a&gt;</source>
          <target state="translated">无耻的插件，我为此写了一个库：P &lt;a href=&quot;https://github.com/houqp/shell.py&quot;&gt;https://github.com/houqp/shell.py&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="253723ab412e01a3b5346e6c5bead7538a06547e" translate="yes" xml:space="preserve">
          <source>Simple, use &lt;code&gt;subprocess.run&lt;/code&gt;, which returns a &lt;code&gt;CompletedProcess&lt;/code&gt; object:</source>
          <target state="translated">简单，使用 &lt;code&gt;subprocess.run&lt;/code&gt; ，它返回 &lt;code&gt;CompletedProcess&lt;/code&gt; 对象：</target>
        </trans-unit>
        <trans-unit id="96916a7d5b2c00cca0f4d8225cd04dfa73ef6174" translate="yes" xml:space="preserve">
          <source>Some hints on detaching the child process from the calling one (starting the child process in background).</source>
          <target state="translated">关于脱离调用子程序的一些提示(在后台启动子程序)。</target>
        </trans-unit>
        <trans-unit id="0ff80ac32b33346bf44e846d95580df486157012" translate="yes" xml:space="preserve">
          <source>Subprocess allows you to call external commands and connect them to their input/output/error pipes (stdin, stdout, and stderr). Subprocess is the default choice for running commands, but sometimes other modules are better.</source>
          <target state="translated">Subprocess允许你调用外部命令,并将它们连接到它们的输入输出管道(stdin、stdout和stderr)。Subprocess是运行命令的默认选择,但有时其他模块会更好。</target>
        </trans-unit>
        <trans-unit id="02d03c537f5a1c1351c07e93fd9b4e1c806b46a3" translate="yes" xml:space="preserve">
          <source>Suppose you want to start a long task from a CGI script. That is, the child process should live longer than the CGI script execution process.</source>
          <target state="translated">假设你想从CGI脚本中启动一个长任务。也就是说,子进程的寿命应该比CGI脚本执行进程长。</target>
        </trans-unit>
        <trans-unit id="4bf5eed33409a9d4cce95fee5d4f206f094bd0c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/library/os.html#os.system&quot;&gt;official documentation&lt;/a&gt; recommends the &lt;code&gt;subprocess&lt;/code&gt; module over the alternative &lt;code&gt;os.system()&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/library/os.html#os.system&quot;&gt;官方文档&lt;/a&gt;建议使用替代 &lt;code&gt;os.system()&lt;/code&gt; 的 &lt;code&gt;subprocess&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="afab629b263a23850b4a4c4fab6559124e8a2b16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/library/subprocess.html#replacing-older-functions-with-the-subprocess-module&quot;&gt;Replacing Older Functions with the subprocess Module&lt;/a&gt; section in the &lt;code&gt;subprocess&lt;/code&gt; documentation may have some helpful recipes.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/library/subprocess.html#replacing-older-functions-with-the-subprocess-module&quot;&gt;子&lt;/a&gt; &lt;code&gt;subprocess&lt;/code&gt; 文档中的用子流程模块替换较早的功能部分可能有一些有用的方法。</target>
        </trans-unit>
        <trans-unit id="3d3e9d8c82b51530830672b08d0ef35fbab40e8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Popen&lt;/code&gt; class of the &lt;code&gt;subprocess&lt;/code&gt; module.  This is intended as a replacement for &lt;code&gt;os.popen&lt;/code&gt; but has the downside of being slightly more complicated by virtue of being so comprehensive.  For example, you'd say:</source>
          <target state="translated">&lt;code&gt;subprocess&lt;/code&gt; 模块的 &lt;code&gt;Popen&lt;/code&gt; 类。 它打算替代 &lt;code&gt;os.popen&lt;/code&gt; ,但缺点是由于过于全面而变得稍微复杂一些。 例如，您会说：</target>
        </trans-unit>
        <trans-unit id="dc4253a08585d55cf4522486cf9b6b0fd47078e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; function from the &lt;code&gt;subprocess&lt;/code&gt; module.  This is basically just like the &lt;code&gt;Popen&lt;/code&gt; class and takes all of the same arguments, but it simply waits until the command completes and gives you the return code.  For example:</source>
          <target state="translated">来自 &lt;code&gt;subprocess&lt;/code&gt; 模块的 &lt;code&gt;call&lt;/code&gt; 函数。 基本上，这和 &lt;code&gt;Popen&lt;/code&gt; 类一样，并接受所有相同的参数，但是它只是等待命令完成并提供返回代码。 例如：</target>
        </trans-unit>
        <trans-unit id="0f65b9b491329c7dcc455e3c2ab564bc130ce4f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;popenargs&lt;/code&gt; and &lt;code&gt;kwargs&lt;/code&gt; are given to the &lt;code&gt;Popen&lt;/code&gt; constructor. &lt;code&gt;input&lt;/code&gt; can be a string of bytes (or unicode, if specify encoding or &lt;code&gt;universal_newlines=True&lt;/code&gt;) that will be piped to the subprocess's stdin.</source>
          <target state="translated">将 &lt;code&gt;popenargs&lt;/code&gt; 和 &lt;code&gt;kwargs&lt;/code&gt; 赋予Popen构造函数。 &lt;code&gt;input&lt;/code&gt; 可以是将通过管道传递到子流程的stdin的字节字符串（或unicode，如果指定了encoding或 &lt;code&gt;universal_newlines=True&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="597f463d6181383c2aa9eec8291dee90c9093b6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subprocess&lt;/code&gt; module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function [&lt;a href=&quot;https://docs.python.org/library/os.html#os.system&quot;&gt;&lt;code&gt;os.system()&lt;/code&gt;&lt;/a&gt;].</source>
          <target state="translated">&lt;code&gt;subprocess&lt;/code&gt; 模块提供了更强大的功能来生成新流程并检索其结果。 使用该模块优于使用此功能[ &lt;a href=&quot;https://docs.python.org/library/os.html#os.system&quot;&gt; &lt;code&gt;os.system()&lt;/code&gt; &lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="67d0649a95bbe6d8f66c8ce42cbc0bbe2015de0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subprocess&lt;/code&gt; module should probably be what you use.</source>
          <target state="translated">&lt;code&gt;subprocess&lt;/code&gt; 模块可能应该是您所使用的模块。</target>
        </trans-unit>
        <trans-unit id="4bcefe52191489f5553bf306d97423d4d878396f" translate="yes" xml:space="preserve">
          <source>The advantage of &lt;code&gt;subprocess&lt;/code&gt; vs. &lt;code&gt;system&lt;/code&gt; is that it is more flexible (you can get the &lt;code&gt;stdout&lt;/code&gt;, &lt;code&gt;stderr&lt;/code&gt;, the &quot;real&quot; status code, better error handling, etc...).</source>
          <target state="translated">&lt;code&gt;subprocess&lt;/code&gt; 相对于 &lt;code&gt;system&lt;/code&gt; 的优势在于它更加灵活（您可以获取 &lt;code&gt;stdout&lt;/code&gt; ， &lt;code&gt;stderr&lt;/code&gt; ，&amp;ldquo;真实&amp;rdquo;状态代码，更好的错误处理等）。</target>
        </trans-unit>
        <trans-unit id="7f6b131d63315089780cb79a3bbe13a68d7390e4" translate="yes" xml:space="preserve">
          <source>The classical example from the subprocess module documentation is:</source>
          <target state="translated">从子程序模块文档中的经典例子是:。</target>
        </trans-unit>
        <trans-unit id="d9e6b82421ed6a6933bae7646b83fa3f410deae4" translate="yes" xml:space="preserve">
          <source>The documentation describes &lt;code&gt;timeout=&lt;/code&gt; and &lt;code&gt;check=True&lt;/code&gt; better than I could:</source>
          <target state="translated">该文档比我能更好地描述 &lt;code&gt;timeout=&lt;/code&gt; 和 &lt;code&gt;check=True&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2599271d58968cf1345f8ce1dcef378e8bb253f8" translate="yes" xml:space="preserve">
          <source>The edit was based on J.F. Sebastian's comment.</source>
          <target state="translated">编辑根据J.F.Sebastian的评论进行了编辑。</target>
        </trans-unit>
        <trans-unit id="9375ec9cf1e1a48088ebd84b5d61ce8b4d2113fd" translate="yes" xml:space="preserve">
          <source>The idea here is that you do not want to wait in the line 'call subprocess' until the longtask.py is finished. But it is not clear what happens after the line 'some more code here' from the example.</source>
          <target state="translated">这里的想法是,你不想在'调用子进程'这行'call subprocess'中等待,直到longtask.py完成。但不清楚例子中的'这里还有一些代码'这一行之后会发生什么。</target>
        </trans-unit>
        <trans-unit id="0362ab403486d100b39df78902a34185bb350a53" translate="yes" xml:space="preserve">
          <source>The os module also has all of the fork/exec/spawn functions that you'd have in a C program, but I don't recommend using them directly.</source>
          <target state="translated">os模块也有所有的forkexecspawn函数,你可以在C程序中使用,但我不建议直接使用它们。</target>
        </trans-unit>
        <trans-unit id="d17b17fb1061b744b6a11011160bfee60f824a44" translate="yes" xml:space="preserve">
          <source>The recommended approach to invoking subprocesses is to use the run() function for all use cases it can handle. For more advanced use cases, the underlying Popen interface can be used directly.</source>
          <target state="translated">推荐的调用子进程的方法是在它能处理的所有用例中使用run()函数。对于更高级的用例,可以直接使用底层Popen接口。</target>
        </trans-unit>
        <trans-unit id="797610109e8cd0a523dfb35244a626e04eef5841" translate="yes" xml:space="preserve">
          <source>The solution is to pass DETACHED_PROCESS &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx&quot;&gt;Process Creation Flag&lt;/a&gt; to the underlying CreateProcess function in Windows API.
If you happen to have installed pywin32, you can import the flag from the win32process module, otherwise you should define it yourself:</source>
          <target state="translated">解决方案是将DETACHED_PROCESS &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx&quot;&gt;进程创建标志&lt;/a&gt;传递给Windows API中的基础CreateProcess函数。 如果碰巧安装了pywin32，则可以从win32process模块​​中导入该标志，否则您应该自己定义它：</target>
        </trans-unit>
        <trans-unit id="852fa7991bff81d637c1d755f860b4928e883903" translate="yes" xml:space="preserve">
          <source>The timeout argument is passed to Popen.communicate(). If the timeout
  expires, the child process will be killed and waited for. The
  TimeoutExpired exception will be re-raised after the child process has
  terminated.</source>
          <target state="translated">超时参数被传递给Popen.communicat()。如果超时过期,子进程将被杀死并等待。在子进程终止后,TimeoutExpired异常将被重新提出。</target>
        </trans-unit>
        <trans-unit id="74e1ee39ecbbaf46f408aa59d7805c5b18bc39a2" translate="yes" xml:space="preserve">
          <source>There are lots of different libraries which allow you to call external commands with Python. For each library I've given a description and shown an example of calling an external command. The command I used as the example is &lt;code&gt;ls -l&lt;/code&gt; (list all files). If you want to find out more about any of the libraries I've listed and linked the documentation for each of them.</source>
          <target state="translated">有很多不同的库，可让您使用Python调用外部命令。 对于每个库，我都进行了描述，并显示了调用外部命令的示例。 我用作示例的命令是 &lt;code&gt;ls -l&lt;/code&gt; （列出所有文件）。 如果您想了解有关任何库的更多信息，我已列出并链接了每个库的文档。</target>
        </trans-unit>
        <trans-unit id="3faf13f8df1bc7e3959874fdea7e123c8931bbc5" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;http://plumbum.readthedocs.org/en/latest/&quot;&gt;Plumbum&lt;/a&gt;</source>
          <target state="translated">还有&lt;a href=&quot;http://plumbum.readthedocs.org/en/latest/&quot;&gt;铅&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="523e816fff3d635b4b57a3c72de2f42570b0fc48" translate="yes" xml:space="preserve">
          <source>There is another difference here which is not mentioned previously.</source>
          <target state="translated">这里还有一个区别,是前面没有提到的。</target>
        </trans-unit>
        <trans-unit id="dff6fe0f782361a67af3bcde93ee7b9df92bd107" translate="yes" xml:space="preserve">
          <source>This is how I run my commands. This code has everything you need pretty much</source>
          <target state="translated">这就是我如何运行我的命令。这段代码几乎包含了你所需要的一切</target>
        </trans-unit>
        <trans-unit id="c7245e51bd7139e445469159ab77eaaaf30497c0" translate="yes" xml:space="preserve">
          <source>Typical implementation:</source>
          <target state="translated">典型的实施方式。</target>
        </trans-unit>
        <trans-unit id="31ff876228262ef5e8f98bb8df82ae987194c0be" translate="yes" xml:space="preserve">
          <source>Under Linux, in case you would like to call an external command that will execute independently (will keep running after the python script terminates), you can use a simple queue as &lt;a href=&quot;http://vicerveza.homeunix.net/~viric/soft/ts/&quot;&gt;task spooler&lt;/a&gt; or the &lt;a href=&quot;https://linux.die.net/man/1/at&quot;&gt;at&lt;/a&gt; command</source>
          <target state="translated">在Linux下，如果您想调用将独立执行的外部命令（在python脚本终止后将继续运行），则可以使用简单的队列作为&lt;a href=&quot;http://vicerveza.homeunix.net/~viric/soft/ts/&quot;&gt;任务假脱机程序&lt;/a&gt;或&lt;a href=&quot;https://linux.die.net/man/1/at&quot;&gt;at&lt;/a&gt;命令</target>
        </trans-unit>
        <trans-unit id="bdf5a0a4c93fff1b17f183c226012273c1d43069" translate="yes" xml:space="preserve">
          <source>Understanding the remaining documentation on &lt;code&gt;Popen&lt;/code&gt; will be left as an exercise for the reader.</source>
          <target state="translated">读者可以自己掌握有关 &lt;code&gt;Popen&lt;/code&gt; 的其余文档的知识。</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="a724e226efd328d314410553d9d0a6c3eb761723" translate="yes" xml:space="preserve">
          <source>Use &lt;em&gt;&lt;a href=&quot;https://docs.python.org/2/library/subprocess.html&quot;&gt;subprocess&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">使用&lt;em&gt;&lt;a href=&quot;https://docs.python.org/2/library/subprocess.html&quot;&gt;子过程&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="edd176fcbe63d71b143043c47f74083e7b9d9787" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://docs.python.org/2/library/os.html&quot;&gt;os module&lt;/a&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.python.org/2/library/os.html&quot;&gt;os模块&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="19a090ab4bedfbcf29e7da7a4077073280a686e2" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt;subprocess module&lt;/a&gt; (Python 3):</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt;子流程模块&lt;/a&gt; （Python 3）：</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="448cfe5db01084af3e9371ab7cf08e61c69bb1c3" translate="yes" xml:space="preserve">
          <source>We can inspect the returned object and see the command that was given and the returncode:</source>
          <target state="translated">我们可以对返回的对象进行检查,看到给出的命令和返回码。</target>
        </trans-unit>
        <trans-unit id="3bb310ac00cac6fcd37979db1016551743aa642b" translate="yes" xml:space="preserve">
          <source>When use &lt;code&gt;Popen&lt;/code&gt; instead? I would struggle to find use-case based on the arguments alone. Direct usage of &lt;code&gt;Popen&lt;/code&gt; would, however, give you access to its methods, including &lt;code&gt;poll&lt;/code&gt;, 'send_signal', 'terminate', and 'wait'.</source>
          <target state="translated">何时使用 &lt;code&gt;Popen&lt;/code&gt; 代替？ 我将很难仅根据参数来找到用例。 但是，直接使用 &lt;code&gt;Popen&lt;/code&gt; 可以使您访问其方法，包括 &lt;code&gt;poll&lt;/code&gt; ，'send_signal'，'terminate'和'wait'。</target>
        </trans-unit>
        <trans-unit id="d77989c1e3c0e0ace735631597dc367ffdfa6f32" translate="yes" xml:space="preserve">
          <source>Why?</source>
          <target state="translated">Why?</target>
        </trans-unit>
        <trans-unit id="18f27c9ee823db5e4c0a614a16980da6367604a3" translate="yes" xml:space="preserve">
          <source>With external dependencies</source>
          <target state="translated">有了外部依附关系</target>
        </trans-unit>
        <trans-unit id="d14ab858678072f32ca74ab1b82e081dfcfc055d" translate="yes" xml:space="preserve">
          <source>With output of the result:</source>
          <target state="translated">随着输出的结果。</target>
        </trans-unit>
        <trans-unit id="aaaa9eb5d49bd41216be4aab4c1d7019aec73518" translate="yes" xml:space="preserve">
          <source>With the standard library</source>
          <target state="translated">有了标准的图书馆</target>
        </trans-unit>
        <trans-unit id="a163f8072d2582ac0b08270fa37f04b08c90ff97" translate="yes" xml:space="preserve">
          <source>Without the output of the result:</source>
          <target state="translated">没有输出的结果。</target>
        </trans-unit>
        <trans-unit id="e7cdf9aef9dcc1e68939ec2e3584bf7ad40cff4d" translate="yes" xml:space="preserve">
          <source>You are free to do what you want with the &lt;code&gt;stdout&lt;/code&gt; data in the pipe.  In fact, you can simply omit those parameters (&lt;code&gt;stdout=&lt;/code&gt; and &lt;code&gt;stderr=&lt;/code&gt;) and it'll behave like &lt;code&gt;os.system()&lt;/code&gt;.</source>
          <target state="translated">您可以随意使用管道中的 &lt;code&gt;stdout&lt;/code&gt; 数据执行所需的操作。 实际上，您可以简单地忽略这些参数（ &lt;code&gt;stdout=&lt;/code&gt; 和 &lt;code&gt;stderr=&lt;/code&gt; ），其行为类似于 &lt;code&gt;os.system()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c122bf1eaa4c6177c760488496e22187b9c197dc" translate="yes" xml:space="preserve">
          <source>You could set the number of concurrent processes to be run (&quot;slots&quot;) with:</source>
          <target state="translated">你可以设置要运行的并发进程的数量(&quot;插槽&quot;)。</target>
        </trans-unit>
        <trans-unit id="e9dbd017d634c57685e9ea83e3ab03bb5edef87f" translate="yes" xml:space="preserve">
          <source>and imagine that the user enters something &quot;my mama didnt love me &amp;amp;&amp;amp; rm -rf /&quot; which could erase the whole filesystem.</source>
          <target state="translated">并想象用户输入了&amp;ldquo;我的妈妈不爱我&amp;amp;&amp;amp; rm -rf /&amp;rdquo;这可能会擦除整个文件系统的信息。</target>
        </trans-unit>
        <trans-unit id="f17ada58f79678c2c2c55e53fc4e2f5df1f34d13" translate="yes" xml:space="preserve">
          <source>and this example for &lt;code&gt;check=True&lt;/code&gt; is better than one I could come up with:</source>
          <target state="translated">这个 &lt;code&gt;check=True&lt;/code&gt; 的示例比我能想到的示例更好：</target>
        </trans-unit>
        <trans-unit id="70d923d5b13c8294ffdbf19c5dbe40d59fe15cbf" translate="yes" xml:space="preserve">
          <source>but it is nice to have all of the options there in one unified class instead of 4 different popen functions.  See &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#popen-constructor&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">但是将所有选项都放在一个统一的类中而不是4个不同的popen函数是一个很好的选择。 请参阅&lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#popen-constructor&quot;&gt;文档&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="b904e73103fc2e4e766606e93e37406669eeba11" translate="yes" xml:space="preserve">
          <source>commands: &lt;a href=&quot;https://docs.python.org/2/library/commands.html&quot;&gt;https://docs.python.org/2/library/commands.html&lt;/a&gt;</source>
          <target state="translated">命令： &lt;a href=&quot;https://docs.python.org/2/library/commands.html&quot;&gt;https&lt;/a&gt; ： //docs.python.org/2/library/commands.html</target>
        </trans-unit>
        <trans-unit id="52d303eda30df68defd302e06660eb6bb684fbb9" translate="yes" xml:space="preserve">
          <source>envoy is known as &quot;subprocess for humans&quot;. It is used as a convenience wrapper around the &lt;code&gt;subprocess&lt;/code&gt; module.</source>
          <target state="translated">特使被称为&amp;ldquo;人类子过程&amp;rdquo;。 它用作 &lt;code&gt;subprocess&lt;/code&gt; 模块周围的便利包装。</target>
        </trans-unit>
        <trans-unit id="da9733bfafc172eabc90b2758bfeab6b4cb34a4f" translate="yes" xml:space="preserve">
          <source>envoy: &lt;a href=&quot;https://github.com/kennethreitz/envoy&quot;&gt;https://github.com/kennethreitz/envoy&lt;/a&gt;</source>
          <target state="translated">特使： &lt;a href=&quot;https://github.com/kennethreitz/envoy&quot;&gt;https&lt;/a&gt; : //github.com/kennethreitz/envoy</target>
        </trans-unit>
        <trans-unit id="d7f621f19f6af467ef23fb98f8ee0c656389c12a" translate="yes" xml:space="preserve">
          <source>fabric is a Python 2.5 and 2.7 library. It allows you to execute local and remote shell commands. Fabric is simple alternative for running commands in a secure shell (SSH)</source>
          <target state="translated">fabric 是一个 Python 2.5 和 2.7 库。它允许你执行本地和远程shell命令。Fabric 是在安全 shell (SSH)中运行命令的简单选择。</target>
        </trans-unit>
        <trans-unit id="b1a08d055b8bb30483bf0ea122392e6d37082e73" translate="yes" xml:space="preserve">
          <source>fabric: &lt;a href=&quot;http://www.fabfile.org/&quot;&gt;http://www.fabfile.org/&lt;/a&gt;</source>
          <target state="translated">面料： &lt;a href=&quot;http://www.fabfile.org/&quot;&gt;http&lt;/a&gt; ： //www.fabfile.org/</target>
        </trans-unit>
        <trans-unit id="6c8457cd65849bf5a9285f8b862e990e1a44ac09" translate="yes" xml:space="preserve">
          <source>instead of:</source>
          <target state="translated">而不是:</target>
        </trans-unit>
        <trans-unit id="5957da8d14d5f58f81aefab1967a97dba4f1d41b" translate="yes" xml:space="preserve">
          <source>os is used for &quot;operating system dependent functionality&quot;. It can also be used to call external commands with &lt;code&gt;os.system&lt;/code&gt; and &lt;code&gt;os.popen&lt;/code&gt; (Note: There is also a subprocess.popen). os will always run the shell and is a simple alternative for people who don't need to, or don't know how to use &lt;code&gt;subprocess.run&lt;/code&gt;.</source>
          <target state="translated">os用于&amp;ldquo;取决于操作系统的功能&amp;rdquo;。 它也可以用于通过 &lt;code&gt;os.system&lt;/code&gt; 和 &lt;code&gt;os.popen&lt;/code&gt; 调用外部命令（注意：还有一个subprocess.popen ）。 os将始终运行该shell，对于不需要或不知道如何使用 &lt;code&gt;subprocess.run&lt;/code&gt; 的人们来说，它是一个简单的选择。</target>
        </trans-unit>
        <trans-unit id="cbcca4febe8f373e15156fec6a4033260e13e466" translate="yes" xml:space="preserve">
          <source>os: &lt;a href=&quot;https://docs.python.org/3.5/library/os.html&quot;&gt;https://docs.python.org/3.5/library/os.html&lt;/a&gt;</source>
          <target state="translated">操作系统： &lt;a href=&quot;https://docs.python.org/3.5/library/os.html&quot;&gt;https&lt;/a&gt; ： //docs.python.org/3.5/library/os.html</target>
        </trans-unit>
        <trans-unit id="a8d9686cb58c073c2456d6dd10a62bd7b4149915" translate="yes" xml:space="preserve">
          <source>pexpect lets you spawn child applications, control them and find patterns in their output. This is a better alternative to subprocess for commands that expect a tty on Unix.</source>
          <target state="translated">pexpect可以让你生成子程序,控制它们,并在它们的输出中找到模式。对于Unix上期望有tty的命令来说,这是子进程的更好的选择。</target>
        </trans-unit>
        <trans-unit id="42668b41f9ed9ad1246add137130a19892d12138" translate="yes" xml:space="preserve">
          <source>pexpect: &lt;a href=&quot;https://pexpect.readthedocs.io/en/stable/&quot;&gt;https://pexpect.readthedocs.io/en/stable/&lt;/a&gt;</source>
          <target state="translated">pexpect： &lt;a href=&quot;https://pexpect.readthedocs.io/en/stable/&quot;&gt;https&lt;/a&gt; ://pexpect.readthedocs.io/en/stable/</target>
        </trans-unit>
        <trans-unit id="af8ce099c02940f7dae91a34a3b1ac9f97531070" translate="yes" xml:space="preserve">
          <source>plumbum is a library for &quot;script-like&quot; Python programs. You can call programs like functions as in &lt;code&gt;sh&lt;/code&gt;. Plumbum is useful if you want to run a pipeline without the shell.</source>
          <target state="translated">plumbum是用于&amp;ldquo;类似脚本&amp;rdquo;的Python程序的库。 您可以像 &lt;code&gt;sh&lt;/code&gt; 中的函数那样调用程序。 如果您要在没有外壳的情况下运行管道，则Plumbum很有用。</target>
        </trans-unit>
        <trans-unit id="1e6a45273361198ccb9f4fb2ba60008d603a5712" translate="yes" xml:space="preserve">
          <source>plumbum: &lt;a href=&quot;https://plumbum.readthedocs.io/en/latest/&quot;&gt;https://plumbum.readthedocs.io/en/latest/&lt;/a&gt;</source>
          <target state="translated">铅： &lt;a href=&quot;https://plumbum.readthedocs.io/en/latest/&quot;&gt;https&lt;/a&gt; : //plumbum.readthedocs.io/en/latest/</target>
        </trans-unit>
        <trans-unit id="24560916a5b723031ab61aae18088346943f299c" translate="yes" xml:space="preserve">
          <source>sh is a subprocess interface which lets you call programs as if they were functions. This is useful if you want to run a command multiple times.</source>
          <target state="translated">sh是一个子进程接口,可以让你像调用函数一样调用程序。如果你想多次运行一条命令,这很有用。</target>
        </trans-unit>
        <trans-unit id="08f15a5c418f54cf27af2fee84fb94963fd9c7be" translate="yes" xml:space="preserve">
          <source>sh: &lt;a href=&quot;https://amoffat.github.io/sh/&quot;&gt;https://amoffat.github.io/sh/&lt;/a&gt;</source>
          <target state="translated">sh： &lt;a href=&quot;https://amoffat.github.io/sh/&quot;&gt;https&lt;/a&gt; : //amoffat.github.io/sh/</target>
        </trans-unit>
        <trans-unit id="b2f1ab3fa95d766a02a1042a18e5de4b6ce04e69" translate="yes" xml:space="preserve">
          <source>shlex: &lt;a href=&quot;https://docs.python.org/3/library/shlex.html&quot;&gt;https://docs.python.org/3/library/shlex.html&lt;/a&gt;</source>
          <target state="translated">shlex： &lt;a href=&quot;https://docs.python.org/3/library/shlex.html&quot;&gt;https&lt;/a&gt; ：//docs.python.org/3/library/shlex.html</target>
        </trans-unit>
        <trans-unit id="215f1313cfe29ed2c9cd0789a6c38b916645aedc" translate="yes" xml:space="preserve">
          <source>subprocess: &lt;a href=&quot;https://docs.python.org/3.5/library/subprocess.html&quot;&gt;https://docs.python.org/3.5/library/subprocess.html&lt;/a&gt;</source>
          <target state="translated">子流程： &lt;a href=&quot;https://docs.python.org/3.5/library/subprocess.html&quot;&gt;https&lt;/a&gt; ： //docs.python.org/3.5/library/subprocess.html</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
