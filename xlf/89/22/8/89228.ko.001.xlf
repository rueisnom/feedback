<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/89228">
    <body>
      <group id="89228">
        <trans-unit id="2fa022bd967a52296e65e0e93e4983b8a1355086" translate="yes" xml:space="preserve">
          <source>(I find it interesting and slightly counterintuitive that the version info gets put to stderr instead of stdout.)</source>
          <target state="translated">(버전 정보가 stdout 대신 stderr에 배치되는 것이 흥미롭고 약간 반 직관적입니다.)</target>
        </trans-unit>
        <trans-unit id="d73ee7e04c378d99b234285f778f66d6d33d3f5e" translate="yes" xml:space="preserve">
          <source>...or for a very simple command:</source>
          <target state="translated">... 또는 매우 간단한 명령 :</target>
        </trans-unit>
        <trans-unit id="03e119785353bdbc85f2148afb573722fd371740" translate="yes" xml:space="preserve">
          <source>/* &lt;em&gt;UPD 2015.10.27&lt;/em&gt; @eryksun in a comment below notes, that the semantically correct flag is CREATE_NEW_CONSOLE (0x00000010) */</source>
          <target state="translated">/ * &lt;em&gt;UPD 2015.10.27&lt;/em&gt; @eryksun 아래 주석에서 의미 적으로 올바른 플래그는 CREATE_NEW_CONSOLE (0x00000010) * /입니다.</target>
        </trans-unit>
        <trans-unit id="a13e78e8e9e3bfa32930177509f879f3e0e23897" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;commands&lt;/code&gt; contains wrapper functions for &lt;code&gt;os.popen&lt;/code&gt;, but it has been removed from Python 3 since &lt;code&gt;subprocess&lt;/code&gt; is a better alternative.</source>
          <target state="translated">&lt;code&gt;commands&lt;/code&gt; 에는 &lt;code&gt;os.popen&lt;/code&gt; 래퍼 함수가 포함되어 있지만 &lt;code&gt;subprocess&lt;/code&gt; 가 더 나은 대안이므로 Python 3에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="4c8bf122b90b453d9cf47e82094c872bf30dbac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.system(&quot;some_command with args&quot;)&lt;/code&gt; passes the command and arguments to your system's shell.  This is nice because you can actually run multiple commands at once in this manner and set up pipes and input/output redirection.  For example:</source>
          <target state="translated">&lt;code&gt;os.system(&quot;some_command with args&quot;)&lt;/code&gt; 는 명령과 인수를 시스템 쉘에 전달합니다. 이 방법으로 실제로 여러 명령을 한 번에 실행하고 파이프 및 입 / 출력 리디렉션을 설정할 수 있기 때문에 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f933a6d1f532e7034395c9645f4d7b96a2af4e03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.system&lt;/code&gt; does not allow you to store results, so if you want to store results in some list or something, a &lt;code&gt;subprocess.call&lt;/code&gt; works.</source>
          <target state="translated">&lt;code&gt;os.system&lt;/code&gt; 을 사용하면 결과를 저장할 수 없으므로 결과를 일부 목록 또는 무언가에 저장하려는 경우 &lt;code&gt;subprocess.call&lt;/code&gt; 이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e0a4cc68bc86b75a6e42b06c428e42fa3f4d7cd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.system&lt;/code&gt; is OK, but kind of dated.  It's also not very secure.  Instead, try &lt;code&gt;subprocess&lt;/code&gt;.  &lt;code&gt;subprocess&lt;/code&gt; does not call sh directly and is therefore more secure than &lt;code&gt;os.system&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os.system&lt;/code&gt; 은 정상이지만 날짜가 있습니다. 또한 매우 안전하지 않습니다. 대신 &lt;code&gt;subprocess&lt;/code&gt; 를 시도하십시오. &lt;code&gt;subprocess&lt;/code&gt; 는 sh를 직접 호출하지 않으므로 &lt;code&gt;os.system&lt;/code&gt; 보다 안전 합니다 .</target>
        </trans-unit>
        <trans-unit id="1be8c4f39fb826c1206cfeb8a2a8525188e3ba01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run&lt;/code&gt; waits for the command to successfully finish, then returns a &lt;code&gt;CompletedProcess&lt;/code&gt; object. It may instead raise &lt;code&gt;TimeoutExpired&lt;/code&gt; (if you give it a &lt;code&gt;timeout=&lt;/code&gt; argument) or &lt;code&gt;CalledProcessError&lt;/code&gt; (if it fails and you pass &lt;code&gt;check=True&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 은 명령이 성공적으로 완료 될 때까지 기다린 다음 &lt;code&gt;CompletedProcess&lt;/code&gt; 객체를 반환합니다. 대신 &lt;code&gt;TimeoutExpired&lt;/code&gt; ( &lt;code&gt;timeout=&lt;/code&gt; 인수를 제공 한 경우) 또는 &lt;code&gt;CalledProcessError&lt;/code&gt; (실패하고 &lt;code&gt;check=True&lt;/code&gt; 를 전달한 경우)가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37700740d479dac1f23a3d7e42187418def430b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stream = os.popen(&quot;some_command with args&quot;)&lt;/code&gt; will do the same thing as &lt;code&gt;os.system&lt;/code&gt; except that it gives you a file-like object that you can use to access standard input/output for that process.  There are 3 other variants of popen that all handle the i/o slightly differently.  If you pass everything as a string, then your command is passed to the shell; if you pass them as a list then you don't need to worry about escaping anything.  See &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.popen&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;stream = os.popen(&quot;some_command with args&quot;)&lt;/code&gt; 는 &lt;code&gt;os.system&lt;/code&gt; 과 동일한 작업을 수행하여 해당 프로세스의 표준 입 / 출력에 액세스하는 데 사용할 수있는 파일과 유사한 객체를 제공합니다. 모두 다른 방식으로 i / o를 처리하는 3 가지 다른 종류의 popen이 있습니다. 모든 것을 문자열로 전달하면 명령이 셸로 전달됩니다. 당신이 그들을 목록으로 전달하면 아무것도 탈출에 대해 걱정할 필요가 없습니다. &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.popen&quot;&gt;설명서를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4416f3a6f2bce6eeb7854601cba76dadb8bf5bd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subprocess.Popen&lt;/code&gt; executes the &amp;lt;command&amp;gt; as a subprocess. In my case, I need to execute file &amp;lt;a&amp;gt; which needs to communicate with another program, &amp;lt;b&amp;gt;.</source>
          <target state="translated">&lt;code&gt;subprocess.Popen&lt;/code&gt; 은 &amp;lt;command&amp;gt;를 하위 프로세스로 실행합니다. 제 경우에는 다른 프로그램 인 &amp;lt;b&amp;gt;와 통신해야하는 &amp;lt;a&amp;gt; 파일을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="33e4bd1cac6b8c03f49979ab4855183ec2d516b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subprocess.check_call&lt;/code&gt; is convenient if you don't want to test return values. It throws an exception on any error.</source>
          <target state="translated">반환 값을 테스트하지 않으려는 경우 &lt;code&gt;subprocess.check_call&lt;/code&gt; 이 편리합니다. 오류가 발생하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ff4a1b97ccf371c558c702bd25078a23e3ea92ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subprocess.run&lt;/code&gt; is the recommended approach &lt;a href=&quot;https://docs.python.org/3.6/whatsnew/3.5.html#whatsnew-subprocess&quot;&gt;as of Python 3.5&lt;/a&gt; if your code does not need to maintain compatibility with earlier Python versions. It's more consistent and offers similar ease-of-use as Envoy. (Piping isn't as straightforward though. See &lt;a href=&quot;https://stackoverflow.com/questions/7389662/link-several-popen-commands-with-pipes&quot;&gt;this question for how&lt;/a&gt;.)</source>
          <target state="translated">코드에서 이전 Python 버전과의 호환성을 유지할 필요가없는 경우 &lt;code&gt;subprocess.run&lt;/code&gt; 은 &lt;a href=&quot;https://docs.python.org/3.6/whatsnew/3.5.html#whatsnew-subprocess&quot;&gt;Python 3.5&lt;/a&gt; 부터 권장되는 방법입니다. 보다 일관성 있고 Envoy와 비슷한 사용 편의성을 제공합니다. (배관은 간단하지 않습니다. 방법에 대해서는 &lt;a href=&quot;https://stackoverflow.com/questions/7389662/link-several-popen-commands-with-pipes&quot;&gt;이 질문을&lt;/a&gt; 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="6c10957c993d4d3137d83cbbd9734cf58bddc749" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note on Python version: If you are still using Python 2, &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#subprocess.call&quot;&gt;subprocess.call&lt;/a&gt; works in a similar way.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Python 버전 참고 사항 : 여전히 Python 2를 사용하는 경우 &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#subprocess.call&quot;&gt;subprocess.call도&lt;/a&gt; 비슷한 방식으로 작동합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="abdf1ab661fc1bb5d31823425f22c54b0fe0a4c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ProTip: &lt;a href=&quot;https://docs.python.org/2/library/shlex.html#shlex.split&quot;&gt;shlex.split&lt;/a&gt; can help you to parse the command for &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and other &lt;code&gt;subprocess&lt;/code&gt; functions in case you don't want (or you can't!) provide them in form of lists:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ProTip : &lt;a href=&quot;https://docs.python.org/2/library/shlex.html#shlex.split&quot;&gt;shlex.split&lt;/a&gt; 을 사용하면 &lt;code&gt;run&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; 및 기타 &lt;code&gt;subprocess&lt;/code&gt; 함수에 대한 명령을 목록 형식으로 제공하지 않으려는 경우 (또는 할 수없는 경우) 구문 분석 할 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2beb69e6e367fef69658c1d696a2a07e072fa71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sources:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Sources:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fae92702cc843aed7b6f7742cd5bf98fb81d5390" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;These are all the libraries:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다음은 모든 라이브러리입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="122b554b12ec9d4243a60880464396676946c117" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;commands&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;commands&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="295a7b21b6132cb7af6f19ee9b55d3e68dccd713" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;envoy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;envoy&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0f149e4b6717c8ff1d7cb99cddbe344ab27b8f06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fabric&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;fabric&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57b5d2dd621b183cb3e77e4464994db536fc8f8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;os - This module provides a portable way of using operating system-dependent functionality.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;os-이 모듈은 운영 체제 종속 기능을 사용하는 이식 가능한 방법을 제공합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce67685e9d0f0271929077ff3385b7f97cb94aa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;os&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;os&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e109416858f9fd7878d662f569388a7e5ac5120e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;pexpect&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;pexpect&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8ee21152a9f689364ff72189ea954186f6d2bea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;plumbum&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;plumbum&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fe04888499cbb6a1a7308e216ab1b1883dd3550a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;sh&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;sh&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a295458c00f4d8f888b9bb2e34b5e88b7961da8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;subprocess&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;subprocess&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f4b0ef6809aac2c4cea3880f034fe3f8c0e1165" translate="yes" xml:space="preserve">
          <source>Also note the &lt;a href=&quot;https://docs.python.org/3.6/library/subprocess.html#frequently-used-arguments&quot;&gt;shell&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.6/library/subprocess.html#frequently-used-arguments&quot;&gt;쉘&lt;/a&gt; 매개 변수도 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="12fa2ebb13aa4c6f3737660d048e954b248d81c2" translate="yes" xml:space="preserve">
          <source>An example with task spooler:</source>
          <target state="translated">작업 스풀러의 예 :</target>
        </trans-unit>
        <trans-unit id="783369e650b595352e4b203badb3f8950cfa6399" translate="yes" xml:space="preserve">
          <source>Another popular library is &lt;a href=&quot;https://pypi.python.org/pypi/sh&quot;&gt;sh&lt;/a&gt;:</source>
          <target state="translated">또 다른 인기있는 라이브러리는 &lt;a href=&quot;https://pypi.python.org/pypi/sh&quot;&gt;sh입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7810dfe6b8148f0e818246c5528184e5ee081bc" translate="yes" xml:space="preserve">
          <source>Anyone runs the kwrite not being a subprocess (i.e. in the system monitor it must appear at the leftmost edge of the tree).</source>
          <target state="translated">누구나 kwrite를 하위 프로세스가 아닌 상태로 실행합니다 (즉, 시스템 모니터에서 트리의 가장 왼쪽 가장자리에 표시되어야 함).</target>
        </trans-unit>
        <trans-unit id="cb2a196ab266c2677a36a1ff39e9a77602d3e268" translate="yes" xml:space="preserve">
          <source>As of Python 3.5, the documentation recommends &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt;subprocess.run&lt;/a&gt;:</source>
          <target state="translated">Python 3.5부터 문서는 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt;subprocess.run을&lt;/a&gt; 권장합니다.</target>
        </trans-unit>
        <trans-unit id="e0a5626c26468b935b29b7609635694dc9b379ed" translate="yes" xml:space="preserve">
          <source>As you might infer from the above example, stdout and stderr both get piped to your own stdout and stderr by default.</source>
          <target state="translated">위의 예에서 알 수 있듯이 stdout 및 stderr은 기본적으로 자신의 stdout 및 stderr로 파이프됩니다.</target>
        </trans-unit>
        <trans-unit id="71e8fb399394db284421a62daa01522b012fe135" translate="yes" xml:space="preserve">
          <source>But more informative is &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#popen-constructor&quot;&gt;the &lt;code&gt;Popen&lt;/code&gt; documentation&lt;/a&gt;:</source>
          <target state="translated">그러나 더 많은 정보는 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#popen-constructor&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; 문서입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42c3d980ac63ed21471d91749f0230e954125b26" translate="yes" xml:space="preserve">
          <source>But this seem to be a good tool: &lt;a href=&quot;https://github.com/amoffat/sh&quot;&gt;&lt;code&gt;sh&lt;/code&gt; (Python subprocess interface)&lt;/a&gt;.</source>
          <target state="translated">그러나 이것은 좋은 도구 인 것 같습니다 : &lt;a href=&quot;https://github.com/amoffat/sh&quot;&gt; &lt;code&gt;sh&lt;/code&gt; (Python subprocess interface)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="040353c1be3fc4d64bd7a04883d5de25a9889047" translate="yes" xml:space="preserve">
          <source>Calling an external command from Python</source>
          <target state="translated">파이썬에서 외부 명령 호출</target>
        </trans-unit>
        <trans-unit id="73d24b095f38cb410b90189e614453dd440a6a13" translate="yes" xml:space="preserve">
          <source>Calling an external command in Python</source>
          <target state="translated">파이썬에서 외부 명령 호출</target>
        </trans-unit>
        <trans-unit id="73c1ff3b1f2c79f4fb4b9eeeb7f9489bc652b2ed" translate="yes" xml:space="preserve">
          <source>Capture output:</source>
          <target state="translated">캡처 출력 :</target>
        </trans-unit>
        <trans-unit id="821248556b70b1a5b77fcba34211dde7762c0d29" translate="yes" xml:space="preserve">
          <source>Capturing output</source>
          <target state="translated">출력 캡처</target>
        </trans-unit>
        <trans-unit id="7b6e4384f3588ea08309a1d68b2c594a5a6ef91d" translate="yes" xml:space="preserve">
          <source>Check the &quot;pexpect&quot; Python library, too.</source>
          <target state="translated">&quot;pexpect&quot;Python 라이브러리도 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="04c1ab878cc2981820a3c703c587e0b1e6d43b31" translate="yes" xml:space="preserve">
          <source>Example usage from &lt;a href=&quot;https://github.com/kennethreitz/envoy#readme&quot;&gt;the README&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/kennethreitz/envoy#readme&quot;&gt;README의&lt;/a&gt; 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="85d1e51f42bcdee83f1807c85ad03b44972f7625" translate="yes" xml:space="preserve">
          <source>Execute a child program in a new process. On POSIX, the class uses
  os.execvp()-like behavior to execute the child program. On Windows,
  the class uses the Windows CreateProcess() function. The arguments to
  Popen are as follows.</source>
          <target state="translated">새 프로세스에서 하위 프로그램을 실행하십시오. POSIX에서 클래스는 os.execvp ()와 유사한 동작을 사용하여 자식 프로그램을 실행합니다. Windows에서 클래스는 Windows CreateProcess () 함수를 사용합니다. Popen에 대한 주장은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a714c705dea02d0d422508d397211ab5d0c556f" translate="yes" xml:space="preserve">
          <source>Expanded Signature</source>
          <target state="translated">확장 된 서명</target>
        </trans-unit>
        <trans-unit id="4793ba5a9403e9efafa59c26d506241288256613" translate="yes" xml:space="preserve">
          <source>Finally please be aware that for all methods where you pass the final command to be executed by the shell as a string and you are responsible for escaping it. &lt;strong&gt;There are serious security implications&lt;/strong&gt; if any part of the string that you pass can not be fully trusted. For example, if a user is entering some/any part of the string. If you are unsure, only use these methods with constants. To give you a hint of the implications consider this code:</source>
          <target state="translated">마지막으로 쉘이 문자열로 실행하도록 최종 명령을 전달하는 모든 메소드에 대해 이스케이프 처리해야합니다. 전달하는 문자열의 일부를 완전히 신뢰할 수없는 경우 &lt;strong&gt;보안에 심각한 영향을 미칩니다&lt;/strong&gt; . 예를 들어, 사용자가 문자열의 일부 또는 일부를 입력하는 경우. 확실하지 않은 경우 상수와 함께이 방법 만 사용하십시오. 의미에 대한 힌트를 제공하려면 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="fd628ede4dea14449c2bd6ce7ddc3a17d4be5bc0" translate="yes" xml:space="preserve">
          <source>For the more &lt;code&gt;os&lt;/code&gt; functions, &lt;a href=&quot;https://docs.python.org/2/library/os.html&quot;&gt;here&lt;/a&gt; is the documentation.</source>
          <target state="translated">더 많은 &lt;code&gt;os&lt;/code&gt; 기능에 대해서는 다음 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9c4ae2ec46821c328b164a9bd8097808acc3eb0e" translate="yes" xml:space="preserve">
          <source>For versions of Python before 3.5, use &lt;code&gt;call&lt;/code&gt;:</source>
          <target state="translated">3.5 이전의 Python 버전의 경우 &lt;code&gt;call&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="048b33f3180e834803e6dc87333de2eb9542760b" translate="yes" xml:space="preserve">
          <source>Full Signature</source>
          <target state="translated">완전한 서명</target>
        </trans-unit>
        <trans-unit id="6d74b3bf384964ae40c82bc487f9ebeeff7b54bd" translate="yes" xml:space="preserve">
          <source>Get more information &lt;a href=&quot;https://docs.python.org/library/subprocess.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;https://docs.python.org/library/subprocess.html&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1ddee242c3c47b20fdebe1a8e42128b53fe1db7" translate="yes" xml:space="preserve">
          <source>Here's a summary of the ways to call external programs and the advantages and disadvantages of each:</source>
          <target state="translated">다음은 외부 프로그램을 호출하는 방법과 각각의 장단점을 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="69638c61ab5a206a75c4a4d3c5fd0660eeea0a49" translate="yes" xml:space="preserve">
          <source>Here's an example from the documentation:</source>
          <target state="translated">다음은 설명서의 예입니다.</target>
        </trans-unit>
        <trans-unit id="89e73100a297543bdc607a0b518448335c8e3a66" translate="yes" xml:space="preserve">
          <source>Here's an example of the simplest possible usage - and it does exactly as asked:</source>
          <target state="translated">가장 간단한 사용법의 예는 다음과 같습니다. 요청한대로 정확하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a57c3b7a9b591fcf528aa657d826d36e28aadd44" translate="yes" xml:space="preserve">
          <source>Here's an expanded signature, as given in the documentation:</source>
          <target state="translated">설명서에 제공된 확장 된 서명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f8248ec43960110eab95fc9c88ecc8149428271" translate="yes" xml:space="preserve">
          <source>Here's some examples from &lt;a href=&quot;https://docs.python.org/3.6/library/subprocess.html#subprocess.run&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">다음 &lt;a href=&quot;https://docs.python.org/3.6/library/subprocess.html#subprocess.run&quot;&gt;은 문서&lt;/a&gt; 의 일부 예입니다.</target>
        </trans-unit>
        <trans-unit id="7df370006ffdbaaae32d6957ed8cd623e4cabd51" translate="yes" xml:space="preserve">
          <source>Here's the &lt;code&gt;Popen&lt;/code&gt; signature as given in &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/subprocess.py#L587&quot;&gt;the source&lt;/a&gt;. I think this is the most precise encapsulation of the information (as opposed to &lt;code&gt;help(Popen)&lt;/code&gt;):</source>
          <target state="translated">다음 &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/subprocess.py#L587&quot;&gt;은 source에&lt;/a&gt; 제공된 &lt;code&gt;Popen&lt;/code&gt; 서명입니다. 나는 이것이 &lt;code&gt;help(Popen)&lt;/code&gt; 과는 반대로 정보의 가장 정확한 캡슐화라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="df51a7d6022c342aad00d00ab7ef7e5c14f28726" translate="yes" xml:space="preserve">
          <source>Here's the actual signature in the source and as shown by &lt;code&gt;help(run)&lt;/code&gt;:</source>
          <target state="translated">다음은 소스의 실제 서명이며 &lt;code&gt;help(run)&lt;/code&gt; 로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2908129e81281b22c758cbb06b4955a1e130bec2" translate="yes" xml:space="preserve">
          <source>Hopefully this will help you make a decision on which library to use :)</source>
          <target state="translated">바라건대 이것은 사용할 라이브러리를 결정하는 데 도움이 될 것입니다. :)</target>
        </trans-unit>
        <trans-unit id="d51db9b97fe38ab99295964d3561093d6d5384a2" translate="yes" xml:space="preserve">
          <source>How do you call an external command (as if I'd typed it at the Unix shell or Windows command prompt) from within a Python script?</source>
          <target state="translated">파이썬 스크립트에서 외부 명령 (유닉스 쉘이나 Windows 명령 프롬프트에서 입력 한 것처럼)을 어떻게 호출합니까?</target>
        </trans-unit>
        <trans-unit id="36fa38bf21838dc62f7e8cb9fd98dc8c0092ddac" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;sh&lt;/code&gt; dropped Windows support, so it's not as awesome as it used to be. Install by &lt;code&gt;pip install sh&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;sh&lt;/code&gt; 는 Windows 지원을 중단했기 때문에 예전처럼 훌륭하지 않았습니다. &lt;code&gt;pip install sh&lt;/code&gt; 로 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="f015f510394548ba21928d02139f329649001561" translate="yes" xml:space="preserve">
          <source>However, while this is convenient, you have to manually handle the escaping of shell characters such as spaces, etc.  On the other hand, this also lets you run commands which are simply shell commands and not actually external programs.  See &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.system&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">그러나 이것은 편리하지만 공백과 같은 쉘 문자의 이스케이프 처리를 수동으로 처리해야합니다. 반면에, 이것은 실제로 외부 프로그램이 아닌 단순히 쉘 명령 인 명령을 실행할 수있게합니다. &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.system&quot;&gt;설명서를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a8ff91da18889bd85a334ef54dcb4f539b84312b" translate="yes" xml:space="preserve">
          <source>I always use &lt;code&gt;fabric&lt;/code&gt; for this things like:</source>
          <target state="translated">나는 항상 다음과 같은 것을 위해 &lt;code&gt;fabric&lt;/code&gt; 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a34e56daccbd52ec707831ca674c7a9f92aa8b9c" translate="yes" xml:space="preserve">
          <source>I have not checked the code on other platforms and do not know the reasons of the behaviour on FreeBSD. If anyone knows, please share your ideas. Googling on starting background processes in Python does not shed any light yet.</source>
          <target state="translated">다른 플랫폼에서 코드를 확인하지 않았으며 FreeBSD에서의 동작의 이유를 모릅니다. 누구나 알고 있다면 아이디어를 공유하십시오. 파이썬에서 백그라운드 프로세스를 시작하는 인터넷 검색은 아직 밝혀지지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="89a3de001ed039e3c675db0ed8e17c1de62d6bb7" translate="yes" xml:space="preserve">
          <source>I quite like &lt;a href=&quot;http://shell-command.readthedocs.org/en/latest/index.html&quot;&gt;shell_command&lt;/a&gt; for its simplicity.  It's built on top of the subprocess module.</source>
          <target state="translated">나는 단순함을 위해 &lt;a href=&quot;http://shell-command.readthedocs.org/en/latest/index.html&quot;&gt;shell_command&lt;/a&gt; 를 아주 좋아합니다. 하위 프로세스 모듈 위에 구축되었습니다.</target>
        </trans-unit>
        <trans-unit id="bc6c376176890b6c7f696d60143eb6f24c04e18b" translate="yes" xml:space="preserve">
          <source>I recommend trying &lt;a href=&quot;https://github.com/kennethreitz/envoy&quot;&gt;Envoy&lt;/a&gt;. It's a wrapper for subprocess, which in turn &lt;a href=&quot;http://docs.python.org/2/library/subprocess.html&quot;&gt;aims to replace&lt;/a&gt; the older modules and functions. Envoy is subprocess for humans.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/kennethreitz/envoy&quot;&gt;Envoy&lt;/a&gt; 시도해 보는 것이 좋습니다. 하위 프로세스의 래퍼로, 이전 모듈과 함수 &lt;a href=&quot;http://docs.python.org/2/library/subprocess.html&quot;&gt;를 대체&lt;/a&gt; 하는 것을 목표로 합니다. 특사는 인간의 하위 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="6f120f3c03a438bb08852a052c9519c10e97399d" translate="yes" xml:space="preserve">
          <source>I tend to use &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html&quot;&gt;subprocess&lt;/a&gt; together with &lt;a href=&quot;https://docs.python.org/2/library/shlex.html&quot;&gt;shlex&lt;/a&gt; (to handle escaping of quoted strings):</source>
          <target state="translated">나는 인용 된 문자열의 이스케이프를 처리하기 위해 &lt;a href=&quot;https://docs.python.org/2/library/shlex.html&quot;&gt;shlex&lt;/a&gt; 와 함께 &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html&quot;&gt;서브 프로세스&lt;/a&gt; 를 사용하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1fb0cafb2ff5f705a7913c2243d7361a24e9395" translate="yes" xml:space="preserve">
          <source>I tried subprocess, and execution was successful. However &amp;lt;b&amp;gt; could not communicate with &amp;lt;a&amp;gt;.
Everything is normal when I run both from the terminal.</source>
          <target state="translated">하위 프로세스를 시도했는데 실행이 성공했습니다. 그러나 &amp;lt;b&amp;gt;은 &amp;lt;a&amp;gt;와 통신 할 수 없습니다. 터미널에서 둘 다 실행할 때 모든 것이 정상입니다.</target>
        </trans-unit>
        <trans-unit id="20d0bdd77f0317c3ad96c6df5b327ec89ea4e117" translate="yes" xml:space="preserve">
          <source>I'd recommend using the &lt;a href=&quot;http://docs.python.org/library/subprocess.html&quot;&gt;subprocess&lt;/a&gt; module instead of os.system because it does shell escaping for you and is therefore much safer.</source>
          <target state="translated">os.system 대신 &lt;a href=&quot;http://docs.python.org/library/subprocess.html&quot;&gt;subprocess&lt;/a&gt; 모듈을 사용하는 것이 좋습니다. 쉘 이스케이프 처리가 훨씬 안전하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3306f6b4f57a8e60469dc14d026d29435c7937c1" translate="yes" xml:space="preserve">
          <source>If check is true, and the process exits with a non-zero exit code, a
  CalledProcessError exception will be raised. Attributes of that
  exception hold the arguments, the exit code, and stdout and stderr if
  they were captured.</source>
          <target state="translated">check가 true이고 프로세스가 0이 아닌 종료 코드로 종료되면 CalledProcessError 예외가 발생합니다. 해당 예외의 속성은 인수, 종료 코드 및 stdout 및 stderr이 캡처 된 경우 보유합니다.</target>
        </trans-unit>
        <trans-unit id="7513b2e3638518f8194dc11be855a41d965d8024" translate="yes" xml:space="preserve">
          <source>If shell is &lt;code&gt;True&lt;/code&gt;, the specified command will be executed through the shell. This can be useful if you are using Python primarily for the enhanced control flow it offers over most system shells and still want convenient access to other shell features such as shell pipes, filename wildcards, environment variable expansion, and expansion of ~ to a user&amp;rsquo;s home directory. However, note that Python itself offers implementations of many shell-like features (in particular, &lt;code&gt;glob&lt;/code&gt;, &lt;code&gt;fnmatch&lt;/code&gt;, &lt;code&gt;os.walk()&lt;/code&gt;, &lt;code&gt;os.path.expandvars()&lt;/code&gt;, &lt;code&gt;os.path.expanduser()&lt;/code&gt;, and &lt;code&gt;shutil&lt;/code&gt;).</source>
          <target state="translated">shell이 &lt;code&gt;True&lt;/code&gt; 이면 지정된 명령이 셸을 통해 실행됩니다. 이것은 대부분의 시스템 셸에서 제공하는 향상된 제어 흐름을 위해 Python을 주로 사용하면서 셸 파이프, 파일 이름 와일드 카드, 환경 변수 확장 및 사용자의 집으로 ~ 확장과 같은 다른 셸 기능에 편리하게 액세스하려는 경우 유용합니다. 예배 규칙서. 그러나 Python 자체는 많은 쉘과 같은 기능 (특히 &lt;code&gt;glob&lt;/code&gt; , &lt;code&gt;fnmatch&lt;/code&gt; , &lt;code&gt;os.walk()&lt;/code&gt; , &lt;code&gt;os.path.expandvars()&lt;/code&gt; , &lt;code&gt;os.path.expanduser()&lt;/code&gt; 및 &lt;code&gt;shutil&lt;/code&gt; )의 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c64a88fb4da9b7b730048f1a8dd5918c6a117af0" translate="yes" xml:space="preserve">
          <source>If you do not mind external dependencies, use &lt;a href=&quot;https://pypi.python.org/pypi/plumbum&quot;&gt;plumbum&lt;/a&gt;:</source>
          <target state="translated">외부 의존성을 신경 쓰지 않으면 &lt;a href=&quot;https://pypi.python.org/pypi/plumbum&quot;&gt;plumbum을&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7363228fcdaba9c20bf56aae3fc8e7f106d140e2" translate="yes" xml:space="preserve">
          <source>If you need the output from the command you are calling,
then you can use &lt;a href=&quot;https://docs.python.org/3.6/library/subprocess.html#subprocess.check_output&quot;&gt;subprocess.check_output&lt;/a&gt; (Python 2.7+).</source>
          <target state="translated">호출하는 명령의 출력이 필요한 경우 &lt;a href=&quot;https://docs.python.org/3.6/library/subprocess.html#subprocess.check_output&quot;&gt;subprocess.check_output&lt;/a&gt; (Python 2.7+)을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f4e9f7315aeec38a6e52736117eab1064d48ef4" translate="yes" xml:space="preserve">
          <source>If you try &lt;code&gt;os.system(&quot;kwrite&quot;)&lt;/code&gt;, program flow freezes until the user closes kwrite. To overcome that I tried instead &lt;code&gt;os.system(konsole -e kwrite)&lt;/code&gt;. This time program continued to flow, but kwrite became the subprocess of the console.</source>
          <target state="translated">&lt;code&gt;os.system(&quot;kwrite&quot;)&lt;/code&gt; 을 시도하면 사용자가 kwrite를 닫을 때까지 프로그램 흐름이 정지됩니다. 그것을 극복하기 위해 대신 &lt;code&gt;os.system(konsole -e kwrite)&lt;/code&gt; 시도했습니다. 이번에는 프로그램이 계속 진행되었지만 kwrite는 콘솔의 하위 프로세스가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e7dd6dd4afa9c4d20e2b859c4c05c2f008a37f97" translate="yes" xml:space="preserve">
          <source>If you want to capture the output, you can pass &lt;code&gt;subprocess.PIPE&lt;/code&gt; to the appropriate &lt;code&gt;stderr&lt;/code&gt; or &lt;code&gt;stdout&lt;/code&gt;:</source>
          <target state="translated">출력을 캡처하려면 &lt;code&gt;subprocess.PIPE&lt;/code&gt; 를 적절한 &lt;code&gt;stderr&lt;/code&gt; 또는 &lt;code&gt;stdout&lt;/code&gt; 에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92362498e29cfb081397f0c34ab9249f9720243e" translate="yes" xml:space="preserve">
          <source>If you want to return the results of the command, you can use &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.popen&quot;&gt;&lt;code&gt;os.popen&lt;/code&gt;&lt;/a&gt;. However, this is deprecated since version 2.6 in favor of the &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#module-subprocess&quot;&gt;subprocess module&lt;/a&gt;, which other answers have covered well.</source>
          <target state="translated">명령 결과를 리턴하려면 &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.popen&quot;&gt; &lt;code&gt;os.popen&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다. 그러나 이것은 &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#module-subprocess&quot;&gt;하위 프로세스 모듈&lt;/a&gt; 을 선호하여 버전 2.6부터 더 이상 사용되지 않으며 다른 답변도 잘 다루었습니다.</target>
        </trans-unit>
        <trans-unit id="af2adabd4a25ba82a40a7045bc7d52e5e486b80a" translate="yes" xml:space="preserve">
          <source>If you're on Python 3.5 or later, you can use the new &lt;a href=&quot;https://docs.python.org/3.5/library/subprocess.html#subprocess.run&quot;&gt;&lt;code&gt;subprocess.run&lt;/code&gt;&lt;/a&gt; function, which is a lot like the above but even more flexible and returns a &lt;a href=&quot;https://docs.python.org/3.5/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;CompletedProcess&lt;/code&gt;&lt;/a&gt; object when the command finishes executing.</source>
          <target state="translated">Python 3.5 이상을 사용하는 경우 새로운 &lt;a href=&quot;https://docs.python.org/3.5/library/subprocess.html#subprocess.run&quot;&gt; &lt;code&gt;subprocess.run&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다.이 함수는 위와 비슷하지만 훨씬 유연하며 명령 실행이 완료되면 &lt;a href=&quot;https://docs.python.org/3.5/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;CompletedProcess&lt;/code&gt; &lt;/a&gt; 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a8c86e3653f19cdf348b2172a4bbdb83232ae1aa" translate="yes" xml:space="preserve">
          <source>In Windows you can just import the &lt;code&gt;subprocess&lt;/code&gt; module and run external commands by calling &lt;code&gt;subprocess.Popen()&lt;/code&gt;, &lt;code&gt;subprocess.Popen().communicate()&lt;/code&gt; and &lt;code&gt;subprocess.Popen().wait()&lt;/code&gt; as below:</source>
          <target state="translated">Windows에서는 다음과 같이 &lt;code&gt;subprocess.Popen()&lt;/code&gt; , &lt;code&gt;subprocess.Popen().communicate()&lt;/code&gt; 및 &lt;code&gt;subprocess.Popen().wait()&lt;/code&gt; 을 호출하여 &lt;code&gt;subprocess&lt;/code&gt; 모듈을 가져오고 외부 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6098bdcea6354241592eea73912efde1afabb629" translate="yes" xml:space="preserve">
          <source>Installing &lt;code&gt;ts&lt;/code&gt; doesn't requires admin privileges. You can download and compile it from source with a simple &lt;code&gt;make&lt;/code&gt;, add it to your path and you're done.</source>
          <target state="translated">&lt;code&gt;ts&lt;/code&gt; 를 설치하는 데 관리자 권한이 필요하지 않습니다. 간단한 &lt;code&gt;make&lt;/code&gt; 를 사용하여 소스에서 다운로드하여 컴파일하고 경로에 추가하면 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="e98b09203f0328a90cfc78f75d841debdd5b9276" translate="yes" xml:space="preserve">
          <source>It allows for interactive controlling of external programs/commands, even ssh, ftp, telnet, etc. You can just type something like:</source>
          <target state="translated">ssh, ftp, telnet 등의 외부 프로그램 / 명령을 대화식으로 제어 할 수 있습니다. 다음과 같이 입력하면됩니다.</target>
        </trans-unit>
        <trans-unit id="2b17b931e5cc7a41baf907fc20f514914e06f75b" translate="yes" xml:space="preserve">
          <source>It can be this simple:</source>
          <target state="translated">다음과 같이 간단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1876f45c1a10b475e3da4f444793d729e158467c" translate="yes" xml:space="preserve">
          <source>It is the best &lt;code&gt;subprocess&lt;/code&gt; wrapper. It's cross-platform, i.e. it works on both Windows and Unix-like systems. Install by &lt;code&gt;pip install plumbum&lt;/code&gt;.</source>
          <target state="translated">최고의 &lt;code&gt;subprocess&lt;/code&gt; 래퍼입니다. 크로스 플랫폼입니다. 즉, Windows 및 Unix 계열 시스템에서 작동합니다. &lt;code&gt;pip install plumbum&lt;/code&gt; 로 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="aaa07cbf594cc966ace34cd19c136a6ec2b63b2b" translate="yes" xml:space="preserve">
          <source>It is the recommended standard way. However, more complicated tasks (pipes, output, input, etc.) can be tedious to construct and write.</source>
          <target state="translated">권장되는 표준 방법입니다. 그러나보다 복잡한 작업 (파이프, 출력, 입력 등)은 구성하고 작성하는 데 지루할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0950087da2cd9f6a22ccabfcf26acb05ebf55d6c" translate="yes" xml:space="preserve">
          <source>It's basically a wrapper for popen and shlex for now. It also supports piping commands so you can chain commands easier in Python. So you can do things like:</source>
          <target state="translated">기본적으로 popen 및 shlex의 래퍼입니다. 파이핑 명령도 지원하므로 Python에서 명령을 더 쉽게 연결할 수 있습니다. 따라서 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="684e4264c8db3e123a99d38088e818bc7f171eb5" translate="yes" xml:space="preserve">
          <source>Look at an example:</source>
          <target state="translated">예를보십시오 :</target>
        </trans-unit>
        <trans-unit id="1204c37bac4cb816da4fb8a8d0bc2c80ab7bd8aa" translate="yes" xml:space="preserve">
          <source>Look at the &lt;a href=&quot;https://docs.python.org/library/subprocess.html&quot;&gt;subprocess&lt;/a&gt; module in the standard library:</source>
          <target state="translated">표준 라이브러리에서 &lt;a href=&quot;https://docs.python.org/library/subprocess.html&quot;&gt;서브 프로세스&lt;/a&gt; 모듈을보십시오.</target>
        </trans-unit>
        <trans-unit id="9233d608f7c0dc4bbdf19142923c6ea55bddb4ae" translate="yes" xml:space="preserve">
          <source>My target platform was FreeBSD, but the development was on Windows, so I faced the problem on Windows first.</source>
          <target state="translated">내 목표 플랫폼은 FreeBSD 였지만 개발은 Windows에 있었으므로 Windows에서 먼저 문제에 직면했습니다.</target>
        </trans-unit>
        <trans-unit id="3e19a10fe630c4891bdeeed97635e547e260c810" translate="yes" xml:space="preserve">
          <source>Note that this indicates that only the args list should be passed positionally. So pass the remaining arguments as keyword arguments.</source>
          <target state="translated">이는 args 목록 만 위치 적으로 전달해야 함을 나타냅니다. 나머지 인수는 키워드 인수로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="a24dc5dfdb8a300a722b06eb63d191c14fe3e25a" translate="yes" xml:space="preserve">
          <source>Note that this is dangerous, since the command isn't cleaned. I leave it up to you to google for the relevant documentation on the 'os' and 'sys' modules. There are a bunch of functions (exec* and spawn*) that will do similar things.</source>
          <target state="translated">명령이 정리되지 않았으므로 위험합니다. 'os'및 'sys'모듈에 대한 관련 문서는 Google에 맡기십시오. 비슷한 기능을 수행하는 많은 함수 (exec * 및 spawn *)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d935935cd721060cd471db94f9ef7b7e4d625f4" translate="yes" xml:space="preserve">
          <source>Note, only &lt;code&gt;args&lt;/code&gt; should be passed positionally.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 만 위치 적으로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="13e1383053d018a118f339a408b60348fa0c10df" translate="yes" xml:space="preserve">
          <source>Notes about task spooler (&lt;code&gt;ts&lt;/code&gt;):</source>
          <target state="translated">작업 스풀러 ( &lt;code&gt;ts&lt;/code&gt; )에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="17f85f0219883423eaae3030acbe2e8068839e11" translate="yes" xml:space="preserve">
          <source>On FreeBSD we have another problem: when the parent process is finished, it finishes the child processes as well. And that is not what you want in a CGI script either. Some experiments showed that the problem seemed to be in sharing sys.stdout. And the working solution was the following:</source>
          <target state="translated">FreeBSD에는 또 다른 문제가 있습니다. 부모 프로세스가 완료되면 자식 프로세스도 완료됩니다. 그리고 그것은 CGI 스크립트에서 원하는 것이 아닙니다. 일부 실험에서는 sys.stdout을 공유하는 데 문제가있는 것으로 나타났습니다. 작업 솔루션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d77fda016063bfb5e284fb2828725f67f1e0abcd" translate="yes" xml:space="preserve">
          <source>On Windows (Windows&amp;nbsp;XP), the parent process will not finish until the longtask.py has finished its work. It is not what you want in a CGI script. The problem is not specific to Python; in the PHP community the problems are the same.</source>
          <target state="translated">Windows (Windows XP)에서는 longtask.py가 작업을 완료 할 때까지 상위 프로세스가 완료되지 않습니다. CGI 스크립트에서 원하는 것이 아닙니다. 이 문제는 파이썬에만 국한된 것이 아닙니다. PHP 커뮤니티에서 문제는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="73cc2ccf316b575a875f3123af48e3e1bc8b7676" translate="yes" xml:space="preserve">
          <source>One might easily move from manually providing a command string (like the question suggests) to providing a string built programmatically. &lt;strong&gt;Don't build strings programmatically.&lt;/strong&gt; This is a potential security issue. It's better to assume you don't trust the input.</source>
          <target state="translated">명령 문자열 제공 (질문과 같이)을 프로그래밍 방식으로 빌드 한 문자열 제공으로 쉽게 이동할 수 있습니다. &lt;strong&gt;프로그래밍 방식으로 문자열을 작성하지 마십시오.&lt;/strong&gt; 잠재적 인 보안 문제입니다. 입력을 신뢰하지 않는다고 가정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="41a57f8f481028cebaba1e0f5469024183974d84" translate="yes" xml:space="preserve">
          <source>One more: 
(NOTE: kwrite behaves different from other applications. If you try the below with Firefox, the results will not be the same.)</source>
          <target state="translated">하나 더 : (참고 : kwrite는 다른 응용 프로그램과 다르게 작동합니다. Firefox에서 아래를 시도하면 결과가 동일하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="e25727ac8c89aabb607297c433808248a7a0e1e1" translate="yes" xml:space="preserve">
          <source>Original answer:</source>
          <target state="translated">원래 답변 :</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="9eb209cce757a602d7f2f0ca560ec376bddc2235" translate="yes" xml:space="preserve">
          <source>Pass a command list</source>
          <target state="translated">명령 목록 전달</target>
        </trans-unit>
        <trans-unit id="8cab791770584f20f8736085e6f06ba110e4d582" translate="yes" xml:space="preserve">
          <source>Pipe stuff around too:</source>
          <target state="translated">파이프도 주위에 :</target>
        </trans-unit>
        <trans-unit id="ebb071acd0b348557933898f1183ca1a9ebf2a6b" translate="yes" xml:space="preserve">
          <source>Popen</source>
          <target state="translated">Popen</target>
        </trans-unit>
        <trans-unit id="2bbaa21688c027b406e5f4b12b6e7be1b87ff580" translate="yes" xml:space="preserve">
          <source>Raise on failed run:</source>
          <target state="translated">실패한 실행시 발생 :</target>
        </trans-unit>
        <trans-unit id="bf8cfc7ba5a5f5bee4c9521c60f879e6686ff1dc" translate="yes" xml:space="preserve">
          <source>Run a process:</source>
          <target state="translated">프로세스를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="770bbd7c071f378133b5752a9ea61c937cf5ce7e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#subprocess.call&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#subprocess.call&quot;&gt;설명서를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2f169459d9aa145196151308de045b7515b46ab1" translate="yes" xml:space="preserve">
          <source>Shameless plug, I wrote a library for this :P
&lt;a href=&quot;https://github.com/houqp/shell.py&quot;&gt;https://github.com/houqp/shell.py&lt;/a&gt;</source>
          <target state="translated">뻔뻔한 플러그, 나는 이것을 위해 라이브러리를 썼다 : P &lt;a href=&quot;https://github.com/houqp/shell.py&quot;&gt;https://github.com/houqp/shell.py&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="253723ab412e01a3b5346e6c5bead7538a06547e" translate="yes" xml:space="preserve">
          <source>Simple, use &lt;code&gt;subprocess.run&lt;/code&gt;, which returns a &lt;code&gt;CompletedProcess&lt;/code&gt; object:</source>
          <target state="translated">&lt;code&gt;subprocess.run&lt;/code&gt; 을 사용하면 &lt;code&gt;CompletedProcess&lt;/code&gt; 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="96916a7d5b2c00cca0f4d8225cd04dfa73ef6174" translate="yes" xml:space="preserve">
          <source>Some hints on detaching the child process from the calling one (starting the child process in background).</source>
          <target state="translated">하위 프로세스를 호출 프로세스에서 분리하는 방법에 대한 힌트 (백그라운드에서 하위 프로세스 시작).</target>
        </trans-unit>
        <trans-unit id="0ff80ac32b33346bf44e846d95580df486157012" translate="yes" xml:space="preserve">
          <source>Subprocess allows you to call external commands and connect them to their input/output/error pipes (stdin, stdout, and stderr). Subprocess is the default choice for running commands, but sometimes other modules are better.</source>
          <target state="translated">서브 프로세스를 사용하면 외부 명령을 호출하여 입력 / 출력 / 오류 파이프 (stdin, stdout 및 stderr)에 연결할 수 있습니다. 서브 프로세스는 명령 실행을위한 기본 선택이지만 때로는 다른 모듈이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="02d03c537f5a1c1351c07e93fd9b4e1c806b46a3" translate="yes" xml:space="preserve">
          <source>Suppose you want to start a long task from a CGI script. That is, the child process should live longer than the CGI script execution process.</source>
          <target state="translated">CGI 스크립트에서 긴 작업을 시작한다고 가정합니다. 즉, 하위 프로세스는 CGI 스크립트 실행 프로세스보다 오래 지속되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4bf5eed33409a9d4cce95fee5d4f206f094bd0c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/library/os.html#os.system&quot;&gt;official documentation&lt;/a&gt; recommends the &lt;code&gt;subprocess&lt;/code&gt; module over the alternative &lt;code&gt;os.system()&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/library/os.html#os.system&quot;&gt;공식 문서&lt;/a&gt; 는 대체 &lt;code&gt;os.system()&lt;/code&gt; 보다 &lt;code&gt;subprocess&lt;/code&gt; 모듈을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="afab629b263a23850b4a4c4fab6559124e8a2b16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/library/subprocess.html#replacing-older-functions-with-the-subprocess-module&quot;&gt;Replacing Older Functions with the subprocess Module&lt;/a&gt; section in the &lt;code&gt;subprocess&lt;/code&gt; documentation may have some helpful recipes.</source>
          <target state="translated">&lt;code&gt;subprocess&lt;/code&gt; 문서에서 &lt;a href=&quot;https://docs.python.org/library/subprocess.html#replacing-older-functions-with-the-subprocess-module&quot;&gt;서브 프로세스 모듈로 이전 기능 바꾸기&lt;/a&gt; 섹션에 유용한 레시피가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d3e9d8c82b51530830672b08d0ef35fbab40e8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Popen&lt;/code&gt; class of the &lt;code&gt;subprocess&lt;/code&gt; module.  This is intended as a replacement for &lt;code&gt;os.popen&lt;/code&gt; but has the downside of being slightly more complicated by virtue of being so comprehensive.  For example, you'd say:</source>
          <target state="translated">&lt;code&gt;subprocess&lt;/code&gt; 모듈의 &lt;code&gt;Popen&lt;/code&gt; 클래스 이것은 &lt;code&gt;os.popen&lt;/code&gt; 을 대체하기위한 것이지만 너무 포괄적이기 때문에 약간 더 복잡하다는 단점이 있습니다. 예를 들어 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc4253a08585d55cf4522486cf9b6b0fd47078e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; function from the &lt;code&gt;subprocess&lt;/code&gt; module.  This is basically just like the &lt;code&gt;Popen&lt;/code&gt; class and takes all of the same arguments, but it simply waits until the command completes and gives you the return code.  For example:</source>
          <target state="translated">&lt;code&gt;subprocess&lt;/code&gt; 모듈의 &lt;code&gt;call&lt;/code&gt; 기능. 이것은 기본적으로 &lt;code&gt;Popen&lt;/code&gt; 클래스와 동일하며 동일한 인수를 모두 사용하지만 명령이 완료 될 때까지 기다렸다가 리턴 코드를 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f65b9b491329c7dcc455e3c2ab564bc130ce4f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;popenargs&lt;/code&gt; and &lt;code&gt;kwargs&lt;/code&gt; are given to the &lt;code&gt;Popen&lt;/code&gt; constructor. &lt;code&gt;input&lt;/code&gt; can be a string of bytes (or unicode, if specify encoding or &lt;code&gt;universal_newlines=True&lt;/code&gt;) that will be piped to the subprocess's stdin.</source>
          <target state="translated">&lt;code&gt;popenargs&lt;/code&gt; 와 &lt;code&gt;kwargs&lt;/code&gt; 는 Popen 생성자에게 제공됩니다. &lt;code&gt;input&lt;/code&gt; 은 서브 프로세스의 stdin으로 파이프 될 바이트 문자열 (또는 인코딩 또는 &lt;code&gt;universal_newlines=True&lt;/code&gt; 를 지정하는 경우 유니 코드) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="597f463d6181383c2aa9eec8291dee90c9093b6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subprocess&lt;/code&gt; module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function [&lt;a href=&quot;https://docs.python.org/library/os.html#os.system&quot;&gt;&lt;code&gt;os.system()&lt;/code&gt;&lt;/a&gt;].</source>
          <target state="translated">&lt;code&gt;subprocess&lt;/code&gt; 모듈은 새로운 프로세스를 생성하고 결과를 검색 할 수있는보다 강력한 기능을 제공합니다. 이 함수를 사용하는 것 &lt;a href=&quot;https://docs.python.org/library/os.html#os.system&quot;&gt; &lt;code&gt;os.system()&lt;/code&gt; &lt;/a&gt; 모듈을 사용하는 것이 좋습니다 [ os.system () ].</target>
        </trans-unit>
        <trans-unit id="67d0649a95bbe6d8f66c8ce42cbc0bbe2015de0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subprocess&lt;/code&gt; module should probably be what you use.</source>
          <target state="translated">&lt;code&gt;subprocess&lt;/code&gt; 모듈은 아마도 당신이 사용하는 것이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4bcefe52191489f5553bf306d97423d4d878396f" translate="yes" xml:space="preserve">
          <source>The advantage of &lt;code&gt;subprocess&lt;/code&gt; vs. &lt;code&gt;system&lt;/code&gt; is that it is more flexible (you can get the &lt;code&gt;stdout&lt;/code&gt;, &lt;code&gt;stderr&lt;/code&gt;, the &quot;real&quot; status code, better error handling, etc...).</source>
          <target state="translated">&lt;code&gt;subprocess&lt;/code&gt; 와 &lt;code&gt;system&lt;/code&gt; 의 장점은 더 유연하다는 것입니다 ( &lt;code&gt;stdout&lt;/code&gt; , &lt;code&gt;stderr&lt;/code&gt; , &quot;실제&quot;상태 코드, 더 나은 오류 처리 등을 얻을 수 있습니다 ...).</target>
        </trans-unit>
        <trans-unit id="7f6b131d63315089780cb79a3bbe13a68d7390e4" translate="yes" xml:space="preserve">
          <source>The classical example from the subprocess module documentation is:</source>
          <target state="translated">서브 프로세스 모듈 문서의 전형적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9e6b82421ed6a6933bae7646b83fa3f410deae4" translate="yes" xml:space="preserve">
          <source>The documentation describes &lt;code&gt;timeout=&lt;/code&gt; and &lt;code&gt;check=True&lt;/code&gt; better than I could:</source>
          <target state="translated">이 문서는 &lt;code&gt;timeout=&lt;/code&gt; 및 &lt;code&gt;check=True&lt;/code&gt; 에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2599271d58968cf1345f8ce1dcef378e8bb253f8" translate="yes" xml:space="preserve">
          <source>The edit was based on J.F. Sebastian's comment.</source>
          <target state="translated">편집은 JF Sebastian의 의견을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="9375ec9cf1e1a48088ebd84b5d61ce8b4d2113fd" translate="yes" xml:space="preserve">
          <source>The idea here is that you do not want to wait in the line 'call subprocess' until the longtask.py is finished. But it is not clear what happens after the line 'some more code here' from the example.</source>
          <target state="translated">longtask.py가 완료 될 때까지 'call subprocess'줄을 기다리지 않기를 원합니다. 그러나 예제의 '여기에 더 많은 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0362ab403486d100b39df78902a34185bb350a53" translate="yes" xml:space="preserve">
          <source>The os module also has all of the fork/exec/spawn functions that you'd have in a C program, but I don't recommend using them directly.</source>
          <target state="translated">os 모듈에는 C 프로그램에있는 모든 fork / exec / spawn 함수가 있지만 직접 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d17b17fb1061b744b6a11011160bfee60f824a44" translate="yes" xml:space="preserve">
          <source>The recommended approach to invoking subprocesses is to use the run() function for all use cases it can handle. For more advanced use cases, the underlying Popen interface can be used directly.</source>
          <target state="translated">서브 프로세스 호출에 권장되는 접근 방식은 처리 할 수있는 모든 사용 사례에 대해 run () 함수를 사용하는 것입니다. 고급 사용 사례의 경우 기본 Popen 인터페이스를 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="797610109e8cd0a523dfb35244a626e04eef5841" translate="yes" xml:space="preserve">
          <source>The solution is to pass DETACHED_PROCESS &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx&quot;&gt;Process Creation Flag&lt;/a&gt; to the underlying CreateProcess function in Windows API.
If you happen to have installed pywin32, you can import the flag from the win32process module, otherwise you should define it yourself:</source>
          <target state="translated">해결책은 DETACHED_PROCESS &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx&quot;&gt;Process Creation Flag&lt;/a&gt; 를 Windows API의 기본 CreateProcess 함수에 전달하는 것입니다. pywin32를 설치 한 경우 win32process 모듈에서 플래그를 가져올 수 있습니다. 그렇지 않으면 직접 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="852fa7991bff81d637c1d755f860b4928e883903" translate="yes" xml:space="preserve">
          <source>The timeout argument is passed to Popen.communicate(). If the timeout
  expires, the child process will be killed and waited for. The
  TimeoutExpired exception will be re-raised after the child process has
  terminated.</source>
          <target state="translated">제한 시간 인수는 Popen.communicate ()에 전달됩니다. 제한 시간이 만료되면 하위 프로세스가 종료되고 대기합니다. 하위 프로세스가 종료 된 후 TimeoutExpired 예외가 다시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="74e1ee39ecbbaf46f408aa59d7805c5b18bc39a2" translate="yes" xml:space="preserve">
          <source>There are lots of different libraries which allow you to call external commands with Python. For each library I've given a description and shown an example of calling an external command. The command I used as the example is &lt;code&gt;ls -l&lt;/code&gt; (list all files). If you want to find out more about any of the libraries I've listed and linked the documentation for each of them.</source>
          <target state="translated">파이썬으로 외부 명령을 호출 할 수있는 다양한 라이브러리가 있습니다. 각 라이브러리에 대해 설명하고 외부 명령을 호출하는 예를 보여주었습니다. 예제로 사용한 명령은 &lt;code&gt;ls -l&lt;/code&gt; 입니다 (모든 파일 나열). 라이브러리에 대해 더 자세히 알고 싶다면 각 라이브러리에 대한 문서를 나열하고 링크했습니다.</target>
        </trans-unit>
        <trans-unit id="3faf13f8df1bc7e3959874fdea7e123c8931bbc5" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;http://plumbum.readthedocs.org/en/latest/&quot;&gt;Plumbum&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://plumbum.readthedocs.org/en/latest/&quot;&gt;Plumbum도 있습니다&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="523e816fff3d635b4b57a3c72de2f42570b0fc48" translate="yes" xml:space="preserve">
          <source>There is another difference here which is not mentioned previously.</source>
          <target state="translated">이전에 언급되지 않은 또 다른 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dff6fe0f782361a67af3bcde93ee7b9df92bd107" translate="yes" xml:space="preserve">
          <source>This is how I run my commands. This code has everything you need pretty much</source>
          <target state="translated">이것이 내가 명령을 실행하는 방법입니다. 이 코드에는 필요한 모든 것이 있습니다</target>
        </trans-unit>
        <trans-unit id="c7245e51bd7139e445469159ab77eaaaf30497c0" translate="yes" xml:space="preserve">
          <source>Typical implementation:</source>
          <target state="translated">일반적인 구현 :</target>
        </trans-unit>
        <trans-unit id="31ff876228262ef5e8f98bb8df82ae987194c0be" translate="yes" xml:space="preserve">
          <source>Under Linux, in case you would like to call an external command that will execute independently (will keep running after the python script terminates), you can use a simple queue as &lt;a href=&quot;http://vicerveza.homeunix.net/~viric/soft/ts/&quot;&gt;task spooler&lt;/a&gt; or the &lt;a href=&quot;https://linux.die.net/man/1/at&quot;&gt;at&lt;/a&gt; command</source>
          <target state="translated">Linux에서 독립적으로 실행되는 외부 명령을 호출하려는 경우 (python 스크립트가 종료 된 후에도 계속 실행 됨) &lt;a href=&quot;http://vicerveza.homeunix.net/~viric/soft/ts/&quot;&gt;작업 스풀러&lt;/a&gt; 또는 &lt;a href=&quot;https://linux.die.net/man/1/at&quot;&gt;at&lt;/a&gt; 명령으로 간단한 큐를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdf5a0a4c93fff1b17f183c226012273c1d43069" translate="yes" xml:space="preserve">
          <source>Understanding the remaining documentation on &lt;code&gt;Popen&lt;/code&gt; will be left as an exercise for the reader.</source>
          <target state="translated">&lt;code&gt;Popen&lt;/code&gt; 에 남은 문서를 이해하는 것은 독자를위한 연습으로 남을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="a724e226efd328d314410553d9d0a6c3eb761723" translate="yes" xml:space="preserve">
          <source>Use &lt;em&gt;&lt;a href=&quot;https://docs.python.org/2/library/subprocess.html&quot;&gt;subprocess&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://docs.python.org/2/library/subprocess.html&quot;&gt;subprocess를&lt;/a&gt;&lt;/em&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="edd176fcbe63d71b143043c47f74083e7b9d9787" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://docs.python.org/2/library/os.html&quot;&gt;os module&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/library/os.html&quot;&gt;os 모듈을&lt;/a&gt; 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="19a090ab4bedfbcf29e7da7a4077073280a686e2" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt;subprocess module&lt;/a&gt; (Python 3):</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt;하위 프로세스 모듈&lt;/a&gt; (Python 3)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="448cfe5db01084af3e9371ab7cf08e61c69bb1c3" translate="yes" xml:space="preserve">
          <source>We can inspect the returned object and see the command that was given and the returncode:</source>
          <target state="translated">반환 된 객체를 검사하고 주어진 명령과 반환 코드를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bb310ac00cac6fcd37979db1016551743aa642b" translate="yes" xml:space="preserve">
          <source>When use &lt;code&gt;Popen&lt;/code&gt; instead? I would struggle to find use-case based on the arguments alone. Direct usage of &lt;code&gt;Popen&lt;/code&gt; would, however, give you access to its methods, including &lt;code&gt;poll&lt;/code&gt;, 'send_signal', 'terminate', and 'wait'.</source>
          <target state="translated">&lt;code&gt;Popen&lt;/code&gt; 을 대신 사용할 때 ? 나는 논쟁만으로 유스 케이스를 찾는 데 어려움을 겪을 것입니다. 그러나 &lt;code&gt;Popen&lt;/code&gt; 을 직접 사용하면 &lt;code&gt;poll&lt;/code&gt; , 'send_signal', 'terminate'및 'wait'를 포함한 메소드에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d77989c1e3c0e0ace735631597dc367ffdfa6f32" translate="yes" xml:space="preserve">
          <source>Why?</source>
          <target state="translated">Why?</target>
        </trans-unit>
        <trans-unit id="18f27c9ee823db5e4c0a614a16980da6367604a3" translate="yes" xml:space="preserve">
          <source>With external dependencies</source>
          <target state="translated">외부 의존성</target>
        </trans-unit>
        <trans-unit id="d14ab858678072f32ca74ab1b82e081dfcfc055d" translate="yes" xml:space="preserve">
          <source>With output of the result:</source>
          <target state="translated">결과 출력 :</target>
        </trans-unit>
        <trans-unit id="aaaa9eb5d49bd41216be4aab4c1d7019aec73518" translate="yes" xml:space="preserve">
          <source>With the standard library</source>
          <target state="translated">표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="a163f8072d2582ac0b08270fa37f04b08c90ff97" translate="yes" xml:space="preserve">
          <source>Without the output of the result:</source>
          <target state="translated">결과가 출력되지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="e7cdf9aef9dcc1e68939ec2e3584bf7ad40cff4d" translate="yes" xml:space="preserve">
          <source>You are free to do what you want with the &lt;code&gt;stdout&lt;/code&gt; data in the pipe.  In fact, you can simply omit those parameters (&lt;code&gt;stdout=&lt;/code&gt; and &lt;code&gt;stderr=&lt;/code&gt;) and it'll behave like &lt;code&gt;os.system()&lt;/code&gt;.</source>
          <target state="translated">파이프의 &lt;code&gt;stdout&lt;/code&gt; 데이터로 원하는 것을 자유롭게 수행 할 수 있습니다. 실제로 이러한 매개 변수 ( &lt;code&gt;stdout=&lt;/code&gt; 및 &lt;code&gt;stderr=&lt;/code&gt; )를 생략하면 &lt;code&gt;os.system()&lt;/code&gt; 과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c122bf1eaa4c6177c760488496e22187b9c197dc" translate="yes" xml:space="preserve">
          <source>You could set the number of concurrent processes to be run (&quot;slots&quot;) with:</source>
          <target state="translated">다음을 사용하여 실행할 동시 프로세스 수 ( &quot;슬롯&quot;)를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9dbd017d634c57685e9ea83e3ab03bb5edef87f" translate="yes" xml:space="preserve">
          <source>and imagine that the user enters something &quot;my mama didnt love me &amp;amp;&amp;amp; rm -rf /&quot; which could erase the whole filesystem.</source>
          <target state="translated">그리고 사용자가 전체 파일 시스템을 지울 수있는 &quot;엄마가 나를 사랑하지 않는 &amp;amp;&amp;amp; rm -rf /&quot;무언가를 입력했다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="f17ada58f79678c2c2c55e53fc4e2f5df1f34d13" translate="yes" xml:space="preserve">
          <source>and this example for &lt;code&gt;check=True&lt;/code&gt; is better than one I could come up with:</source>
          <target state="translated">그리고 &lt;code&gt;check=True&lt;/code&gt; 에 대한이 예제는 내가 생각해 낼 수있는 것보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="70d923d5b13c8294ffdbf19c5dbe40d59fe15cbf" translate="yes" xml:space="preserve">
          <source>but it is nice to have all of the options there in one unified class instead of 4 different popen functions.  See &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#popen-constructor&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">그러나 4 가지 다른 popen 함수 대신 하나의 통합 클래스에서 모든 옵션을 사용하는 것이 좋습니다. &lt;a href=&quot;https://docs.python.org/2/library/subprocess.html#popen-constructor&quot;&gt;설명서를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b904e73103fc2e4e766606e93e37406669eeba11" translate="yes" xml:space="preserve">
          <source>commands: &lt;a href=&quot;https://docs.python.org/2/library/commands.html&quot;&gt;https://docs.python.org/2/library/commands.html&lt;/a&gt;</source>
          <target state="translated">명령 : &lt;a href=&quot;https://docs.python.org/2/library/commands.html&quot;&gt;https://docs.python.org/2/library/commands.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52d303eda30df68defd302e06660eb6bb684fbb9" translate="yes" xml:space="preserve">
          <source>envoy is known as &quot;subprocess for humans&quot;. It is used as a convenience wrapper around the &lt;code&gt;subprocess&lt;/code&gt; module.</source>
          <target state="translated">특사는 &quot;인간 하위 프로세스&quot;로 알려져 있습니다. &lt;code&gt;subprocess&lt;/code&gt; 모듈 주위의 편의 랩퍼로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da9733bfafc172eabc90b2758bfeab6b4cb34a4f" translate="yes" xml:space="preserve">
          <source>envoy: &lt;a href=&quot;https://github.com/kennethreitz/envoy&quot;&gt;https://github.com/kennethreitz/envoy&lt;/a&gt;</source>
          <target state="translated">사절 : &lt;a href=&quot;https://github.com/kennethreitz/envoy&quot;&gt;https://github.com/kennethreitz/envoy&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7f621f19f6af467ef23fb98f8ee0c656389c12a" translate="yes" xml:space="preserve">
          <source>fabric is a Python 2.5 and 2.7 library. It allows you to execute local and remote shell commands. Fabric is simple alternative for running commands in a secure shell (SSH)</source>
          <target state="translated">fabric은 Python 2.5 및 2.7 라이브러리입니다. 로컬 및 원격 쉘 명령을 실행할 수 있습니다. 패브릭은 SSH (Secure Shell)에서 명령을 실행하는 간단한 대안입니다.</target>
        </trans-unit>
        <trans-unit id="b1a08d055b8bb30483bf0ea122392e6d37082e73" translate="yes" xml:space="preserve">
          <source>fabric: &lt;a href=&quot;http://www.fabfile.org/&quot;&gt;http://www.fabfile.org/&lt;/a&gt;</source>
          <target state="translated">패브릭 : &lt;a href=&quot;http://www.fabfile.org/&quot;&gt;http://www.fabfile.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c8457cd65849bf5a9285f8b862e990e1a44ac09" translate="yes" xml:space="preserve">
          <source>instead of:</source>
          <target state="translated">대신에:</target>
        </trans-unit>
        <trans-unit id="5957da8d14d5f58f81aefab1967a97dba4f1d41b" translate="yes" xml:space="preserve">
          <source>os is used for &quot;operating system dependent functionality&quot;. It can also be used to call external commands with &lt;code&gt;os.system&lt;/code&gt; and &lt;code&gt;os.popen&lt;/code&gt; (Note: There is also a subprocess.popen). os will always run the shell and is a simple alternative for people who don't need to, or don't know how to use &lt;code&gt;subprocess.run&lt;/code&gt;.</source>
          <target state="translated">os는 &quot;운영 체제 종속 기능&quot;에 사용됩니다. &lt;code&gt;os.system&lt;/code&gt; 및 &lt;code&gt;os.popen&lt;/code&gt; 을 사용하여 외부 명령을 호출하는 데에도 사용할 수 있습니다 (참고 : subprocess.popen도 있습니다). os는 항상 셸을 실행하며 &lt;code&gt;subprocess.run&lt;/code&gt; 을 사용할 필요가 없거나 사용 방법을 모르는 사람들을위한 간단한 대안입니다.</target>
        </trans-unit>
        <trans-unit id="cbcca4febe8f373e15156fec6a4033260e13e466" translate="yes" xml:space="preserve">
          <source>os: &lt;a href=&quot;https://docs.python.org/3.5/library/os.html&quot;&gt;https://docs.python.org/3.5/library/os.html&lt;/a&gt;</source>
          <target state="translated">os : &lt;a href=&quot;https://docs.python.org/3.5/library/os.html&quot;&gt;https://docs.python.org/3.5/library/os.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8d9686cb58c073c2456d6dd10a62bd7b4149915" translate="yes" xml:space="preserve">
          <source>pexpect lets you spawn child applications, control them and find patterns in their output. This is a better alternative to subprocess for commands that expect a tty on Unix.</source>
          <target state="translated">pexpect를 사용하면 자식 응용 프로그램을 생성하고 제어하고 출력에서 ​​패턴을 찾을 수 있습니다. 이것은 유닉스에서 tty를 기대하는 명령에 대한 하위 프로세스에 대한 더 나은 대안입니다.</target>
        </trans-unit>
        <trans-unit id="42668b41f9ed9ad1246add137130a19892d12138" translate="yes" xml:space="preserve">
          <source>pexpect: &lt;a href=&quot;https://pexpect.readthedocs.io/en/stable/&quot;&gt;https://pexpect.readthedocs.io/en/stable/&lt;/a&gt;</source>
          <target state="translated">pexpect : &lt;a href=&quot;https://pexpect.readthedocs.io/en/stable/&quot;&gt;https://pexpect.readthedocs.io/en/stable/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af8ce099c02940f7dae91a34a3b1ac9f97531070" translate="yes" xml:space="preserve">
          <source>plumbum is a library for &quot;script-like&quot; Python programs. You can call programs like functions as in &lt;code&gt;sh&lt;/code&gt;. Plumbum is useful if you want to run a pipeline without the shell.</source>
          <target state="translated">plumbum은 &quot;스크립트와 같은&quot;Python 프로그램을위한 라이브러리입니다. &lt;code&gt;sh&lt;/code&gt; 와 같은 함수와 같은 프로그램을 호출 할 수 있습니다. Plumbum은 셸없이 파이프 라인을 실행하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1e6a45273361198ccb9f4fb2ba60008d603a5712" translate="yes" xml:space="preserve">
          <source>plumbum: &lt;a href=&quot;https://plumbum.readthedocs.io/en/latest/&quot;&gt;https://plumbum.readthedocs.io/en/latest/&lt;/a&gt;</source>
          <target state="translated">plumbum : &lt;a href=&quot;https://plumbum.readthedocs.io/en/latest/&quot;&gt;https://plumbum.readthedocs.io/en/latest/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24560916a5b723031ab61aae18088346943f299c" translate="yes" xml:space="preserve">
          <source>sh is a subprocess interface which lets you call programs as if they were functions. This is useful if you want to run a command multiple times.</source>
          <target state="translated">sh는 마치 마치 마치 프로그램 인 것처럼 프로그램을 호출 할 수있는 하위 프로세스 인터페이스입니다. 명령을 여러 번 실행하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="08f15a5c418f54cf27af2fee84fb94963fd9c7be" translate="yes" xml:space="preserve">
          <source>sh: &lt;a href=&quot;https://amoffat.github.io/sh/&quot;&gt;https://amoffat.github.io/sh/&lt;/a&gt;</source>
          <target state="translated">sh : &lt;a href=&quot;https://amoffat.github.io/sh/&quot;&gt;https://amoffat.github.io/sh/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2f1ab3fa95d766a02a1042a18e5de4b6ce04e69" translate="yes" xml:space="preserve">
          <source>shlex: &lt;a href=&quot;https://docs.python.org/3/library/shlex.html&quot;&gt;https://docs.python.org/3/library/shlex.html&lt;/a&gt;</source>
          <target state="translated">shlex : &lt;a href=&quot;https://docs.python.org/3/library/shlex.html&quot;&gt;https://docs.python.org/3/library/shlex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="215f1313cfe29ed2c9cd0789a6c38b916645aedc" translate="yes" xml:space="preserve">
          <source>subprocess: &lt;a href=&quot;https://docs.python.org/3.5/library/subprocess.html&quot;&gt;https://docs.python.org/3.5/library/subprocess.html&lt;/a&gt;</source>
          <target state="translated">하위 프로세스 : &lt;a href=&quot;https://docs.python.org/3.5/library/subprocess.html&quot;&gt;https://docs.python.org/3.5/library/subprocess.html&lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
